/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5561:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
var da = {
  code: "da",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Forrige",
    next: "N\xE6ste",
    today: "I dag",
    month: "M\xE5ned",
    week: "Uge",
    day: "Dag",
    list: "Agenda"
  },
  weekText: "Uge",
  allDayText: "Hele dagen",
  moreLinkText: "flere",
  noEventsText: "Ingen arrangementer at vise"
};
exports.Z = da;

/***/ }),

/***/ 7892:
/***/ (function(module) {

!function (t, e) {
   true ? module.exports = e() : 0;
}(this, function () {
  "use strict";

  var t = 1e3,
      e = 6e4,
      n = 36e5,
      r = "millisecond",
      i = "second",
      s = "minute",
      u = "hour",
      a = "day",
      o = "week",
      f = "month",
      h = "quarter",
      c = "year",
      d = "date",
      $ = "Invalid Date",
      l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      M = {
    name: "en",
    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
  },
      m = function m(t, e, n) {
    var r = String(t);
    return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
  },
      g = {
    s: m,
    z: function z(t) {
      var e = -t.utcOffset(),
          n = Math.abs(e),
          r = Math.floor(n / 60),
          i = n % 60;
      return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
    },
    m: function t(e, n) {
      if (e.date() < n.date()) return -t(n, e);
      var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
          i = e.clone().add(r, f),
          s = n - i < 0,
          u = e.clone().add(r + (s ? -1 : 1), f);
      return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
    },
    a: function a(t) {
      return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
    },
    p: function p(t) {
      return {
        M: f,
        y: c,
        w: o,
        d: a,
        D: d,
        h: u,
        m: s,
        s: i,
        ms: r,
        Q: h
      }[t] || String(t || "").toLowerCase().replace(/s$/, "");
    },
    u: function u(t) {
      return void 0 === t;
    }
  },
      v = "en",
      D = {};

  D[v] = M;

  var p = function p(t) {
    return t instanceof _;
  },
      S = function t(e, n, r) {
    var i;
    if (!e) return v;

    if ("string" == typeof e) {
      var s = e.toLowerCase();
      D[s] && (i = s), n && (D[s] = n, i = s);
      var u = e.split("-");
      if (!i && u.length > 1) return t(u[0]);
    } else {
      var a = e.name;
      D[a] = e, i = a;
    }

    return !r && i && (v = i), i || !r && v;
  },
      w = function w(t, e) {
    if (p(t)) return t.clone();
    var n = "object" == typeof e ? e : {};
    return n.date = t, n.args = arguments, new _(n);
  },
      O = g;

  O.l = S, O.i = p, O.w = function (t, e) {
    return w(t, {
      locale: e.$L,
      utc: e.$u,
      x: e.$x,
      $offset: e.$offset
    });
  };

  var _ = function () {
    function M(t) {
      this.$L = S(t.locale, null, !0), this.parse(t);
    }

    var m = M.prototype;
    return m.parse = function (t) {
      this.$d = function (t) {
        var e = t.date,
            n = t.utc;
        if (null === e) return new Date(NaN);
        if (O.u(e)) return new Date();
        if (e instanceof Date) return new Date(e);

        if ("string" == typeof e && !/Z$/i.test(e)) {
          var r = e.match(l);

          if (r) {
            var i = r[2] - 1 || 0,
                s = (r[7] || "0").substring(0, 3);
            return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
          }
        }

        return new Date(e);
      }(t), this.$x = t.x || {}, this.init();
    }, m.init = function () {
      var t = this.$d;
      this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
    }, m.$utils = function () {
      return O;
    }, m.isValid = function () {
      return !(this.$d.toString() === $);
    }, m.isSame = function (t, e) {
      var n = w(t);
      return this.startOf(e) <= n && n <= this.endOf(e);
    }, m.isAfter = function (t, e) {
      return w(t) < this.startOf(e);
    }, m.isBefore = function (t, e) {
      return this.endOf(e) < w(t);
    }, m.$g = function (t, e, n) {
      return O.u(t) ? this[e] : this.set(n, t);
    }, m.unix = function () {
      return Math.floor(this.valueOf() / 1e3);
    }, m.valueOf = function () {
      return this.$d.getTime();
    }, m.startOf = function (t, e) {
      var n = this,
          r = !!O.u(e) || e,
          h = O.p(t),
          $ = function $(t, e) {
        var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
        return r ? i : i.endOf(a);
      },
          l = function l(t, e) {
        return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), n);
      },
          y = this.$W,
          M = this.$M,
          m = this.$D,
          g = "set" + (this.$u ? "UTC" : "");

      switch (h) {
        case c:
          return r ? $(1, 0) : $(31, 11);

        case f:
          return r ? $(1, M) : $(0, M + 1);

        case o:
          var v = this.$locale().weekStart || 0,
              D = (y < v ? y + 7 : y) - v;
          return $(r ? m - D : m + (6 - D), M);

        case a:
        case d:
          return l(g + "Hours", 0);

        case u:
          return l(g + "Minutes", 1);

        case s:
          return l(g + "Seconds", 2);

        case i:
          return l(g + "Milliseconds", 3);

        default:
          return this.clone();
      }
    }, m.endOf = function (t) {
      return this.startOf(t, !1);
    }, m.$set = function (t, e) {
      var n,
          o = O.p(t),
          h = "set" + (this.$u ? "UTC" : ""),
          $ = (n = {}, n[a] = h + "Date", n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o],
          l = o === a ? this.$D + (e - this.$W) : e;

      if (o === f || o === c) {
        var y = this.clone().set(d, 1);
        y.$d[$](l), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
      } else $ && this.$d[$](l);

      return this.init(), this;
    }, m.set = function (t, e) {
      return this.clone().$set(t, e);
    }, m.get = function (t) {
      return this[O.p(t)]();
    }, m.add = function (r, h) {
      var d,
          $ = this;
      r = Number(r);

      var l = O.p(h),
          y = function y(t) {
        var e = w($);
        return O.w(e.date(e.date() + Math.round(t * r)), $);
      };

      if (l === f) return this.set(f, this.$M + r);
      if (l === c) return this.set(c, this.$y + r);
      if (l === a) return y(1);
      if (l === o) return y(7);
      var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[l] || 1,
          m = this.$d.getTime() + r * M;
      return O.w(m, this);
    }, m.subtract = function (t, e) {
      return this.add(-1 * t, e);
    }, m.format = function (t) {
      var e = this,
          n = this.$locale();
      if (!this.isValid()) return n.invalidDate || $;

      var r = t || "YYYY-MM-DDTHH:mm:ssZ",
          i = O.z(this),
          s = this.$H,
          u = this.$m,
          a = this.$M,
          o = n.weekdays,
          f = n.months,
          h = function h(t, n, i, s) {
        return t && (t[n] || t(e, r)) || i[n].slice(0, s);
      },
          c = function c(t) {
        return O.s(s % 12 || 12, t, "0");
      },
          d = n.meridiem || function (t, e, n) {
        var r = t < 12 ? "AM" : "PM";
        return n ? r.toLowerCase() : r;
      },
          l = {
        YY: String(this.$y).slice(-2),
        YYYY: this.$y,
        M: a + 1,
        MM: O.s(a + 1, 2, "0"),
        MMM: h(n.monthsShort, a, f, 3),
        MMMM: h(f, a),
        D: this.$D,
        DD: O.s(this.$D, 2, "0"),
        d: String(this.$W),
        dd: h(n.weekdaysMin, this.$W, o, 2),
        ddd: h(n.weekdaysShort, this.$W, o, 3),
        dddd: o[this.$W],
        H: String(s),
        HH: O.s(s, 2, "0"),
        h: c(1),
        hh: c(2),
        a: d(s, u, !0),
        A: d(s, u, !1),
        m: String(u),
        mm: O.s(u, 2, "0"),
        s: String(this.$s),
        ss: O.s(this.$s, 2, "0"),
        SSS: O.s(this.$ms, 3, "0"),
        Z: i
      };

      return r.replace(y, function (t, e) {
        return e || l[t] || i.replace(":", "");
      });
    }, m.utcOffset = function () {
      return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
    }, m.diff = function (r, d, $) {
      var l,
          y = O.p(d),
          M = w(r),
          m = (M.utcOffset() - this.utcOffset()) * e,
          g = this - M,
          v = O.m(this, M);
      return v = (l = {}, l[c] = v / 12, l[f] = v, l[h] = v / 3, l[o] = (g - m) / 6048e5, l[a] = (g - m) / 864e5, l[u] = g / n, l[s] = g / e, l[i] = g / t, l)[y] || g, $ ? v : O.a(v);
    }, m.daysInMonth = function () {
      return this.endOf(f).$D;
    }, m.$locale = function () {
      return D[this.$L];
    }, m.locale = function (t, e) {
      if (!t) return this.$L;
      var n = this.clone(),
          r = S(t, e, !0);
      return r && (n.$L = r), n;
    }, m.clone = function () {
      return O.w(this.$d, this);
    }, m.toDate = function () {
      return new Date(this.valueOf());
    }, m.toJSON = function () {
      return this.isValid() ? this.toISOString() : null;
    }, m.toISOString = function () {
      return this.$d.toISOString();
    }, m.toString = function () {
      return this.$d.toUTCString();
    }, M;
  }(),
      T = _.prototype;

  return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function (t) {
    T[t[1]] = function (e) {
      return this.$g(e, t[0], t[1]);
    };
  }), w.extend = function (t, e) {
    return t.$i || (t(e, _, w), t.$i = !0), w;
  }, w.locale = S, w.isDayjs = p, w.unix = function (t) {
    return w(1e3 * t);
  }, w.en = D[v], w.Ls = D, w.p = {}, w;
});

/***/ }),

/***/ 6794:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

!function (e, t) {
   true ? module.exports = t(__webpack_require__(7892)) : 0;
}(this, function (e) {
  "use strict";

  function t(e) {
    return e && "object" == typeof e && "default" in e ? e : {
      default: e
    };
  }

  var d = t(e),
      n = {
    name: "da",
    weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
    weekdaysShort: "søn._man._tirs._ons._tors._fre._lør.".split("_"),
    weekdaysMin: "sø._ma._ti._on._to._fr._lø.".split("_"),
    months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
    monthsShort: "jan._feb._mar._apr._maj_juni_juli_aug._sept._okt._nov._dec.".split("_"),
    weekStart: 1,
    ordinal: function ordinal(e) {
      return e + ".";
    },
    formats: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY HH:mm",
      LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
    },
    relativeTime: {
      future: "om %s",
      past: "%s siden",
      s: "få sekunder",
      m: "et minut",
      mm: "%d minutter",
      h: "en time",
      hh: "%d timer",
      d: "en dag",
      dd: "%d dage",
      M: "en måned",
      MM: "%d måneder",
      y: "et år",
      yy: "%d år"
    }
  };
  return d.default.locale(n, null, !0), n;
});

/***/ }),

/***/ 4776:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */

var ElementType;

(function (ElementType) {
  /** Type for the root element of a document */
  ElementType["Root"] = "root";
  /** Type for Text */

  ElementType["Text"] = "text";
  /** Type for <? ... ?> */

  ElementType["Directive"] = "directive";
  /** Type for <!-- ... --> */

  ElementType["Comment"] = "comment";
  /** Type for <script> tags */

  ElementType["Script"] = "script";
  /** Type for <style> tags */

  ElementType["Style"] = "style";
  /** Type for Any tag */

  ElementType["Tag"] = "tag";
  /** Type for <![CDATA[ ... ]]> */

  ElementType["CDATA"] = "cdata";
  /** Type for <!doctype ...> */

  ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */


function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}

exports.isTag = isTag; // Exports for backwards compatibility

/** Type for the root element of a document */

exports.Root = ElementType.Root;
/** Type for Text */

exports.Text = ElementType.Text;
/** Type for <? ... ?> */

exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */

exports.Comment = ElementType.Comment;
/** Type for <script> tags */

exports.Script = ElementType.Script;
/** Type for <style> tags */

exports.Style = ElementType.Style;
/** Type for Any tag */

exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */

exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */

exports.Doctype = ElementType.Doctype;

/***/ }),

/***/ 8703:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _slicedToArray = (__webpack_require__(7424)["default"]);

var _createForOfIteratorHelper = (__webpack_require__(4704)["default"]);

var _construct = (__webpack_require__(3515)["default"]);

var _toConsumableArray = (__webpack_require__(861)["default"]);

/*! @license DOMPurify 3.0.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.3/LICENSE */
(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  var entries = Object.entries,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringToString = unapply(String.prototype.toString);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }
  /* Add properties to a lookup table */


  function addToSet(set, array, transformCaseFunc) {
    var _transformCaseFunc;

    transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;

    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;

    while (l--) {
      var element = array[l];

      if (typeof element === 'string') {
        var lcElement = transformCaseFunc(element);

        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }
  /* Shallow clone an object */


  function clone(object) {
    var newObject = create(null);

    var _iterator = _createForOfIteratorHelper(entries(object)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            property = _step$value[0],
            value = _step$value[1];

        newObject[property] = value;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return newObject;
  }
  /* This method automatically checks if the prop is function
   * or getter and behaves accordingly. */


  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);

      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

  var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.

  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
  var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']); // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.

  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
  var text = freeze(['#text']);
  var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
  var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
  var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);
  var EXPRESSIONS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MUSTACHE_EXPR: MUSTACHE_EXPR,
    ERB_EXPR: ERB_EXPR,
    TMPLIT_EXPR: TMPLIT_EXPR,
    DATA_ATTR: DATA_ATTR,
    ARIA_ATTR: ARIA_ATTR,
    IS_ALLOWED_URI: IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE: ATTR_WHITESPACE,
    DOCTYPE_NAME: DOCTYPE_NAME
  });

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };
  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported or creating the policy failed).
   */


  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    } // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.


    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';

    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html) {
          return html;
        },
        createScriptURL: function createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };
    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */


    DOMPurify.version = '3.0.3';
    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */

    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;
      return DOMPurify;
    }

    var originalDocument = window.document;
    var currentScript = originalDocument.currentScript;
    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        HTMLFormElement = window.HTMLFormElement,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;
    var ElementPrototype = Element.prototype;
    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.

    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');

      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy;
    var emptyHTML = '';
    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var hooks = {};
    /**
     * Expose whether this browser supports running the full DOMPurify.
     */

    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
    var MUSTACHE_EXPR = EXPRESSIONS.MUSTACHE_EXPR,
        ERB_EXPR = EXPRESSIONS.ERB_EXPR,
        TMPLIT_EXPR = EXPRESSIONS.TMPLIT_EXPR,
        DATA_ATTR = EXPRESSIONS.DATA_ATTR,
        ARIA_ATTR = EXPRESSIONS.ARIA_ATTR,
        IS_SCRIPT_OR_DATA = EXPRESSIONS.IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE = EXPRESSIONS.ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = EXPRESSIONS.IS_ALLOWED_URI;
    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    /* Allowed attribute names */

    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    /*
     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */

    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

    var FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

    var FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */

    var ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */

    var ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */

    var ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Decide if self-closing tags in attributes are allowed.
     * Usually removed due to a mXSS issue in jQuery 3.0 */

    var ALLOW_SELF_CLOSE_IN_ATTR = true;
    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */

    var SAFE_FOR_TEMPLATES = false;
    /* Decide if document with <html>... should be returned */

    var WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */

    var SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */

    var FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */

    var RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */

    var RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */

    var RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
     */

    var SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
     *
     * HTML/DOM spec rules that enable DOM Clobbering:
     *   - Named Access on Window (§7.3.3)
     *   - DOM Tree Accessors (§3.1.5)
     *   - Form Element Parent-Child Relations (§4.10.3)
     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
     *   - HTMLCollection (§4.2.10.2)
     *
     * Namespace isolation is implemented by prefixing `id` and `name` attributes
     * with a constant string, i.e., `user-content-`
     */

    var SANITIZE_NAMED_PROPS = false;
    var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    /* Keep element content when removing element? */

    var KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */

    var IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */

    var USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */

    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
    /* Tags that are safe for data: URIs */

    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    /* Attributes safe for values like "javascript:" */

    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */

    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    /* Allowed XHTML+XML namespaces */

    var ALLOWED_NAMESPACES = null;
    var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    /* Parsing of strict XHTML documents */

    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc;
    /* Keep a reference to config to pass to hooks */

    var CONFIG = null;
    /* Ideally, do not touch anything below this line */

    /* ______________________________________________ */

    var formElement = document.createElement('form');

    var isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity


    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      /* Shield configuration object from tampering */


      if (!cfg || typeof cfg !== 'object') {
        cfg = {};
      }
      /* Shield configuration object from prototype pollution */


      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
      /* Set configuration parameters */

      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true

      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

      RETURN_DOM = cfg.RETURN_DOM || false; // Default false

      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

      FORCE_BODY = cfg.FORCE_BODY || false; // Default false

      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

      IN_PLACE = cfg.IN_PLACE || false; // Default false

      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      /* Parse profile info */


      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
        ALLOWED_ATTR = [];

        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      /* Merge configuration parameters */


      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      /* Add #text in case KEEP_CONTENT is set to true */


      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }
      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }
      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }

        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        } // Overwrite existing TrustedTypes policy.


        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY; // Sign local variables required by `sanitize`.

        emptyHTML = trustedTypesPolicy.createHTML('');
      } else {
        // Uninitialized policy, attempt to initialize the internal dompurify policy.
        if (trustedTypesPolicy === undefined) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        } // If creating the internal policy succeeded sign internal variables.


        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
          emptyHTML = trustedTypesPolicy.createHTML('');
        }
      } // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.


      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.

    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */

    var ALL_SVG_TAGS = addToSet({}, svg$1);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */

    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.

      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        } // The only way to switch from MathML to SVG is via`
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.


        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        } // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.


        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        } // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points


        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        } // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.


        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        } // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace


        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      } // For XHTML and XML documents that support custom namespaces


      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      } // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
      // Return false just in case.


      return false;
    };
    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */


    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });

      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        node.remove();
      }
    };
    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */


    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };
    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */


    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc;
      var leadingWhitespace;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */

      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }
      /* Use createHTMLDocument in case DOMParser is not available */


      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);

        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_) {// Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      /* Work on whole document or just its body */


      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */


    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };
    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */


    var _isClobbered = function _isClobbered(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
    };
    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */


    var _isNode = function _isNode(object) {
      return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };
    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */


    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };
    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */


    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeElements', currentNode, null);
      /* Check if element is clobbered or can clobber */


      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Now let's check the element's type and name */


      var tagName = transformCaseFunc(currentNode.nodeName);
      /* Execute a hook if present */

      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });
      /* Detect mXSS attempts abusing namespace confusion */


      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Remove element if anything forbids its presence */


      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
        }
        /* Keep content except for bad-listed elements */


        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);

        return true;
      }
      /* Check whether element has a valid namespace */


      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Make sure that older browsers don't get noscript mXSS */


      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Sanitize element content to be template-safe */


      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR, ' ');
        content = stringReplace(content, ERB_EXPR, ' ');
        content = stringReplace(content, TMPLIT_EXPR, ' ');

        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };
    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity


    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }
      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */


      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if (value) {
        return false;
      } else ;
      return true;
    };
    /**
     * _basicCustomElementCheck
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     * @param {string} tagName name of the tag of the node to sanitize
     */


    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
      return tagName.indexOf('-') > 0;
    };
    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */


    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr;
      var value;
      var lcName;
      var l;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;
      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;
      /* Go backwards over all attributes; safely remove bad ones */

      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;
        value = name === 'value' ? attr.value : stringTrim(attr.value);
        lcName = transformCaseFunc(name);
        /* Execute a hook if present */

        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */

        if (hookEvent.forceKeepAttr) {
          continue;
        }
        /* Remove attribute */


        _removeAttribute(name, currentNode);
        /* Did the hooks approve of the attribute? */


        if (!hookEvent.keepAttr) {
          continue;
        }
        /* Work around a security issue in jQuery 3.0 */


        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);

          continue;
        }
        /* Sanitize attribute content to be template-safe */


        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR, ' ');
          value = stringReplace(value, ERB_EXPR, ' ');
          value = stringReplace(value, TMPLIT_EXPR, ' ');
        }
        /* Is `value` valid for this attribute? */


        var lcTag = transformCaseFunc(currentNode.nodeName);

        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        /* Full DOM Clobbering protection via namespace isolation,
         * Prefix id and name attributes with `user-content-`
         */


        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
          // Remove the attribute with this value
          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        /* Handle attributes that require Trusted Types */


        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
          if (namespaceURI) ;else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case 'TrustedHTML':
                {
                  value = trustedTypesPolicy.createHTML(value);
                  break;
                }

              case 'TrustedScriptURL':
                {
                  value = trustedTypesPolicy.createScriptURL(value);
                  break;
                }
            }
          }
        }
        /* Handle invalid data-* attribute set by try-catching it */


        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeAttributes', currentNode, null);
    };
    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */


    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode;

      var shadowIterator = _createIterator(fragment);
      /* Execute a hook if present */


      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);
        /* Sanitize tags and elements */


        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        /* Deep shadow DOM detected */


        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(shadowNode);
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };
    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity


    DOMPurify.sanitize = function (dirty) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var body;
      var importedNode;
      var currentNode;
      var returnNode;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */

      IS_EMPTY_INPUT = !dirty;

      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }
      /* Stringify, in case dirty is an object */


      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        if (typeof dirty.toString === 'function') {
          dirty = dirty.toString();

          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        } else {
          throw typeErrorCreate('toString is not a function');
        }
      }
      /* Return dirty HTML if DOMPurify cannot run */


      if (!DOMPurify.isSupported) {
        return dirty;
      }
      /* Assign config vars */


      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      /* Clean up removed elements */


      DOMPurify.removed = [];
      /* Check if dirty is correctly typed for IN_PLACE */

      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);

          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);

        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        /* Initialize the document to work on */


        body = _initDocument(dirty);
        /* Check we have a DOM node from the data */

        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }
      /* Remove first element node (ours) if FORCE_BODY is set */


      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      /* Get node iterator */


      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      /* Now start iterating over the created document */


      while (currentNode = nodeIterator.nextNode()) {
        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        /* Shadow DOM detected, sanitize it */


        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(currentNode);
      }
      /* If we sanitized `dirty` in-place, return it. */


      if (IN_PLACE) {
        return dirty;
      }
      /* Return sanitized string or DOM */


      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      /* Serialize doctype if allowed */

      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }
      /* Sanitize final string template-safe */


      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');
        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */


    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);

      SET_CONFIG = true;
    };
    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */


    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };
    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */


    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */


    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     * @return {Function} removed(popped) hook
     */


    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */


    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */


    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();
  return purify;
});

/***/ }),

/***/ 2110:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(8309);
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),

/***/ 746:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var b = "function" === typeof Symbol && Symbol.for,
    c = b ? Symbol.for("react.element") : 60103,
    d = b ? Symbol.for("react.portal") : 60106,
    e = b ? Symbol.for("react.fragment") : 60107,
    f = b ? Symbol.for("react.strict_mode") : 60108,
    g = b ? Symbol.for("react.profiler") : 60114,
    h = b ? Symbol.for("react.provider") : 60109,
    k = b ? Symbol.for("react.context") : 60110,
    l = b ? Symbol.for("react.async_mode") : 60111,
    m = b ? Symbol.for("react.concurrent_mode") : 60111,
    n = b ? Symbol.for("react.forward_ref") : 60112,
    p = b ? Symbol.for("react.suspense") : 60113,
    q = b ? Symbol.for("react.suspense_list") : 60120,
    r = b ? Symbol.for("react.memo") : 60115,
    t = b ? Symbol.for("react.lazy") : 60116,
    v = b ? Symbol.for("react.block") : 60121,
    w = b ? Symbol.for("react.fundamental") : 60117,
    x = b ? Symbol.for("react.responder") : 60118,
    y = b ? Symbol.for("react.scope") : 60119;

function z(a) {
  if ("object" === typeof a && null !== a) {
    var u = a.$$typeof;

    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;

              default:
                return u;
            }

        }

      case d:
        return u;
    }
  }
}

function A(a) {
  return z(a) === m;
}

exports.AsyncMode = l;
exports.ConcurrentMode = m;
exports.ContextConsumer = k;
exports.ContextProvider = h;
exports.Element = c;
exports.ForwardRef = n;
exports.Fragment = e;
exports.Lazy = t;
exports.Memo = r;
exports.Portal = d;
exports.Profiler = g;
exports.StrictMode = f;
exports.Suspense = p;

exports.isAsyncMode = function (a) {
  return A(a) || z(a) === l;
};

exports.isConcurrentMode = A;

exports.isContextConsumer = function (a) {
  return z(a) === k;
};

exports.isContextProvider = function (a) {
  return z(a) === h;
};

exports.isElement = function (a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};

exports.isForwardRef = function (a) {
  return z(a) === n;
};

exports.isFragment = function (a) {
  return z(a) === e;
};

exports.isLazy = function (a) {
  return z(a) === t;
};

exports.isMemo = function (a) {
  return z(a) === r;
};

exports.isPortal = function (a) {
  return z(a) === d;
};

exports.isProfiler = function (a) {
  return z(a) === g;
};

exports.isStrictMode = function (a) {
  return z(a) === f;
};

exports.isSuspense = function (a) {
  return z(a) === p;
};

exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};

exports.typeOf = z;

/***/ }),

/***/ 8309:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(746);
} else {}

/***/ }),

/***/ 9127:
/***/ (function(__unused_webpack_module, exports) {

/**
 * SVG elements are case-sensitive.
 *
 * @see {@link https://developer.mozilla.org/docs/Web/SVG/Element#svg_elements_a_to_z}
 */
exports.CASE_SENSITIVE_TAG_NAMES = ['animateMotion', 'animateTransform', 'clipPath', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'foreignObject', 'linearGradient', 'radialGradient', 'textPath'];

/***/ }),

/***/ 9409:
/***/ (function(module) {

// constants
var HTML = 'html';
var HEAD = 'head';
var BODY = 'body';
var FIRST_TAG_REGEX = /<([a-zA-Z]+[0-9]?)/; // e.g., <h1>
// match-all-characters in case of newlines (DOTALL)

var HEAD_TAG_REGEX = /<head[^]*>/i;
var BODY_TAG_REGEX = /<body[^]*>/i; // falls back to `parseFromString` if `createHTMLDocument` cannot be used

var parseFromDocument = function parseFromDocument() {
  throw new Error('This browser does not support `document.implementation.createHTMLDocument`');
};

var parseFromString = function parseFromString() {
  throw new Error('This browser does not support `DOMParser.prototype.parseFromString`');
};

var DOMParser = typeof window === 'object' && window.DOMParser;
/**
 * DOMParser (performance: slow).
 *
 * @see https://developer.mozilla.org/docs/Web/API/DOMParser#Parsing_an_SVG_or_HTML_document
 */

if (typeof DOMParser === 'function') {
  var domParser = new DOMParser();
  var mimeType = 'text/html';
  /**
   * Creates an HTML document using `DOMParser.parseFromString`.
   *
   * @param  {string} html      - The HTML string.
   * @param  {string} [tagName] - The element to render the HTML (with 'body' as fallback).
   * @return {HTMLDocument}
   */

  parseFromString = function parseFromString(html, tagName) {
    if (tagName) {
      html = '<' + tagName + '>' + html + '</' + tagName + '>';
    }

    return domParser.parseFromString(html, mimeType);
  };

  parseFromDocument = parseFromString;
}
/**
 * DOMImplementation (performance: fair).
 *
 * @see https://developer.mozilla.org/docs/Web/API/DOMImplementation/createHTMLDocument
 */


if (typeof document === 'object' && document.implementation) {
  var doc = document.implementation.createHTMLDocument();
  /**
   * Use HTML document created by `document.implementation.createHTMLDocument`.
   *
   * @param  {string} html      - The HTML string.
   * @param  {string} [tagName] - The element to render the HTML (with 'body' as fallback).
   * @return {HTMLDocument}
   */

  parseFromDocument = function parseFromDocument(html, tagName) {
    if (tagName) {
      var element = doc.documentElement.querySelector(tagName);
      element.innerHTML = html;
      return doc;
    }

    doc.documentElement.innerHTML = html;
    return doc;
  };
}
/**
 * Template (performance: fast).
 *
 * @see https://developer.mozilla.org/docs/Web/HTML/Element/template
 */


var template = typeof document === 'object' ? document.createElement('template') : {};
var parseFromTemplate;

if (template.content) {
  /**
   * Uses a template element (content fragment) to parse HTML.
   *
   * @param  {string} html - The HTML string.
   * @return {NodeList}
   */
  parseFromTemplate = function parseFromTemplate(html) {
    template.innerHTML = html;
    return template.content.childNodes;
  };
}
/**
 * Parses HTML string to DOM nodes.
 *
 * @param  {string}   html - HTML markup.
 * @return {NodeList}
 */


function domparser(html) {
  var firstTagName;
  var match = html.match(FIRST_TAG_REGEX);

  if (match && match[1]) {
    firstTagName = match[1].toLowerCase();
  }

  var doc;
  var element;
  var elements;

  switch (firstTagName) {
    case HTML:
      doc = parseFromString(html); // the created document may come with filler head/body elements,
      // so make sure to remove them if they don't actually exist

      if (!HEAD_TAG_REGEX.test(html)) {
        element = doc.querySelector(HEAD);

        if (element) {
          element.parentNode.removeChild(element);
        }
      }

      if (!BODY_TAG_REGEX.test(html)) {
        element = doc.querySelector(BODY);

        if (element) {
          element.parentNode.removeChild(element);
        }
      }

      return doc.querySelectorAll(HTML);

    case HEAD:
    case BODY:
      doc = parseFromDocument(html);
      elements = doc.querySelectorAll(firstTagName); // if there's a sibling element, then return both elements

      if (BODY_TAG_REGEX.test(html) && HEAD_TAG_REGEX.test(html)) {
        return elements[0].parentNode.childNodes;
      }

      return elements;
    // low-level tag or text

    default:
      if (parseFromTemplate) {
        return parseFromTemplate(html);
      }

      element = parseFromDocument(html, BODY).querySelector(BODY);
      return element.childNodes;
  }
}

module.exports = domparser;

/***/ }),

/***/ 159:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var domparser = __webpack_require__(9409);

var utilities = __webpack_require__(1716);

var formatDOM = utilities.formatDOM;
var DIRECTIVE_REGEX = /<(![a-zA-Z\s]+)>/; // e.g., <!doctype html>

/**
 * Parses HTML string to DOM nodes in browser.
 *
 * @param  {string} html  - HTML markup.
 * @return {DomElement[]} - DOM elements.
 */

function HTMLDOMParser(html) {
  if (typeof html !== 'string') {
    throw new TypeError('First argument must be a string');
  }

  if (html === '') {
    return [];
  } // match directive


  var match = html.match(DIRECTIVE_REGEX);
  var directive;

  if (match && match[1]) {
    directive = match[1];
  }

  return formatDOM(domparser(html), null, directive);
}

module.exports = HTMLDOMParser;

/***/ }),

/***/ 1716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var domhandler = __webpack_require__(538);

var constants = __webpack_require__(9127);

var CASE_SENSITIVE_TAG_NAMES = constants.CASE_SENSITIVE_TAG_NAMES;
var Comment = domhandler.Comment;
var Element = domhandler.Element;
var ProcessingInstruction = domhandler.ProcessingInstruction;
var Text = domhandler.Text;
var caseSensitiveTagNamesMap = {};
var tagName;

for (var i = 0, len = CASE_SENSITIVE_TAG_NAMES.length; i < len; i++) {
  tagName = CASE_SENSITIVE_TAG_NAMES[i];
  caseSensitiveTagNamesMap[tagName.toLowerCase()] = tagName;
}
/**
 * Gets case-sensitive tag name.
 *
 * @param {string} tagName - Tag name in lowercase.
 * @returns {string|undefined} - Case-sensitive tag name.
 */


function getCaseSensitiveTagName(tagName) {
  return caseSensitiveTagNamesMap[tagName];
}
/**
 * Formats DOM attributes to a hash map.
 *
 * @param {NamedNodeMap} attributes - List of attributes.
 * @returns {object} - Map of attribute name to value.
 */


function formatAttributes(attributes) {
  var result = {};
  var attribute; // `NamedNodeMap` is array-like

  for (var i = 0, len = attributes.length; i < len; i++) {
    attribute = attributes[i];
    result[attribute.name] = attribute.value;
  }

  return result;
}
/**
 * Corrects the tag name if it is case-sensitive (SVG).
 * Otherwise, returns the lowercase tag name (HTML).
 *
 * @param {string} tagName - Lowercase tag name.
 * @returns {string} - Formatted tag name.
 */


function formatTagName(tagName) {
  tagName = tagName.toLowerCase();
  var caseSensitiveTagName = getCaseSensitiveTagName(tagName);

  if (caseSensitiveTagName) {
    return caseSensitiveTagName;
  }

  return tagName;
}
/**
 * Transforms DOM nodes to `domhandler` nodes.
 *
 * @param {NodeList} nodes - DOM nodes.
 * @param {Element|null} [parent=null] - Parent node.
 * @param {string} [directive] - Directive.
 * @returns {Array<Comment|Element|ProcessingInstruction|Text>}
 */


function formatDOM(nodes, parent, directive) {
  parent = parent || null;
  var result = [];
  var tagName;

  for (var index = 0, len = nodes.length; index < len; index++) {
    var node = nodes[index];
    var current; // set the node data given the type

    switch (node.nodeType) {
      case 1:
        tagName = formatTagName(node.nodeName); // script, style, or tag

        current = new Element(tagName, formatAttributes(node.attributes));
        current.children = formatDOM( // template children are on content
        tagName === 'template' ? node.content.childNodes : node.childNodes, current);
        break;

      case 3:
        current = new Text(node.nodeValue);
        break;

      case 8:
        current = new Comment(node.nodeValue);
        break;

      default:
        continue;
    } // set previous node next


    var prev = result[index - 1] || null;

    if (prev) {
      prev.next = current;
    } // set properties for current node


    current.parent = parent;
    current.prev = prev;
    current.next = null;
    result.push(current);
  }

  if (directive) {
    current = new ProcessingInstruction(directive.substring(0, directive.indexOf(' ')).toLowerCase(), directive);
    current.next = result[0] || null;
    current.parent = parent;
    result.unshift(current);

    if (result[1]) {
      result[1].prev = result[0];
    }
  }

  return result;
}

exports.formatAttributes = formatAttributes;
exports.formatDOM = formatDOM;

/***/ }),

/***/ 538:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DomHandler = void 0;

var domelementtype_1 = __webpack_require__(4776);

var node_js_1 = __webpack_require__(4362);

__exportStar(__webpack_require__(4362), exports); // Default options


var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};

var DomHandler =
/** @class */
function () {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  function DomHandler(callback, options, elementCB) {
    /** The elements of the DOM */
    this.dom = [];
    /** The root element for the DOM */

    this.root = new node_js_1.Document(this.dom);
    /** Indicated whether parsing has been completed. */

    this.done = false;
    /** Stack of open tags. */

    this.tagStack = [this.root];
    /** A data node that is still being written to. */

    this.lastNode = null;
    /** Reference to the parser instance. Used for location information. */

    this.parser = null; // Make it possible to skip arguments, for backwards-compatibility

    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }

    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }

    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }

  DomHandler.prototype.onparserinit = function (parser) {
    this.parser = parser;
  }; // Resets the handler back to starting state


  DomHandler.prototype.onreset = function () {
    this.dom = [];
    this.root = new node_js_1.Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }; // Signals the handler that parsing is done


  DomHandler.prototype.onend = function () {
    if (this.done) return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  };

  DomHandler.prototype.onerror = function (error) {
    this.handleCallback(error);
  };

  DomHandler.prototype.onclosetag = function () {
    this.lastNode = null;
    var elem = this.tagStack.pop();

    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }

    if (this.elementCB) this.elementCB(elem);
  };

  DomHandler.prototype.onopentag = function (name, attribs) {
    var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
    var element = new node_js_1.Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  };

  DomHandler.prototype.ontext = function (data) {
    var lastNode = this.lastNode;

    if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
      lastNode.data += data;

      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      var node = new node_js_1.Text(data);
      this.addNode(node);
      this.lastNode = node;
    }
  };

  DomHandler.prototype.oncomment = function (data) {
    if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }

    var node = new node_js_1.Comment(data);
    this.addNode(node);
    this.lastNode = node;
  };

  DomHandler.prototype.oncommentend = function () {
    this.lastNode = null;
  };

  DomHandler.prototype.oncdatastart = function () {
    var text = new node_js_1.Text("");
    var node = new node_js_1.CDATA([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  };

  DomHandler.prototype.oncdataend = function () {
    this.lastNode = null;
  };

  DomHandler.prototype.onprocessinginstruction = function (name, data) {
    var node = new node_js_1.ProcessingInstruction(name, data);
    this.addNode(node);
  };

  DomHandler.prototype.handleCallback = function (error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  };

  DomHandler.prototype.addNode = function (node) {
    var parent = this.tagStack[this.tagStack.length - 1];
    var previousSibling = parent.children[parent.children.length - 1];

    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }

    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }

    parent.children.push(node);

    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }

    node.parent = parent;
    this.lastNode = null;
  };

  return DomHandler;
}();

exports.DomHandler = DomHandler;
exports["default"] = DomHandler;

/***/ }),

/***/ 4362:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;

var domelementtype_1 = __webpack_require__(4776);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */


var Node =
/** @class */
function () {
  function Node() {
    /** Parent of the node */
    this.parent = null;
    /** Previous sibling */

    this.prev = null;
    /** Next sibling */

    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */

    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */

    this.endIndex = null;
  }

  Object.defineProperty(Node.prototype, "parentNode", {
    // Read-write aliases for properties

    /**
     * Same as {@link parent}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.parent;
    },
    set: function set(parent) {
      this.parent = parent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "previousSibling", {
    /**
     * Same as {@link prev}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.prev;
    },
    set: function set(prev) {
      this.prev = prev;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "nextSibling", {
    /**
     * Same as {@link next}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.next;
    },
    set: function set(next) {
      this.next = next;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */

  Node.prototype.cloneNode = function (recursive) {
    if (recursive === void 0) {
      recursive = false;
    }

    return cloneNode(this, recursive);
  };

  return Node;
}();

exports.Node = Node;
/**
 * A node that contains some data.
 */

var DataNode =
/** @class */
function (_super) {
  __extends(DataNode, _super);
  /**
   * @param data The content of the data node
   */


  function DataNode(data) {
    var _this = _super.call(this) || this;

    _this.data = data;
    return _this;
  }

  Object.defineProperty(DataNode.prototype, "nodeValue", {
    /**
     * Same as {@link data}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.data;
    },
    set: function set(data) {
      this.data = data;
    },
    enumerable: false,
    configurable: true
  });
  return DataNode;
}(Node);

exports.DataNode = DataNode;
/**
 * Text within the document.
 */

var Text =
/** @class */
function (_super) {
  __extends(Text, _super);

  function Text() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.Text;
    return _this;
  }

  Object.defineProperty(Text.prototype, "nodeType", {
    get: function get() {
      return 3;
    },
    enumerable: false,
    configurable: true
  });
  return Text;
}(DataNode);

exports.Text = Text;
/**
 * Comments within the document.
 */

var Comment =
/** @class */
function (_super) {
  __extends(Comment, _super);

  function Comment() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.Comment;
    return _this;
  }

  Object.defineProperty(Comment.prototype, "nodeType", {
    get: function get() {
      return 8;
    },
    enumerable: false,
    configurable: true
  });
  return Comment;
}(DataNode);

exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */

var ProcessingInstruction =
/** @class */
function (_super) {
  __extends(ProcessingInstruction, _super);

  function ProcessingInstruction(name, data) {
    var _this = _super.call(this, data) || this;

    _this.name = name;
    _this.type = domelementtype_1.ElementType.Directive;
    return _this;
  }

  Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
    get: function get() {
      return 1;
    },
    enumerable: false,
    configurable: true
  });
  return ProcessingInstruction;
}(DataNode);

exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */

var NodeWithChildren =
/** @class */
function (_super) {
  __extends(NodeWithChildren, _super);
  /**
   * @param children Children of the node. Only certain node types can have children.
   */


  function NodeWithChildren(children) {
    var _this = _super.call(this) || this;

    _this.children = children;
    return _this;
  }

  Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
    // Aliases

    /** First child of the node. */
    get: function get() {
      var _a;

      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
    /** Last child of the node. */
    get: function get() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
    /**
     * Same as {@link children}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.children;
    },
    set: function set(children) {
      this.children = children;
    },
    enumerable: false,
    configurable: true
  });
  return NodeWithChildren;
}(Node);

exports.NodeWithChildren = NodeWithChildren;

var CDATA =
/** @class */
function (_super) {
  __extends(CDATA, _super);

  function CDATA() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.CDATA;
    return _this;
  }

  Object.defineProperty(CDATA.prototype, "nodeType", {
    get: function get() {
      return 4;
    },
    enumerable: false,
    configurable: true
  });
  return CDATA;
}(NodeWithChildren);

exports.CDATA = CDATA;
/**
 * The root node of the document.
 */

var Document =
/** @class */
function (_super) {
  __extends(Document, _super);

  function Document() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.Root;
    return _this;
  }

  Object.defineProperty(Document.prototype, "nodeType", {
    get: function get() {
      return 9;
    },
    enumerable: false,
    configurable: true
  });
  return Document;
}(NodeWithChildren);

exports.Document = Document;
/**
 * An element within the DOM.
 */

var Element =
/** @class */
function (_super) {
  __extends(Element, _super);
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */


  function Element(name, attribs, children, type) {
    if (children === void 0) {
      children = [];
    }

    if (type === void 0) {
      type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
    }

    var _this = _super.call(this, children) || this;

    _this.name = name;
    _this.attribs = attribs;
    _this.type = type;
    return _this;
  }

  Object.defineProperty(Element.prototype, "nodeType", {
    get: function get() {
      return 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Element.prototype, "tagName", {
    // DOM Level 1 aliases

    /**
     * Same as {@link name}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.name;
    },
    set: function set(name) {
      this.name = name;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Element.prototype, "attributes", {
    get: function get() {
      var _this = this;

      return Object.keys(this.attribs).map(function (name) {
        var _a, _b;

        return {
          name: name,
          value: _this.attribs[name],
          namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
          prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
        };
      });
    },
    enumerable: false,
    configurable: true
  });
  return Element;
}(NodeWithChildren);

exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */

function isTag(node) {
  return (0, domelementtype_1.isTag)(node);
}

exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */

function isCDATA(node) {
  return node.type === domelementtype_1.ElementType.CDATA;
}

exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */

function isText(node) {
  return node.type === domelementtype_1.ElementType.Text;
}

exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */

function isComment(node) {
  return node.type === domelementtype_1.ElementType.Comment;
}

exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */

function isDirective(node) {
  return node.type === domelementtype_1.ElementType.Directive;
}

exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */

function isDocument(node) {
  return node.type === domelementtype_1.ElementType.Root;
}

exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */

function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}

exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */

function cloneNode(node, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }

  var result;

  if (isText(node)) {
    result = new Text(node.data);
  } else if (isComment(node)) {
    result = new Comment(node.data);
  } else if (isTag(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
    children.forEach(function (child) {
      return child.parent = clone_1;
    });

    if (node.namespace != null) {
      clone_1.namespace = node.namespace;
    }

    if (node["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
    }

    if (node["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
    }

    result = clone_1;
  } else if (isCDATA(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_2 = new CDATA(children);
    children.forEach(function (child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_3 = new Document(children);
    children.forEach(function (child) {
      return child.parent = clone_3;
    });

    if (node["x-mode"]) {
      clone_3["x-mode"] = node["x-mode"];
    }

    result = clone_3;
  } else if (isDirective(node)) {
    var instruction = new ProcessingInstruction(node.name, node.data);

    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }

    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node.type));
  }

  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;

  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }

  return result;
}

exports.cloneNode = cloneNode;

function cloneChildren(childs) {
  var children = childs.map(function (child) {
    return cloneNode(child, true);
  });

  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }

  return children;
}

/***/ }),

/***/ 6854:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var domhandler = __webpack_require__(9936);

var htmlToDOM = __webpack_require__(159);

var attributesToProps = __webpack_require__(8131);

var domToReact = __webpack_require__(4595); // support backwards compatibility for ES Module


htmlToDOM =
/* istanbul ignore next */
typeof htmlToDOM.default === 'function' ? htmlToDOM.default : htmlToDOM;
var domParserOptions = {
  lowerCaseAttributeNames: false
};
/**
 * Converts HTML string to React elements.
 *
 * @param {string} html - HTML string.
 * @param {object} [options] - Parser options.
 * @param {object} [options.htmlparser2] - htmlparser2 options.
 * @param {object} [options.library] - Library for React, Preact, etc.
 * @param {Function} [options.replace] - Replace method.
 * @returns {JSX.Element|JSX.Element[]|string} - React element(s), empty array, or string.
 */

function HTMLReactParser(html, options) {
  if (typeof html !== 'string') {
    throw new TypeError('First argument must be a string');
  }

  if (html === '') {
    return [];
  }

  options = options || {};
  return domToReact(htmlToDOM(html, options.htmlparser2 || domParserOptions), options);
}

HTMLReactParser.domToReact = domToReact;
HTMLReactParser.htmlToDOM = htmlToDOM;
HTMLReactParser.attributesToProps = attributesToProps; // domhandler

HTMLReactParser.Comment = domhandler.Comment;
HTMLReactParser.Element = domhandler.Element;
HTMLReactParser.ProcessingInstruction = domhandler.ProcessingInstruction;
HTMLReactParser.Text = domhandler.Text; // support CommonJS and ES Modules

module.exports = HTMLReactParser;
HTMLReactParser.default = HTMLReactParser;

/***/ }),

/***/ 8131:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var reactProperty = __webpack_require__(6195);

var utilities = __webpack_require__(4141); // https://reactjs.org/docs/uncontrolled-components.html
// https://developer.mozilla.org/docs/Web/HTML/Attributes


var UNCONTROLLED_COMPONENT_ATTRIBUTES = ['checked', 'value'];
var UNCONTROLLED_COMPONENT_NAMES = ['input', 'select', 'textarea'];
var VALUE_ONLY_INPUTS = {
  reset: true,
  submit: true
};
/**
 * Converts HTML/SVG DOM attributes to React props.
 *
 * @param {object} [attributes={}] - HTML/SVG DOM attributes.
 * @param {string} [nodeName] - DOM node name.
 * @returns - React props.
 */

module.exports = function attributesToProps(attributes, nodeName) {
  attributes = attributes || {};
  var attributeName;
  var attributeNameLowerCased;
  var attributeValue;
  var propName;
  var propertyInfo;
  var props = {};
  var inputIsValueOnly = attributes.type && VALUE_ONLY_INPUTS[attributes.type];

  for (attributeName in attributes) {
    attributeValue = attributes[attributeName]; // ARIA (aria-*) or custom data (data-*) attribute

    if (reactProperty.isCustomAttribute(attributeName)) {
      props[attributeName] = attributeValue;
      continue;
    } // convert HTML/SVG attribute to React prop


    attributeNameLowerCased = attributeName.toLowerCase();
    propName = getPropName(attributeNameLowerCased);

    if (propName) {
      propertyInfo = reactProperty.getPropertyInfo(propName); // convert attribute to uncontrolled component prop (e.g., `value` to `defaultValue`)

      if (UNCONTROLLED_COMPONENT_ATTRIBUTES.indexOf(propName) !== -1 && UNCONTROLLED_COMPONENT_NAMES.indexOf(nodeName) !== -1 && !inputIsValueOnly) {
        propName = getPropName('default' + attributeNameLowerCased);
      }

      props[propName] = attributeValue;

      switch (propertyInfo && propertyInfo.type) {
        case reactProperty.BOOLEAN:
          props[propName] = true;
          break;

        case reactProperty.OVERLOADED_BOOLEAN:
          if (attributeValue === '') {
            props[propName] = true;
          }

          break;
      }

      continue;
    } // preserve custom attribute if React >=16


    if (utilities.PRESERVE_CUSTOM_ATTRIBUTES) {
      props[attributeName] = attributeValue;
    }
  } // transform inline style to object


  utilities.setStyleProp(attributes.style, props);
  return props;
};
/**
 * Gets prop name from lowercased attribute name.
 *
 * @param {string} attributeName - Lowercased attribute name.
 * @returns - Prop name.
 */


function getPropName(attributeName) {
  return reactProperty.possibleStandardNames[attributeName];
}

/***/ }),

/***/ 4595:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var React = __webpack_require__(2791);

var attributesToProps = __webpack_require__(8131);

var utilities = __webpack_require__(4141);

var setStyleProp = utilities.setStyleProp;
var canTextBeChildOfNode = utilities.canTextBeChildOfNode;
/**
 * Converts DOM nodes to JSX element(s).
 *
 * @param {DomElement[]} nodes - DOM nodes.
 * @param {object} [options={}] - Options.
 * @param {Function} [options.replace] - Replacer.
 * @param {object} [options.library] - Library (React, Preact, etc.).
 * @returns - String or JSX element(s).
 */

function domToReact(nodes, options) {
  options = options || {};
  var library = options.library || React;
  var cloneElement = library.cloneElement;
  var createElement = library.createElement;
  var isValidElement = library.isValidElement;
  var result = [];
  var node;
  var isWhitespace;
  var hasReplace = typeof options.replace === 'function';
  var replaceElement;
  var props;
  var children;
  var trim = options.trim;

  for (var i = 0, len = nodes.length; i < len; i++) {
    node = nodes[i]; // replace with custom React element (if present)

    if (hasReplace) {
      replaceElement = options.replace(node);

      if (isValidElement(replaceElement)) {
        // set "key" prop for sibling elements
        // https://fb.me/react-warning-keys
        if (len > 1) {
          replaceElement = cloneElement(replaceElement, {
            key: replaceElement.key || i
          });
        }

        result.push(replaceElement);
        continue;
      }
    }

    if (node.type === 'text') {
      isWhitespace = !node.data.trim().length;

      if (isWhitespace && node.parent && !canTextBeChildOfNode(node.parent)) {
        // We have a whitespace node that can't be nested in its parent
        // so skip it
        continue;
      }

      if (trim && isWhitespace) {
        // Trim is enabled and we have a whitespace node
        // so skip it
        continue;
      } // We have a text node that's not whitespace and it can be nested
      // in its parent so add it to the results


      result.push(node.data);
      continue;
    }

    props = node.attribs;

    if (skipAttributesToProps(node)) {
      setStyleProp(props.style, props);
    } else if (props) {
      props = attributesToProps(props, node.name);
    }

    children = null;

    switch (node.type) {
      case 'script':
      case 'style':
        // prevent text in <script> or <style> from being escaped
        // https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
        if (node.children[0]) {
          props.dangerouslySetInnerHTML = {
            __html: node.children[0].data
          };
        }

        break;

      case 'tag':
        // setting textarea value in children is an antipattern in React
        // https://reactjs.org/docs/forms.html#the-textarea-tag
        if (node.name === 'textarea' && node.children[0]) {
          props.defaultValue = node.children[0].data;
        } else if (node.children && node.children.length) {
          // continue recursion of creating React elements (if applicable)
          children = domToReact(node.children, options);
        }

        break;
      // skip all other cases (e.g., comment)

      default:
        continue;
    } // set "key" prop for sibling elements
    // https://fb.me/react-warning-keys


    if (len > 1) {
      props.key = i;
    }

    result.push(createElement(node.name, props, children));
  }

  return result.length === 1 ? result[0] : result;
}
/**
 * Determines whether DOM element attributes should be transformed to props.
 * Web Components should not have their attributes transformed except for `style`.
 *
 * @param {DomElement} node
 * @returns - Whether node attributes should be converted to props.
 */


function skipAttributesToProps(node) {
  return utilities.PRESERVE_CUSTOM_ATTRIBUTES && node.type === 'tag' && utilities.isCustomComponent(node.name, node.attribs);
}

module.exports = domToReact;

/***/ }),

/***/ 4141:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var React = __webpack_require__(2791);

var styleToJS = (__webpack_require__(5792)["default"]);
/**
 * Swap key with value in an object.
 *
 * @param {object} obj - The object.
 * @param {Function} [override] - The override method.
 * @returns - The inverted object.
 */


function invertObject(obj, override) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('First argument must be an object');
  }

  var key;
  var value;
  var isOverridePresent = typeof override === 'function';
  var overrides = {};
  var result = {};

  for (key in obj) {
    value = obj[key];

    if (isOverridePresent) {
      overrides = override(key, value);

      if (overrides && overrides.length === 2) {
        result[overrides[0]] = overrides[1];
        continue;
      }
    }

    if (typeof value === 'string') {
      result[value] = key;
    }
  }

  return result;
}
/**
 * Check if a given tag is a custom component.
 *
 * @see {@link https://github.com/facebook/react/blob/v16.6.3/packages/react-dom/src/shared/isCustomComponent.js}
 *
 * @param {string} tagName - The name of the html tag.
 * @param {object} props - The props being passed to the element.
 * @returns - Whether tag is custom component.
 */


function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return props && typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

var styleToJSOptions = {
  reactCompat: true
};
/**
 * Sets style prop.
 *
 * @param {null|undefined|string} style
 * @param {object} props
 */

function setStyleProp(style, props) {
  if (style === null || style === undefined) {
    return;
  }

  try {
    props.style = styleToJS(style, styleToJSOptions);
  } catch (err) {
    props.style = {};
  }
}
/**
 * @constant {boolean}
 * @see {@link https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html}
 */


var PRESERVE_CUSTOM_ATTRIBUTES = React.version.split('.')[0] >= 16; // Taken from
// https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react-dom/src/client/validateDOMNesting.js#L213

var elementsWithNoTextChildren = new Set(['tr', 'tbody', 'thead', 'tfoot', 'colgroup', 'table', 'head', 'html', 'frameset']);
/**
 * Checks if the given node can contain text nodes
 *
 * @param {DomElement} node - Node.
 * @returns - Whether node can contain text nodes.
 */

function canTextBeChildOfNode(node) {
  return !elementsWithNoTextChildren.has(node.name);
}

module.exports = {
  PRESERVE_CUSTOM_ATTRIBUTES: PRESERVE_CUSTOM_ATTRIBUTES,
  invertObject: invertObject,
  isCustomComponent: isCustomComponent,
  setStyleProp: setStyleProp,
  canTextBeChildOfNode: canTextBeChildOfNode,
  elementsWithNoTextChildren: elementsWithNoTextChildren
};

/***/ }),

/***/ 9936:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DomHandler = void 0;

var domelementtype_1 = __webpack_require__(4776);

var node_js_1 = __webpack_require__(1262);

__exportStar(__webpack_require__(1262), exports); // Default options


var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};

var DomHandler =
/** @class */
function () {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  function DomHandler(callback, options, elementCB) {
    /** The elements of the DOM */
    this.dom = [];
    /** The root element for the DOM */

    this.root = new node_js_1.Document(this.dom);
    /** Indicated whether parsing has been completed. */

    this.done = false;
    /** Stack of open tags. */

    this.tagStack = [this.root];
    /** A data node that is still being written to. */

    this.lastNode = null;
    /** Reference to the parser instance. Used for location information. */

    this.parser = null; // Make it possible to skip arguments, for backwards-compatibility

    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }

    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }

    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }

  DomHandler.prototype.onparserinit = function (parser) {
    this.parser = parser;
  }; // Resets the handler back to starting state


  DomHandler.prototype.onreset = function () {
    this.dom = [];
    this.root = new node_js_1.Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }; // Signals the handler that parsing is done


  DomHandler.prototype.onend = function () {
    if (this.done) return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  };

  DomHandler.prototype.onerror = function (error) {
    this.handleCallback(error);
  };

  DomHandler.prototype.onclosetag = function () {
    this.lastNode = null;
    var elem = this.tagStack.pop();

    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }

    if (this.elementCB) this.elementCB(elem);
  };

  DomHandler.prototype.onopentag = function (name, attribs) {
    var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
    var element = new node_js_1.Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  };

  DomHandler.prototype.ontext = function (data) {
    var lastNode = this.lastNode;

    if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
      lastNode.data += data;

      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      var node = new node_js_1.Text(data);
      this.addNode(node);
      this.lastNode = node;
    }
  };

  DomHandler.prototype.oncomment = function (data) {
    if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }

    var node = new node_js_1.Comment(data);
    this.addNode(node);
    this.lastNode = node;
  };

  DomHandler.prototype.oncommentend = function () {
    this.lastNode = null;
  };

  DomHandler.prototype.oncdatastart = function () {
    var text = new node_js_1.Text("");
    var node = new node_js_1.CDATA([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  };

  DomHandler.prototype.oncdataend = function () {
    this.lastNode = null;
  };

  DomHandler.prototype.onprocessinginstruction = function (name, data) {
    var node = new node_js_1.ProcessingInstruction(name, data);
    this.addNode(node);
  };

  DomHandler.prototype.handleCallback = function (error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  };

  DomHandler.prototype.addNode = function (node) {
    var parent = this.tagStack[this.tagStack.length - 1];
    var previousSibling = parent.children[parent.children.length - 1];

    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }

    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }

    parent.children.push(node);

    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }

    node.parent = parent;
    this.lastNode = null;
  };

  return DomHandler;
}();

exports.DomHandler = DomHandler;
exports["default"] = DomHandler;

/***/ }),

/***/ 1262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;

var domelementtype_1 = __webpack_require__(4776);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */


var Node =
/** @class */
function () {
  function Node() {
    /** Parent of the node */
    this.parent = null;
    /** Previous sibling */

    this.prev = null;
    /** Next sibling */

    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */

    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */

    this.endIndex = null;
  }

  Object.defineProperty(Node.prototype, "parentNode", {
    // Read-write aliases for properties

    /**
     * Same as {@link parent}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.parent;
    },
    set: function set(parent) {
      this.parent = parent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "previousSibling", {
    /**
     * Same as {@link prev}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.prev;
    },
    set: function set(prev) {
      this.prev = prev;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "nextSibling", {
    /**
     * Same as {@link next}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.next;
    },
    set: function set(next) {
      this.next = next;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */

  Node.prototype.cloneNode = function (recursive) {
    if (recursive === void 0) {
      recursive = false;
    }

    return cloneNode(this, recursive);
  };

  return Node;
}();

exports.Node = Node;
/**
 * A node that contains some data.
 */

var DataNode =
/** @class */
function (_super) {
  __extends(DataNode, _super);
  /**
   * @param data The content of the data node
   */


  function DataNode(data) {
    var _this = _super.call(this) || this;

    _this.data = data;
    return _this;
  }

  Object.defineProperty(DataNode.prototype, "nodeValue", {
    /**
     * Same as {@link data}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.data;
    },
    set: function set(data) {
      this.data = data;
    },
    enumerable: false,
    configurable: true
  });
  return DataNode;
}(Node);

exports.DataNode = DataNode;
/**
 * Text within the document.
 */

var Text =
/** @class */
function (_super) {
  __extends(Text, _super);

  function Text() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.Text;
    return _this;
  }

  Object.defineProperty(Text.prototype, "nodeType", {
    get: function get() {
      return 3;
    },
    enumerable: false,
    configurable: true
  });
  return Text;
}(DataNode);

exports.Text = Text;
/**
 * Comments within the document.
 */

var Comment =
/** @class */
function (_super) {
  __extends(Comment, _super);

  function Comment() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.Comment;
    return _this;
  }

  Object.defineProperty(Comment.prototype, "nodeType", {
    get: function get() {
      return 8;
    },
    enumerable: false,
    configurable: true
  });
  return Comment;
}(DataNode);

exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */

var ProcessingInstruction =
/** @class */
function (_super) {
  __extends(ProcessingInstruction, _super);

  function ProcessingInstruction(name, data) {
    var _this = _super.call(this, data) || this;

    _this.name = name;
    _this.type = domelementtype_1.ElementType.Directive;
    return _this;
  }

  Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
    get: function get() {
      return 1;
    },
    enumerable: false,
    configurable: true
  });
  return ProcessingInstruction;
}(DataNode);

exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */

var NodeWithChildren =
/** @class */
function (_super) {
  __extends(NodeWithChildren, _super);
  /**
   * @param children Children of the node. Only certain node types can have children.
   */


  function NodeWithChildren(children) {
    var _this = _super.call(this) || this;

    _this.children = children;
    return _this;
  }

  Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
    // Aliases

    /** First child of the node. */
    get: function get() {
      var _a;

      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
    /** Last child of the node. */
    get: function get() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
    /**
     * Same as {@link children}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.children;
    },
    set: function set(children) {
      this.children = children;
    },
    enumerable: false,
    configurable: true
  });
  return NodeWithChildren;
}(Node);

exports.NodeWithChildren = NodeWithChildren;

var CDATA =
/** @class */
function (_super) {
  __extends(CDATA, _super);

  function CDATA() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.CDATA;
    return _this;
  }

  Object.defineProperty(CDATA.prototype, "nodeType", {
    get: function get() {
      return 4;
    },
    enumerable: false,
    configurable: true
  });
  return CDATA;
}(NodeWithChildren);

exports.CDATA = CDATA;
/**
 * The root node of the document.
 */

var Document =
/** @class */
function (_super) {
  __extends(Document, _super);

  function Document() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = domelementtype_1.ElementType.Root;
    return _this;
  }

  Object.defineProperty(Document.prototype, "nodeType", {
    get: function get() {
      return 9;
    },
    enumerable: false,
    configurable: true
  });
  return Document;
}(NodeWithChildren);

exports.Document = Document;
/**
 * An element within the DOM.
 */

var Element =
/** @class */
function (_super) {
  __extends(Element, _super);
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */


  function Element(name, attribs, children, type) {
    if (children === void 0) {
      children = [];
    }

    if (type === void 0) {
      type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
    }

    var _this = _super.call(this, children) || this;

    _this.name = name;
    _this.attribs = attribs;
    _this.type = type;
    return _this;
  }

  Object.defineProperty(Element.prototype, "nodeType", {
    get: function get() {
      return 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Element.prototype, "tagName", {
    // DOM Level 1 aliases

    /**
     * Same as {@link name}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function get() {
      return this.name;
    },
    set: function set(name) {
      this.name = name;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Element.prototype, "attributes", {
    get: function get() {
      var _this = this;

      return Object.keys(this.attribs).map(function (name) {
        var _a, _b;

        return {
          name: name,
          value: _this.attribs[name],
          namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
          prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
        };
      });
    },
    enumerable: false,
    configurable: true
  });
  return Element;
}(NodeWithChildren);

exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */

function isTag(node) {
  return (0, domelementtype_1.isTag)(node);
}

exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */

function isCDATA(node) {
  return node.type === domelementtype_1.ElementType.CDATA;
}

exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */

function isText(node) {
  return node.type === domelementtype_1.ElementType.Text;
}

exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */

function isComment(node) {
  return node.type === domelementtype_1.ElementType.Comment;
}

exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */

function isDirective(node) {
  return node.type === domelementtype_1.ElementType.Directive;
}

exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */

function isDocument(node) {
  return node.type === domelementtype_1.ElementType.Root;
}

exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */

function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}

exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */

function cloneNode(node, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }

  var result;

  if (isText(node)) {
    result = new Text(node.data);
  } else if (isComment(node)) {
    result = new Comment(node.data);
  } else if (isTag(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
    children.forEach(function (child) {
      return child.parent = clone_1;
    });

    if (node.namespace != null) {
      clone_1.namespace = node.namespace;
    }

    if (node["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
    }

    if (node["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
    }

    result = clone_1;
  } else if (isCDATA(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_2 = new CDATA(children);
    children.forEach(function (child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_3 = new Document(children);
    children.forEach(function (child) {
      return child.parent = clone_3;
    });

    if (node["x-mode"]) {
      clone_3["x-mode"] = node["x-mode"];
    }

    result = clone_3;
  } else if (isDirective(node)) {
    var instruction = new ProcessingInstruction(node.name, node.data);

    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }

    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node.type));
  }

  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;

  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }

  return result;
}

exports.cloneNode = cloneNode;

function cloneChildren(childs) {
  var children = childs.map(function (child) {
    return cloneNode(child, true);
  });

  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }

  return children;
}

/***/ }),

/***/ 1065:
/***/ (function(module) {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/; // declaration

var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/; // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill

var TRIM_REGEX = /^\s+|\s+$/g; // strings

var NEWLINE = '\n';
var FORWARD_SLASH = '/';
var ASTERISK = '*';
var EMPTY_STRING = ''; // types

var TYPE_COMMENT = 'comment';
var TYPE_DECLARATION = 'declaration';
/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */

module.exports = function (style, options) {
  if (typeof style !== 'string') {
    throw new TypeError('First argument must be a string');
  }

  if (!style) return [];
  options = options || {};
  /**
   * Positional.
   */

  var lineno = 1;
  var column = 1;
  /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */

  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column = ~i ? str.length - i : column + str.length;
  }
  /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */


  function position() {
    var start = {
      line: lineno,
      column: column
    };
    return function (node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }
  /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */


  function Position(start) {
    this.start = start;
    this.end = {
      line: lineno,
      column: column
    };
    this.source = options.source;
  }
  /**
   * Non-enumerable source string.
   */


  Position.prototype.content = style;
  var errorsList = [];
  /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */

  function error(msg) {
    var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = style;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }
  /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */


  function match(re) {
    var m = re.exec(style);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m;
  }
  /**
   * Parse whitespace.
   */


  function whitespace() {
    match(WHITESPACE_REGEX);
  }
  /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */


  function comments(rules) {
    var c;
    rules = rules || [];

    while (c = comment()) {
      if (c !== false) {
        rules.push(c);
      }
    }

    return rules;
  }
  /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */


  function comment() {
    var pos = position();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
    var i = 2;

    while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
      ++i;
    }

    i += 2;

    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error('End of comment missing');
    }

    var str = style.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    style = style.slice(i);
    column += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }
  /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */


  function declaration() {
    var pos = position(); // prop

    var prop = match(PROPERTY_REGEX);
    if (!prop) return;
    comment(); // :

    if (!match(COLON_REGEX)) return error("property missing ':'"); // val

    var val = match(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    }); // ;

    match(SEMICOLON_REGEX);
    return ret;
  }
  /**
   * Parse declarations.
   *
   * @return {Object[]}
   */


  function declarations() {
    var decls = [];
    comments(decls); // declarations

    var decl;

    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    return decls;
  }

  whitespace();
  return declarations();
};
/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */


function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}

/***/ }),

/***/ 5950:
/***/ (function(module) {

!function (t, i) {
   true ? module.exports = i() : 0;
}(this, function () {
  "use strict";

  function t(t, r, e, a, h) {
    !function t(n, r, e, a, h) {
      for (; a > e;) {
        if (a - e > 600) {
          var o = a - e + 1,
              s = r - e + 1,
              l = Math.log(o),
              f = .5 * Math.exp(2 * l / 3),
              u = .5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1),
              m = Math.max(e, Math.floor(r - s * f / o + u)),
              c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
          t(n, r, m, c, h);
        }

        var p = n[r],
            d = e,
            x = a;

        for (i(n, e, r), h(n[a], p) > 0 && i(n, e, a); d < x;) {
          for (i(n, d, x), d++, x--; h(n[d], p) < 0;) {
            d++;
          }

          for (; h(n[x], p) > 0;) {
            x--;
          }
        }

        0 === h(n[e], p) ? i(n, e, x) : i(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
      }
    }(t, r, e || 0, a || t.length - 1, h || n);
  }

  function i(t, i, n) {
    var r = t[i];
    t[i] = t[n], t[n] = r;
  }

  function n(t, i) {
    return t < i ? -1 : t > i ? 1 : 0;
  }

  var r = function r(t) {
    void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
  };

  function e(t, i, n) {
    if (!n) return i.indexOf(t);

    for (var r = 0; r < i.length; r++) {
      if (n(t, i[r])) return r;
    }

    return -1;
  }

  function a(t, i) {
    h(t, 0, t.children.length, i, t);
  }

  function h(t, i, n, r, e) {
    e || (e = p(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;

    for (var a = i; a < n; a++) {
      var h = t.children[a];
      o(e, t.leaf ? r(h) : h);
    }

    return e;
  }

  function o(t, i) {
    return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
  }

  function s(t, i) {
    return t.minX - i.minX;
  }

  function l(t, i) {
    return t.minY - i.minY;
  }

  function f(t) {
    return (t.maxX - t.minX) * (t.maxY - t.minY);
  }

  function u(t) {
    return t.maxX - t.minX + (t.maxY - t.minY);
  }

  function m(t, i) {
    return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
  }

  function c(t, i) {
    return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
  }

  function p(t) {
    return {
      children: t,
      height: 1,
      leaf: !0,
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: -1 / 0,
      maxY: -1 / 0
    };
  }

  function d(i, n, r, e, a) {
    for (var h = [n, r]; h.length;) {
      if (!((r = h.pop()) - (n = h.pop()) <= e)) {
        var o = n + Math.ceil((r - n) / e / 2) * e;
        t(i, o, n, r, a), h.push(n, o, o, r);
      }
    }
  }

  return r.prototype.all = function () {
    return this._all(this.data, []);
  }, r.prototype.search = function (t) {
    var i = this.data,
        n = [];
    if (!c(t, i)) return n;

    for (var r = this.toBBox, e = []; i;) {
      for (var a = 0; a < i.children.length; a++) {
        var h = i.children[a],
            o = i.leaf ? r(h) : h;
        c(t, o) && (i.leaf ? n.push(h) : m(t, o) ? this._all(h, n) : e.push(h));
      }

      i = e.pop();
    }

    return n;
  }, r.prototype.collides = function (t) {
    var i = this.data;
    if (!c(t, i)) return !1;

    for (var n = []; i;) {
      for (var r = 0; r < i.children.length; r++) {
        var e = i.children[r],
            a = i.leaf ? this.toBBox(e) : e;

        if (c(t, a)) {
          if (i.leaf || m(t, a)) return !0;
          n.push(e);
        }
      }

      i = n.pop();
    }

    return !1;
  }, r.prototype.load = function (t) {
    if (!t || !t.length) return this;

    if (t.length < this._minEntries) {
      for (var i = 0; i < t.length; i++) {
        this.insert(t[i]);
      }

      return this;
    }

    var n = this._build(t.slice(), 0, t.length - 1, 0);

    if (this.data.children.length) {
      if (this.data.height === n.height) this._splitRoot(this.data, n);else {
        if (this.data.height < n.height) {
          var r = this.data;
          this.data = n, n = r;
        }

        this._insert(n, this.data.height - n.height - 1, !0);
      }
    } else this.data = n;
    return this;
  }, r.prototype.insert = function (t) {
    return t && this._insert(t, this.data.height - 1), this;
  }, r.prototype.clear = function () {
    return this.data = p([]), this;
  }, r.prototype.remove = function (t, i) {
    if (!t) return this;

    for (var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;) {
      if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
        var f = e(t, h.children, i);
        if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
      }

      a || h.leaf || !m(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
    }

    return this;
  }, r.prototype.toBBox = function (t) {
    return t;
  }, r.prototype.compareMinX = function (t, i) {
    return t.minX - i.minX;
  }, r.prototype.compareMinY = function (t, i) {
    return t.minY - i.minY;
  }, r.prototype.toJSON = function () {
    return this.data;
  }, r.prototype.fromJSON = function (t) {
    return this.data = t, this;
  }, r.prototype._all = function (t, i) {
    for (var n = []; t;) {
      t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
    }

    return i;
  }, r.prototype._build = function (t, i, n, r) {
    var e,
        h = n - i + 1,
        o = this._maxEntries;
    if (h <= o) return a(e = p(t.slice(i, n + 1)), this.toBBox), e;
    r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p([])).leaf = !1, e.height = r;
    var s = Math.ceil(h / o),
        l = s * Math.ceil(Math.sqrt(o));
    d(t, i, n, l, this.compareMinX);

    for (var f = i; f <= n; f += l) {
      var u = Math.min(f + l - 1, n);
      d(t, f, u, s, this.compareMinY);

      for (var m = f; m <= u; m += s) {
        var c = Math.min(m + s - 1, u);
        e.children.push(this._build(t, m, c, r - 1));
      }
    }

    return a(e, this.toBBox), e;
  }, r.prototype._chooseSubtree = function (t, i, n, r) {
    for (; r.push(i), !i.leaf && r.length - 1 !== n;) {
      for (var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++) {
        var s = i.children[o],
            l = f(s),
            u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
        u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
      }

      i = h || i.children[0];
    }

    var m, c;
    return i;
  }, r.prototype._insert = function (t, i, n) {
    var r = n ? t : this.toBBox(t),
        e = [],
        a = this._chooseSubtree(r, this.data, i, e);

    for (a.children.push(t), o(a, r); i >= 0 && e[i].children.length > this._maxEntries;) {
      this._split(e, i), i--;
    }

    this._adjustParentBBoxes(r, e, i);
  }, r.prototype._split = function (t, i) {
    var n = t[i],
        r = n.children.length,
        e = this._minEntries;

    this._chooseSplitAxis(n, e, r);

    var h = this._chooseSplitIndex(n, e, r),
        o = p(n.children.splice(h, n.children.length - h));

    o.height = n.height, o.leaf = n.leaf, a(n, this.toBBox), a(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
  }, r.prototype._splitRoot = function (t, i) {
    this.data = p([t, i]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
  }, r.prototype._chooseSplitIndex = function (t, i, n) {
    for (var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++) {
      var d = h(t, 0, p, this.toBBox),
          x = h(t, p, n, this.toBBox),
          v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)),
          M = f(d) + f(x);
      v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
    }

    return r || n - i;
  }, r.prototype._chooseSplitAxis = function (t, i, n) {
    var r = t.leaf ? this.compareMinX : s,
        e = t.leaf ? this.compareMinY : l;
    this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
  }, r.prototype._allDistMargin = function (t, i, n, r) {
    t.children.sort(r);

    for (var e = this.toBBox, a = h(t, 0, i, e), s = h(t, n - i, n, e), l = u(a) + u(s), f = i; f < n - i; f++) {
      var m = t.children[f];
      o(a, t.leaf ? e(m) : m), l += u(a);
    }

    for (var c = n - i - 1; c >= i; c--) {
      var p = t.children[c];
      o(s, t.leaf ? e(p) : p), l += u(s);
    }

    return l;
  }, r.prototype._adjustParentBBoxes = function (t, i, n) {
    for (var r = n; r >= 0; r--) {
      o(i[r], t);
    }
  }, r.prototype._condense = function (t) {
    for (var i = t.length - 1, n = void 0; i >= 0; i--) {
      0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a(t[i], this.toBBox);
    }
  }, r;
});

/***/ }),

/***/ 1071:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var aa = __webpack_require__(2791);

function l(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var p = Object.prototype.hasOwnProperty,
    fa = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    ha = {},
    ia = {};

function ja(a) {
  if (p.call(ia, a)) return !0;
  if (p.call(ha, a)) return !1;
  if (fa.test(a)) return ia[a] = !0;
  ha[a] = !0;
  return !1;
}

function r(a, b, c, d, f, e, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = f;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = e;
  this.removeEmptyString = g;
}

var t = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  t[a] = new r(a, 0, !1, a, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];
  t[b] = new r(b, 1, !1, a[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  t[a] = new r(a, 2, !1, a.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  t[a] = new r(a, 2, !1, a, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  t[a] = new r(a, 3, !1, a.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function (a) {
  t[a] = new r(a, 3, !0, a, null, !1, !1);
});
["capture", "download"].forEach(function (a) {
  t[a] = new r(a, 4, !1, a, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (a) {
  t[a] = new r(a, 6, !1, a, null, !1, !1);
});
["rowSpan", "start"].forEach(function (a) {
  t[a] = new r(a, 5, !1, a.toLowerCase(), null, !1, !1);
});
var ka = /[\-:]([a-z])/g;

function la(a) {
  return a[1].toUpperCase();
}

"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(ka, la);
  t[b] = new r(b, 1, !1, a, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(ka, la);
  t[b] = new r(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(ka, la);
  t[b] = new r(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (a) {
  t[a] = new r(a, 1, !1, a.toLowerCase(), null, !1, !1);
});
t.xlinkHref = new r("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (a) {
  t[a] = new r(a, 1, !1, a.toLowerCase(), null, !0, !0);
});
var u = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
},
    ma = ["Webkit", "ms", "Moz", "O"];
Object.keys(u).forEach(function (a) {
  ma.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    u[b] = u[a];
  });
});
var na = /["'&<>]/;

function v(a) {
  if ("boolean" === typeof a || "number" === typeof a) return "" + a;
  a = "" + a;
  var b = na.exec(a);

  if (b) {
    var c = "",
        d,
        f = 0;

    for (d = b.index; d < a.length; d++) {
      switch (a.charCodeAt(d)) {
        case 34:
          b = "&quot;";
          break;

        case 38:
          b = "&amp;";
          break;

        case 39:
          b = "&#x27;";
          break;

        case 60:
          b = "&lt;";
          break;

        case 62:
          b = "&gt;";
          break;

        default:
          continue;
      }

      f !== d && (c += a.substring(f, d));
      f = d + 1;
      c += b;
    }

    a = f !== d ? c + a.substring(f, d) : c;
  }

  return a;
}

var oa = /([A-Z])/g,
    pa = /^ms-/,
    qa = Array.isArray;

function w(a, b) {
  return {
    insertionMode: a,
    selectedValue: b
  };
}

function ra(a, b, c) {
  switch (b) {
    case "select":
      return w(1, null != c.value ? c.value : c.defaultValue);

    case "svg":
      return w(2, null);

    case "math":
      return w(3, null);

    case "foreignObject":
      return w(1, null);

    case "table":
      return w(4, null);

    case "thead":
    case "tbody":
    case "tfoot":
      return w(5, null);

    case "colgroup":
      return w(7, null);

    case "tr":
      return w(6, null);
  }

  return 4 <= a.insertionMode || 0 === a.insertionMode ? w(1, null) : a;
}

var sa = new Map();

function ta(a, b, c) {
  if ("object" !== typeof c) throw Error(l(62));
  b = !0;

  for (var d in c) {
    if (p.call(c, d)) {
      var f = c[d];

      if (null != f && "boolean" !== typeof f && "" !== f) {
        if (0 === d.indexOf("--")) {
          var e = v(d);
          f = v(("" + f).trim());
        } else {
          e = d;
          var g = sa.get(e);
          void 0 !== g ? e = g : (g = v(e.replace(oa, "-$1").toLowerCase().replace(pa, "-ms-")), sa.set(e, g), e = g);
          f = "number" === typeof f ? 0 === f || p.call(u, d) ? "" + f : f + "px" : v(("" + f).trim());
        }

        b ? (b = !1, a.push(' style="', e, ":", f)) : a.push(";", e, ":", f);
      }
    }
  }

  b || a.push('"');
}

function x(a, b, c, d) {
  switch (c) {
    case "style":
      ta(a, b, d);
      return;

    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }

  if (!(2 < c.length) || "o" !== c[0] && "O" !== c[0] || "n" !== c[1] && "N" !== c[1]) if (b = t.hasOwnProperty(c) ? t[c] : null, null !== b) {
    switch (typeof d) {
      case "function":
      case "symbol":
        return;

      case "boolean":
        if (!b.acceptsBooleans) return;
    }

    c = b.attributeName;

    switch (b.type) {
      case 3:
        d && a.push(" ", c, '=""');
        break;

      case 4:
        !0 === d ? a.push(" ", c, '=""') : !1 !== d && a.push(" ", c, '="', v(d), '"');
        break;

      case 5:
        isNaN(d) || a.push(" ", c, '="', v(d), '"');
        break;

      case 6:
        !isNaN(d) && 1 <= d && a.push(" ", c, '="', v(d), '"');
        break;

      default:
        b.sanitizeURL && (d = "" + d), a.push(" ", c, '="', v(d), '"');
    }
  } else if (ja(c)) {
    switch (typeof d) {
      case "function":
      case "symbol":
        return;

      case "boolean":
        if (b = c.toLowerCase().slice(0, 5), "data-" !== b && "aria-" !== b) return;
    }

    a.push(" ", c, '="', v(d), '"');
  }
}

function y(a, b, c) {
  if (null != b) {
    if (null != c) throw Error(l(60));
    if ("object" !== typeof b || !("__html" in b)) throw Error(l(61));
    b = b.__html;
    null !== b && void 0 !== b && a.push("" + b);
  }
}

function ua(a) {
  var b = "";
  aa.Children.forEach(a, function (a) {
    null != a && (b += a);
  });
  return b;
}

function va(a, b, c, d) {
  a.push(A(c));
  var f = c = null,
      e;

  for (e in b) {
    if (p.call(b, e)) {
      var g = b[e];
      if (null != g) switch (e) {
        case "children":
          c = g;
          break;

        case "dangerouslySetInnerHTML":
          f = g;
          break;

        default:
          x(a, d, e, g);
      }
    }
  }

  a.push(">");
  y(a, f, c);
  return "string" === typeof c ? (a.push(v(c)), null) : c;
}

var wa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    xa = new Map();

function A(a) {
  var b = xa.get(a);

  if (void 0 === b) {
    if (!wa.test(a)) throw Error(l(65, a));
    b = "<" + a;
    xa.set(a, b);
  }

  return b;
}

function ya(a, b, c, d, f) {
  switch (b) {
    case "select":
      a.push(A("select"));
      var e = null,
          g = null;

      for (n in c) {
        if (p.call(c, n)) {
          var h = c[n];
          if (null != h) switch (n) {
            case "children":
              e = h;
              break;

            case "dangerouslySetInnerHTML":
              g = h;
              break;

            case "defaultValue":
            case "value":
              break;

            default:
              x(a, d, n, h);
          }
        }
      }

      a.push(">");
      y(a, g, e);
      return e;

    case "option":
      g = f.selectedValue;
      a.push(A("option"));
      var k = h = null,
          m = null;
      var n = null;

      for (e in c) {
        if (p.call(c, e)) {
          var q = c[e];
          if (null != q) switch (e) {
            case "children":
              h = q;
              break;

            case "selected":
              m = q;
              break;

            case "dangerouslySetInnerHTML":
              n = q;
              break;

            case "value":
              k = q;

            default:
              x(a, d, e, q);
          }
        }
      }

      if (null != g) {
        if (c = null !== k ? "" + k : ua(h), qa(g)) for (d = 0; d < g.length; d++) {
          if ("" + g[d] === c) {
            a.push(' selected=""');
            break;
          }
        } else "" + g === c && a.push(' selected=""');
      } else m && a.push(' selected=""');
      a.push(">");
      y(a, n, h);
      return h;

    case "textarea":
      a.push(A("textarea"));
      n = g = e = null;

      for (h in c) {
        if (p.call(c, h) && (k = c[h], null != k)) switch (h) {
          case "children":
            n = k;
            break;

          case "value":
            e = k;
            break;

          case "defaultValue":
            g = k;
            break;

          case "dangerouslySetInnerHTML":
            throw Error(l(91));

          default:
            x(a, d, h, k);
        }
      }

      null === e && null !== g && (e = g);
      a.push(">");

      if (null != n) {
        if (null != e) throw Error(l(92));
        if (qa(n) && 1 < n.length) throw Error(l(93));
        e = "" + n;
      }

      "string" === typeof e && "\n" === e[0] && a.push("\n");
      null !== e && a.push(v("" + e));
      return null;

    case "input":
      a.push(A("input"));
      k = n = h = e = null;

      for (g in c) {
        if (p.call(c, g) && (m = c[g], null != m)) switch (g) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(l(399, "input"));

          case "defaultChecked":
            k = m;
            break;

          case "defaultValue":
            h = m;
            break;

          case "checked":
            n = m;
            break;

          case "value":
            e = m;
            break;

          default:
            x(a, d, g, m);
        }
      }

      null !== n ? x(a, d, "checked", n) : null !== k && x(a, d, "checked", k);
      null !== e ? x(a, d, "value", e) : null !== h && x(a, d, "value", h);
      a.push("/>");
      return null;

    case "menuitem":
      a.push(A("menuitem"));

      for (var C in c) {
        if (p.call(c, C) && (e = c[C], null != e)) switch (C) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(l(400));

          default:
            x(a, d, C, e);
        }
      }

      a.push(">");
      return null;

    case "title":
      a.push(A("title"));
      e = null;

      for (q in c) {
        if (p.call(c, q) && (g = c[q], null != g)) switch (q) {
          case "children":
            e = g;
            break;

          case "dangerouslySetInnerHTML":
            throw Error(l(434));

          default:
            x(a, d, q, g);
        }
      }

      a.push(">");
      return e;

    case "listing":
    case "pre":
      a.push(A(b));
      g = e = null;

      for (k in c) {
        if (p.call(c, k) && (h = c[k], null != h)) switch (k) {
          case "children":
            e = h;
            break;

          case "dangerouslySetInnerHTML":
            g = h;
            break;

          default:
            x(a, d, k, h);
        }
      }

      a.push(">");

      if (null != g) {
        if (null != e) throw Error(l(60));
        if ("object" !== typeof g || !("__html" in g)) throw Error(l(61));
        c = g.__html;
        null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push("\n", c) : a.push("" + c));
      }

      "string" === typeof e && "\n" === e[0] && a.push("\n");
      return e;

    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a.push(A(b));

      for (var D in c) {
        if (p.call(c, D) && (e = c[D], null != e)) switch (D) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(l(399, b));

          default:
            x(a, d, D, e);
        }
      }

      a.push("/>");
      return null;

    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return va(a, c, b, d);

    case "html":
      return 0 === f.insertionMode && a.push("<!DOCTYPE html>"), va(a, c, b, d);

    default:
      if (-1 === b.indexOf("-") && "string" !== typeof c.is) return va(a, c, b, d);
      a.push(A(b));
      g = e = null;

      for (m in c) {
        if (p.call(c, m) && (h = c[m], null != h)) switch (m) {
          case "children":
            e = h;
            break;

          case "dangerouslySetInnerHTML":
            g = h;
            break;

          case "style":
            ta(a, d, h);
            break;

          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;

          default:
            ja(m) && "function" !== typeof h && "symbol" !== typeof h && a.push(" ", m, '="', v(h), '"');
        }
      }

      a.push(">");
      y(a, g, e);
      return e;
  }
}

function za(a, b, c) {
  a.push('\x3c!--$?--\x3e<template id="');
  if (null === c) throw Error(l(395));
  a.push(c);
  return a.push('"></template>');
}

function Aa(a, b, c, d) {
  switch (c.insertionMode) {
    case 0:
    case 1:
      return a.push('<div hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');

    case 2:
      return a.push('<svg aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');

    case 3:
      return a.push('<math aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');

    case 4:
      return a.push('<table hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');

    case 5:
      return a.push('<table hidden><tbody id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');

    case 6:
      return a.push('<table hidden><tr id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');

    case 7:
      return a.push('<table hidden><colgroup id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');

    default:
      throw Error(l(397));
  }
}

function Ba(a, b) {
  switch (b.insertionMode) {
    case 0:
    case 1:
      return a.push("</div>");

    case 2:
      return a.push("</svg>");

    case 3:
      return a.push("</math>");

    case 4:
      return a.push("</table>");

    case 5:
      return a.push("</tbody></table>");

    case 6:
      return a.push("</tr></table>");

    case 7:
      return a.push("</colgroup></table>");

    default:
      throw Error(l(397));
  }
}

var Ca = /[<\u2028\u2029]/g;

function Da(a) {
  return JSON.stringify(a).replace(Ca, function (a) {
    switch (a) {
      case "<":
        return "\\u003c";

      case "\u2028":
        return "\\u2028";

      case "\u2029":
        return "\\u2029";

      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}

function Ea(a, b) {
  b = void 0 === b ? "" : b;
  return {
    bootstrapChunks: [],
    startInlineScript: "<script>",
    placeholderPrefix: b + "P:",
    segmentPrefix: b + "S:",
    boundaryPrefix: b + "B:",
    idPrefix: b,
    nextSuspenseID: 0,
    sentCompleteSegmentFunction: !1,
    sentCompleteBoundaryFunction: !1,
    sentClientRenderFunction: !1,
    generateStaticMarkup: a
  };
}

function Fa(a, b, c, d) {
  if (c.generateStaticMarkup) return a.push(v(b)), !1;
  "" === b ? a = d : (d && a.push("\x3c!-- --\x3e"), a.push(v(b)), a = !0);
  return a;
}

var B = Object.assign,
    Ga = Symbol.for("react.element"),
    Ha = Symbol.for("react.portal"),
    Ia = Symbol.for("react.fragment"),
    Ja = Symbol.for("react.strict_mode"),
    Ka = Symbol.for("react.profiler"),
    La = Symbol.for("react.provider"),
    Ma = Symbol.for("react.context"),
    Na = Symbol.for("react.forward_ref"),
    Oa = Symbol.for("react.suspense"),
    Pa = Symbol.for("react.suspense_list"),
    Qa = Symbol.for("react.memo"),
    Ra = Symbol.for("react.lazy"),
    Sa = Symbol.for("react.scope"),
    Ta = Symbol.for("react.debug_trace_mode"),
    Ua = Symbol.for("react.legacy_hidden"),
    Va = Symbol.for("react.default_value"),
    Wa = Symbol.iterator;

function Xa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;

  switch (a) {
    case Ia:
      return "Fragment";

    case Ha:
      return "Portal";

    case Ka:
      return "Profiler";

    case Ja:
      return "StrictMode";

    case Oa:
      return "Suspense";

    case Pa:
      return "SuspenseList";
  }

  if ("object" === typeof a) switch (a.$$typeof) {
    case Ma:
      return (a.displayName || "Context") + ".Consumer";

    case La:
      return (a._context.displayName || "Context") + ".Provider";

    case Na:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;

    case Qa:
      return b = a.displayName || null, null !== b ? b : Xa(a.type) || "Memo";

    case Ra:
      b = a._payload;
      a = a._init;

      try {
        return Xa(a(b));
      } catch (c) {}

  }
  return null;
}

var Ya = {};

function Za(a, b) {
  a = a.contextTypes;
  if (!a) return Ya;
  var c = {},
      d;

  for (d in a) {
    c[d] = b[d];
  }

  return c;
}

var E = null;

function F(a, b) {
  if (a !== b) {
    a.context._currentValue2 = a.parentValue;
    a = a.parent;
    var c = b.parent;

    if (null === a) {
      if (null !== c) throw Error(l(401));
    } else {
      if (null === c) throw Error(l(401));
      F(a, c);
    }

    b.context._currentValue2 = b.value;
  }
}

function $a(a) {
  a.context._currentValue2 = a.parentValue;
  a = a.parent;
  null !== a && $a(a);
}

function ab(a) {
  var b = a.parent;
  null !== b && ab(b);
  a.context._currentValue2 = a.value;
}

function bb(a, b) {
  a.context._currentValue2 = a.parentValue;
  a = a.parent;
  if (null === a) throw Error(l(402));
  a.depth === b.depth ? F(a, b) : bb(a, b);
}

function cb(a, b) {
  var c = b.parent;
  if (null === c) throw Error(l(402));
  a.depth === c.depth ? F(a, c) : cb(a, c);
  b.context._currentValue2 = b.value;
}

function G(a) {
  var b = E;
  b !== a && (null === b ? ab(a) : null === a ? $a(b) : b.depth === a.depth ? F(b, a) : b.depth > a.depth ? bb(b, a) : cb(b, a), E = a);
}

var db = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueSetState: function enqueueSetState(a, b) {
    a = a._reactInternals;
    null !== a.queue && a.queue.push(b);
  },
  enqueueReplaceState: function enqueueReplaceState(a, b) {
    a = a._reactInternals;
    a.replace = !0;
    a.queue = [b];
  },
  enqueueForceUpdate: function enqueueForceUpdate() {}
};

function eb(a, b, c, d) {
  var f = void 0 !== a.state ? a.state : null;
  a.updater = db;
  a.props = c;
  a.state = f;
  var e = {
    queue: [],
    replace: !1
  };
  a._reactInternals = e;
  var g = b.contextType;
  a.context = "object" === typeof g && null !== g ? g._currentValue2 : d;
  g = b.getDerivedStateFromProps;
  "function" === typeof g && (g = g(c, f), f = null === g || void 0 === g ? f : B({}, f, g), a.state = f);
  if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && db.enqueueReplaceState(a, a.state, null), null !== e.queue && 0 < e.queue.length) {
    if (b = e.queue, g = e.replace, e.queue = null, e.replace = !1, g && 1 === b.length) a.state = b[0];else {
      e = g ? b[0] : a.state;
      f = !0;

      for (g = g ? 1 : 0; g < b.length; g++) {
        var h = b[g];
        h = "function" === typeof h ? h.call(a, e, c, d) : h;
        null != h && (f ? (f = !1, e = B({}, e, h)) : B(e, h));
      }

      a.state = e;
    }
  } else e.queue = null;
}

var fb = {
  id: 1,
  overflow: ""
};

function gb(a, b, c) {
  var d = a.id;
  a = a.overflow;
  var f = 32 - H(d) - 1;
  d &= ~(1 << f);
  c += 1;
  var e = 32 - H(b) + f;

  if (30 < e) {
    var g = f - f % 5;
    e = (d & (1 << g) - 1).toString(32);
    d >>= g;
    f -= g;
    return {
      id: 1 << 32 - H(b) + f | c << f | d,
      overflow: e + a
    };
  }

  return {
    id: 1 << e | c << f | d,
    overflow: a
  };
}

var H = Math.clz32 ? Math.clz32 : hb,
    ib = Math.log,
    jb = Math.LN2;

function hb(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (ib(a) / jb | 0) | 0;
}

function kb(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}

var lb = "function" === typeof Object.is ? Object.is : kb,
    I = null,
    ob = null,
    J = null,
    K = null,
    L = !1,
    M = !1,
    N = 0,
    O = null,
    P = 0;

function Q() {
  if (null === I) throw Error(l(321));
  return I;
}

function pb() {
  if (0 < P) throw Error(l(312));
  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}

function qb() {
  null === K ? null === J ? (L = !1, J = K = pb()) : (L = !0, K = J) : null === K.next ? (L = !1, K = K.next = pb()) : (L = !0, K = K.next);
  return K;
}

function rb() {
  ob = I = null;
  M = !1;
  J = null;
  P = 0;
  K = O = null;
}

function sb(a, b) {
  return "function" === typeof b ? b(a) : b;
}

function tb(a, b, c) {
  I = Q();
  K = qb();

  if (L) {
    var d = K.queue;
    b = d.dispatch;

    if (null !== O && (c = O.get(d), void 0 !== c)) {
      O.delete(d);
      d = K.memoizedState;

      do {
        d = a(d, c.action), c = c.next;
      } while (null !== c);

      K.memoizedState = d;
      return [d, b];
    }

    return [K.memoizedState, b];
  }

  a = a === sb ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
  K.memoizedState = a;
  a = K.queue = {
    last: null,
    dispatch: null
  };
  a = a.dispatch = ub.bind(null, I, a);
  return [K.memoizedState, a];
}

function vb(a, b) {
  I = Q();
  K = qb();
  b = void 0 === b ? null : b;

  if (null !== K) {
    var c = K.memoizedState;

    if (null !== c && null !== b) {
      var d = c[1];

      a: if (null === d) d = !1;else {
        for (var f = 0; f < d.length && f < b.length; f++) {
          if (!lb(b[f], d[f])) {
            d = !1;
            break a;
          }
        }

        d = !0;
      }

      if (d) return c[0];
    }
  }

  a = a();
  K.memoizedState = [a, b];
  return a;
}

function ub(a, b, c) {
  if (25 <= P) throw Error(l(301));
  if (a === I) if (M = !0, a = {
    action: c,
    next: null
  }, null === O && (O = new Map()), c = O.get(b), void 0 === c) O.set(b, a);else {
    for (b = c; null !== b.next;) {
      b = b.next;
    }

    b.next = a;
  }
}

function wb() {
  throw Error(l(394));
}

function R() {}

var xb = {
  readContext: function readContext(a) {
    return a._currentValue2;
  },
  useContext: function useContext(a) {
    Q();
    return a._currentValue2;
  },
  useMemo: vb,
  useReducer: tb,
  useRef: function useRef(a) {
    I = Q();
    K = qb();
    var b = K.memoizedState;
    return null === b ? (a = {
      current: a
    }, K.memoizedState = a) : b;
  },
  useState: function useState(a) {
    return tb(sb, a);
  },
  useInsertionEffect: R,
  useLayoutEffect: function useLayoutEffect() {},
  useCallback: function useCallback(a, b) {
    return vb(function () {
      return a;
    }, b);
  },
  useImperativeHandle: R,
  useEffect: R,
  useDebugValue: R,
  useDeferredValue: function useDeferredValue(a) {
    Q();
    return a;
  },
  useTransition: function useTransition() {
    Q();
    return [!1, wb];
  },
  useId: function useId() {
    var a = ob.treeContext;
    var b = a.overflow;
    a = a.id;
    a = (a & ~(1 << 32 - H(a) - 1)).toString(32) + b;
    var c = S;
    if (null === c) throw Error(l(404));
    b = N++;
    a = ":" + c.idPrefix + "R" + a;
    0 < b && (a += "H" + b.toString(32));
    return a + ":";
  },
  useMutableSource: function useMutableSource(a, b) {
    Q();
    return b(a._source);
  },
  useSyncExternalStore: function useSyncExternalStore(a, b, c) {
    if (void 0 === c) throw Error(l(407));
    return c();
  }
},
    S = null,
    yb = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;

function zb(a) {
  console.error(a);
  return null;
}

function T() {}

function Ab(a, b, c, d, f, e, g, h, k) {
  var m = [],
      n = new Set();
  b = {
    destination: null,
    responseState: b,
    progressiveChunkSize: void 0 === d ? 12800 : d,
    status: 0,
    fatalError: null,
    nextSegmentId: 0,
    allPendingTasks: 0,
    pendingRootTasks: 0,
    completedRootSegment: null,
    abortableTasks: n,
    pingedTasks: m,
    clientRenderedBoundaries: [],
    completedBoundaries: [],
    partialBoundaries: [],
    onError: void 0 === f ? zb : f,
    onAllReady: void 0 === e ? T : e,
    onShellReady: void 0 === g ? T : g,
    onShellError: void 0 === h ? T : h,
    onFatalError: void 0 === k ? T : k
  };
  c = U(b, 0, null, c, !1, !1);
  c.parentFlushed = !0;
  a = Bb(b, a, null, c, n, Ya, null, fb);
  m.push(a);
  return b;
}

function Bb(a, b, c, d, f, e, g, h) {
  a.allPendingTasks++;
  null === c ? a.pendingRootTasks++ : c.pendingTasks++;
  var k = {
    node: b,
    ping: function ping() {
      var b = a.pingedTasks;
      b.push(k);
      1 === b.length && Cb(a);
    },
    blockedBoundary: c,
    blockedSegment: d,
    abortSet: f,
    legacyContext: e,
    context: g,
    treeContext: h
  };
  f.add(k);
  return k;
}

function U(a, b, c, d, f, e) {
  return {
    status: 0,
    id: -1,
    index: b,
    parentFlushed: !1,
    chunks: [],
    children: [],
    formatContext: d,
    boundary: c,
    lastPushedText: f,
    textEmbedded: e
  };
}

function V(a, b) {
  a = a.onError(b);
  if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
  return a;
}

function W(a, b) {
  var c = a.onShellError;
  c(b);
  c = a.onFatalError;
  c(b);
  null !== a.destination ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
}

function Db(a, b, c, d, f) {
  I = {};
  ob = b;
  N = 0;

  for (a = c(d, f); M;) {
    M = !1, N = 0, P += 1, K = null, a = c(d, f);
  }

  rb();
  return a;
}

function Eb(a, b, c, d) {
  var f = c.render(),
      e = d.childContextTypes;

  if (null !== e && void 0 !== e) {
    var g = b.legacyContext;
    if ("function" !== typeof c.getChildContext) d = g;else {
      c = c.getChildContext();

      for (var h in c) {
        if (!(h in e)) throw Error(l(108, Xa(d) || "Unknown", h));
      }

      d = B({}, g, c);
    }
    b.legacyContext = d;
    X(a, b, f);
    b.legacyContext = g;
  } else X(a, b, f);
}

function Fb(a, b) {
  if (a && a.defaultProps) {
    b = B({}, b);
    a = a.defaultProps;

    for (var c in a) {
      void 0 === b[c] && (b[c] = a[c]);
    }

    return b;
  }

  return b;
}

function Gb(a, b, c, d, f) {
  if ("function" === typeof c) {
    if (c.prototype && c.prototype.isReactComponent) {
      f = Za(c, b.legacyContext);
      var e = c.contextType;
      e = new c(d, "object" === typeof e && null !== e ? e._currentValue2 : f);
      eb(e, c, d, f);
      Eb(a, b, e, c);
    } else {
      e = Za(c, b.legacyContext);
      f = Db(a, b, c, d, e);
      var g = 0 !== N;
      if ("object" === typeof f && null !== f && "function" === typeof f.render && void 0 === f.$$typeof) eb(f, c, d, e), Eb(a, b, f, c);else if (g) {
        d = b.treeContext;
        b.treeContext = gb(d, 1, 0);

        try {
          X(a, b, f);
        } finally {
          b.treeContext = d;
        }
      } else X(a, b, f);
    }
  } else if ("string" === typeof c) {
    f = b.blockedSegment;
    e = ya(f.chunks, c, d, a.responseState, f.formatContext);
    f.lastPushedText = !1;
    g = f.formatContext;
    f.formatContext = ra(g, c, d);
    Hb(a, b, e);
    f.formatContext = g;

    switch (c) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;

      default:
        f.chunks.push("</", c, ">");
    }

    f.lastPushedText = !1;
  } else {
    switch (c) {
      case Ua:
      case Ta:
      case Ja:
      case Ka:
      case Ia:
        X(a, b, d.children);
        return;

      case Pa:
        X(a, b, d.children);
        return;

      case Sa:
        throw Error(l(343));

      case Oa:
        a: {
          c = b.blockedBoundary;
          f = b.blockedSegment;
          e = d.fallback;
          d = d.children;
          g = new Set();
          var h = {
            id: null,
            rootSegmentID: -1,
            parentFlushed: !1,
            pendingTasks: 0,
            forceClientRender: !1,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks: g,
            errorDigest: null
          },
              k = U(a, f.chunks.length, h, f.formatContext, !1, !1);
          f.children.push(k);
          f.lastPushedText = !1;
          var m = U(a, 0, null, f.formatContext, !1, !1);
          m.parentFlushed = !0;
          b.blockedBoundary = h;
          b.blockedSegment = m;

          try {
            if (Hb(a, b, d), a.responseState.generateStaticMarkup || m.lastPushedText && m.textEmbedded && m.chunks.push("\x3c!-- --\x3e"), m.status = 1, Y(h, m), 0 === h.pendingTasks) break a;
          } catch (n) {
            m.status = 4, h.forceClientRender = !0, h.errorDigest = V(a, n);
          } finally {
            b.blockedBoundary = c, b.blockedSegment = f;
          }

          b = Bb(a, e, c, k, g, b.legacyContext, b.context, b.treeContext);
          a.pingedTasks.push(b);
        }

        return;
    }

    if ("object" === typeof c && null !== c) switch (c.$$typeof) {
      case Na:
        d = Db(a, b, c.render, d, f);

        if (0 !== N) {
          c = b.treeContext;
          b.treeContext = gb(c, 1, 0);

          try {
            X(a, b, d);
          } finally {
            b.treeContext = c;
          }
        } else X(a, b, d);

        return;

      case Qa:
        c = c.type;
        d = Fb(c, d);
        Gb(a, b, c, d, f);
        return;

      case La:
        f = d.children;
        c = c._context;
        d = d.value;
        e = c._currentValue2;
        c._currentValue2 = d;
        g = E;
        E = d = {
          parent: g,
          depth: null === g ? 0 : g.depth + 1,
          context: c,
          parentValue: e,
          value: d
        };
        b.context = d;
        X(a, b, f);
        a = E;
        if (null === a) throw Error(l(403));
        d = a.parentValue;
        a.context._currentValue2 = d === Va ? a.context._defaultValue : d;
        a = E = a.parent;
        b.context = a;
        return;

      case Ma:
        d = d.children;
        d = d(c._currentValue2);
        X(a, b, d);
        return;

      case Ra:
        f = c._init;
        c = f(c._payload);
        d = Fb(c, d);
        Gb(a, b, c, d, void 0);
        return;
    }
    throw Error(l(130, null == c ? c : typeof c, ""));
  }
}

function X(a, b, c) {
  b.node = c;

  if ("object" === typeof c && null !== c) {
    switch (c.$$typeof) {
      case Ga:
        Gb(a, b, c.type, c.props, c.ref);
        return;

      case Ha:
        throw Error(l(257));

      case Ra:
        var d = c._init;
        c = d(c._payload);
        X(a, b, c);
        return;
    }

    if (qa(c)) {
      Ib(a, b, c);
      return;
    }

    null === c || "object" !== typeof c ? d = null : (d = Wa && c[Wa] || c["@@iterator"], d = "function" === typeof d ? d : null);

    if (d && (d = d.call(c))) {
      c = d.next();

      if (!c.done) {
        var f = [];

        do {
          f.push(c.value), c = d.next();
        } while (!c.done);

        Ib(a, b, f);
      }

      return;
    }

    a = Object.prototype.toString.call(c);
    throw Error(l(31, "[object Object]" === a ? "object with keys {" + Object.keys(c).join(", ") + "}" : a));
  }

  "string" === typeof c ? (d = b.blockedSegment, d.lastPushedText = Fa(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : "number" === typeof c && (d = b.blockedSegment, d.lastPushedText = Fa(b.blockedSegment.chunks, "" + c, a.responseState, d.lastPushedText));
}

function Ib(a, b, c) {
  for (var d = c.length, f = 0; f < d; f++) {
    var e = b.treeContext;
    b.treeContext = gb(e, d, f);

    try {
      Hb(a, b, c[f]);
    } finally {
      b.treeContext = e;
    }
  }
}

function Hb(a, b, c) {
  var d = b.blockedSegment.formatContext,
      f = b.legacyContext,
      e = b.context;

  try {
    return X(a, b, c);
  } catch (k) {
    if (rb(), "object" === typeof k && null !== k && "function" === typeof k.then) {
      c = k;
      var g = b.blockedSegment,
          h = U(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
      g.children.push(h);
      g.lastPushedText = !1;
      a = Bb(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping;
      c.then(a, a);
      b.blockedSegment.formatContext = d;
      b.legacyContext = f;
      b.context = e;
      G(e);
    } else throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, G(e), k;
  }
}

function Jb(a) {
  var b = a.blockedBoundary;
  a = a.blockedSegment;
  a.status = 3;
  Kb(this, b, a);
}

function Lb(a, b, c) {
  var d = a.blockedBoundary;
  a.blockedSegment.status = 3;
  null === d ? (b.allPendingTasks--, 2 !== b.status && (b.status = 2, null !== b.destination && b.destination.push(null))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, a = void 0 === c ? Error(l(432)) : c, d.errorDigest = b.onError(a), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function (a) {
    return Lb(a, b, c);
  }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (d = b.onAllReady, d()));
}

function Y(a, b) {
  if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
    var c = b.children[0];
    c.id = b.id;
    c.parentFlushed = !0;
    1 === c.status && Y(a, c);
  } else a.completedSegments.push(b);
}

function Kb(a, b, c) {
  if (null === b) {
    if (c.parentFlushed) {
      if (null !== a.completedRootSegment) throw Error(l(389));
      a.completedRootSegment = c;
    }

    a.pendingRootTasks--;
    0 === a.pendingRootTasks && (a.onShellError = T, b = a.onShellReady, b());
  } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && Y(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Jb, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (Y(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));

  a.allPendingTasks--;
  0 === a.allPendingTasks && (a = a.onAllReady, a());
}

function Cb(a) {
  if (2 !== a.status) {
    var b = E,
        c = yb.current;
    yb.current = xb;
    var d = S;
    S = a.responseState;

    try {
      var f = a.pingedTasks,
          e;

      for (e = 0; e < f.length; e++) {
        var g = f[e];
        var h = a,
            k = g.blockedSegment;

        if (0 === k.status) {
          G(g.context);

          try {
            X(h, g, g.node), h.responseState.generateStaticMarkup || k.lastPushedText && k.textEmbedded && k.chunks.push("\x3c!-- --\x3e"), g.abortSet.delete(g), k.status = 1, Kb(h, g.blockedBoundary, k);
          } catch (z) {
            if (rb(), "object" === typeof z && null !== z && "function" === typeof z.then) {
              var m = g.ping;
              z.then(m, m);
            } else {
              g.abortSet.delete(g);
              k.status = 4;
              var n = g.blockedBoundary,
                  q = z,
                  C = V(h, q);
              null === n ? W(h, q) : (n.pendingTasks--, n.forceClientRender || (n.forceClientRender = !0, n.errorDigest = C, n.parentFlushed && h.clientRenderedBoundaries.push(n)));
              h.allPendingTasks--;

              if (0 === h.allPendingTasks) {
                var D = h.onAllReady;
                D();
              }
            }
          } finally {}
        }
      }

      f.splice(0, e);
      null !== a.destination && Mb(a, a.destination);
    } catch (z) {
      V(a, z), W(a, z);
    } finally {
      S = d, yb.current = c, c === xb && G(b);
    }
  }
}

function Z(a, b, c) {
  c.parentFlushed = !0;

  switch (c.status) {
    case 0:
      var d = c.id = a.nextSegmentId++;
      c.lastPushedText = !1;
      c.textEmbedded = !1;
      a = a.responseState;
      b.push('<template id="');
      b.push(a.placeholderPrefix);
      a = d.toString(16);
      b.push(a);
      return b.push('"></template>');

    case 1:
      c.status = 2;
      var f = !0;
      d = c.chunks;
      var e = 0;
      c = c.children;

      for (var g = 0; g < c.length; g++) {
        for (f = c[g]; e < f.index; e++) {
          b.push(d[e]);
        }

        f = Nb(a, b, f);
      }

      for (; e < d.length - 1; e++) {
        b.push(d[e]);
      }

      e < d.length && (f = b.push(d[e]));
      return f;

    default:
      throw Error(l(390));
  }
}

function Nb(a, b, c) {
  var d = c.boundary;
  if (null === d) return Z(a, b, c);
  d.parentFlushed = !0;
  if (d.forceClientRender) return a.responseState.generateStaticMarkup || (d = d.errorDigest, b.push("\x3c!--$!--\x3e"), b.push("<template"), d && (b.push(' data-dgst="'), d = v(d), b.push(d), b.push('"')), b.push("></template>")), Z(a, b, c), a = a.responseState.generateStaticMarkup ? !0 : b.push("\x3c!--/$--\x3e"), a;

  if (0 < d.pendingTasks) {
    d.rootSegmentID = a.nextSegmentId++;
    0 < d.completedSegments.length && a.partialBoundaries.push(d);
    var f = a.responseState;
    var e = f.nextSuspenseID++;
    f = f.boundaryPrefix + e.toString(16);
    d = d.id = f;
    za(b, a.responseState, d);
    Z(a, b, c);
    return b.push("\x3c!--/$--\x3e");
  }

  if (d.byteSize > a.progressiveChunkSize) return d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), za(b, a.responseState, d.id), Z(a, b, c), b.push("\x3c!--/$--\x3e");
  a.responseState.generateStaticMarkup || b.push("\x3c!--$--\x3e");
  c = d.completedSegments;
  if (1 !== c.length) throw Error(l(391));
  Nb(a, b, c[0]);
  a = a.responseState.generateStaticMarkup ? !0 : b.push("\x3c!--/$--\x3e");
  return a;
}

function Ob(a, b, c) {
  Aa(b, a.responseState, c.formatContext, c.id);
  Nb(a, b, c);
  return Ba(b, c.formatContext);
}

function Pb(a, b, c) {
  for (var d = c.completedSegments, f = 0; f < d.length; f++) {
    Qb(a, b, c, d[f]);
  }

  d.length = 0;
  a = a.responseState;
  d = c.id;
  c = c.rootSegmentID;
  b.push(a.startInlineScript);
  a.sentCompleteBoundaryFunction ? b.push('$RC("') : (a.sentCompleteBoundaryFunction = !0, b.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'));
  if (null === d) throw Error(l(395));
  c = c.toString(16);
  b.push(d);
  b.push('","');
  b.push(a.segmentPrefix);
  b.push(c);
  return b.push('")\x3c/script>');
}

function Qb(a, b, c, d) {
  if (2 === d.status) return !0;
  var f = d.id;

  if (-1 === f) {
    if (-1 === (d.id = c.rootSegmentID)) throw Error(l(392));
    return Ob(a, b, d);
  }

  Ob(a, b, d);
  a = a.responseState;
  b.push(a.startInlineScript);
  a.sentCompleteSegmentFunction ? b.push('$RS("') : (a.sentCompleteSegmentFunction = !0, b.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'));
  b.push(a.segmentPrefix);
  f = f.toString(16);
  b.push(f);
  b.push('","');
  b.push(a.placeholderPrefix);
  b.push(f);
  return b.push('")\x3c/script>');
}

function Mb(a, b) {
  try {
    var c = a.completedRootSegment;

    if (null !== c && 0 === a.pendingRootTasks) {
      Nb(a, b, c);
      a.completedRootSegment = null;
      var d = a.responseState.bootstrapChunks;

      for (c = 0; c < d.length - 1; c++) {
        b.push(d[c]);
      }

      c < d.length && b.push(d[c]);
    }

    var f = a.clientRenderedBoundaries,
        e;

    for (e = 0; e < f.length; e++) {
      var g = f[e];
      d = b;
      var h = a.responseState,
          k = g.id,
          m = g.errorDigest,
          n = g.errorMessage,
          q = g.errorComponentStack;
      d.push(h.startInlineScript);
      h.sentClientRenderFunction ? d.push('$RX("') : (h.sentClientRenderFunction = !0, d.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'));
      if (null === k) throw Error(l(395));
      d.push(k);
      d.push('"');

      if (m || n || q) {
        d.push(",");
        var C = Da(m || "");
        d.push(C);
      }

      if (n || q) {
        d.push(",");
        var D = Da(n || "");
        d.push(D);
      }

      if (q) {
        d.push(",");
        var z = Da(q);
        d.push(z);
      }

      if (!d.push(")\x3c/script>")) {
        a.destination = null;
        e++;
        f.splice(0, e);
        return;
      }
    }

    f.splice(0, e);
    var ba = a.completedBoundaries;

    for (e = 0; e < ba.length; e++) {
      if (!Pb(a, b, ba[e])) {
        a.destination = null;
        e++;
        ba.splice(0, e);
        return;
      }
    }

    ba.splice(0, e);
    var ca = a.partialBoundaries;

    for (e = 0; e < ca.length; e++) {
      var mb = ca[e];

      a: {
        f = a;
        g = b;
        var da = mb.completedSegments;

        for (h = 0; h < da.length; h++) {
          if (!Qb(f, g, mb, da[h])) {
            h++;
            da.splice(0, h);
            var nb = !1;
            break a;
          }
        }

        da.splice(0, h);
        nb = !0;
      }

      if (!nb) {
        a.destination = null;
        e++;
        ca.splice(0, e);
        return;
      }
    }

    ca.splice(0, e);
    var ea = a.completedBoundaries;

    for (e = 0; e < ea.length; e++) {
      if (!Pb(a, b, ea[e])) {
        a.destination = null;
        e++;
        ea.splice(0, e);
        return;
      }
    }

    ea.splice(0, e);
  } finally {
    0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length && b.push(null);
  }
}

function Rb(a, b) {
  try {
    var c = a.abortableTasks;
    c.forEach(function (c) {
      return Lb(c, a, b);
    });
    c.clear();
    null !== a.destination && Mb(a, a.destination);
  } catch (d) {
    V(a, d), W(a, d);
  }
}

function Sb() {}

function Tb(a, b, c, d) {
  var f = !1,
      e = null,
      g = "",
      h = {
    push: function push(a) {
      null !== a && (g += a);
      return !0;
    },
    destroy: function destroy(a) {
      f = !0;
      e = a;
    }
  },
      k = !1;
  a = Ab(a, Ea(c, b ? b.identifierPrefix : void 0), {
    insertionMode: 1,
    selectedValue: null
  }, Infinity, Sb, void 0, function () {
    k = !0;
  }, void 0, void 0);
  Cb(a);
  Rb(a, d);
  if (1 === a.status) a.status = 2, h.destroy(a.fatalError);else if (2 !== a.status && null === a.destination) {
    a.destination = h;

    try {
      Mb(a, h);
    } catch (m) {
      V(a, m), W(a, m);
    }
  }
  if (f) throw e;
  if (!k) throw Error(l(426));
  return g;
}

exports.renderToNodeStream = function () {
  throw Error(l(207));
};

exports.renderToStaticMarkup = function (a, b) {
  return Tb(a, b, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
};

exports.renderToStaticNodeStream = function () {
  throw Error(l(208));
};

exports.renderToString = function (a, b) {
  return Tb(a, b, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
};

exports.version = "18.2.0";

/***/ }),

/***/ 4424:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var aa = __webpack_require__(2791);

function k(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var l = null,
    n = 0;

function p(a, b) {
  if (0 !== b.length) if (512 < b.length) 0 < n && (a.enqueue(new Uint8Array(l.buffer, 0, n)), l = new Uint8Array(512), n = 0), a.enqueue(b);else {
    var c = l.length - n;
    c < b.length && (0 === c ? a.enqueue(l) : (l.set(b.subarray(0, c), n), a.enqueue(l), b = b.subarray(c)), l = new Uint8Array(512), n = 0);
    l.set(b, n);
    n += b.length;
  }
}

function t(a, b) {
  p(a, b);
  return !0;
}

function ba(a) {
  l && 0 < n && (a.enqueue(new Uint8Array(l.buffer, 0, n)), l = null, n = 0);
}

var ca = new TextEncoder();

function u(a) {
  return ca.encode(a);
}

function w(a) {
  return ca.encode(a);
}

function da(a, b) {
  "function" === typeof a.error ? a.error(b) : a.close();
}

var x = Object.prototype.hasOwnProperty,
    ea = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    fa = {},
    ha = {};

function ia(a) {
  if (x.call(ha, a)) return !0;
  if (x.call(fa, a)) return !1;
  if (ea.test(a)) return ha[a] = !0;
  fa[a] = !0;
  return !1;
}

function y(a, b, c, d, f, e, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = f;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = e;
  this.removeEmptyString = g;
}

var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  z[a] = new y(a, 0, !1, a, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];
  z[b] = new y(b, 1, !1, a[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  z[a] = new y(a, 2, !1, a.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  z[a] = new y(a, 2, !1, a, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  z[a] = new y(a, 3, !1, a.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function (a) {
  z[a] = new y(a, 3, !0, a, null, !1, !1);
});
["capture", "download"].forEach(function (a) {
  z[a] = new y(a, 4, !1, a, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (a) {
  z[a] = new y(a, 6, !1, a, null, !1, !1);
});
["rowSpan", "start"].forEach(function (a) {
  z[a] = new y(a, 5, !1, a.toLowerCase(), null, !1, !1);
});
var ja = /[\-:]([a-z])/g;

function ka(a) {
  return a[1].toUpperCase();
}

"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(ja, ka);
  z[b] = new y(b, 1, !1, a, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(ja, ka);
  z[b] = new y(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(ja, ka);
  z[b] = new y(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (a) {
  z[a] = new y(a, 1, !1, a.toLowerCase(), null, !1, !1);
});
z.xlinkHref = new y("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (a) {
  z[a] = new y(a, 1, !1, a.toLowerCase(), null, !0, !0);
});
var B = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
},
    la = ["Webkit", "ms", "Moz", "O"];
Object.keys(B).forEach(function (a) {
  la.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    B[b] = B[a];
  });
});
var oa = /["'&<>]/;

function C(a) {
  if ("boolean" === typeof a || "number" === typeof a) return "" + a;
  a = "" + a;
  var b = oa.exec(a);

  if (b) {
    var c = "",
        d,
        f = 0;

    for (d = b.index; d < a.length; d++) {
      switch (a.charCodeAt(d)) {
        case 34:
          b = "&quot;";
          break;

        case 38:
          b = "&amp;";
          break;

        case 39:
          b = "&#x27;";
          break;

        case 60:
          b = "&lt;";
          break;

        case 62:
          b = "&gt;";
          break;

        default:
          continue;
      }

      f !== d && (c += a.substring(f, d));
      f = d + 1;
      c += b;
    }

    a = f !== d ? c + a.substring(f, d) : c;
  }

  return a;
}

var pa = /([A-Z])/g,
    qa = /^ms-/,
    ra = Array.isArray,
    sa = w("<script>"),
    ta = w("\x3c/script>"),
    ua = w('<script src="'),
    va = w('<script type="module" src="'),
    wa = w('" async="">\x3c/script>'),
    xa = /(<\/|<)(s)(cript)/gi;

function ya(a, b, c, d) {
  return "" + b + ("s" === c ? "\\u0073" : "\\u0053") + d;
}

function za(a, b, c, d, f) {
  a = void 0 === a ? "" : a;
  b = void 0 === b ? sa : w('<script nonce="' + C(b) + '">');
  var e = [];
  void 0 !== c && e.push(b, u(("" + c).replace(xa, ya)), ta);
  if (void 0 !== d) for (c = 0; c < d.length; c++) {
    e.push(ua, u(C(d[c])), wa);
  }
  if (void 0 !== f) for (d = 0; d < f.length; d++) {
    e.push(va, u(C(f[d])), wa);
  }
  return {
    bootstrapChunks: e,
    startInlineScript: b,
    placeholderPrefix: w(a + "P:"),
    segmentPrefix: w(a + "S:"),
    boundaryPrefix: a + "B:",
    idPrefix: a,
    nextSuspenseID: 0,
    sentCompleteSegmentFunction: !1,
    sentCompleteBoundaryFunction: !1,
    sentClientRenderFunction: !1
  };
}

function D(a, b) {
  return {
    insertionMode: a,
    selectedValue: b
  };
}

function Aa(a) {
  return D("http://www.w3.org/2000/svg" === a ? 2 : "http://www.w3.org/1998/Math/MathML" === a ? 3 : 0, null);
}

function Ba(a, b, c) {
  switch (b) {
    case "select":
      return D(1, null != c.value ? c.value : c.defaultValue);

    case "svg":
      return D(2, null);

    case "math":
      return D(3, null);

    case "foreignObject":
      return D(1, null);

    case "table":
      return D(4, null);

    case "thead":
    case "tbody":
    case "tfoot":
      return D(5, null);

    case "colgroup":
      return D(7, null);

    case "tr":
      return D(6, null);
  }

  return 4 <= a.insertionMode || 0 === a.insertionMode ? D(1, null) : a;
}

var Ca = w("\x3c!-- --\x3e");

function Da(a, b, c, d) {
  if ("" === b) return d;
  d && a.push(Ca);
  a.push(u(C(b)));
  return !0;
}

var Ea = new Map(),
    Fa = w(' style="'),
    Ga = w(":"),
    Ha = w(";");

function Ia(a, b, c) {
  if ("object" !== typeof c) throw Error(k(62));
  b = !0;

  for (var d in c) {
    if (x.call(c, d)) {
      var f = c[d];

      if (null != f && "boolean" !== typeof f && "" !== f) {
        if (0 === d.indexOf("--")) {
          var e = u(C(d));
          f = u(C(("" + f).trim()));
        } else {
          e = d;
          var g = Ea.get(e);
          void 0 !== g ? e = g : (g = w(C(e.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-"))), Ea.set(e, g), e = g);
          f = "number" === typeof f ? 0 === f || x.call(B, d) ? u("" + f) : u(f + "px") : u(C(("" + f).trim()));
        }

        b ? (b = !1, a.push(Fa, e, Ga, f)) : a.push(Ha, e, Ga, f);
      }
    }
  }

  b || a.push(E);
}

var H = w(" "),
    I = w('="'),
    E = w('"'),
    Ja = w('=""');

function J(a, b, c, d) {
  switch (c) {
    case "style":
      Ia(a, b, d);
      return;

    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }

  if (!(2 < c.length) || "o" !== c[0] && "O" !== c[0] || "n" !== c[1] && "N" !== c[1]) if (b = z.hasOwnProperty(c) ? z[c] : null, null !== b) {
    switch (typeof d) {
      case "function":
      case "symbol":
        return;

      case "boolean":
        if (!b.acceptsBooleans) return;
    }

    c = u(b.attributeName);

    switch (b.type) {
      case 3:
        d && a.push(H, c, Ja);
        break;

      case 4:
        !0 === d ? a.push(H, c, Ja) : !1 !== d && a.push(H, c, I, u(C(d)), E);
        break;

      case 5:
        isNaN(d) || a.push(H, c, I, u(C(d)), E);
        break;

      case 6:
        !isNaN(d) && 1 <= d && a.push(H, c, I, u(C(d)), E);
        break;

      default:
        b.sanitizeURL && (d = "" + d), a.push(H, c, I, u(C(d)), E);
    }
  } else if (ia(c)) {
    switch (typeof d) {
      case "function":
      case "symbol":
        return;

      case "boolean":
        if (b = c.toLowerCase().slice(0, 5), "data-" !== b && "aria-" !== b) return;
    }

    a.push(H, u(c), I, u(C(d)), E);
  }
}

var K = w(">"),
    Ka = w("/>");

function L(a, b, c) {
  if (null != b) {
    if (null != c) throw Error(k(60));
    if ("object" !== typeof b || !("__html" in b)) throw Error(k(61));
    b = b.__html;
    null !== b && void 0 !== b && a.push(u("" + b));
  }
}

function La(a) {
  var b = "";
  aa.Children.forEach(a, function (a) {
    null != a && (b += a);
  });
  return b;
}

var Ma = w(' selected=""');

function Na(a, b, c, d) {
  a.push(M(c));
  var f = c = null,
      e;

  for (e in b) {
    if (x.call(b, e)) {
      var g = b[e];
      if (null != g) switch (e) {
        case "children":
          c = g;
          break;

        case "dangerouslySetInnerHTML":
          f = g;
          break;

        default:
          J(a, d, e, g);
      }
    }
  }

  a.push(K);
  L(a, f, c);
  return "string" === typeof c ? (a.push(u(C(c))), null) : c;
}

var Oa = w("\n"),
    Pa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    Qa = new Map();

function M(a) {
  var b = Qa.get(a);

  if (void 0 === b) {
    if (!Pa.test(a)) throw Error(k(65, a));
    b = w("<" + a);
    Qa.set(a, b);
  }

  return b;
}

var Ra = w("<!DOCTYPE html>");

function Sa(a, b, c, d, f) {
  switch (b) {
    case "select":
      a.push(M("select"));
      var e = null,
          g = null;

      for (r in c) {
        if (x.call(c, r)) {
          var h = c[r];
          if (null != h) switch (r) {
            case "children":
              e = h;
              break;

            case "dangerouslySetInnerHTML":
              g = h;
              break;

            case "defaultValue":
            case "value":
              break;

            default:
              J(a, d, r, h);
          }
        }
      }

      a.push(K);
      L(a, g, e);
      return e;

    case "option":
      g = f.selectedValue;
      a.push(M("option"));
      var m = h = null,
          q = null;
      var r = null;

      for (e in c) {
        if (x.call(c, e)) {
          var v = c[e];
          if (null != v) switch (e) {
            case "children":
              h = v;
              break;

            case "selected":
              q = v;
              break;

            case "dangerouslySetInnerHTML":
              r = v;
              break;

            case "value":
              m = v;

            default:
              J(a, d, e, v);
          }
        }
      }

      if (null != g) {
        if (c = null !== m ? "" + m : La(h), ra(g)) for (d = 0; d < g.length; d++) {
          if ("" + g[d] === c) {
            a.push(Ma);
            break;
          }
        } else "" + g === c && a.push(Ma);
      } else q && a.push(Ma);
      a.push(K);
      L(a, r, h);
      return h;

    case "textarea":
      a.push(M("textarea"));
      r = g = e = null;

      for (h in c) {
        if (x.call(c, h) && (m = c[h], null != m)) switch (h) {
          case "children":
            r = m;
            break;

          case "value":
            e = m;
            break;

          case "defaultValue":
            g = m;
            break;

          case "dangerouslySetInnerHTML":
            throw Error(k(91));

          default:
            J(a, d, h, m);
        }
      }

      null === e && null !== g && (e = g);
      a.push(K);

      if (null != r) {
        if (null != e) throw Error(k(92));
        if (ra(r) && 1 < r.length) throw Error(k(93));
        e = "" + r;
      }

      "string" === typeof e && "\n" === e[0] && a.push(Oa);
      null !== e && a.push(u(C("" + e)));
      return null;

    case "input":
      a.push(M("input"));
      m = r = h = e = null;

      for (g in c) {
        if (x.call(c, g) && (q = c[g], null != q)) switch (g) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(k(399, "input"));

          case "defaultChecked":
            m = q;
            break;

          case "defaultValue":
            h = q;
            break;

          case "checked":
            r = q;
            break;

          case "value":
            e = q;
            break;

          default:
            J(a, d, g, q);
        }
      }

      null !== r ? J(a, d, "checked", r) : null !== m && J(a, d, "checked", m);
      null !== e ? J(a, d, "value", e) : null !== h && J(a, d, "value", h);
      a.push(Ka);
      return null;

    case "menuitem":
      a.push(M("menuitem"));

      for (var A in c) {
        if (x.call(c, A) && (e = c[A], null != e)) switch (A) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(k(400));

          default:
            J(a, d, A, e);
        }
      }

      a.push(K);
      return null;

    case "title":
      a.push(M("title"));
      e = null;

      for (v in c) {
        if (x.call(c, v) && (g = c[v], null != g)) switch (v) {
          case "children":
            e = g;
            break;

          case "dangerouslySetInnerHTML":
            throw Error(k(434));

          default:
            J(a, d, v, g);
        }
      }

      a.push(K);
      return e;

    case "listing":
    case "pre":
      a.push(M(b));
      g = e = null;

      for (m in c) {
        if (x.call(c, m) && (h = c[m], null != h)) switch (m) {
          case "children":
            e = h;
            break;

          case "dangerouslySetInnerHTML":
            g = h;
            break;

          default:
            J(a, d, m, h);
        }
      }

      a.push(K);

      if (null != g) {
        if (null != e) throw Error(k(60));
        if ("object" !== typeof g || !("__html" in g)) throw Error(k(61));
        c = g.__html;
        null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push(Oa, u(c)) : a.push(u("" + c)));
      }

      "string" === typeof e && "\n" === e[0] && a.push(Oa);
      return e;

    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a.push(M(b));

      for (var F in c) {
        if (x.call(c, F) && (e = c[F], null != e)) switch (F) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(k(399, b));

          default:
            J(a, d, F, e);
        }
      }

      a.push(Ka);
      return null;

    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return Na(a, c, b, d);

    case "html":
      return 0 === f.insertionMode && a.push(Ra), Na(a, c, b, d);

    default:
      if (-1 === b.indexOf("-") && "string" !== typeof c.is) return Na(a, c, b, d);
      a.push(M(b));
      g = e = null;

      for (q in c) {
        if (x.call(c, q) && (h = c[q], null != h)) switch (q) {
          case "children":
            e = h;
            break;

          case "dangerouslySetInnerHTML":
            g = h;
            break;

          case "style":
            Ia(a, d, h);
            break;

          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;

          default:
            ia(q) && "function" !== typeof h && "symbol" !== typeof h && a.push(H, u(q), I, u(C(h)), E);
        }
      }

      a.push(K);
      L(a, g, e);
      return e;
  }
}

var Ta = w("</"),
    Ua = w(">"),
    Va = w('<template id="'),
    Wa = w('"></template>'),
    Xa = w("\x3c!--$--\x3e"),
    Ya = w('\x3c!--$?--\x3e<template id="'),
    Za = w('"></template>'),
    $a = w("\x3c!--$!--\x3e"),
    ab = w("\x3c!--/$--\x3e"),
    bb = w("<template"),
    cb = w('"'),
    db = w(' data-dgst="');
w(' data-msg="');
w(' data-stck="');
var eb = w("></template>");

function fb(a, b, c) {
  p(a, Ya);
  if (null === c) throw Error(k(395));
  p(a, c);
  return t(a, Za);
}

var gb = w('<div hidden id="'),
    hb = w('">'),
    ib = w("</div>"),
    jb = w('<svg aria-hidden="true" style="display:none" id="'),
    kb = w('">'),
    lb = w("</svg>"),
    mb = w('<math aria-hidden="true" style="display:none" id="'),
    nb = w('">'),
    ob = w("</math>"),
    pb = w('<table hidden id="'),
    qb = w('">'),
    rb = w("</table>"),
    sb = w('<table hidden><tbody id="'),
    tb = w('">'),
    ub = w("</tbody></table>"),
    vb = w('<table hidden><tr id="'),
    wb = w('">'),
    xb = w("</tr></table>"),
    yb = w('<table hidden><colgroup id="'),
    zb = w('">'),
    Ab = w("</colgroup></table>");

function Bb(a, b, c, d) {
  switch (c.insertionMode) {
    case 0:
    case 1:
      return p(a, gb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, hb);

    case 2:
      return p(a, jb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, kb);

    case 3:
      return p(a, mb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, nb);

    case 4:
      return p(a, pb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, qb);

    case 5:
      return p(a, sb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, tb);

    case 6:
      return p(a, vb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, wb);

    case 7:
      return p(a, yb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, zb);

    default:
      throw Error(k(397));
  }
}

function Cb(a, b) {
  switch (b.insertionMode) {
    case 0:
    case 1:
      return t(a, ib);

    case 2:
      return t(a, lb);

    case 3:
      return t(a, ob);

    case 4:
      return t(a, rb);

    case 5:
      return t(a, ub);

    case 6:
      return t(a, xb);

    case 7:
      return t(a, Ab);

    default:
      throw Error(k(397));
  }
}

var Db = w('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'),
    Eb = w('$RS("'),
    Gb = w('","'),
    Hb = w('")\x3c/script>'),
    Ib = w('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'),
    Jb = w('$RC("'),
    Kb = w('","'),
    Lb = w('")\x3c/script>'),
    Mb = w('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'),
    Nb = w('$RX("'),
    Ob = w('"'),
    Pb = w(")\x3c/script>"),
    Qb = w(","),
    Rb = /[<\u2028\u2029]/g;

function Sb(a) {
  return JSON.stringify(a).replace(Rb, function (a) {
    switch (a) {
      case "<":
        return "\\u003c";

      case "\u2028":
        return "\\u2028";

      case "\u2029":
        return "\\u2029";

      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}

var N = Object.assign,
    Tb = Symbol.for("react.element"),
    Ub = Symbol.for("react.portal"),
    Vb = Symbol.for("react.fragment"),
    Wb = Symbol.for("react.strict_mode"),
    Xb = Symbol.for("react.profiler"),
    Yb = Symbol.for("react.provider"),
    Zb = Symbol.for("react.context"),
    $b = Symbol.for("react.forward_ref"),
    ac = Symbol.for("react.suspense"),
    bc = Symbol.for("react.suspense_list"),
    cc = Symbol.for("react.memo"),
    dc = Symbol.for("react.lazy"),
    ec = Symbol.for("react.scope"),
    fc = Symbol.for("react.debug_trace_mode"),
    gc = Symbol.for("react.legacy_hidden"),
    hc = Symbol.for("react.default_value"),
    ic = Symbol.iterator;

function jc(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;

  switch (a) {
    case Vb:
      return "Fragment";

    case Ub:
      return "Portal";

    case Xb:
      return "Profiler";

    case Wb:
      return "StrictMode";

    case ac:
      return "Suspense";

    case bc:
      return "SuspenseList";
  }

  if ("object" === typeof a) switch (a.$$typeof) {
    case Zb:
      return (a.displayName || "Context") + ".Consumer";

    case Yb:
      return (a._context.displayName || "Context") + ".Provider";

    case $b:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;

    case cc:
      return b = a.displayName || null, null !== b ? b : jc(a.type) || "Memo";

    case dc:
      b = a._payload;
      a = a._init;

      try {
        return jc(a(b));
      } catch (c) {}

  }
  return null;
}

var kc = {};

function lc(a, b) {
  a = a.contextTypes;
  if (!a) return kc;
  var c = {},
      d;

  for (d in a) {
    c[d] = b[d];
  }

  return c;
}

var O = null;

function P(a, b) {
  if (a !== b) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    var c = b.parent;

    if (null === a) {
      if (null !== c) throw Error(k(401));
    } else {
      if (null === c) throw Error(k(401));
      P(a, c);
    }

    b.context._currentValue = b.value;
  }
}

function mc(a) {
  a.context._currentValue = a.parentValue;
  a = a.parent;
  null !== a && mc(a);
}

function nc(a) {
  var b = a.parent;
  null !== b && nc(b);
  a.context._currentValue = a.value;
}

function oc(a, b) {
  a.context._currentValue = a.parentValue;
  a = a.parent;
  if (null === a) throw Error(k(402));
  a.depth === b.depth ? P(a, b) : oc(a, b);
}

function pc(a, b) {
  var c = b.parent;
  if (null === c) throw Error(k(402));
  a.depth === c.depth ? P(a, c) : pc(a, c);
  b.context._currentValue = b.value;
}

function Q(a) {
  var b = O;
  b !== a && (null === b ? nc(a) : null === a ? mc(b) : b.depth === a.depth ? P(b, a) : b.depth > a.depth ? oc(b, a) : pc(b, a), O = a);
}

var qc = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueSetState: function enqueueSetState(a, b) {
    a = a._reactInternals;
    null !== a.queue && a.queue.push(b);
  },
  enqueueReplaceState: function enqueueReplaceState(a, b) {
    a = a._reactInternals;
    a.replace = !0;
    a.queue = [b];
  },
  enqueueForceUpdate: function enqueueForceUpdate() {}
};

function rc(a, b, c, d) {
  var f = void 0 !== a.state ? a.state : null;
  a.updater = qc;
  a.props = c;
  a.state = f;
  var e = {
    queue: [],
    replace: !1
  };
  a._reactInternals = e;
  var g = b.contextType;
  a.context = "object" === typeof g && null !== g ? g._currentValue : d;
  g = b.getDerivedStateFromProps;
  "function" === typeof g && (g = g(c, f), f = null === g || void 0 === g ? f : N({}, f, g), a.state = f);
  if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && qc.enqueueReplaceState(a, a.state, null), null !== e.queue && 0 < e.queue.length) {
    if (b = e.queue, g = e.replace, e.queue = null, e.replace = !1, g && 1 === b.length) a.state = b[0];else {
      e = g ? b[0] : a.state;
      f = !0;

      for (g = g ? 1 : 0; g < b.length; g++) {
        var h = b[g];
        h = "function" === typeof h ? h.call(a, e, c, d) : h;
        null != h && (f ? (f = !1, e = N({}, e, h)) : N(e, h));
      }

      a.state = e;
    }
  } else e.queue = null;
}

var sc = {
  id: 1,
  overflow: ""
};

function tc(a, b, c) {
  var d = a.id;
  a = a.overflow;
  var f = 32 - uc(d) - 1;
  d &= ~(1 << f);
  c += 1;
  var e = 32 - uc(b) + f;

  if (30 < e) {
    var g = f - f % 5;
    e = (d & (1 << g) - 1).toString(32);
    d >>= g;
    f -= g;
    return {
      id: 1 << 32 - uc(b) + f | c << f | d,
      overflow: e + a
    };
  }

  return {
    id: 1 << e | c << f | d,
    overflow: a
  };
}

var uc = Math.clz32 ? Math.clz32 : vc,
    wc = Math.log,
    xc = Math.LN2;

function vc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (wc(a) / xc | 0) | 0;
}

function yc(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}

var zc = "function" === typeof Object.is ? Object.is : yc,
    R = null,
    Ac = null,
    Bc = null,
    S = null,
    T = !1,
    Cc = !1,
    U = 0,
    V = null,
    Dc = 0;

function W() {
  if (null === R) throw Error(k(321));
  return R;
}

function Ec() {
  if (0 < Dc) throw Error(k(312));
  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}

function Fc() {
  null === S ? null === Bc ? (T = !1, Bc = S = Ec()) : (T = !0, S = Bc) : null === S.next ? (T = !1, S = S.next = Ec()) : (T = !0, S = S.next);
  return S;
}

function Gc() {
  Ac = R = null;
  Cc = !1;
  Bc = null;
  Dc = 0;
  S = V = null;
}

function Hc(a, b) {
  return "function" === typeof b ? b(a) : b;
}

function Ic(a, b, c) {
  R = W();
  S = Fc();

  if (T) {
    var d = S.queue;
    b = d.dispatch;

    if (null !== V && (c = V.get(d), void 0 !== c)) {
      V.delete(d);
      d = S.memoizedState;

      do {
        d = a(d, c.action), c = c.next;
      } while (null !== c);

      S.memoizedState = d;
      return [d, b];
    }

    return [S.memoizedState, b];
  }

  a = a === Hc ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
  S.memoizedState = a;
  a = S.queue = {
    last: null,
    dispatch: null
  };
  a = a.dispatch = Jc.bind(null, R, a);
  return [S.memoizedState, a];
}

function Kc(a, b) {
  R = W();
  S = Fc();
  b = void 0 === b ? null : b;

  if (null !== S) {
    var c = S.memoizedState;

    if (null !== c && null !== b) {
      var d = c[1];

      a: if (null === d) d = !1;else {
        for (var f = 0; f < d.length && f < b.length; f++) {
          if (!zc(b[f], d[f])) {
            d = !1;
            break a;
          }
        }

        d = !0;
      }

      if (d) return c[0];
    }
  }

  a = a();
  S.memoizedState = [a, b];
  return a;
}

function Jc(a, b, c) {
  if (25 <= Dc) throw Error(k(301));
  if (a === R) if (Cc = !0, a = {
    action: c,
    next: null
  }, null === V && (V = new Map()), c = V.get(b), void 0 === c) V.set(b, a);else {
    for (b = c; null !== b.next;) {
      b = b.next;
    }

    b.next = a;
  }
}

function Lc() {
  throw Error(k(394));
}

function Mc() {}

var Oc = {
  readContext: function readContext(a) {
    return a._currentValue;
  },
  useContext: function useContext(a) {
    W();
    return a._currentValue;
  },
  useMemo: Kc,
  useReducer: Ic,
  useRef: function useRef(a) {
    R = W();
    S = Fc();
    var b = S.memoizedState;
    return null === b ? (a = {
      current: a
    }, S.memoizedState = a) : b;
  },
  useState: function useState(a) {
    return Ic(Hc, a);
  },
  useInsertionEffect: Mc,
  useLayoutEffect: function useLayoutEffect() {},
  useCallback: function useCallback(a, b) {
    return Kc(function () {
      return a;
    }, b);
  },
  useImperativeHandle: Mc,
  useEffect: Mc,
  useDebugValue: Mc,
  useDeferredValue: function useDeferredValue(a) {
    W();
    return a;
  },
  useTransition: function useTransition() {
    W();
    return [!1, Lc];
  },
  useId: function useId() {
    var a = Ac.treeContext;
    var b = a.overflow;
    a = a.id;
    a = (a & ~(1 << 32 - uc(a) - 1)).toString(32) + b;
    var c = Nc;
    if (null === c) throw Error(k(404));
    b = U++;
    a = ":" + c.idPrefix + "R" + a;
    0 < b && (a += "H" + b.toString(32));
    return a + ":";
  },
  useMutableSource: function useMutableSource(a, b) {
    W();
    return b(a._source);
  },
  useSyncExternalStore: function useSyncExternalStore(a, b, c) {
    if (void 0 === c) throw Error(k(407));
    return c();
  }
},
    Nc = null,
    Pc = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;

function Qc(a) {
  console.error(a);
  return null;
}

function X() {}

function Rc(a, b, c, d, f, e, g, h, m) {
  var q = [],
      r = new Set();
  b = {
    destination: null,
    responseState: b,
    progressiveChunkSize: void 0 === d ? 12800 : d,
    status: 0,
    fatalError: null,
    nextSegmentId: 0,
    allPendingTasks: 0,
    pendingRootTasks: 0,
    completedRootSegment: null,
    abortableTasks: r,
    pingedTasks: q,
    clientRenderedBoundaries: [],
    completedBoundaries: [],
    partialBoundaries: [],
    onError: void 0 === f ? Qc : f,
    onAllReady: void 0 === e ? X : e,
    onShellReady: void 0 === g ? X : g,
    onShellError: void 0 === h ? X : h,
    onFatalError: void 0 === m ? X : m
  };
  c = Sc(b, 0, null, c, !1, !1);
  c.parentFlushed = !0;
  a = Tc(b, a, null, c, r, kc, null, sc);
  q.push(a);
  return b;
}

function Tc(a, b, c, d, f, e, g, h) {
  a.allPendingTasks++;
  null === c ? a.pendingRootTasks++ : c.pendingTasks++;
  var m = {
    node: b,
    ping: function ping() {
      var b = a.pingedTasks;
      b.push(m);
      1 === b.length && Uc(a);
    },
    blockedBoundary: c,
    blockedSegment: d,
    abortSet: f,
    legacyContext: e,
    context: g,
    treeContext: h
  };
  f.add(m);
  return m;
}

function Sc(a, b, c, d, f, e) {
  return {
    status: 0,
    id: -1,
    index: b,
    parentFlushed: !1,
    chunks: [],
    children: [],
    formatContext: d,
    boundary: c,
    lastPushedText: f,
    textEmbedded: e
  };
}

function Y(a, b) {
  a = a.onError(b);
  if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
  return a;
}

function Vc(a, b) {
  var c = a.onShellError;
  c(b);
  c = a.onFatalError;
  c(b);
  null !== a.destination ? (a.status = 2, da(a.destination, b)) : (a.status = 1, a.fatalError = b);
}

function Wc(a, b, c, d, f) {
  R = {};
  Ac = b;
  U = 0;

  for (a = c(d, f); Cc;) {
    Cc = !1, U = 0, Dc += 1, S = null, a = c(d, f);
  }

  Gc();
  return a;
}

function Xc(a, b, c, d) {
  var f = c.render(),
      e = d.childContextTypes;

  if (null !== e && void 0 !== e) {
    var g = b.legacyContext;
    if ("function" !== typeof c.getChildContext) d = g;else {
      c = c.getChildContext();

      for (var h in c) {
        if (!(h in e)) throw Error(k(108, jc(d) || "Unknown", h));
      }

      d = N({}, g, c);
    }
    b.legacyContext = d;
    Z(a, b, f);
    b.legacyContext = g;
  } else Z(a, b, f);
}

function Yc(a, b) {
  if (a && a.defaultProps) {
    b = N({}, b);
    a = a.defaultProps;

    for (var c in a) {
      void 0 === b[c] && (b[c] = a[c]);
    }

    return b;
  }

  return b;
}

function Zc(a, b, c, d, f) {
  if ("function" === typeof c) {
    if (c.prototype && c.prototype.isReactComponent) {
      f = lc(c, b.legacyContext);
      var e = c.contextType;
      e = new c(d, "object" === typeof e && null !== e ? e._currentValue : f);
      rc(e, c, d, f);
      Xc(a, b, e, c);
    } else {
      e = lc(c, b.legacyContext);
      f = Wc(a, b, c, d, e);
      var g = 0 !== U;
      if ("object" === typeof f && null !== f && "function" === typeof f.render && void 0 === f.$$typeof) rc(f, c, d, e), Xc(a, b, f, c);else if (g) {
        d = b.treeContext;
        b.treeContext = tc(d, 1, 0);

        try {
          Z(a, b, f);
        } finally {
          b.treeContext = d;
        }
      } else Z(a, b, f);
    }
  } else if ("string" === typeof c) {
    f = b.blockedSegment;
    e = Sa(f.chunks, c, d, a.responseState, f.formatContext);
    f.lastPushedText = !1;
    g = f.formatContext;
    f.formatContext = Ba(g, c, d);
    $c(a, b, e);
    f.formatContext = g;

    switch (c) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;

      default:
        f.chunks.push(Ta, u(c), Ua);
    }

    f.lastPushedText = !1;
  } else {
    switch (c) {
      case gc:
      case fc:
      case Wb:
      case Xb:
      case Vb:
        Z(a, b, d.children);
        return;

      case bc:
        Z(a, b, d.children);
        return;

      case ec:
        throw Error(k(343));

      case ac:
        a: {
          c = b.blockedBoundary;
          f = b.blockedSegment;
          e = d.fallback;
          d = d.children;
          g = new Set();
          var h = {
            id: null,
            rootSegmentID: -1,
            parentFlushed: !1,
            pendingTasks: 0,
            forceClientRender: !1,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks: g,
            errorDigest: null
          },
              m = Sc(a, f.chunks.length, h, f.formatContext, !1, !1);
          f.children.push(m);
          f.lastPushedText = !1;
          var q = Sc(a, 0, null, f.formatContext, !1, !1);
          q.parentFlushed = !0;
          b.blockedBoundary = h;
          b.blockedSegment = q;

          try {
            if ($c(a, b, d), q.lastPushedText && q.textEmbedded && q.chunks.push(Ca), q.status = 1, ad(h, q), 0 === h.pendingTasks) break a;
          } catch (r) {
            q.status = 4, h.forceClientRender = !0, h.errorDigest = Y(a, r);
          } finally {
            b.blockedBoundary = c, b.blockedSegment = f;
          }

          b = Tc(a, e, c, m, g, b.legacyContext, b.context, b.treeContext);
          a.pingedTasks.push(b);
        }

        return;
    }

    if ("object" === typeof c && null !== c) switch (c.$$typeof) {
      case $b:
        d = Wc(a, b, c.render, d, f);

        if (0 !== U) {
          c = b.treeContext;
          b.treeContext = tc(c, 1, 0);

          try {
            Z(a, b, d);
          } finally {
            b.treeContext = c;
          }
        } else Z(a, b, d);

        return;

      case cc:
        c = c.type;
        d = Yc(c, d);
        Zc(a, b, c, d, f);
        return;

      case Yb:
        f = d.children;
        c = c._context;
        d = d.value;
        e = c._currentValue;
        c._currentValue = d;
        g = O;
        O = d = {
          parent: g,
          depth: null === g ? 0 : g.depth + 1,
          context: c,
          parentValue: e,
          value: d
        };
        b.context = d;
        Z(a, b, f);
        a = O;
        if (null === a) throw Error(k(403));
        d = a.parentValue;
        a.context._currentValue = d === hc ? a.context._defaultValue : d;
        a = O = a.parent;
        b.context = a;
        return;

      case Zb:
        d = d.children;
        d = d(c._currentValue);
        Z(a, b, d);
        return;

      case dc:
        f = c._init;
        c = f(c._payload);
        d = Yc(c, d);
        Zc(a, b, c, d, void 0);
        return;
    }
    throw Error(k(130, null == c ? c : typeof c, ""));
  }
}

function Z(a, b, c) {
  b.node = c;

  if ("object" === typeof c && null !== c) {
    switch (c.$$typeof) {
      case Tb:
        Zc(a, b, c.type, c.props, c.ref);
        return;

      case Ub:
        throw Error(k(257));

      case dc:
        var d = c._init;
        c = d(c._payload);
        Z(a, b, c);
        return;
    }

    if (ra(c)) {
      bd(a, b, c);
      return;
    }

    null === c || "object" !== typeof c ? d = null : (d = ic && c[ic] || c["@@iterator"], d = "function" === typeof d ? d : null);

    if (d && (d = d.call(c))) {
      c = d.next();

      if (!c.done) {
        var f = [];

        do {
          f.push(c.value), c = d.next();
        } while (!c.done);

        bd(a, b, f);
      }

      return;
    }

    a = Object.prototype.toString.call(c);
    throw Error(k(31, "[object Object]" === a ? "object with keys {" + Object.keys(c).join(", ") + "}" : a));
  }

  "string" === typeof c ? (d = b.blockedSegment, d.lastPushedText = Da(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : "number" === typeof c && (d = b.blockedSegment, d.lastPushedText = Da(b.blockedSegment.chunks, "" + c, a.responseState, d.lastPushedText));
}

function bd(a, b, c) {
  for (var d = c.length, f = 0; f < d; f++) {
    var e = b.treeContext;
    b.treeContext = tc(e, d, f);

    try {
      $c(a, b, c[f]);
    } finally {
      b.treeContext = e;
    }
  }
}

function $c(a, b, c) {
  var d = b.blockedSegment.formatContext,
      f = b.legacyContext,
      e = b.context;

  try {
    return Z(a, b, c);
  } catch (m) {
    if (Gc(), "object" === typeof m && null !== m && "function" === typeof m.then) {
      c = m;
      var g = b.blockedSegment,
          h = Sc(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
      g.children.push(h);
      g.lastPushedText = !1;
      a = Tc(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping;
      c.then(a, a);
      b.blockedSegment.formatContext = d;
      b.legacyContext = f;
      b.context = e;
      Q(e);
    } else throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, Q(e), m;
  }
}

function cd(a) {
  var b = a.blockedBoundary;
  a = a.blockedSegment;
  a.status = 3;
  dd(this, b, a);
}

function ed(a, b, c) {
  var d = a.blockedBoundary;
  a.blockedSegment.status = 3;
  null === d ? (b.allPendingTasks--, 2 !== b.status && (b.status = 2, null !== b.destination && b.destination.close())) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, a = void 0 === c ? Error(k(432)) : c, d.errorDigest = b.onError(a), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function (a) {
    return ed(a, b, c);
  }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (d = b.onAllReady, d()));
}

function ad(a, b) {
  if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
    var c = b.children[0];
    c.id = b.id;
    c.parentFlushed = !0;
    1 === c.status && ad(a, c);
  } else a.completedSegments.push(b);
}

function dd(a, b, c) {
  if (null === b) {
    if (c.parentFlushed) {
      if (null !== a.completedRootSegment) throw Error(k(389));
      a.completedRootSegment = c;
    }

    a.pendingRootTasks--;
    0 === a.pendingRootTasks && (a.onShellError = X, b = a.onShellReady, b());
  } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && ad(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(cd, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (ad(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));

  a.allPendingTasks--;
  0 === a.allPendingTasks && (a = a.onAllReady, a());
}

function Uc(a) {
  if (2 !== a.status) {
    var b = O,
        c = Pc.current;
    Pc.current = Oc;
    var d = Nc;
    Nc = a.responseState;

    try {
      var f = a.pingedTasks,
          e;

      for (e = 0; e < f.length; e++) {
        var g = f[e];
        var h = a,
            m = g.blockedSegment;

        if (0 === m.status) {
          Q(g.context);

          try {
            Z(h, g, g.node), m.lastPushedText && m.textEmbedded && m.chunks.push(Ca), g.abortSet.delete(g), m.status = 1, dd(h, g.blockedBoundary, m);
          } catch (G) {
            if (Gc(), "object" === typeof G && null !== G && "function" === typeof G.then) {
              var q = g.ping;
              G.then(q, q);
            } else {
              g.abortSet.delete(g);
              m.status = 4;
              var r = g.blockedBoundary,
                  v = G,
                  A = Y(h, v);
              null === r ? Vc(h, v) : (r.pendingTasks--, r.forceClientRender || (r.forceClientRender = !0, r.errorDigest = A, r.parentFlushed && h.clientRenderedBoundaries.push(r)));
              h.allPendingTasks--;

              if (0 === h.allPendingTasks) {
                var F = h.onAllReady;
                F();
              }
            }
          } finally {}
        }
      }

      f.splice(0, e);
      null !== a.destination && fd(a, a.destination);
    } catch (G) {
      Y(a, G), Vc(a, G);
    } finally {
      Nc = d, Pc.current = c, c === Oc && Q(b);
    }
  }
}

function gd(a, b, c) {
  c.parentFlushed = !0;

  switch (c.status) {
    case 0:
      var d = c.id = a.nextSegmentId++;
      c.lastPushedText = !1;
      c.textEmbedded = !1;
      a = a.responseState;
      p(b, Va);
      p(b, a.placeholderPrefix);
      a = u(d.toString(16));
      p(b, a);
      return t(b, Wa);

    case 1:
      c.status = 2;
      var f = !0;
      d = c.chunks;
      var e = 0;
      c = c.children;

      for (var g = 0; g < c.length; g++) {
        for (f = c[g]; e < f.index; e++) {
          p(b, d[e]);
        }

        f = hd(a, b, f);
      }

      for (; e < d.length - 1; e++) {
        p(b, d[e]);
      }

      e < d.length && (f = t(b, d[e]));
      return f;

    default:
      throw Error(k(390));
  }
}

function hd(a, b, c) {
  var d = c.boundary;
  if (null === d) return gd(a, b, c);
  d.parentFlushed = !0;
  if (d.forceClientRender) d = d.errorDigest, t(b, $a), p(b, bb), d && (p(b, db), p(b, u(C(d))), p(b, cb)), t(b, eb), gd(a, b, c);else if (0 < d.pendingTasks) {
    d.rootSegmentID = a.nextSegmentId++;
    0 < d.completedSegments.length && a.partialBoundaries.push(d);
    var f = a.responseState;
    var e = f.nextSuspenseID++;
    f = w(f.boundaryPrefix + e.toString(16));
    d = d.id = f;
    fb(b, a.responseState, d);
    gd(a, b, c);
  } else if (d.byteSize > a.progressiveChunkSize) d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), fb(b, a.responseState, d.id), gd(a, b, c);else {
    t(b, Xa);
    c = d.completedSegments;
    if (1 !== c.length) throw Error(k(391));
    hd(a, b, c[0]);
  }
  return t(b, ab);
}

function id(a, b, c) {
  Bb(b, a.responseState, c.formatContext, c.id);
  hd(a, b, c);
  return Cb(b, c.formatContext);
}

function jd(a, b, c) {
  for (var d = c.completedSegments, f = 0; f < d.length; f++) {
    kd(a, b, c, d[f]);
  }

  d.length = 0;
  a = a.responseState;
  d = c.id;
  c = c.rootSegmentID;
  p(b, a.startInlineScript);
  a.sentCompleteBoundaryFunction ? p(b, Jb) : (a.sentCompleteBoundaryFunction = !0, p(b, Ib));
  if (null === d) throw Error(k(395));
  c = u(c.toString(16));
  p(b, d);
  p(b, Kb);
  p(b, a.segmentPrefix);
  p(b, c);
  return t(b, Lb);
}

function kd(a, b, c, d) {
  if (2 === d.status) return !0;
  var f = d.id;

  if (-1 === f) {
    if (-1 === (d.id = c.rootSegmentID)) throw Error(k(392));
    return id(a, b, d);
  }

  id(a, b, d);
  a = a.responseState;
  p(b, a.startInlineScript);
  a.sentCompleteSegmentFunction ? p(b, Eb) : (a.sentCompleteSegmentFunction = !0, p(b, Db));
  p(b, a.segmentPrefix);
  f = u(f.toString(16));
  p(b, f);
  p(b, Gb);
  p(b, a.placeholderPrefix);
  p(b, f);
  return t(b, Hb);
}

function fd(a, b) {
  l = new Uint8Array(512);
  n = 0;

  try {
    var c = a.completedRootSegment;

    if (null !== c && 0 === a.pendingRootTasks) {
      hd(a, b, c);
      a.completedRootSegment = null;
      var d = a.responseState.bootstrapChunks;

      for (c = 0; c < d.length - 1; c++) {
        p(b, d[c]);
      }

      c < d.length && t(b, d[c]);
    }

    var f = a.clientRenderedBoundaries,
        e;

    for (e = 0; e < f.length; e++) {
      var g = f[e];
      d = b;
      var h = a.responseState,
          m = g.id,
          q = g.errorDigest,
          r = g.errorMessage,
          v = g.errorComponentStack;
      p(d, h.startInlineScript);
      h.sentClientRenderFunction ? p(d, Nb) : (h.sentClientRenderFunction = !0, p(d, Mb));
      if (null === m) throw Error(k(395));
      p(d, m);
      p(d, Ob);
      if (q || r || v) p(d, Qb), p(d, u(Sb(q || "")));
      if (r || v) p(d, Qb), p(d, u(Sb(r || "")));
      v && (p(d, Qb), p(d, u(Sb(v))));

      if (!t(d, Pb)) {
        a.destination = null;
        e++;
        f.splice(0, e);
        return;
      }
    }

    f.splice(0, e);
    var A = a.completedBoundaries;

    for (e = 0; e < A.length; e++) {
      if (!jd(a, b, A[e])) {
        a.destination = null;
        e++;
        A.splice(0, e);
        return;
      }
    }

    A.splice(0, e);
    ba(b);
    l = new Uint8Array(512);
    n = 0;
    var F = a.partialBoundaries;

    for (e = 0; e < F.length; e++) {
      var G = F[e];

      a: {
        f = a;
        g = b;
        var ma = G.completedSegments;

        for (h = 0; h < ma.length; h++) {
          if (!kd(f, g, G, ma[h])) {
            h++;
            ma.splice(0, h);
            var Fb = !1;
            break a;
          }
        }

        ma.splice(0, h);
        Fb = !0;
      }

      if (!Fb) {
        a.destination = null;
        e++;
        F.splice(0, e);
        return;
      }
    }

    F.splice(0, e);
    var na = a.completedBoundaries;

    for (e = 0; e < na.length; e++) {
      if (!jd(a, b, na[e])) {
        a.destination = null;
        e++;
        na.splice(0, e);
        return;
      }
    }

    na.splice(0, e);
  } finally {
    ba(b), 0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length && b.close();
  }
}

function ld(a, b) {
  try {
    var c = a.abortableTasks;
    c.forEach(function (c) {
      return ed(c, a, b);
    });
    c.clear();
    null !== a.destination && fd(a, a.destination);
  } catch (d) {
    Y(a, d), Vc(a, d);
  }
}

exports.renderToReadableStream = function (a, b) {
  return new Promise(function (c, d) {
    var f,
        e,
        g = new Promise(function (a, b) {
      e = a;
      f = b;
    }),
        h = Rc(a, za(b ? b.identifierPrefix : void 0, b ? b.nonce : void 0, b ? b.bootstrapScriptContent : void 0, b ? b.bootstrapScripts : void 0, b ? b.bootstrapModules : void 0), Aa(b ? b.namespaceURI : void 0), b ? b.progressiveChunkSize : void 0, b ? b.onError : void 0, e, function () {
      var a = new ReadableStream({
        type: "bytes",
        pull: function pull(a) {
          if (1 === h.status) h.status = 2, da(a, h.fatalError);else if (2 !== h.status && null === h.destination) {
            h.destination = a;

            try {
              fd(h, a);
            } catch (A) {
              Y(h, A), Vc(h, A);
            }
          }
        },
        cancel: function cancel() {
          ld(h);
        }
      }, {
        highWaterMark: 0
      });
      a.allReady = g;
      c(a);
    }, function (a) {
      g.catch(function () {});
      d(a);
    }, f);

    if (b && b.signal) {
      var m = b.signal,
          q = function q() {
        ld(h, m.reason);
        m.removeEventListener("abort", q);
      };

      m.addEventListener("abort", q);
    }

    Uc(h);
  });
};

exports.version = "18.2.0";

/***/ }),

/***/ 4463:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var aa = __webpack_require__(2791),
    ca = __webpack_require__(5296);

function p(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var da = new Set(),
    ea = {};

function fa(a, b) {
  ha(a, b);
  ha(a + "Capture", b);
}

function ha(a, b) {
  ea[a] = b;

  for (a = 0; a < b.length; a++) {
    da.add(b[a]);
  }
}

var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
    ja = Object.prototype.hasOwnProperty,
    ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    la = {},
    ma = {};

function oa(a) {
  if (ja.call(ma, a)) return !0;
  if (ja.call(la, a)) return !1;
  if (ka.test(a)) return ma[a] = !0;
  la[a] = !0;
  return !1;
}

function pa(a, b, c, d) {
  if (null !== c && 0 === c.type) return !1;

  switch (typeof b) {
    case "function":
    case "symbol":
      return !0;

    case "boolean":
      if (d) return !1;
      if (null !== c) return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;

    default:
      return !1;
  }
}

function qa(a, b, c, d) {
  if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return !0;
  if (d) return !1;
  if (null !== c) switch (c.type) {
    case 3:
      return !b;

    case 4:
      return !1 === b;

    case 5:
      return isNaN(b);

    case 6:
      return isNaN(b) || 1 > b;
  }
  return !1;
}

function v(a, b, c, d, e, f, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}

var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  z[a] = new v(a, 0, !1, a, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];
  z[b] = new v(b, 1, !1, a[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  z[a] = new v(a, 2, !1, a.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  z[a] = new v(a, 2, !1, a, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  z[a] = new v(a, 3, !1, a.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function (a) {
  z[a] = new v(a, 3, !0, a, null, !1, !1);
});
["capture", "download"].forEach(function (a) {
  z[a] = new v(a, 4, !1, a, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (a) {
  z[a] = new v(a, 6, !1, a, null, !1, !1);
});
["rowSpan", "start"].forEach(function (a) {
  z[a] = new v(a, 5, !1, a.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;

function sa(a) {
  return a[1].toUpperCase();
}

"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (a) {
  z[a] = new v(a, 1, !1, a.toLowerCase(), null, !1, !1);
});
z.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (a) {
  z[a] = new v(a, 1, !1, a.toLowerCase(), null, !0, !0);
});

function ta(a, b, c, d) {
  var e = z.hasOwnProperty(b) ? z[b] : null;
  if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
}

var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    va = Symbol.for("react.element"),
    wa = Symbol.for("react.portal"),
    ya = Symbol.for("react.fragment"),
    za = Symbol.for("react.strict_mode"),
    Aa = Symbol.for("react.profiler"),
    Ba = Symbol.for("react.provider"),
    Ca = Symbol.for("react.context"),
    Da = Symbol.for("react.forward_ref"),
    Ea = Symbol.for("react.suspense"),
    Fa = Symbol.for("react.suspense_list"),
    Ga = Symbol.for("react.memo"),
    Ha = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var Ia = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.cache");
Symbol.for("react.tracing_marker");
var Ja = Symbol.iterator;

function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

var A = Object.assign,
    La;

function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);
    La = b && b[1] || "";
  }
  return "\n" + La + a;
}

var Na = !1;

function Oa(a, b) {
  if (!a || Na) return "";
  Na = !0;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;

  try {
    if (b) {
      if (b = function b() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", {
        set: function set() {
          throw Error();
        }
      }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }

        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }

        a.call(b.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (l) {
        d = l;
      }

      a();
    }
  } catch (l) {
    if (l && d && "string" === typeof l.stack) {
      for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) {
        h--;
      }

      for (; 1 <= g && 0 <= h; g--, h--) {
        if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do {
              if (g--, h--, 0 > h || e[g] !== f[h]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                return k;
              }
            } while (1 <= g && 0 <= h);
          }

          break;
        }
      }
    }
  } finally {
    Na = !1, Error.prepareStackTrace = c;
  }

  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}

function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);

    case 16:
      return Ma("Lazy");

    case 13:
      return Ma("Suspense");

    case 19:
      return Ma("SuspenseList");

    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, !1), a;

    case 11:
      return a = Oa(a.type.render, !1), a;

    case 1:
      return a = Oa(a.type, !0), a;

    default:
      return "";
  }
}

function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;

  switch (a) {
    case ya:
      return "Fragment";

    case wa:
      return "Portal";

    case Aa:
      return "Profiler";

    case za:
      return "StrictMode";

    case Ea:
      return "Suspense";

    case Fa:
      return "SuspenseList";
  }

  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";

    case Ba:
      return (a._context.displayName || "Context") + ".Provider";

    case Da:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;

    case Ga:
      return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";

    case Ha:
      b = a._payload;
      a = a._init;

      try {
        return Qa(a(b));
      } catch (c) {}

  }
  return null;
}

function Ra(a) {
  var b = a.type;

  switch (a.tag) {
    case 24:
      return "Cache";

    case 9:
      return (b.displayName || "Context") + ".Consumer";

    case 10:
      return (b._context.displayName || "Context") + ".Provider";

    case 18:
      return "DehydratedFragment";

    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");

    case 7:
      return "Fragment";

    case 5:
      return b;

    case 4:
      return "Portal";

    case 3:
      return "Root";

    case 6:
      return "Text";

    case 16:
      return Qa(b);

    case 8:
      return b === za ? "StrictMode" : "Mode";

    case 22:
      return "Offscreen";

    case 12:
      return "Profiler";

    case 21:
      return "Scope";

    case 13:
      return "Suspense";

    case 19:
      return "SuspenseList";

    case 25:
      return "TracingMarker";

    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b) return b.displayName || b.name || null;
      if ("string" === typeof b) return b;
  }

  return null;
}

function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;

    case "object":
      return a;

    default:
      return "";
  }
}

function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}

function Ua(a) {
  var b = Ta(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];

  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get,
        f = c.set;
    Object.defineProperty(a, b, {
      configurable: !0,
      get: function get() {
        return e.call(this);
      },
      set: function set(a) {
        d = "" + a;
        f.call(this, a);
      }
    });
    Object.defineProperty(a, b, {
      enumerable: c.enumerable
    });
    return {
      getValue: function getValue() {
        return d;
      },
      setValue: function setValue(a) {
        d = "" + a;
      },
      stopTracking: function stopTracking() {
        a._valueTracker = null;
        delete a[b];
      }
    };
  }
}

function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}

function Wa(a) {
  if (!a) return !1;
  var b = a._valueTracker;
  if (!b) return !0;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), !0) : !1;
}

function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;

  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}

function Ya(a, b) {
  var c = b.checked;
  return A({}, b, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: null != c ? c : a._wrapperState.initialChecked
  });
}

function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue,
      d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = {
    initialChecked: d,
    initialValue: c,
    controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
  };
}

function ab(a, b) {
  b = b.checked;
  null != b && ta(a, "checked", b, !1);
}

function bb(a, b) {
  ab(a, b);
  var c = Sa(b.value),
      d = b.type;
  if (null != c) {
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}

function db(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }

  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}

function cb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}

var eb = Array.isArray;

function fb(a, b, c, d) {
  a = a.options;

  if (b) {
    b = {};

    for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }

    for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + Sa(c);
    b = null;

    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;
        d && (a[e].defaultSelected = !0);
        return;
      }

      null !== b || a[e].disabled || (b = a[e]);
    }

    null !== b && (b.selected = !0);
  }
}

function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
  return A({}, b, {
    value: void 0,
    defaultValue: void 0,
    children: "" + a._wrapperState.initialValue
  });
}

function hb(a, b) {
  var c = b.value;

  if (null == c) {
    c = b.children;
    b = b.defaultValue;

    if (null != c) {
      if (null != b) throw Error(p(92));

      if (eb(c)) {
        if (1 < c.length) throw Error(p(93));
        c = c[0];
      }

      b = c;
    }

    null == b && (b = "");
    c = b;
  }

  a._wrapperState = {
    initialValue: Sa(c)
  };
}

function ib(a, b) {
  var c = Sa(b.value),
      d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}

function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}

function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";

    case "math":
      return "http://www.w3.org/1998/Math/MathML";

    default:
      return "http://www.w3.org/1999/xhtml";
  }
}

function lb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}

var mb,
    nb = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";

    for (b = mb.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }

    for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
});

function ob(a, b) {
  if (b) {
    var c = a.firstChild;

    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }

  a.textContent = b;
}

var pb = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
},
    qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function (a) {
  qb.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b] = pb[a];
  });
});

function rb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
}

function sb(a, b) {
  a = a.style;

  for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"),
          e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}

var tb = A({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});

function ub(a, b) {
  if (b) {
    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));

    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(p(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
    }

    if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
  }
}

function vb(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;

  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;

    default:
      return !0;
  }
}

var wb = null;

function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}

var yb = null,
    zb = null,
    Ab = null;

function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}

function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}

function Fb() {
  if (zb) {
    var a = zb,
        b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b) for (a = 0; a < b.length; a++) {
      Bb(b[a]);
    }
  }
}

function Gb(a, b) {
  return a(b);
}

function Hb() {}

var Ib = !1;

function Jb(a, b, c) {
  if (Ib) return a(b, c);
  Ib = !0;

  try {
    return Gb(a, b, c);
  } finally {
    if (Ib = !1, null !== zb || null !== Ab) Hb(), Fb();
  }
}

function Kb(a, b) {
  var c = a.stateNode;
  if (null === c) return null;
  var d = Db(c);
  if (null === d) return null;
  c = d[b];

  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;

    default:
      a = !1;
  }

  if (a) return null;
  if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
  return c;
}

var Lb = !1;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", {
    get: function get() {
      Lb = !0;
    }
  });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = !1;
}

function Nb(a, b, c, d, e, f, g, h, k) {
  var l = Array.prototype.slice.call(arguments, 3);

  try {
    b.apply(c, l);
  } catch (m) {
    this.onError(m);
  }
}

var Ob = !1,
    Pb = null,
    Qb = !1,
    Rb = null,
    Sb = {
  onError: function onError(a) {
    Ob = !0;
    Pb = a;
  }
};

function Tb(a, b, c, d, e, f, g, h, k) {
  Ob = !1;
  Pb = null;
  Nb.apply(Sb, arguments);
}

function Ub(a, b, c, d, e, f, g, h, k) {
  Tb.apply(this, arguments);

  if (Ob) {
    if (Ob) {
      var l = Pb;
      Ob = !1;
      Pb = null;
    } else throw Error(p(198));

    Qb || (Qb = !0, Rb = l);
  }
}

function Vb(a) {
  var b = a,
      c = a;
  if (a.alternate) for (; b.return;) {
    b = b.return;
  } else {
    a = b;

    do {
      b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
    } while (a);
  }
  return 3 === b.tag ? c : null;
}

function Wb(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b) return b.dehydrated;
  }

  return null;
}

function Xb(a) {
  if (Vb(a) !== a) throw Error(p(188));
}

function Yb(a) {
  var b = a.alternate;

  if (!b) {
    b = Vb(a);
    if (null === b) throw Error(p(188));
    return b !== a ? null : a;
  }

  for (var c = a, d = b;;) {
    var e = c.return;
    if (null === e) break;
    var f = e.alternate;

    if (null === f) {
      d = e.return;

      if (null !== d) {
        c = d;
        continue;
      }

      break;
    }

    if (e.child === f.child) {
      for (f = e.child; f;) {
        if (f === c) return Xb(e), a;
        if (f === d) return Xb(e), b;
        f = f.sibling;
      }

      throw Error(p(188));
    }

    if (c.return !== d.return) c = e, d = f;else {
      for (var g = !1, h = e.child; h;) {
        if (h === c) {
          g = !0;
          c = e;
          d = f;
          break;
        }

        if (h === d) {
          g = !0;
          d = e;
          c = f;
          break;
        }

        h = h.sibling;
      }

      if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;
            c = f;
            d = e;
            break;
          }

          if (h === d) {
            g = !0;
            d = f;
            c = e;
            break;
          }

          h = h.sibling;
        }

        if (!g) throw Error(p(189));
      }
    }
    if (c.alternate !== d) throw Error(p(190));
  }

  if (3 !== c.tag) throw Error(p(188));
  return c.stateNode.current === c ? a : b;
}

function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}

function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;

  for (a = a.child; null !== a;) {
    var b = $b(a);
    if (null !== b) return b;
    a = a.sibling;
  }

  return null;
}

var ac = ca.unstable_scheduleCallback,
    bc = ca.unstable_cancelCallback,
    cc = ca.unstable_shouldYield,
    dc = ca.unstable_requestPaint,
    B = ca.unstable_now,
    ec = ca.unstable_getCurrentPriorityLevel,
    fc = ca.unstable_ImmediatePriority,
    gc = ca.unstable_UserBlockingPriority,
    hc = ca.unstable_NormalPriority,
    ic = ca.unstable_LowPriority,
    jc = ca.unstable_IdlePriority,
    kc = null,
    lc = null;

function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b) {}
}

var oc = Math.clz32 ? Math.clz32 : nc,
    pc = Math.log,
    qc = Math.LN2;

function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}

var rc = 64,
    sc = 4194304;

function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;

    case 2:
      return 2;

    case 4:
      return 4;

    case 8:
      return 8;

    case 16:
      return 16;

    case 32:
      return 32;

    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;

    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;

    case 134217728:
      return 134217728;

    case 268435456:
      return 268435456;

    case 536870912:
      return 536870912;

    case 1073741824:
      return 1073741824;

    default:
      return a;
  }
}

function uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c) return 0;
  var d = 0,
      e = a.suspendedLanes,
      f = a.pingedLanes,
      g = c & 268435455;

  if (0 !== g) {
    var h = g & ~e;
    0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
  } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));

  if (0 === d) return 0;
  if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
  0 !== (d & 4) && (d |= c & 16);
  b = a.entangledLanes;
  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) {
    c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
  }
  return d;
}

function vc(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;

    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5E3;

    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;

    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;

    default:
      return -1;
  }
}

function wc(a, b) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;) {
    var g = 31 - oc(f),
        h = 1 << g,
        k = e[g];

    if (-1 === k) {
      if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
    } else k <= b && (a.expiredLanes |= h);

    f &= ~h;
  }
}

function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}

function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}

function zc(a) {
  for (var b = [], c = 0; 31 > c; c++) {
    b.push(a);
  }

  return b;
}

function Ac(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc(b);
  a[b] = c;
}

function Bc(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d = a.eventTimes;

  for (a = a.expirationTimes; 0 < c;) {
    var e = 31 - oc(c),
        f = 1 << e;
    b[e] = 0;
    d[e] = -1;
    a[e] = -1;
    c &= ~f;
  }
}

function Cc(a, b) {
  var c = a.entangledLanes |= b;

  for (a = a.entanglements; c;) {
    var d = 31 - oc(c),
        e = 1 << d;
    e & b | a[d] & b && (a[d] |= b);
    c &= ~e;
  }
}

var C = 0;

function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}

var Ec,
    Fc,
    Gc,
    Hc,
    Ic,
    Jc = !1,
    Kc = [],
    Lc = null,
    Mc = null,
    Nc = null,
    Oc = new Map(),
    Pc = new Map(),
    Qc = [],
    Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function Sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;

    case "dragenter":
    case "dragleave":
      Mc = null;
      break;

    case "mouseover":
    case "mouseout":
      Nc = null;
      break;

    case "pointerover":
    case "pointerout":
      Oc.delete(b.pointerId);
      break;

    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b.pointerId);
  }
}

function Tc(a, b, c, d, e, f) {
  if (null === a || a.nativeEvent !== f) return a = {
    blockedOn: b,
    domEventName: c,
    eventSystemFlags: d,
    nativeEvent: f,
    targetContainers: [e]
  }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}

function Uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return Lc = Tc(Lc, a, b, c, d, e), !0;

    case "dragenter":
      return Mc = Tc(Mc, a, b, c, d, e), !0;

    case "mouseover":
      return Nc = Tc(Nc, a, b, c, d, e), !0;

    case "pointerover":
      var f = e.pointerId;
      Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
      return !0;

    case "gotpointercapture":
      return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), !0;
  }

  return !1;
}

function Vc(a) {
  var b = Wc(a.target);

  if (null !== b) {
    var c = Vb(b);
    if (null !== c) if (b = c.tag, 13 === b) {
      if (b = Wb(c), null !== b) {
        a.blockedOn = b;
        Ic(a.priority, function () {
          Gc(c);
        });
        return;
      }
    } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
      a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
      return;
    }
  }

  a.blockedOn = null;
}

function Xc(a) {
  if (null !== a.blockedOn) return !1;

  for (var b = a.targetContainers; 0 < b.length;) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);

    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, !1;

    b.shift();
  }

  return !0;
}

function Zc(a, b, c) {
  Xc(a) && c.delete(b);
}

function $c() {
  Jc = !1;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}

function ad(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}

function bd(a) {
  function b(b) {
    return ad(b, a);
  }

  if (0 < Kc.length) {
    ad(Kc[0], a);

    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }

  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b);
  Pc.forEach(b);

  for (c = 0; c < Qc.length; c++) {
    d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  }

  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn);) {
    Vc(c), null === c.blockedOn && Qc.shift();
  }
}

var cd = ua.ReactCurrentBatchConfig,
    dd = !0;

function ed(a, b, c, d) {
  var e = C,
      f = cd.transition;
  cd.transition = null;

  try {
    C = 1, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f;
  }
}

function gd(a, b, c, d) {
  var e = C,
      f = cd.transition;
  cd.transition = null;

  try {
    C = 4, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f;
  }
}

function fd(a, b, c, d) {
  if (dd) {
    var e = Yc(a, b, c, d);
    if (null === e) hd(a, b, d, id, c), Sc(a, d);else if (Uc(e, a, b, c, d)) d.stopPropagation();else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e;) {
        var f = Cb(e);
        null !== f && Ec(f);
        f = Yc(a, b, c, d);
        null === f && hd(a, b, d, id, c);
        if (f === e) break;
        e = f;
      }

      null !== e && d.stopPropagation();
    } else hd(a, b, d, null, c);
  }
}

var id = null;

function Yc(a, b, c, d) {
  id = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a) if (b = Vb(a), null === b) a = null;else if (c = b.tag, 13 === c) {
    a = Wb(b);
    if (null !== a) return a;
    a = null;
  } else if (3 === c) {
    if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
    a = null;
  } else b !== a && (a = null);
  id = a;
  return null;
}

function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;

    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;

    case "message":
      switch (ec()) {
        case fc:
          return 1;

        case gc:
          return 4;

        case hc:
        case ic:
          return 16;

        case jc:
          return 536870912;

        default:
          return 16;
      }

    default:
      return 16;
  }
}

var kd = null,
    ld = null,
    md = null;

function nd() {
  if (md) return md;
  var a,
      b = ld,
      c = b.length,
      d,
      e = "value" in kd ? kd.value : kd.textContent,
      f = e.length;

  for (a = 0; a < c && b[a] === e[a]; a++) {
    ;
  }

  var g = c - a;

  for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {
    ;
  }

  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}

function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}

function pd() {
  return !0;
}

function qd() {
  return !1;
}

function rd(a) {
  function b(b, d, e, f, g) {
    this._reactName = b;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;

    for (var c in a) {
      a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
    }

    this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }

  A(b.prototype, {
    preventDefault: function preventDefault() {
      this.defaultPrevented = !0;
      var a = this.nativeEvent;
      a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
    },
    stopPropagation: function stopPropagation() {
      var a = this.nativeEvent;
      a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
    },
    persist: function persist() {},
    isPersistent: pd
  });
  return b;
}

var sd = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
},
    td = rd(sd),
    ud = A({}, sd, {
  view: 0,
  detail: 0
}),
    vd = rd(ud),
    wd,
    xd,
    yd,
    Ad = A({}, ud, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: zd,
  button: 0,
  buttons: 0,
  relatedTarget: function relatedTarget(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  },
  movementX: function movementX(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  },
  movementY: function movementY(a) {
    return "movementY" in a ? a.movementY : xd;
  }
}),
    Bd = rd(Ad),
    Cd = A({}, Ad, {
  dataTransfer: 0
}),
    Dd = rd(Cd),
    Ed = A({}, ud, {
  relatedTarget: 0
}),
    Fd = rd(Ed),
    Gd = A({}, sd, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}),
    Hd = rd(Gd),
    Id = A({}, sd, {
  clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  }
}),
    Jd = rd(Id),
    Kd = A({}, sd, {
  data: 0
}),
    Ld = rd(Kd),
    Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
},
    Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
},
    Od = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};

function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
}

function zd() {
  return Pd;
}

var Qd = A({}, ud, {
  key: function key(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }

    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  },
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: zd,
  charCode: function charCode(a) {
    return "keypress" === a.type ? od(a) : 0;
  },
  keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  },
  which: function which(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }
}),
    Rd = rd(Qd),
    Sd = A({}, Ad, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
}),
    Td = rd(Sd),
    Ud = A({}, ud, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: zd
}),
    Vd = rd(Ud),
    Wd = A({}, sd, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}),
    Xd = rd(Wd),
    Yd = A({}, Ad, {
  deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}),
    Zd = rd(Yd),
    $d = [9, 13, 27, 32],
    ae = ia && "CompositionEvent" in window,
    be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be,
    de = ia && (!ae || be && 8 < be && 11 >= be),
    ee = String.fromCharCode(32),
    fe = !1;

function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);

    case "keydown":
      return 229 !== b.keyCode;

    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;

    default:
      return !1;
  }
}

function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}

var ie = !1;

function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);

    case "keypress":
      if (32 !== b.which) return null;
      fe = !0;
      return ee;

    case "textInput":
      return a = b.data, a === ee && fe ? null : a;

    default:
      return null;
  }
}

function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;

  switch (a) {
    case "paste":
      return null;

    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;
        if (b.which) return String.fromCharCode(b.which);
      }

      return null;

    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;

    default:
      return null;
  }
}

var le = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};

function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
}

function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
    event: c,
    listeners: b
  }));
}

var pe = null,
    qe = null;

function re(a) {
  se(a, 0);
}

function te(a) {
  var b = ue(a);
  if (Wa(b)) return a;
}

function ve(a, b) {
  if ("change" === a) return b;
}

var we = !1;

if (ia) {
  var xe;

  if (ia) {
    var ye = ("oninput" in document);

    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }

    xe = ye;
  } else xe = !1;

  we = xe && (!document.documentMode || 9 < document.documentMode);
}

function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}

function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    Jb(re, b);
  }
}

function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}

function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}

function Ee(a, b) {
  if ("click" === a) return te(b);
}

function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}

function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}

var He = "function" === typeof Object.is ? Object.is : Ge;

function Ie(a, b) {
  if (He(a, b)) return !0;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
  var c = Object.keys(a),
      d = Object.keys(b);
  if (c.length !== d.length) return !1;

  for (d = 0; d < c.length; d++) {
    var e = c[d];
    if (!ja.call(b, e) || !He(a[e], b[e])) return !1;
  }

  return !0;
}

function Je(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }

  return a;
}

function Ke(a, b) {
  var c = Je(a);
  a = 0;

  for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return {
        node: c,
        offset: b - a
      };
      a = d;
    }

    a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }

        c = c.parentNode;
      }

      c = void 0;
    }

    c = Je(c);
  }
}

function Le(a, b) {
  return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
}

function Me() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = !1;
    }

    if (c) a = b.contentWindow;else break;
    b = Xa(a.document);
  }

  return b;
}

function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}

function Oe(a) {
  var b = Me(),
      c = a.focusedElem,
      d = a.selectionRange;

  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
      a = a.getSelection();
      var e = c.textContent.length,
          f = Math.min(d.start, e);
      d = void 0 === d.end ? f : Math.min(d.end, e);
      !a.extend && f > d && (e = d, d = f, f = e);
      e = Ke(c, f);
      var g = Ke(c, d);
      e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
    }
    b = [];

    for (a = c; a = a.parentNode;) {
      1 === a.nodeType && b.push({
        element: a,
        left: a.scrollLeft,
        top: a.scrollTop
      });
    }

    "function" === typeof c.focus && c.focus();

    for (c = 0; c < b.length; c++) {
      a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
}

var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
    Qe = null,
    Re = null,
    Se = null,
    Te = !1;

function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
    start: d.selectionStart,
    end: d.selectionEnd
  } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
    anchorNode: d.anchorNode,
    anchorOffset: d.anchorOffset,
    focusNode: d.focusNode,
    focusOffset: d.focusOffset
  }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
    event: b,
    listeners: d
  }), b.target = Qe)));
}

function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}

var We = {
  animationend: Ve("Animation", "AnimationEnd"),
  animationiteration: Ve("Animation", "AnimationIteration"),
  animationstart: Ve("Animation", "AnimationStart"),
  transitionend: Ve("Transition", "TransitionEnd")
},
    Xe = {},
    Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);

function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b = We[a],
      c;

  for (c in b) {
    if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
  }

  return a;
}

var $e = Ze("animationend"),
    af = Ze("animationiteration"),
    bf = Ze("animationstart"),
    cf = Ze("transitionend"),
    df = new Map(),
    ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function ff(a, b) {
  df.set(a, b);
  fa(b, [a]);
}

for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf],
      jf = hf.toLowerCase(),
      kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}

ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));

function nf(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b, void 0, a);
  a.currentTarget = null;
}

function se(a, b) {
  b = 0 !== (b & 4);

  for (var c = 0; c < a.length; c++) {
    var d = a[c],
        e = d.event;
    d = d.listeners;

    a: {
      var f = void 0;
      if (b) for (var g = d.length - 1; 0 <= g; g--) {
        var h = d[g],
            k = h.instance,
            l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        nf(e, h, l);
        f = k;
      } else for (g = 0; g < d.length; g++) {
        h = d[g];
        k = h.instance;
        l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        nf(e, h, l);
        f = k;
      }
    }
  }

  if (Qb) throw a = Rb, Qb = !1, Rb = null, a;
}

function D(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b, a, 2, !1), c.add(d));
}

function qf(a, b, c) {
  var d = 0;
  b && (d |= 4);
  pf(c, a, d, b);
}

var rf = "_reactListening" + Math.random().toString(36).slice(2);

function sf(a) {
  if (!a[rf]) {
    a[rf] = !0;
    da.forEach(function (b) {
      "selectionchange" !== b && (mf.has(b) || qf(b, !1, a), qf(b, !0, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
  }
}

function pf(a, b, c, d) {
  switch (jd(b)) {
    case 1:
      var e = ed;
      break;

    case 4:
      e = gd;
      break;

    default:
      e = fd;
  }

  c = e.bind(null, b, c, a);
  e = void 0;
  !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
  d ? void 0 !== e ? a.addEventListener(b, c, {
    capture: !0,
    passive: e
  }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
    passive: e
  }) : a.addEventListener(b, c, !1);
}

function hd(a, b, c, d, e) {
  var f = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
    if (null === d) return;
    var g = d.tag;

    if (3 === g || 4 === g) {
      var h = d.stateNode.containerInfo;
      if (h === e || 8 === h.nodeType && h.parentNode === e) break;
      if (4 === g) for (g = d.return; null !== g;) {
        var k = g.tag;
        if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
        g = g.return;
      }

      for (; null !== h;) {
        g = Wc(h);
        if (null === g) return;
        k = g.tag;

        if (5 === k || 6 === k) {
          d = f = g;
          continue a;
        }

        h = h.parentNode;
      }
    }

    d = d.return;
  }
  Jb(function () {
    var d = f,
        e = xb(c),
        g = [];

    a: {
      var h = df.get(a);

      if (void 0 !== h) {
        var k = td,
            n = a;

        switch (a) {
          case "keypress":
            if (0 === od(c)) break a;

          case "keydown":
          case "keyup":
            k = Rd;
            break;

          case "focusin":
            n = "focus";
            k = Fd;
            break;

          case "focusout":
            n = "blur";
            k = Fd;
            break;

          case "beforeblur":
          case "afterblur":
            k = Fd;
            break;

          case "click":
            if (2 === c.button) break a;

          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k = Bd;
            break;

          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k = Dd;
            break;

          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k = Vd;
            break;

          case $e:
          case af:
          case bf:
            k = Hd;
            break;

          case cf:
            k = Xd;
            break;

          case "scroll":
            k = vd;
            break;

          case "wheel":
            k = Zd;
            break;

          case "copy":
          case "cut":
          case "paste":
            k = Jd;
            break;

          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k = Td;
        }

        var t = 0 !== (b & 4),
            J = !t && "scroll" === a,
            x = t ? null !== h ? h + "Capture" : null : h;
        t = [];

        for (var w = d, u; null !== w;) {
          u = w;
          var F = u.stateNode;
          5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
          if (J) break;
          w = w.return;
        }

        0 < t.length && (h = new k(h, n, null, c, e), g.push({
          event: h,
          listeners: t
        }));
      }
    }

    if (0 === (b & 7)) {
      a: {
        h = "mouseover" === a || "pointerover" === a;
        k = "mouseout" === a || "pointerout" === a;
        if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;

        if (k || h) {
          h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;

          if (k) {
            if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
          } else k = null, n = d;

          if (k !== n) {
            t = Bd;
            F = "onMouseLeave";
            x = "onMouseEnter";
            w = "mouse";
            if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
            J = null == k ? h : ue(k);
            u = null == n ? h : ue(n);
            h = new t(F, w + "leave", k, c, e);
            h.target = J;
            h.relatedTarget = u;
            F = null;
            Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, F = t);
            J = F;
            if (k && n) b: {
              t = k;
              x = n;
              w = 0;

              for (u = t; u; u = vf(u)) {
                w++;
              }

              u = 0;

              for (F = x; F; F = vf(F)) {
                u++;
              }

              for (; 0 < w - u;) {
                t = vf(t), w--;
              }

              for (; 0 < u - w;) {
                x = vf(x), u--;
              }

              for (; w--;) {
                if (t === x || null !== x && t === x.alternate) break b;
                t = vf(t);
                x = vf(x);
              }

              t = null;
            } else t = null;
            null !== k && wf(g, h, k, t, !1);
            null !== n && null !== J && wf(g, J, n, t, !0);
          }
        }
      }

      a: {
        h = d ? ue(d) : window;
        k = h.nodeName && h.nodeName.toLowerCase();
        if ("select" === k || "input" === k && "file" === h.type) var na = ve;else if (me(h)) {
          if (we) na = Fe;else {
            na = De;
            var xa = Ce;
          }
        } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee);

        if (na && (na = na(a, d))) {
          ne(g, na, c, e);
          break a;
        }

        xa && xa(a, h, d);
        "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
      }

      xa = d ? ue(d) : window;

      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d, Se = null;
          break;

        case "focusout":
          Se = Re = Qe = null;
          break;

        case "mousedown":
          Te = !0;
          break;

        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = !1;
          Ue(g, c, e);
          break;

        case "selectionchange":
          if (Pe) break;

        case "keydown":
        case "keyup":
          Ue(g, c, e);
      }

      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;

          case "compositionend":
            ba = "onCompositionEnd";
            break b;

          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }

        ba = void 0;
      } else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), xa = oe(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), g.push({
        event: ba,
        listeners: xa
      }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
        event: e,
        listeners: d
      }), e.data = $a);
    }

    se(g, b);
  });
}

function tf(a, b, c) {
  return {
    instance: a,
    listener: b,
    currentTarget: c
  };
}

function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a;) {
    var e = a,
        f = e.stateNode;
    5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
    a = a.return;
  }

  return d;
}

function vf(a) {
  if (null === a) return null;

  do {
    a = a.return;
  } while (a && 5 !== a.tag);

  return a ? a : null;
}

function wf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; null !== c && c !== d;) {
    var h = c,
        k = h.alternate,
        l = h.stateNode;
    if (null !== k && k === d) break;
    5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
    c = c.return;
  }

  0 !== g.length && a.push({
    event: b,
    listeners: g
  });
}

var xf = /\r\n?/g,
    yf = /\u0000|\uFFFD/g;

function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}

function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c) throw Error(p(425));
}

function Bf() {}

var Cf = null,
    Df = null;

function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}

var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
    Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
    Hf = "function" === typeof Promise ? Promise : void 0,
    Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function (a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;

function If(a) {
  setTimeout(function () {
    throw a;
  });
}

function Kf(a, b) {
  var c = b,
      d = 0;

  do {
    var e = c.nextSibling;
    a.removeChild(c);
    if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
      if (0 === d) {
        a.removeChild(e);
        bd(b);
        return;
      }

      d--;
    } else "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e;
  } while (c);

  bd(b);
}

function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b) break;

    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b) break;
      if ("/$" === b) return null;
    }
  }

  return a;
}

function Mf(a) {
  a = a.previousSibling;

  for (var b = 0; a;) {
    if (8 === a.nodeType) {
      var c = a.data;

      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;
        b--;
      } else "/$" === c && b++;
    }

    a = a.previousSibling;
  }

  return null;
}

var Nf = Math.random().toString(36).slice(2),
    Of = "__reactFiber$" + Nf,
    Pf = "__reactProps$" + Nf,
    uf = "__reactContainer$" + Nf,
    of = "__reactEvents$" + Nf,
    Qf = "__reactListeners$" + Nf,
    Rf = "__reactHandles$" + Nf;

function Wc(a) {
  var b = a[Of];
  if (b) return b;

  for (var c = a.parentNode; c;) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a;) {
        if (c = a[Of]) return c;
        a = Mf(a);
      }
      return b;
    }

    a = c;
    c = a.parentNode;
  }

  return null;
}

function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}

function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p(33));
}

function Db(a) {
  return a[Pf] || null;
}

var Sf = [],
    Tf = -1;

function Uf(a) {
  return {
    current: a
  };
}

function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}

function G(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}

var Vf = {},
    H = Uf(Vf),
    Wf = Uf(!1),
    Xf = Vf;

function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c) return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e = {},
      f;

  for (f in c) {
    e[f] = b[f];
  }

  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}

function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}

function $f() {
  E(Wf);
  E(H);
}

function ag(a, b, c) {
  if (H.current !== Vf) throw Error(p(168));
  G(H, b);
  G(Wf, c);
}

function bg(a, b, c) {
  var d = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d.getChildContext) return c;
  d = d.getChildContext();

  for (var e in d) {
    if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
  }

  return A({}, c, d);
}

function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return !0;
}

function dg(a, b, c) {
  var d = a.stateNode;
  if (!d) throw Error(p(169));
  c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}

var eg = null,
    fg = !1,
    gg = !1;

function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}

function ig(a) {
  fg = !0;
  hg(a);
}

function jg() {
  if (!gg && null !== eg) {
    gg = !0;
    var a = 0,
        b = C;

    try {
      var c = eg;

      for (C = 1; a < c.length; a++) {
        var d = c[a];

        do {
          d = d(!0);
        } while (null !== d);
      }

      eg = null;
      fg = !1;
    } catch (e) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
    } finally {
      C = b, gg = !1;
    }
  }

  return null;
}

var kg = [],
    lg = 0,
    mg = null,
    ng = 0,
    og = [],
    pg = 0,
    qg = null,
    rg = 1,
    sg = "";

function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}

function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e = 32 - oc(d) - 1;
  d &= ~(1 << e);
  c += 1;
  var f = 32 - oc(b) + e;

  if (30 < f) {
    var g = e - e % 5;
    f = (d & (1 << g) - 1).toString(32);
    d >>= g;
    e -= g;
    rg = 1 << 32 - oc(b) + e | c << e | d;
    sg = f + a;
  } else rg = 1 << f | c << e | d, sg = a;
}

function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}

function wg(a) {
  for (; a === mg;) {
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  }

  for (; a === qg;) {
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
}

var xg = null,
    yg = null,
    I = !1,
    zg = null;

function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}

function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;

    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, !0) : !1;

    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
        id: rg,
        overflow: sg
      } : null, a.memoizedState = {
        dehydrated: b,
        treeContext: c,
        retryLane: 1073741824
      }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, !0) : !1;

    default:
      return !1;
  }
}

function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}

function Eg(a) {
  if (I) {
    var b = yg;

    if (b) {
      var c = b;

      if (!Cg(a, b)) {
        if (Dg(a)) throw Error(p(418));
        b = Lf(c.nextSibling);
        var d = xg;
        b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = !1, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p(418));
      a.flags = a.flags & -4097 | 2;
      I = !1;
      xg = a;
    }
  }
}

function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) {
    a = a.return;
  }

  xg = a;
}

function Gg(a) {
  if (a !== xg) return !1;
  if (!I) return Fg(a), I = !0, !1;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));

  if (b && (b = yg)) {
    if (Dg(a)) throw Hg(), Error(p(418));

    for (; b;) {
      Ag(a, b), b = Lf(b.nextSibling);
    }
  }

  Fg(a);

  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p(317));

    a: {
      a = a.nextSibling;

      for (b = 0; a;) {
        if (8 === a.nodeType) {
          var c = a.data;

          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }

            b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }

        a = a.nextSibling;
      }

      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;

  return !0;
}

function Hg() {
  for (var a = yg; a;) {
    a = Lf(a.nextSibling);
  }
}

function Ig() {
  yg = xg = null;
  I = !1;
}

function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}

var Kg = ua.ReactCurrentBatchConfig;

function Lg(a, b) {
  if (a && a.defaultProps) {
    b = A({}, b);
    a = a.defaultProps;

    for (var c in a) {
      void 0 === b[c] && (b[c] = a[c]);
    }

    return b;
  }

  return b;
}

var Mg = Uf(null),
    Ng = null,
    Og = null,
    Pg = null;

function Qg() {
  Pg = Og = Ng = null;
}

function Rg(a) {
  var b = Mg.current;
  E(Mg);
  a._currentValue = b;
}

function Sg(a, b, c) {
  for (; null !== a;) {
    var d = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
    if (a === c) break;
    a = a.return;
  }
}

function Tg(a, b) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = !0), a.firstContext = null);
}

function Vg(a) {
  var b = a._currentValue;
  if (Pg !== a) if (a = {
    context: a,
    memoizedValue: b,
    next: null
  }, null === Og) {
    if (null === Ng) throw Error(p(308));
    Og = a;
    Ng.dependencies = {
      lanes: 0,
      firstContext: a
    };
  } else Og = Og.next = a;
  return b;
}

var Wg = null;

function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}

function Yg(a, b, c, d) {
  var e = b.interleaved;
  null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
  b.interleaved = c;
  return Zg(a, d);
}

function Zg(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;

  for (a = a.return; null !== a;) {
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  }

  return 3 === c.tag ? c.stateNode : null;
}

var $g = !1;

function ah(a) {
  a.updateQueue = {
    baseState: a.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: 0
    },
    effects: null
  };
}

function bh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = {
    baseState: a.baseState,
    firstBaseUpdate: a.firstBaseUpdate,
    lastBaseUpdate: a.lastBaseUpdate,
    shared: a.shared,
    effects: a.effects
  });
}

function ch(a, b) {
  return {
    eventTime: a,
    lane: b,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  };
}

function dh(a, b, c) {
  var d = a.updateQueue;
  if (null === d) return null;
  d = d.shared;

  if (0 !== (K & 2)) {
    var e = d.pending;
    null === e ? b.next = b : (b.next = e.next, e.next = b);
    d.pending = b;
    return Zg(a, c);
  }

  e = d.interleaved;
  null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
  d.interleaved = b;
  return Zg(a, c);
}

function eh(a, b, c) {
  b = b.updateQueue;

  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}

function fh(a, b) {
  var c = a.updateQueue,
      d = a.alternate;

  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null,
        f = null;
    c = c.firstBaseUpdate;

    if (null !== c) {
      do {
        var g = {
          eventTime: c.eventTime,
          lane: c.lane,
          tag: c.tag,
          payload: c.payload,
          callback: c.callback,
          next: null
        };
        null === f ? e = f = g : f = f.next = g;
        c = c.next;
      } while (null !== c);

      null === f ? e = f = b : f = f.next = b;
    } else e = f = b;

    c = {
      baseState: d.baseState,
      firstBaseUpdate: e,
      lastBaseUpdate: f,
      shared: d.shared,
      effects: d.effects
    };
    a.updateQueue = c;
    return;
  }

  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}

function gh(a, b, c, d) {
  var e = a.updateQueue;
  $g = !1;
  var f = e.firstBaseUpdate,
      g = e.lastBaseUpdate,
      h = e.shared.pending;

  if (null !== h) {
    e.shared.pending = null;
    var k = h,
        l = k.next;
    k.next = null;
    null === g ? f = l : g.next = l;
    g = k;
    var m = a.alternate;
    null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
  }

  if (null !== f) {
    var q = e.baseState;
    g = 0;
    m = l = k = null;
    h = f;

    do {
      var r = h.lane,
          y = h.eventTime;

      if ((d & r) === r) {
        null !== m && (m = m.next = {
          eventTime: y,
          lane: 0,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null
        });

        a: {
          var n = a,
              t = h;
          r = b;
          y = c;

          switch (t.tag) {
            case 1:
              n = t.payload;

              if ("function" === typeof n) {
                q = n.call(y, q, r);
                break a;
              }

              q = n;
              break a;

            case 3:
              n.flags = n.flags & -65537 | 128;

            case 0:
              n = t.payload;
              r = "function" === typeof n ? n.call(y, q, r) : n;
              if (null === r || void 0 === r) break a;
              q = A({}, q, r);
              break a;

            case 2:
              $g = !0;
          }
        }

        null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
      } else y = {
        eventTime: y,
        lane: r,
        tag: h.tag,
        payload: h.payload,
        callback: h.callback,
        next: null
      }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;

      h = h.next;
      if (null === h) if (h = e.shared.pending, null === h) break;else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
    } while (1);

    null === m && (k = q);
    e.baseState = k;
    e.firstBaseUpdate = l;
    e.lastBaseUpdate = m;
    b = e.shared.interleaved;

    if (null !== b) {
      e = b;

      do {
        g |= e.lane, e = e.next;
      } while (e !== b);
    } else null === f && (e.shared.lanes = 0);

    hh |= g;
    a.lanes = g;
    a.memoizedState = q;
  }
}

function ih(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b],
        e = d.callback;

    if (null !== e) {
      d.callback = null;
      d = c;
      if ("function" !== typeof e) throw Error(p(191, e));
      e.call(d);
    }
  }
}

var jh = new aa.Component().refs;

function kh(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : A({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}

var nh = {
  isMounted: function isMounted(a) {
    return (a = a._reactInternals) ? Vb(a) === a : !1;
  },
  enqueueSetState: function enqueueSetState(a, b, c) {
    a = a._reactInternals;
    var d = L(),
        e = lh(a),
        f = ch(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = dh(a, f, e);
    null !== b && (mh(b, a, e, d), eh(b, a, e));
  },
  enqueueReplaceState: function enqueueReplaceState(a, b, c) {
    a = a._reactInternals;
    var d = L(),
        e = lh(a),
        f = ch(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = dh(a, f, e);
    null !== b && (mh(b, a, e, d), eh(b, a, e));
  },
  enqueueForceUpdate: function enqueueForceUpdate(a, b) {
    a = a._reactInternals;
    var c = L(),
        d = lh(a),
        e = ch(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = dh(a, e, d);
    null !== b && (mh(b, a, d, c), eh(b, a, d));
  }
};

function oh(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : !0;
}

function ph(a, b, c) {
  var d = !1,
      e = Vf;
  var f = b.contextType;
  "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
  b = new b(c, f);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = nh;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}

function qh(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && nh.enqueueReplaceState(b, b.state, null);
}

function rh(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = jh;
  ah(a);
  var f = b.contextType;
  "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4194308);
}

function sh(a, b, c) {
  a = c.ref;

  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;

      if (c) {
        if (1 !== c.tag) throw Error(p(309));
        var d = c.stateNode;
      }

      if (!d) throw Error(p(147, a));
      var e = d,
          f = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;

      b = function b(a) {
        var b = e.refs;
        b === jh && (b = e.refs = {});
        null === a ? delete b[f] : b[f] = a;
      };

      b._stringRef = f;
      return b;
    }

    if ("string" !== typeof a) throw Error(p(284));
    if (!c._owner) throw Error(p(290, a));
  }

  return a;
}

function th(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}

function uh(a) {
  var b = a._init;
  return b(a._payload);
}

function vh(a) {
  function b(b, c) {
    if (a) {
      var d = b.deletions;
      null === d ? (b.deletions = [c], b.flags |= 16) : d.push(c);
    }
  }

  function c(c, d) {
    if (!a) return null;

    for (; null !== d;) {
      b(c, d), d = d.sibling;
    }

    return null;
  }

  function d(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }

    return a;
  }

  function e(a, b) {
    a = wh(a, b);
    a.index = 0;
    a.sibling = null;
    return a;
  }

  function f(b, c, d) {
    b.index = d;
    if (!a) return b.flags |= 1048576, c;
    d = b.alternate;
    if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
    b.flags |= 2;
    return c;
  }

  function g(b) {
    a && null === b.alternate && (b.flags |= 2);
    return b;
  }

  function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = xh(c, a.mode, d), b.return = a, b;
    b = e(b, c);
    b.return = a;
    return b;
  }

  function k(a, b, c, d) {
    var f = c.type;
    if (f === ya) return m(a, b, c.props.children, d, c.key);
    if (null !== b && (b.elementType === f || "object" === typeof f && null !== f && f.$$typeof === Ha && uh(f) === b.type)) return d = e(b, c.props), d.ref = sh(a, b, c), d.return = a, d;
    d = yh(c.type, c.key, c.props, null, a.mode, d);
    d.ref = sh(a, b, c);
    d.return = a;
    return d;
  }

  function l(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = zh(c, a.mode, d), b.return = a, b;
    b = e(b, c.children || []);
    b.return = a;
    return b;
  }

  function m(a, b, c, d, f) {
    if (null === b || 7 !== b.tag) return b = Ah(c, a.mode, d, f), b.return = a, b;
    b = e(b, c);
    b.return = a;
    return b;
  }

  function q(a, b, c) {
    if ("string" === typeof b && "" !== b || "number" === typeof b) return b = xh("" + b, a.mode, c), b.return = a, b;

    if ("object" === typeof b && null !== b) {
      switch (b.$$typeof) {
        case va:
          return c = yh(b.type, b.key, b.props, null, a.mode, c), c.ref = sh(a, null, b), c.return = a, c;

        case wa:
          return b = zh(b, a.mode, c), b.return = a, b;

        case Ha:
          var d = b._init;
          return q(a, d(b._payload), c);
      }

      if (eb(b) || Ka(b)) return b = Ah(b, a.mode, c, null), b.return = a, b;
      th(a, b);
    }

    return null;
  }

  function r(a, b, c, d) {
    var e = null !== b ? b.key : null;
    if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);

    if ("object" === typeof c && null !== c) {
      switch (c.$$typeof) {
        case va:
          return c.key === e ? k(a, b, c, d) : null;

        case wa:
          return c.key === e ? l(a, b, c, d) : null;

        case Ha:
          return e = c._init, r(a, b, e(c._payload), d);
      }

      if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
      th(a, c);
    }

    return null;
  }

  function y(a, b, c, d, e) {
    if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);

    if ("object" === typeof d && null !== d) {
      switch (d.$$typeof) {
        case va:
          return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);

        case wa:
          return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);

        case Ha:
          var f = d._init;
          return y(a, b, c, f(d._payload), e);
      }

      if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
      th(b, d);
    }

    return null;
  }

  function n(e, g, h, k) {
    for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
      u.index > w ? (x = u, u = null) : x = u.sibling;
      var n = r(e, u, h[w], k);

      if (null === n) {
        null === u && (u = x);
        break;
      }

      a && u && null === n.alternate && b(e, u);
      g = f(n, g, w);
      null === m ? l = n : m.sibling = n;
      m = n;
      u = x;
    }

    if (w === h.length) return c(e, u), I && tg(e, w), l;

    if (null === u) {
      for (; w < h.length; w++) {
        u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, m = u);
      }

      I && tg(e, w);
      return l;
    }

    for (u = d(e, u); w < h.length; w++) {
      x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
    }

    a && u.forEach(function (a) {
      return b(e, a);
    });
    I && tg(e, w);
    return l;
  }

  function t(e, g, h, k) {
    var l = Ka(h);
    if ("function" !== typeof l) throw Error(p(150));
    h = l.call(h);
    if (null == h) throw Error(p(151));

    for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, n = h.next()) {
      m.index > w ? (x = m, m = null) : x = m.sibling;
      var t = r(e, m, n.value, k);

      if (null === t) {
        null === m && (m = x);
        break;
      }

      a && m && null === t.alternate && b(e, m);
      g = f(t, g, w);
      null === u ? l = t : u.sibling = t;
      u = t;
      m = x;
    }

    if (n.done) return c(e, m), I && tg(e, w), l;

    if (null === m) {
      for (; !n.done; w++, n = h.next()) {
        n = q(e, n.value, k), null !== n && (g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
      }

      I && tg(e, w);
      return l;
    }

    for (m = d(e, m); !n.done; w++, n = h.next()) {
      n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
    }

    a && m.forEach(function (a) {
      return b(e, a);
    });
    I && tg(e, w);
    return l;
  }

  function J(a, d, f, h) {
    "object" === typeof f && null !== f && f.type === ya && null === f.key && (f = f.props.children);

    if ("object" === typeof f && null !== f) {
      switch (f.$$typeof) {
        case va:
          a: {
            for (var k = f.key, l = d; null !== l;) {
              if (l.key === k) {
                k = f.type;

                if (k === ya) {
                  if (7 === l.tag) {
                    c(a, l.sibling);
                    d = e(l, f.props.children);
                    d.return = a;
                    a = d;
                    break a;
                  }
                } else if (l.elementType === k || "object" === typeof k && null !== k && k.$$typeof === Ha && uh(k) === l.type) {
                  c(a, l.sibling);
                  d = e(l, f.props);
                  d.ref = sh(a, l, f);
                  d.return = a;
                  a = d;
                  break a;
                }

                c(a, l);
                break;
              } else b(a, l);

              l = l.sibling;
            }

            f.type === ya ? (d = Ah(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = yh(f.type, f.key, f.props, null, a.mode, h), h.ref = sh(a, d, f), h.return = a, a = h);
          }

          return g(a);

        case wa:
          a: {
            for (l = f.key; null !== d;) {
              if (d.key === l) {
                if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                  c(a, d.sibling);
                  d = e(d, f.children || []);
                  d.return = a;
                  a = d;
                  break a;
                } else {
                  c(a, d);
                  break;
                }
              } else b(a, d);
              d = d.sibling;
            }

            d = zh(f, a.mode, h);
            d.return = a;
            a = d;
          }

          return g(a);

        case Ha:
          return l = f._init, J(a, d, l(f._payload), h);
      }

      if (eb(f)) return n(a, d, f, h);
      if (Ka(f)) return t(a, d, f, h);
      th(a, f);
    }

    return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = xh(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
  }

  return J;
}

var Bh = vh(!0),
    Ch = vh(!1),
    Dh = {},
    Eh = Uf(Dh),
    Fh = Uf(Dh),
    Gh = Uf(Dh);

function Hh(a) {
  if (a === Dh) throw Error(p(174));
  return a;
}

function Ih(a, b) {
  G(Gh, b);
  G(Fh, a);
  G(Eh, Dh);
  a = b.nodeType;

  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
      break;

    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
  }

  E(Eh);
  G(Eh, b);
}

function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}

function Kh(a) {
  Hh(Gh.current);
  var b = Hh(Eh.current);
  var c = lb(b, a.type);
  b !== c && (G(Fh, a), G(Eh, c));
}

function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}

var M = Uf(0);

function Mh(a) {
  for (var b = a; null !== b;) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128)) return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }

    if (b === a) break;

    for (; null === b.sibling;) {
      if (null === b.return || b.return === a) return null;
      b = b.return;
    }

    b.sibling.return = b.return;
    b = b.sibling;
  }

  return null;
}

var Nh = [];

function Oh() {
  for (var a = 0; a < Nh.length; a++) {
    Nh[a]._workInProgressVersionPrimary = null;
  }

  Nh.length = 0;
}

var Ph = ua.ReactCurrentDispatcher,
    Qh = ua.ReactCurrentBatchConfig,
    Rh = 0,
    N = null,
    O = null,
    P = null,
    Sh = !1,
    Th = !1,
    Uh = 0,
    Vh = 0;

function Q() {
  throw Error(p(321));
}

function Wh(a, b) {
  if (null === b) return !1;

  for (var c = 0; c < b.length && c < a.length; c++) {
    if (!He(a[c], b[c])) return !1;
  }

  return !0;
}

function Xh(a, b, c, d, e, f) {
  Rh = f;
  N = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c(d, e);

  if (Th) {
    f = 0;

    do {
      Th = !1;
      Uh = 0;
      if (25 <= f) throw Error(p(301));
      f += 1;
      P = O = null;
      b.updateQueue = null;
      Ph.current = $h;
      a = c(d, e);
    } while (Th);
  }

  Ph.current = ai;
  b = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = !1;
  if (b) throw Error(p(300));
  return a;
}

function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}

function ci() {
  var a = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}

function di() {
  if (null === O) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = O.next;

  var b = null === P ? N.memoizedState : P.next;
  if (null !== b) P = b, O = a;else {
    if (null === a) throw Error(p(310));
    O = a;
    a = {
      memoizedState: O.memoizedState,
      baseState: O.baseState,
      baseQueue: O.baseQueue,
      queue: O.queue,
      next: null
    };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}

function ei(a, b) {
  return "function" === typeof b ? b(a) : b;
}

function fi(a) {
  var b = di(),
      c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = O,
      e = d.baseQueue,
      f = c.pending;

  if (null !== f) {
    if (null !== e) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }

    d.baseQueue = e = f;
    c.pending = null;
  }

  if (null !== e) {
    f = e.next;
    d = d.baseState;
    var h = g = null,
        k = null,
        l = f;

    do {
      var m = l.lane;
      if ((Rh & m) === m) null !== k && (k = k.next = {
        lane: 0,
        action: l.action,
        hasEagerState: l.hasEagerState,
        eagerState: l.eagerState,
        next: null
      }), d = l.hasEagerState ? l.eagerState : a(d, l.action);else {
        var q = {
          lane: m,
          action: l.action,
          hasEagerState: l.hasEagerState,
          eagerState: l.eagerState,
          next: null
        };
        null === k ? (h = k = q, g = d) : k = k.next = q;
        N.lanes |= m;
        hh |= m;
      }
      l = l.next;
    } while (null !== l && l !== f);

    null === k ? g = d : k.next = h;
    He(d, b.memoizedState) || (Ug = !0);
    b.memoizedState = d;
    b.baseState = g;
    b.baseQueue = k;
    c.lastRenderedState = d;
  }

  a = c.interleaved;

  if (null !== a) {
    e = a;

    do {
      f = e.lane, N.lanes |= f, hh |= f, e = e.next;
    } while (e !== a);
  } else null === e && (c.lanes = 0);

  return [b.memoizedState, c.dispatch];
}

function gi(a) {
  var b = di(),
      c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch,
      e = c.pending,
      f = b.memoizedState;

  if (null !== e) {
    c.pending = null;
    var g = e = e.next;

    do {
      f = a(f, g.action), g = g.next;
    } while (g !== e);

    He(f, b.memoizedState) || (Ug = !0);
    b.memoizedState = f;
    null === b.baseQueue && (b.baseState = f);
    c.lastRenderedState = f;
  }

  return [f, d];
}

function hi() {}

function ii(a, b) {
  var c = N,
      d = di(),
      e = b(),
      f = !He(d.memoizedState, e);
  f && (d.memoizedState = e, Ug = !0);
  d = d.queue;
  ji(ki.bind(null, c, d, a), [a]);

  if (d.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
    c.flags |= 2048;
    li(9, mi.bind(null, c, d, e, b), void 0, null);
    if (null === R) throw Error(p(349));
    0 !== (Rh & 30) || ni(c, b, e);
  }

  return e;
}

function ni(a, b, c) {
  a.flags |= 16384;
  a = {
    getSnapshot: b,
    value: c
  };
  b = N.updateQueue;
  null === b ? (b = {
    lastEffect: null,
    stores: null
  }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}

function mi(a, b, c, d) {
  b.value = c;
  b.getSnapshot = d;
  oi(b) && pi(a);
}

function ki(a, b, c) {
  return c(function () {
    oi(b) && pi(a);
  });
}

function oi(a) {
  var b = a.getSnapshot;
  a = a.value;

  try {
    var c = b();
    return !He(a, c);
  } catch (d) {
    return !0;
  }
}

function pi(a) {
  var b = Zg(a, 1);
  null !== b && mh(b, a, 1, -1);
}

function qi(a) {
  var b = ci();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = {
    pending: null,
    interleaved: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: ei,
    lastRenderedState: a
  };
  b.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b.memoizedState, a];
}

function li(a, b, c, d) {
  a = {
    tag: a,
    create: b,
    destroy: c,
    deps: d,
    next: null
  };
  b = N.updateQueue;
  null === b ? (b = {
    lastEffect: null,
    stores: null
  }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}

function si() {
  return di().memoizedState;
}

function ti(a, b, c, d) {
  var e = ci();
  N.flags |= a;
  e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
}

function ui(a, b, c, d) {
  var e = di();
  d = void 0 === d ? null : d;
  var f = void 0;

  if (null !== O) {
    var g = O.memoizedState;
    f = g.destroy;

    if (null !== d && Wh(d, g.deps)) {
      e.memoizedState = li(b, c, f, d);
      return;
    }
  }

  N.flags |= a;
  e.memoizedState = li(1 | b, c, f, d);
}

function vi(a, b) {
  return ti(8390656, 8, a, b);
}

function ji(a, b) {
  return ui(2048, 8, a, b);
}

function wi(a, b) {
  return ui(4, 2, a, b);
}

function xi(a, b) {
  return ui(4, 4, a, b);
}

function yi(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function () {
    b(null);
  };
  if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
    b.current = null;
  };
}

function zi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b, a), c);
}

function Ai() {}

function Bi(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1])) return d[0];
  c.memoizedState = [a, b];
  return a;
}

function Ci(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1])) return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}

function Di(a, b, c) {
  if (0 === (Rh & 21)) return a.baseState && (a.baseState = !1, Ug = !0), a.memoizedState = c;
  He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = !0);
  return b;
}

function Ei(a, b) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(!0);
  var d = Qh.transition;
  Qh.transition = {};

  try {
    a(!1), b();
  } finally {
    C = c, Qh.transition = d;
  }
}

function Fi() {
  return di().memoizedState;
}

function Gi(a, b, c) {
  var d = lh(a);
  c = {
    lane: d,
    action: c,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (Hi(a)) Ii(b, c);else if (c = Yg(a, b, c, d), null !== c) {
    var e = L();
    mh(c, a, d, e);
    Ji(c, b, d);
  }
}

function ri(a, b, c) {
  var d = lh(a),
      e = {
    lane: d,
    action: c,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (Hi(a)) Ii(b, e);else {
    var f = a.alternate;
    if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
      var g = b.lastRenderedState,
          h = f(g, c);
      e.hasEagerState = !0;
      e.eagerState = h;

      if (He(h, g)) {
        var k = b.interleaved;
        null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
        b.interleaved = e;
        return;
      }
    } catch (l) {} finally {}
    c = Yg(a, b, e, d);
    null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
  }
}

function Hi(a) {
  var b = a.alternate;
  return a === N || null !== b && b === N;
}

function Ii(a, b) {
  Th = Sh = !0;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}

function Ji(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}

var ai = {
  readContext: Vg,
  useCallback: Q,
  useContext: Q,
  useEffect: Q,
  useImperativeHandle: Q,
  useInsertionEffect: Q,
  useLayoutEffect: Q,
  useMemo: Q,
  useReducer: Q,
  useRef: Q,
  useState: Q,
  useDebugValue: Q,
  useDeferredValue: Q,
  useTransition: Q,
  useMutableSource: Q,
  useSyncExternalStore: Q,
  useId: Q,
  unstable_isNewReconciler: !1
},
    Yh = {
  readContext: Vg,
  useCallback: function useCallback(a, b) {
    ci().memoizedState = [a, void 0 === b ? null : b];
    return a;
  },
  useContext: Vg,
  useEffect: vi,
  useImperativeHandle: function useImperativeHandle(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return ti(4194308, 4, yi.bind(null, b, a), c);
  },
  useLayoutEffect: function useLayoutEffect(a, b) {
    return ti(4194308, 4, a, b);
  },
  useInsertionEffect: function useInsertionEffect(a, b) {
    return ti(4, 2, a, b);
  },
  useMemo: function useMemo(a, b) {
    var c = ci();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  },
  useReducer: function useReducer(a, b, c) {
    var d = ci();
    b = void 0 !== c ? c(b) : b;
    d.memoizedState = d.baseState = b;
    a = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: a,
      lastRenderedState: b
    };
    d.queue = a;
    a = a.dispatch = Gi.bind(null, N, a);
    return [d.memoizedState, a];
  },
  useRef: function useRef(a) {
    var b = ci();
    a = {
      current: a
    };
    return b.memoizedState = a;
  },
  useState: qi,
  useDebugValue: Ai,
  useDeferredValue: function useDeferredValue(a) {
    return ci().memoizedState = a;
  },
  useTransition: function useTransition() {
    var a = qi(!1),
        b = a[0];
    a = Ei.bind(null, a[1]);
    ci().memoizedState = a;
    return [b, a];
  },
  useMutableSource: function useMutableSource() {},
  useSyncExternalStore: function useSyncExternalStore(a, b, c) {
    var d = N,
        e = ci();

    if (I) {
      if (void 0 === c) throw Error(p(407));
      c = c();
    } else {
      c = b();
      if (null === R) throw Error(p(349));
      0 !== (Rh & 30) || ni(d, b, c);
    }

    e.memoizedState = c;
    var f = {
      value: c,
      getSnapshot: b
    };
    e.queue = f;
    vi(ki.bind(null, d, f, a), [a]);
    d.flags |= 2048;
    li(9, mi.bind(null, d, f, c, b), void 0, null);
    return c;
  },
  useId: function useId() {
    var a = ci(),
        b = R.identifierPrefix;

    if (I) {
      var c = sg;
      var d = rg;
      c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Uh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";

    return a.memoizedState = b;
  },
  unstable_isNewReconciler: !1
},
    Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function useState() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function useDeferredValue(a) {
    var b = di();
    return Di(b, O.memoizedState, a);
  },
  useTransition: function useTransition() {
    var a = fi(ei)[0],
        b = di().memoizedState;
    return [a, b];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: !1
},
    $h = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: gi,
  useRef: si,
  useState: function useState() {
    return gi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function useDeferredValue(a) {
    var b = di();
    return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
  },
  useTransition: function useTransition() {
    var a = gi(ei)[0],
        b = di().memoizedState;
    return [a, b];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: !1
};

function Ki(a, b) {
  try {
    var c = "",
        d = b;

    do {
      c += Pa(d), d = d.return;
    } while (d);

    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }

  return {
    value: a,
    source: b,
    stack: e,
    digest: null
  };
}

function Li(a, b, c) {
  return {
    value: a,
    source: null,
    stack: null != c ? c : null,
    digest: null != b ? b : null
  };
}

function Mi(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function () {
      throw c;
    });
  }
}

var Ni = "function" === typeof WeakMap ? WeakMap : Map;

function Oi(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  c.payload = {
    element: null
  };
  var d = b.value;

  c.callback = function () {
    Pi || (Pi = !0, Qi = d);
    Mi(a, b);
  };

  return c;
}

function Ri(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;

  if ("function" === typeof d) {
    var e = b.value;

    c.payload = function () {
      return d(e);
    };

    c.callback = function () {
      Mi(a, b);
    };
  }

  var f = a.stateNode;
  null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
    Mi(a, b);
    "function" !== typeof d && (null === Si ? Si = new Set([this]) : Si.add(this));
    var c = b.stack;
    this.componentDidCatch(b.value, {
      componentStack: null !== c ? c : ""
    });
  });
  return c;
}

function Ti(a, b, c) {
  var d = a.pingCache;

  if (null === d) {
    d = a.pingCache = new Ni();
    var e = new Set();
    d.set(b, e);
  } else e = d.get(b), void 0 === e && (e = new Set(), d.set(b, e));

  e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
}

function Vi(a) {
  do {
    var b;
    if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? !0 : !1 : !0;
    if (b) return a;
    a = a.return;
  } while (null !== a);

  return null;
}

function Wi(a, b, c, d, e) {
  if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e;
  return a;
}

var Xi = ua.ReactCurrentOwner,
    Ug = !1;

function Yi(a, b, c, d) {
  b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
}

function Zi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  Tg(b, e);
  d = Xh(a, b, c, d, f, e);
  c = bi();
  if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && c && vg(b);
  b.flags |= 1;
  Yi(a, b, d, e);
  return b.child;
}

function aj(a, b, c, d, e) {
  if (null === a) {
    var f = c.type;
    if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d, e);
    a = yh(c.type, null, d, b, b.mode, e);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }

  f = a.child;

  if (0 === (a.lanes & e)) {
    var g = f.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
  }

  b.flags |= 1;
  a = wh(f, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}

function cj(a, b, c, d, e) {
  if (null !== a) {
    var f = a.memoizedProps;
    if (Ie(f, d) && a.ref === b.ref) if (Ug = !1, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = !0);else return b.lanes = a.lanes, $i(a, b, e);
  }

  return dj(a, b, c, d, e);
}

function ej(a, b, c) {
  var d = b.pendingProps,
      e = d.children,
      f = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode) {
    if (0 === (b.mode & 1)) b.memoizedState = {
      baseLanes: 0,
      cachePool: null,
      transitions: null
    }, G(fj, gj), gj |= c;else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
        baseLanes: a,
        cachePool: null,
        transitions: null
      }, b.updateQueue = null, G(fj, gj), gj |= a, null;
      b.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      };
      d = null !== f ? f.baseLanes : c;
      G(fj, gj);
      gj |= d;
    }
  } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
  Yi(a, b, e, c);
  return b.child;
}

function hj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
}

function dj(a, b, c, d, e) {
  var f = Zf(c) ? Xf : H.current;
  f = Yf(b, f);
  Tg(b, e);
  c = Xh(a, b, c, d, f, e);
  d = bi();
  if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && d && vg(b);
  b.flags |= 1;
  Yi(a, b, c, e);
  return b.child;
}

function ij(a, b, c, d, e) {
  if (Zf(c)) {
    var f = !0;
    cg(b);
  } else f = !1;

  Tg(b, e);
  if (null === b.stateNode) jj(a, b), ph(b, c, d), rh(b, c, d, e), d = !0;else if (null === a) {
    var g = b.stateNode,
        h = b.memoizedProps;
    g.props = h;
    var k = g.context,
        l = c.contextType;
    "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
    var m = c.getDerivedStateFromProps,
        q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
    q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l);
    $g = !1;
    var r = b.memoizedState;
    g.state = r;
    gh(b, d, g, e);
    k = b.memoizedState;
    h !== d || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = !1);
  } else {
    g = b.stateNode;
    bh(a, b);
    h = b.memoizedProps;
    l = b.type === b.elementType ? h : Lg(b.type, h);
    g.props = l;
    q = b.pendingProps;
    r = g.context;
    k = c.contextType;
    "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
    var y = c.getDerivedStateFromProps;
    (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k);
    $g = !1;
    r = b.memoizedState;
    g.state = r;
    gh(b, d, g, e);
    var n = b.memoizedState;
    h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || !1) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = !1);
  }
  return kj(a, b, c, d, f, e);
}

function kj(a, b, c, d, e, f) {
  hj(a, b);
  var g = 0 !== (b.flags & 128);
  if (!d && !g) return e && dg(b, c, !1), $i(a, b, f);
  d = b.stateNode;
  Xi.current = b;
  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
  b.memoizedState = d.state;
  e && dg(b, c, !0);
  return b.child;
}

function lj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1);
  Ih(a, b.containerInfo);
}

function mj(a, b, c, d, e) {
  Ig();
  Jg(e);
  b.flags |= 256;
  Yi(a, b, c, d);
  return b.child;
}

var nj = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};

function oj(a) {
  return {
    baseLanes: a,
    cachePool: null,
    transitions: null
  };
}

function pj(a, b, c) {
  var d = b.pendingProps,
      e = M.current,
      f = !1,
      g = 0 !== (b.flags & 128),
      h;
  (h = g) || (h = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
  if (h) f = !0, b.flags &= -129;else if (null === a || null !== a.memoizedState) e |= 1;
  G(M, e & 1);

  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g = d.children;
    a = d.fallback;
    return f ? (d = b.mode, f = b.child, g = {
      mode: "hidden",
      children: g
    }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d, 0, null), a = Ah(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
  }

  e = a.memoizedState;
  if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d, h, e, c);

  if (f) {
    f = d.fallback;
    g = b.mode;
    e = a.child;
    h = e.sibling;
    var k = {
      mode: "hidden",
      children: d.children
    };
    0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = wh(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
    null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
    f.return = b;
    d.return = b;
    d.sibling = f;
    b.child = d;
    d = f;
    f = b.child;
    g = a.child.memoizedState;
    g = null === g ? oj(c) : {
      baseLanes: g.baseLanes | c,
      cachePool: null,
      transitions: g.transitions
    };
    f.memoizedState = g;
    f.childLanes = a.childLanes & ~c;
    b.memoizedState = nj;
    return d;
  }

  f = a.child;
  a = f.sibling;
  d = wh(f, {
    mode: "visible",
    children: d.children
  });
  0 === (b.mode & 1) && (d.lanes = c);
  d.return = b;
  d.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d;
  b.memoizedState = null;
  return d;
}

function rj(a, b) {
  b = qj({
    mode: "visible",
    children: b
  }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}

function tj(a, b, c, d) {
  null !== d && Jg(d);
  Bh(b, a.child, null, c);
  a = rj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}

function sj(a, b, c, d, e, f, g) {
  if (c) {
    if (b.flags & 256) return b.flags &= -257, d = Li(Error(p(422))), tj(a, b, g, d);
    if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
    f = d.fallback;
    e = b.mode;
    d = qj({
      mode: "visible",
      children: d.children
    }, e, 0, null);
    f = Ah(f, e, g, null);
    f.flags |= 2;
    d.return = b;
    f.return = b;
    d.sibling = f;
    b.child = d;
    0 !== (b.mode & 1) && Bh(b, a.child, null, g);
    b.child.memoizedState = oj(g);
    b.memoizedState = nj;
    return f;
  }

  if (0 === (b.mode & 1)) return tj(a, b, g, null);

  if ("$!" === e.data) {
    d = e.nextSibling && e.nextSibling.dataset;
    if (d) var h = d.dgst;
    d = h;
    f = Error(p(419));
    d = Li(f, d, void 0);
    return tj(a, b, g, d);
  }

  h = 0 !== (g & a.childLanes);

  if (Ug || h) {
    d = R;

    if (null !== d) {
      switch (g & -g) {
        case 4:
          e = 2;
          break;

        case 16:
          e = 8;
          break;

        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e = 32;
          break;

        case 536870912:
          e = 268435456;
          break;

        default:
          e = 0;
      }

      e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
      0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d, a, e, -1));
    }

    uj();
    d = Li(Error(p(421)));
    return tj(a, b, g, d);
  }

  if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
  a = f.treeContext;
  yg = Lf(e.nextSibling);
  xg = b;
  I = !0;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = rj(b, d.children);
  b.flags |= 4096;
  return b;
}

function wj(a, b, c) {
  a.lanes |= b;
  var d = a.alternate;
  null !== d && (d.lanes |= b);
  Sg(a.return, b, c);
}

function xj(a, b, c, d, e) {
  var f = a.memoizedState;
  null === f ? a.memoizedState = {
    isBackwards: b,
    rendering: null,
    renderingStartTime: 0,
    last: d,
    tail: c,
    tailMode: e
  } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
}

function yj(a, b, c) {
  var d = b.pendingProps,
      e = d.revealOrder,
      f = d.tail;
  Yi(a, b, d.children, c);
  d = M.current;
  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a;) {
      if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);else if (19 === a.tag) wj(a, c, b);else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b) break a;

      for (; null === a.sibling;) {
        if (null === a.return || a.return === b) break a;
        a = a.return;
      }

      a.sibling.return = a.return;
      a = a.sibling;
    }
    d &= 1;
  }
  G(M, d);
  if (0 === (b.mode & 1)) b.memoizedState = null;else switch (e) {
    case "forwards":
      c = b.child;

      for (e = null; null !== c;) {
        a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
      }

      c = e;
      null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
      xj(b, !1, e, c, f);
      break;

    case "backwards":
      c = null;
      e = b.child;

      for (b.child = null; null !== e;) {
        a = e.alternate;

        if (null !== a && null === Mh(a)) {
          b.child = e;
          break;
        }

        a = e.sibling;
        e.sibling = c;
        c = e;
        e = a;
      }

      xj(b, !0, c, null, f);
      break;

    case "together":
      xj(b, !1, null, null, void 0);
      break;

    default:
      b.memoizedState = null;
  }
  return b.child;
}

function jj(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}

function $i(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  hh |= b.lanes;
  if (0 === (c & b.childLanes)) return null;
  if (null !== a && b.child !== a.child) throw Error(p(153));

  if (null !== b.child) {
    a = b.child;
    c = wh(a, a.pendingProps);
    b.child = c;

    for (c.return = b; null !== a.sibling;) {
      a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
    }

    c.sibling = null;
  }

  return b.child;
}

function zj(a, b, c) {
  switch (b.tag) {
    case 3:
      lj(b);
      Ig();
      break;

    case 5:
      Kh(b);
      break;

    case 1:
      Zf(b.type) && cg(b);
      break;

    case 4:
      Ih(b, b.stateNode.containerInfo);
      break;

    case 10:
      var d = b.type._context,
          e = b.memoizedProps.value;
      G(Mg, d._currentValue);
      d._currentValue = e;
      break;

    case 13:
      d = b.memoizedState;

      if (null !== d) {
        if (null !== d.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
        G(M, M.current & 1);
        a = $i(a, b, c);
        return null !== a ? a.sibling : null;
      }

      G(M, M.current & 1);
      break;

    case 19:
      d = 0 !== (c & b.childLanes);

      if (0 !== (a.flags & 128)) {
        if (d) return yj(a, b, c);
        b.flags |= 128;
      }

      e = b.memoizedState;
      null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
      G(M, M.current);
      if (d) break;else return null;

    case 22:
    case 23:
      return b.lanes = 0, ej(a, b, c);
  }

  return $i(a, b, c);
}

var Aj, Bj, Cj, Dj;

Aj = function Aj(a, b) {
  for (var c = b.child; null !== c;) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b) break;

    for (; null === c.sibling;) {
      if (null === c.return || c.return === b) return;
      c = c.return;
    }

    c.sibling.return = c.return;
    c = c.sibling;
  }
};

Bj = function Bj() {};

Cj = function Cj(a, b, c, d) {
  var e = a.memoizedProps;

  if (e !== d) {
    a = b.stateNode;
    Hh(Eh.current);
    var f = null;

    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;

      case "select":
        e = A({}, e, {
          value: void 0
        });
        d = A({}, d, {
          value: void 0
        });
        f = [];
        break;

      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;

      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }

    ub(c, d);
    var g;
    c = null;

    for (l in e) {
      if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];

        for (g in h) {
          h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        }
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
    }

    for (l in d) {
      var k = d[l];
      h = null != e ? e[l] : void 0;
      if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
        if (h) {
          for (g in h) {
            !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          }

          for (g in k) {
            k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          }
        } else c || (f || (f = []), f.push(l, c)), c = k;
      } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
    }

    c && (f = f || []).push("style", c);
    var l = f;
    if (b.updateQueue = l) b.flags |= 4;
  }
};

Dj = function Dj(a, b, c, d) {
  c !== d && (b.flags |= 4);
};

function Ej(a, b) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b = a.tail;

      for (var c = null; null !== b;) {
        null !== b.alternate && (c = b), b = b.sibling;
      }

      null === c ? a.tail = null : c.sibling = null;
      break;

    case "collapsed":
      c = a.tail;

      for (var d = null; null !== c;) {
        null !== c.alternate && (d = c), c = c.sibling;
      }

      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
  }
}

function S(a) {
  var b = null !== a.alternate && a.alternate.child === a.child,
      c = 0,
      d = 0;
  if (b) for (var e = a.child; null !== e;) {
    c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
  } else for (e = a.child; null !== e;) {
    c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
  }
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b;
}

function Fj(a, b, c) {
  var d = b.pendingProps;
  wg(b);

  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b), null;

    case 1:
      return Zf(b.type) && $f(), S(b), null;

    case 3:
      d = b.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b);
      S(b);
      return null;

    case 5:
      Lh(b);
      var e = Hh(Gh.current);
      c = b.type;
      if (null !== a && null != b.stateNode) Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);else {
        if (!d) {
          if (null === b.stateNode) throw Error(p(166));
          S(b);
          return null;
        }

        a = Hh(Eh.current);

        if (Gg(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[Of] = b;
          d[Pf] = f;
          a = 0 !== (b.mode & 1);

          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;

            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;

            case "video":
            case "audio":
              for (e = 0; e < lf.length; e++) {
                D(lf[e], d);
              }

              break;

            case "source":
              D("error", d);
              break;

            case "img":
            case "image":
            case "link":
              D("error", d);
              D("load", d);
              break;

            case "details":
              D("toggle", d);
              break;

            case "input":
              Za(d, f);
              D("invalid", d);
              break;

            case "select":
              d._wrapperState = {
                wasMultiple: !!f.multiple
              };
              D("invalid", d);
              break;

            case "textarea":
              hb(d, f), D("invalid", d);
          }

          ub(c, f);
          e = null;

          for (var g in f) {
            if (f.hasOwnProperty(g)) {
              var h = f[g];
              "children" === g ? "string" === typeof h ? d.textContent !== h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
            }
          }

          switch (c) {
            case "input":
              Va(d);
              db(d, f, !0);
              break;

            case "textarea":
              Va(d);
              jb(d);
              break;

            case "select":
            case "option":
              break;

            default:
              "function" === typeof f.onClick && (d.onclick = Bf);
          }

          d = e;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
            is: d.is
          }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d;
          Aj(a, b, !1, !1);
          b.stateNode = a;

          a: {
            g = vb(c, d);

            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e = d;
                break;

              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e = d;
                break;

              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) {
                  D(lf[e], a);
                }

                e = d;
                break;

              case "source":
                D("error", a);
                e = d;
                break;

              case "img":
              case "image":
              case "link":
                D("error", a);
                D("load", a);
                e = d;
                break;

              case "details":
                D("toggle", a);
                e = d;
                break;

              case "input":
                Za(a, d);
                e = Ya(a, d);
                D("invalid", a);
                break;

              case "option":
                e = d;
                break;

              case "select":
                a._wrapperState = {
                  wasMultiple: !!d.multiple
                };
                e = A({}, d, {
                  value: void 0
                });
                D("invalid", a);
                break;

              case "textarea":
                hb(a, d);
                e = gb(a, d);
                D("invalid", a);
                break;

              default:
                e = d;
            }

            ub(c, e);
            h = e;

            for (f in h) {
              if (h.hasOwnProperty(f)) {
                var k = h[f];
                "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
              }
            }

            switch (c) {
              case "input":
                Va(a);
                db(a, d, !1);
                break;

              case "textarea":
                Va(a);
                jb(a);
                break;

              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;

              case "select":
                a.multiple = !!d.multiple;
                f = d.value;
                null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
                break;

              default:
                "function" === typeof e.onClick && (a.onclick = Bf);
            }

            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;

              case "img":
                d = !0;
                break a;

              default:
                d = !1;
            }
          }

          d && (b.flags |= 4);
        }

        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S(b);
      return null;

    case 6:
      if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
        c = Hh(Gh.current);
        Hh(Eh.current);

        if (Gg(b)) {
          d = b.stateNode;
          c = b.memoizedProps;
          d[Of] = b;
          if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
            case 3:
              Af(d.nodeValue, c, 0 !== (a.mode & 1));
              break;

            case 5:
              !0 !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
          }
          f && (b.flags |= 4);
        } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
      }
      S(b);
      return null;

    case 13:
      E(M);
      d = b.memoizedState;

      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = !1;else if (f = Gg(b), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f) throw Error(p(318));
            f = b.memoizedState;
            f = null !== f ? f.dehydrated : null;
            if (!f) throw Error(p(317));
            f[Of] = b;
          } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;

          S(b);
          f = !1;
        } else null !== zg && (Gj(zg), zg = null), f = !0;
        if (!f) return b.flags & 65536 ? b : null;
      }

      if (0 !== (b.flags & 128)) return b.lanes = c, b;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b.updateQueue && (b.flags |= 4);
      S(b);
      return null;

    case 4:
      return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;

    case 10:
      return Rg(b.type._context), S(b), null;

    case 17:
      return Zf(b.type) && $f(), S(b), null;

    case 19:
      E(M);
      f = b.memoizedState;
      if (null === f) return S(b), null;
      d = 0 !== (b.flags & 128);
      g = f.rendering;
      if (null === g) {
        if (d) Ej(f, !1);else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a;) {
            g = Mh(a);

            if (null !== g) {
              b.flags |= 128;
              Ej(f, !1);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;

              for (c = b.child; null !== c;) {
                f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                  lanes: a.lanes,
                  firstContext: a.firstContext
                }), c = c.sibling;
              }

              G(M, M.current & 1 | 2);
              return b.child;
            }

            a = a.sibling;
          }
          null !== f.tail && B() > Hj && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
        }
      } else {
        if (!d) if (a = Mh(g), null !== a) {
          if (b.flags |= 128, d = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, !0), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
        } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
        f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
      }
      if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
      S(b);
      return null;

    case 22:
    case 23:
      return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;

    case 24:
      return null;

    case 25:
      return null;
  }

  throw Error(p(156, b.tag));
}

function Jj(a, b) {
  wg(b);

  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;

    case 3:
      return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;

    case 5:
      return Lh(b), null;

    case 13:
      E(M);
      a = b.memoizedState;

      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate) throw Error(p(340));
        Ig();
      }

      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;

    case 19:
      return E(M), null;

    case 4:
      return Jh(), null;

    case 10:
      return Rg(b.type._context), null;

    case 22:
    case 23:
      return Ij(), null;

    case 24:
      return null;

    default:
      return null;
  }
}

var Kj = !1,
    U = !1,
    Lj = "function" === typeof WeakSet ? WeakSet : Set,
    V = null;

function Mj(a, b) {
  var c = a.ref;
  if (null !== c) if ("function" === typeof c) try {
    c(null);
  } catch (d) {
    W(a, b, d);
  } else c.current = null;
}

function Nj(a, b, c) {
  try {
    c();
  } catch (d) {
    W(a, b, d);
  }
}

var Oj = !1;

function Pj(a, b) {
  Cf = dd;
  a = Me();

  if (Ne(a)) {
    if ("selectionStart" in a) var c = {
      start: a.selectionStart,
      end: a.selectionEnd
    };else a: {
      c = (c = a.ownerDocument) && c.defaultView || window;
      var d = c.getSelection && c.getSelection();

      if (d && 0 !== d.rangeCount) {
        c = d.anchorNode;
        var e = d.anchorOffset,
            f = d.focusNode;
        d = d.focusOffset;

        try {
          c.nodeType, f.nodeType;
        } catch (F) {
          c = null;
          break a;
        }

        var g = 0,
            h = -1,
            k = -1,
            l = 0,
            m = 0,
            q = a,
            r = null;

        b: for (;;) {
          for (var y;;) {
            q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
            q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
            3 === q.nodeType && (g += q.nodeValue.length);
            if (null === (y = q.firstChild)) break;
            r = q;
            q = y;
          }

          for (;;) {
            if (q === a) break b;
            r === c && ++l === e && (h = g);
            r === f && ++m === d && (k = g);
            if (null !== (y = q.nextSibling)) break;
            q = r;
            r = q.parentNode;
          }

          q = y;
        }

        c = -1 === h || -1 === k ? null : {
          start: h,
          end: k
        };
      } else c = null;
    }
    c = c || {
      start: 0,
      end: 0
    };
  } else c = null;

  Df = {
    focusedElem: a,
    selectionRange: c
  };
  dd = !1;

  for (V = b; null !== V;) {
    if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;else for (; null !== V;) {
      b = V;

      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;

          case 1:
            if (null !== n) {
              var t = n.memoizedProps,
                  J = n.memoizedState,
                  x = b.stateNode,
                  w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
              x.__reactInternalSnapshotBeforeUpdate = w;
            }

            break;

          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;

          case 5:
          case 6:
          case 4:
          case 17:
            break;

          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }

      a = b.sibling;

      if (null !== a) {
        a.return = b.return;
        V = a;
        break;
      }

      V = b.return;
    }
  }

  n = Oj;
  Oj = !1;
  return n;
}

function Qj(a, b, c) {
  var d = b.updateQueue;
  d = null !== d ? d.lastEffect : null;

  if (null !== d) {
    var e = d = d.next;

    do {
      if ((e.tag & a) === a) {
        var f = e.destroy;
        e.destroy = void 0;
        void 0 !== f && Nj(b, c, f);
      }

      e = e.next;
    } while (e !== d);
  }
}

function Rj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;

  if (null !== b) {
    var c = b = b.next;

    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }

      c = c.next;
    } while (c !== b);
  }
}

function Sj(a) {
  var b = a.ref;

  if (null !== b) {
    var c = a.stateNode;

    switch (a.tag) {
      case 5:
        a = c;
        break;

      default:
        a = c;
    }

    "function" === typeof b ? b(a) : b.current = a;
  }
}

function Tj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Tj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}

function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}

function Vj(a) {
  a: for (;;) {
    for (; null === a.sibling;) {
      if (null === a.return || Uj(a.return)) return null;
      a = a.return;
    }

    a.sibling.return = a.return;

    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;else a.child.return = a, a = a.child;
    }

    if (!(a.flags & 2)) return a.stateNode;
  }
}

function Wj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a;) {
    Wj(a, b, c), a = a.sibling;
  }
}

function Xj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a;) {
    Xj(a, b, c), a = a.sibling;
  }
}

var X = null,
    Yj = !1;

function Zj(a, b, c) {
  for (c = c.child; null !== c;) {
    ak(a, b, c), c = c.sibling;
  }
}

function ak(a, b, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c);
  } catch (h) {}

  switch (c.tag) {
    case 5:
      U || Mj(c, b);

    case 6:
      var d = X,
          e = Yj;
      X = null;
      Zj(a, b, c);
      X = d;
      Yj = e;
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
      break;

    case 18:
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
      break;

    case 4:
      d = X;
      e = Yj;
      X = c.stateNode.containerInfo;
      Yj = !0;
      Zj(a, b, c);
      X = d;
      Yj = e;
      break;

    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e = d = d.next;

        do {
          var f = e,
              g = f.destroy;
          f = f.tag;
          void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
          e = e.next;
        } while (e !== d);
      }

      Zj(a, b, c);
      break;

    case 1:
      if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
      } catch (h) {
        W(c, b, h);
      }
      Zj(a, b, c);
      break;

    case 21:
      Zj(a, b, c);
      break;

    case 22:
      c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
      break;

    default:
      Zj(a, b, c);
  }
}

function bk(a) {
  var b = a.updateQueue;

  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Lj());
    b.forEach(function (b) {
      var d = ck.bind(null, a, b);
      c.has(b) || (c.add(b), b.then(d, d));
    });
  }
}

function dk(a, b) {
  var c = b.deletions;
  if (null !== c) for (var d = 0; d < c.length; d++) {
    var e = c[d];

    try {
      var f = a,
          g = b,
          h = g;

      a: for (; null !== h;) {
        switch (h.tag) {
          case 5:
            X = h.stateNode;
            Yj = !1;
            break a;

          case 3:
            X = h.stateNode.containerInfo;
            Yj = !0;
            break a;

          case 4:
            X = h.stateNode.containerInfo;
            Yj = !0;
            break a;
        }

        h = h.return;
      }

      if (null === X) throw Error(p(160));
      ak(f, g, e);
      X = null;
      Yj = !1;
      var k = e.alternate;
      null !== k && (k.return = null);
      e.return = null;
    } catch (l) {
      W(e, b, l);
    }
  }
  if (b.subtreeFlags & 12854) for (b = b.child; null !== b;) {
    ek(b, a), b = b.sibling;
  }
}

function ek(a, b) {
  var c = a.alternate,
      d = a.flags;

  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b, a);
      fk(a);

      if (d & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t) {
          W(a, a.return, t);
        }

        try {
          Qj(5, a, a.return);
        } catch (t) {
          W(a, a.return, t);
        }
      }

      break;

    case 1:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      break;

    case 5:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);

      if (a.flags & 32) {
        var e = a.stateNode;

        try {
          ob(e, "");
        } catch (t) {
          W(a, a.return, t);
        }
      }

      if (d & 4 && (e = a.stateNode, null != e)) {
        var f = a.memoizedProps,
            g = null !== c ? c.memoizedProps : f,
            h = a.type,
            k = a.updateQueue;
        a.updateQueue = null;
        if (null !== k) try {
          "input" === h && "radio" === f.type && null != f.name && ab(e, f);
          vb(h, g);
          var l = vb(h, f);

          for (g = 0; g < k.length; g += 2) {
            var m = k[g],
                q = k[g + 1];
            "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
          }

          switch (h) {
            case "input":
              bb(e, f);
              break;

            case "textarea":
              ib(e, f);
              break;

            case "select":
              var r = e._wrapperState.wasMultiple;
              e._wrapperState.wasMultiple = !!f.multiple;
              var y = f.value;
              null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
          }

          e[Pf] = f;
        } catch (t) {
          W(a, a.return, t);
        }
      }

      break;

    case 6:
      dk(b, a);
      fk(a);

      if (d & 4) {
        if (null === a.stateNode) throw Error(p(162));
        e = a.stateNode;
        f = a.memoizedProps;

        try {
          e.nodeValue = f;
        } catch (t) {
          W(a, a.return, t);
        }
      }

      break;

    case 3:
      dk(b, a);
      fk(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
        bd(b.containerInfo);
      } catch (t) {
        W(a, a.return, t);
      }
      break;

    case 4:
      dk(b, a);
      fk(a);
      break;

    case 13:
      dk(b, a);
      fk(a);
      e = a.child;
      e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
      d & 4 && bk(a);
      break;

    case 22:
      m = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
      fk(a);

      if (d & 8192) {
        l = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m;) {
          for (q = V = m; null !== V;) {
            r = V;
            y = r.child;

            switch (r.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Qj(4, r, r.return);
                break;

              case 1:
                Mj(r, r.return);
                var n = r.stateNode;

                if ("function" === typeof n.componentWillUnmount) {
                  d = r;
                  c = r.return;

                  try {
                    b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                  } catch (t) {
                    W(d, c, t);
                  }
                }

                break;

              case 5:
                Mj(r, r.return);
                break;

              case 22:
                if (null !== r.memoizedState) {
                  hk(q);
                  continue;
                }

            }

            null !== y ? (y.return = r, V = y) : hk(q);
          }

          m = m.sibling;
        }

        a: for (m = null, q = a;;) {
          if (5 === q.tag) {
            if (null === m) {
              m = q;

              try {
                e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
              } catch (t) {
                W(a, a.return, t);
              }
            }
          } else if (6 === q.tag) {
            if (null === m) try {
              q.stateNode.nodeValue = l ? "" : q.memoizedProps;
            } catch (t) {
              W(a, a.return, t);
            }
          } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
            q.child.return = q;
            q = q.child;
            continue;
          }

          if (q === a) break a;

          for (; null === q.sibling;) {
            if (null === q.return || q.return === a) break a;
            m === q && (m = null);
            q = q.return;
          }

          m === q && (m = null);
          q.sibling.return = q.return;
          q = q.sibling;
        }
      }

      break;

    case 19:
      dk(b, a);
      fk(a);
      d & 4 && bk(a);
      break;

    case 21:
      break;

    default:
      dk(b, a), fk(a);
  }
}

function fk(a) {
  var b = a.flags;

  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c;) {
          if (Uj(c)) {
            var d = c;
            break a;
          }

          c = c.return;
        }

        throw Error(p(160));
      }

      switch (d.tag) {
        case 5:
          var e = d.stateNode;
          d.flags & 32 && (ob(e, ""), d.flags &= -33);
          var f = Vj(a);
          Xj(a, f, e);
          break;

        case 3:
        case 4:
          var g = d.stateNode.containerInfo,
              h = Vj(a);
          Wj(a, h, g);
          break;

        default:
          throw Error(p(161));
      }
    } catch (k) {
      W(a, a.return, k);
    }

    a.flags &= -3;
  }

  b & 4096 && (a.flags &= -4097);
}

function ik(a, b, c) {
  V = a;
  jk(a, b, c);
}

function jk(a, b, c) {
  for (var d = 0 !== (a.mode & 1); null !== V;) {
    var e = V,
        f = e.child;

    if (22 === e.tag && d) {
      var g = null !== e.memoizedState || Kj;

      if (!g) {
        var h = e.alternate,
            k = null !== h && null !== h.memoizedState || U;
        h = Kj;
        var l = U;
        Kj = g;
        if ((U = k) && !l) for (V = e; null !== V;) {
          g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
        }

        for (; null !== f;) {
          V = f, jk(f, b, c), f = f.sibling;
        }

        V = e;
        Kj = h;
        U = l;
      }

      lk(a, b, c);
    } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a, b, c);
  }
}

function lk(a) {
  for (; null !== V;) {
    var b = V;

    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;

      try {
        if (0 !== (b.flags & 8772)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            U || Rj(5, b);
            break;

          case 1:
            var d = b.stateNode;
            if (b.flags & 4 && !U) if (null === c) d.componentDidMount();else {
              var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
              d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
            }
            var f = b.updateQueue;
            null !== f && ih(b, f, d);
            break;

          case 3:
            var g = b.updateQueue;

            if (null !== g) {
              c = null;
              if (null !== b.child) switch (b.child.tag) {
                case 5:
                  c = b.child.stateNode;
                  break;

                case 1:
                  c = b.child.stateNode;
              }
              ih(b, g, c);
            }

            break;

          case 5:
            var h = b.stateNode;

            if (null === c && b.flags & 4) {
              c = h;
              var k = b.memoizedProps;

              switch (b.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k.autoFocus && c.focus();
                  break;

                case "img":
                  k.src && (c.src = k.src);
              }
            }

            break;

          case 6:
            break;

          case 4:
            break;

          case 12:
            break;

          case 13:
            if (null === b.memoizedState) {
              var l = b.alternate;

              if (null !== l) {
                var m = l.memoizedState;

                if (null !== m) {
                  var q = m.dehydrated;
                  null !== q && bd(q);
                }
              }
            }

            break;

          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;

          default:
            throw Error(p(163));
        }
        U || b.flags & 512 && Sj(b);
      } catch (r) {
        W(b, b.return, r);
      }
    }

    if (b === a) {
      V = null;
      break;
    }

    c = b.sibling;

    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }

    V = b.return;
  }
}

function hk(a) {
  for (; null !== V;) {
    var b = V;

    if (b === a) {
      V = null;
      break;
    }

    var c = b.sibling;

    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }

    V = b.return;
  }
}

function kk(a) {
  for (; null !== V;) {
    var b = V;

    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;

          try {
            Rj(4, b);
          } catch (k) {
            W(b, c, k);
          }

          break;

        case 1:
          var d = b.stateNode;

          if ("function" === typeof d.componentDidMount) {
            var e = b.return;

            try {
              d.componentDidMount();
            } catch (k) {
              W(b, e, k);
            }
          }

          var f = b.return;

          try {
            Sj(b);
          } catch (k) {
            W(b, f, k);
          }

          break;

        case 5:
          var g = b.return;

          try {
            Sj(b);
          } catch (k) {
            W(b, g, k);
          }

      }
    } catch (k) {
      W(b, b.return, k);
    }

    if (b === a) {
      V = null;
      break;
    }

    var h = b.sibling;

    if (null !== h) {
      h.return = b.return;
      V = h;
      break;
    }

    V = b.return;
  }
}

var mk = Math.ceil,
    nk = ua.ReactCurrentDispatcher,
    ok = ua.ReactCurrentOwner,
    pk = ua.ReactCurrentBatchConfig,
    K = 0,
    R = null,
    Y = null,
    Z = 0,
    gj = 0,
    fj = Uf(0),
    T = 0,
    qk = null,
    hh = 0,
    rk = 0,
    sk = 0,
    tk = null,
    uk = null,
    gk = 0,
    Hj = Infinity,
    vk = null,
    Pi = !1,
    Qi = null,
    Si = null,
    wk = !1,
    xk = null,
    yk = 0,
    zk = 0,
    Ak = null,
    Bk = -1,
    Ck = 0;

function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}

function lh(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}

function mh(a, b, c, d) {
  if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
  Ac(a, c, d);
  if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
}

function Ek(a, b) {
  var c = a.callbackNode;
  wc(a, b);
  var d = uc(a, a === R ? Z : 0);
  if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;else if (b = d & -d, a.callbackPriority !== b) {
    null != c && bc(c);
    if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function () {
      0 === (K & 6) && jg();
    }), c = null;else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;

        case 4:
          c = gc;
          break;

        case 16:
          c = hc;
          break;

        case 536870912:
          c = jc;
          break;

        default:
          c = hc;
      }

      c = Gk(c, Hk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}

function Hk(a, b) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6)) throw Error(p(327));
  var c = a.callbackNode;
  if (Ik() && a.callbackNode !== c) return null;
  var d = uc(a, a === R ? Z : 0);
  if (0 === d) return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);else {
    b = d;
    var e = K;
    K |= 2;
    var f = Kk();
    if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);

    do {
      try {
        Mk();
        break;
      } catch (h) {
        Nk(a, h);
      }
    } while (1);

    Qg();
    nk.current = f;
    K = e;
    null !== Y ? b = 0 : (R = null, Z = 0, b = T);
  }

  if (0 !== b) {
    2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
    if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
    if (6 === b) Dk(a, d);else {
      e = a.current.alternate;
      if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
      a.finishedWork = e;
      a.finishedLanes = d;

      switch (b) {
        case 0:
        case 1:
          throw Error(p(345));

        case 2:
          Qk(a, uk, vk);
          break;

        case 3:
          Dk(a, d);

          if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
            if (0 !== uc(a, 0)) break;
            e = a.suspendedLanes;

            if ((e & d) !== d) {
              L();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }

            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
            break;
          }

          Qk(a, uk, vk);
          break;

        case 4:
          Dk(a, d);
          if ((d & 4194240) === d) break;
          b = a.eventTimes;

          for (e = -1; 0 < d;) {
            var g = 31 - oc(d);
            f = 1 << g;
            g = b[g];
            g > e && (e = g);
            d &= ~f;
          }

          d = e;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;

          if (10 < d) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
            break;
          }

          Qk(a, uk, vk);
          break;

        case 5:
          Qk(a, uk, vk);
          break;

        default:
          throw Error(p(329));
      }
    }
  }

  Ek(a, B());
  return a.callbackNode === c ? Hk.bind(null, a) : null;
}

function Ok(a, b) {
  var c = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
  a = Jk(a, b);
  2 !== a && (b = uk, uk = c, null !== b && Gj(b));
  return a;
}

function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}

function Pk(a) {
  for (var b = a;;) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
        var e = c[d],
            f = e.getSnapshot;
        e = e.value;

        try {
          if (!He(f(), e)) return !1;
        } catch (g) {
          return !1;
        }
      }
    }

    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;else {
      if (b === a) break;

      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) return !0;
        b = b.return;
      }

      b.sibling.return = b.return;
      b = b.sibling;
    }
  }

  return !0;
}

function Dk(a, b) {
  b &= ~sk;
  b &= ~rk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;

  for (a = a.expirationTimes; 0 < b;) {
    var c = 31 - oc(b),
        d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}

function Fk(a) {
  if (0 !== (K & 6)) throw Error(p(327));
  Ik();
  var b = uc(a, 0);
  if (0 === (b & 1)) return Ek(a, B()), null;
  var c = Jk(a, b);

  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b = d, c = Ok(a, d));
  }

  if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
  if (6 === c) throw Error(p(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Qk(a, uk, vk);
  Ek(a, B());
  return null;
}

function Rk(a, b) {
  var c = K;
  K |= 1;

  try {
    return a(b);
  } finally {
    K = c, 0 === K && (Hj = B() + 500, fg && jg());
  }
}

function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b = K;
  K |= 1;
  var c = pk.transition,
      d = C;

  try {
    if (pk.transition = null, C = 1, a) return a();
  } finally {
    C = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
  }
}

function Ij() {
  gj = fj.current;
  E(fj);
}

function Lk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y) for (c = Y.return; null !== c;) {
    var d = c;
    wg(d);

    switch (d.tag) {
      case 1:
        d = d.type.childContextTypes;
        null !== d && void 0 !== d && $f();
        break;

      case 3:
        Jh();
        E(Wf);
        E(H);
        Oh();
        break;

      case 5:
        Lh(d);
        break;

      case 4:
        Jh();
        break;

      case 13:
        E(M);
        break;

      case 19:
        E(M);
        break;

      case 10:
        Rg(d.type._context);
        break;

      case 22:
      case 23:
        Ij();
    }

    c = c.return;
  }
  R = a;
  Y = a = wh(a.current, null);
  Z = gj = b;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;

  if (null !== Wg) {
    for (b = 0; b < Wg.length; b++) {
      if (c = Wg[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next,
            f = c.pending;

        if (null !== f) {
          var g = f.next;
          f.next = e;
          d.next = g;
        }

        c.pending = d;
      }
    }

    Wg = null;
  }

  return a;
}

function Nk(a, b) {
  do {
    var c = Y;

    try {
      Qg();
      Ph.current = ai;

      if (Sh) {
        for (var d = N.memoizedState; null !== d;) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }

        Sh = !1;
      }

      Rh = 0;
      P = O = N = null;
      Th = !1;
      Uh = 0;
      ok.current = null;

      if (null === c || null === c.return) {
        T = 1;
        qk = b;
        Y = null;
        break;
      }

      a: {
        var f = a,
            g = c.return,
            h = c,
            k = b;
        b = Z;
        h.flags |= 32768;

        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
          var l = k,
              m = h,
              q = m.tag;

          if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
            var r = m.alternate;
            r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
          }

          var y = Vi(g);

          if (null !== y) {
            y.flags &= -257;
            Wi(y, g, h, f, b);
            y.mode & 1 && Ti(f, l, b);
            b = y;
            k = l;
            var n = b.updateQueue;

            if (null === n) {
              var t = new Set();
              t.add(k);
              b.updateQueue = t;
            } else n.add(k);

            break a;
          } else {
            if (0 === (b & 1)) {
              Ti(f, l, b);
              uj();
              break a;
            }

            k = Error(p(426));
          }
        } else if (I && h.mode & 1) {
          var J = Vi(g);

          if (null !== J) {
            0 === (J.flags & 65536) && (J.flags |= 256);
            Wi(J, g, h, f, b);
            Jg(Ki(k, h));
            break a;
          }
        }

        f = k = Ki(k, h);
        4 !== T && (T = 2);
        null === tk ? tk = [f] : tk.push(f);
        f = g;

        do {
          switch (f.tag) {
            case 3:
              f.flags |= 65536;
              b &= -b;
              f.lanes |= b;
              var x = Oi(f, k, b);
              fh(f, x);
              break a;

            case 1:
              h = k;
              var w = f.type,
                  u = f.stateNode;

              if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var F = Ri(f, h, b);
                fh(f, F);
                break a;
              }

          }

          f = f.return;
        } while (null !== f);
      }

      Tk(c);
    } catch (na) {
      b = na;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }

    break;
  } while (1);
}

function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}

function uj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}

function Jk(a, b) {
  var c = K;
  K |= 2;
  var d = Kk();
  if (R !== a || Z !== b) vk = null, Lk(a, b);

  do {
    try {
      Uk();
      break;
    } catch (e) {
      Nk(a, e);
    }
  } while (1);

  Qg();
  K = c;
  nk.current = d;
  if (null !== Y) throw Error(p(261));
  R = null;
  Z = 0;
  return T;
}

function Uk() {
  for (; null !== Y;) {
    Vk(Y);
  }
}

function Mk() {
  for (; null !== Y && !cc();) {
    Vk(Y);
  }
}

function Vk(a) {
  var b = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b ? Tk(a) : Y = b;
  ok.current = null;
}

function Tk(a) {
  var b = a;

  do {
    var c = b.alternate;
    a = b.return;

    if (0 === (b.flags & 32768)) {
      if (c = Fj(c, b, gj), null !== c) {
        Y = c;
        return;
      }
    } else {
      c = Jj(c, b);

      if (null !== c) {
        c.flags &= 32767;
        Y = c;
        return;
      }

      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;else {
        T = 6;
        Y = null;
        return;
      }
    }

    b = b.sibling;

    if (null !== b) {
      Y = b;
      return;
    }

    Y = b = a;
  } while (null !== b);

  0 === T && (T = 5);
}

function Qk(a, b, c) {
  var d = C,
      e = pk.transition;

  try {
    pk.transition = null, C = 1, Xk(a, b, c, d);
  } finally {
    pk.transition = e, C = d;
  }

  return null;
}

function Xk(a, b, c, d) {
  do {
    Ik();
  } while (null !== xk);

  if (0 !== (K & 6)) throw Error(p(327));
  c = a.finishedWork;
  var e = a.finishedLanes;
  if (null === c) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current) throw Error(p(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f = c.lanes | c.childLanes;
  Bc(a, f);
  a === R && (Y = R = null, Z = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = !0, Gk(hc, function () {
    Ik();
    return null;
  }));
  f = 0 !== (c.flags & 15990);

  if (0 !== (c.subtreeFlags & 15990) || f) {
    f = pk.transition;
    pk.transition = null;
    var g = C;
    C = 1;
    var h = K;
    K |= 4;
    ok.current = null;
    Pj(a, c);
    ek(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    ik(c, a, e);
    dc();
    K = h;
    C = g;
    pk.transition = f;
  } else a.current = c;

  wk && (wk = !1, xk = a, yk = e);
  f = a.pendingLanes;
  0 === f && (Si = null);
  mc(c.stateNode, d);
  Ek(a, B());
  if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) {
    e = b[c], d(e.value, {
      componentStack: e.stack,
      digest: e.digest
    });
  }
  if (Pi) throw Pi = !1, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f = a.pendingLanes;
  0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}

function Ik() {
  if (null !== xk) {
    var a = Dc(yk),
        b = pk.transition,
        c = C;

    try {
      pk.transition = null;
      C = 16 > a ? 16 : a;
      if (null === xk) var d = !1;else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6)) throw Error(p(331));
        var e = K;
        K |= 4;

        for (V = a.current; null !== V;) {
          var f = V,
              g = f.child;

          if (0 !== (V.flags & 16)) {
            var h = f.deletions;

            if (null !== h) {
              for (var k = 0; k < h.length; k++) {
                var l = h[k];

                for (V = l; null !== V;) {
                  var m = V;

                  switch (m.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m, f);
                  }

                  var q = m.child;
                  if (null !== q) q.return = m, V = q;else for (; null !== V;) {
                    m = V;
                    var r = m.sibling,
                        y = m.return;
                    Tj(m);

                    if (m === l) {
                      V = null;
                      break;
                    }

                    if (null !== r) {
                      r.return = y;
                      V = r;
                      break;
                    }

                    V = y;
                  }
                }
              }

              var n = f.alternate;

              if (null !== n) {
                var t = n.child;

                if (null !== t) {
                  n.child = null;

                  do {
                    var J = t.sibling;
                    t.sibling = null;
                    t = J;
                  } while (null !== t);
                }
              }

              V = f;
            }
          }

          if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;else b: for (; null !== V;) {
            f = V;
            if (0 !== (f.flags & 2048)) switch (f.tag) {
              case 0:
              case 11:
              case 15:
                Qj(9, f, f.return);
            }
            var x = f.sibling;

            if (null !== x) {
              x.return = f.return;
              V = x;
              break b;
            }

            V = f.return;
          }
        }

        var w = a.current;

        for (V = w; null !== V;) {
          g = V;
          var u = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;else b: for (g = w; null !== V;) {
            h = V;
            if (0 !== (h.flags & 2048)) try {
              switch (h.tag) {
                case 0:
                case 11:
                case 15:
                  Rj(9, h);
              }
            } catch (na) {
              W(h, h.return, na);
            }

            if (h === g) {
              V = null;
              break b;
            }

            var F = h.sibling;

            if (null !== F) {
              F.return = h.return;
              V = F;
              break b;
            }

            V = h.return;
          }
        }

        K = e;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {}
        d = !0;
      }
      return d;
    } finally {
      C = c, pk.transition = b;
    }
  }

  return !1;
}

function Yk(a, b, c) {
  b = Ki(c, b);
  b = Oi(a, b, 1);
  a = dh(a, b, 1);
  b = L();
  null !== a && (Ac(a, 1, b), Ek(a, b));
}

function W(a, b, c) {
  if (3 === a.tag) Yk(a, a, c);else for (; null !== b;) {
    if (3 === b.tag) {
      Yk(b, a, c);
      break;
    } else if (1 === b.tag) {
      var d = b.stateNode;

      if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
        a = Ki(c, a);
        a = Ri(b, a, 1);
        b = dh(b, a, 1);
        a = L();
        null !== b && (Ac(b, 1, a), Ek(b, a));
        break;
      }
    }

    b = b.return;
  }
}

function Ui(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = L();
  a.pingedLanes |= a.suspendedLanes & c;
  R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
  Ek(a, b);
}

function Zk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = L();
  a = Zg(a, b);
  null !== a && (Ac(a, b, c), Ek(a, c));
}

function vj(a) {
  var b = a.memoizedState,
      c = 0;
  null !== b && (c = b.retryLane);
  Zk(a, c);
}

function ck(a, b) {
  var c = 0;

  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e = a.memoizedState;
      null !== e && (c = e.retryLane);
      break;

    case 19:
      d = a.stateNode;
      break;

    default:
      throw Error(p(314));
  }

  null !== d && d.delete(b);
  Zk(a, c);
}

var Wk;

Wk = function Wk(a, b, c) {
  if (null !== a) {
    if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = !0;else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = !1, zj(a, b, c);
      Ug = 0 !== (a.flags & 131072) ? !0 : !1;
    }
  } else Ug = !1, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;

  switch (b.tag) {
    case 2:
      var d = b.type;
      jj(a, b);
      a = b.pendingProps;
      var e = Yf(b, H.current);
      Tg(b, c);
      e = Xh(null, b, d, a, e, c);
      var f = bi();
      b.flags |= 1;
      "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = !0, cg(b)) : f = !1, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, !0, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
      return b;

    case 16:
      d = b.elementType;

      a: {
        jj(a, b);
        a = b.pendingProps;
        e = d._init;
        d = e(d._payload);
        b.type = d;
        e = b.tag = $k(d);
        a = Lg(d, a);

        switch (e) {
          case 0:
            b = dj(null, b, d, a, c);
            break a;

          case 1:
            b = ij(null, b, d, a, c);
            break a;

          case 11:
            b = Zi(null, b, d, a, c);
            break a;

          case 14:
            b = aj(null, b, d, Lg(d.type, a), c);
            break a;
        }

        throw Error(p(306, d, ""));
      }

      return b;

    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);

    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);

    case 3:
      a: {
        lj(b);
        if (null === a) throw Error(p(387));
        d = b.pendingProps;
        f = b.memoizedState;
        e = f.element;
        bh(a, b);
        gh(b, d, null, c);
        var g = b.memoizedState;
        d = g.element;
        if (f.isDehydrated) {
          if (f = {
            element: d,
            isDehydrated: !1,
            cache: g.cache,
            pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
            transitions: g.transitions
          }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ki(Error(p(423)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ki(Error(p(424)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = !0, zg = null, c = Ch(b, null, d, c), b.child = c; c;) {
            c.flags = c.flags & -3 | 4096, c = c.sibling;
          }
        } else {
          Ig();

          if (d === e) {
            b = $i(a, b, c);
            break a;
          }

          Yi(a, b, d, c);
        }
        b = b.child;
      }

      return b;

    case 5:
      return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;

    case 6:
      return null === a && Eg(b), null;

    case 13:
      return pj(a, b, c);

    case 4:
      return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;

    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);

    case 7:
      return Yi(a, b, b.pendingProps, c), b.child;

    case 8:
      return Yi(a, b, b.pendingProps.children, c), b.child;

    case 12:
      return Yi(a, b, b.pendingProps.children, c), b.child;

    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        f = b.memoizedProps;
        g = e.value;
        G(Mg, d._currentValue);
        d._currentValue = g;
        if (null !== f) if (He(f.value, g)) {
          if (f.children === e.children && !Wf.current) {
            b = $i(a, b, c);
            break a;
          }
        } else for (f = b.child, null !== f && (f.return = b); null !== f;) {
          var h = f.dependencies;

          if (null !== h) {
            g = f.child;

            for (var k = h.firstContext; null !== k;) {
              if (k.context === d) {
                if (1 === f.tag) {
                  k = ch(-1, c & -c);
                  k.tag = 2;
                  var l = f.updateQueue;

                  if (null !== l) {
                    l = l.shared;
                    var m = l.pending;
                    null === m ? k.next = k : (k.next = m.next, m.next = k);
                    l.pending = k;
                  }
                }

                f.lanes |= c;
                k = f.alternate;
                null !== k && (k.lanes |= c);
                Sg(f.return, c, b);
                h.lanes |= c;
                break;
              }

              k = k.next;
            }
          } else if (10 === f.tag) g = f.type === b.type ? null : f.child;else if (18 === f.tag) {
            g = f.return;
            if (null === g) throw Error(p(341));
            g.lanes |= c;
            h = g.alternate;
            null !== h && (h.lanes |= c);
            Sg(g, c, b);
            g = f.sibling;
          } else g = f.child;

          if (null !== g) g.return = f;else for (g = f; null !== g;) {
            if (g === b) {
              g = null;
              break;
            }

            f = g.sibling;

            if (null !== f) {
              f.return = g.return;
              g = f;
              break;
            }

            g = g.return;
          }
          f = g;
        }
        Yi(a, b, e.children, c);
        b = b.child;
      }

      return b;

    case 9:
      return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;

    case 14:
      return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);

    case 15:
      return cj(a, b, b.type, b.pendingProps, c);

    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, !0, a, c);

    case 19:
      return yj(a, b, c);

    case 22:
      return ej(a, b, c);
  }

  throw Error(p(156, b.tag));
};

function Gk(a, b) {
  return ac(a, b);
}

function al(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}

function Bg(a, b, c, d) {
  return new al(a, b, c, d);
}

function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}

function $k(a) {
  if ("function" === typeof a) return bj(a) ? 1 : 0;

  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }

  return 2;
}

function wh(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : {
    lanes: b.lanes,
    firstContext: b.firstContext
  };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}

function yh(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if ("function" === typeof a) bj(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
    case ya:
      return Ah(c.children, e, f, b);

    case za:
      g = 8;
      e |= 8;
      break;

    case Aa:
      return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;

    case Ea:
      return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;

    case Fa:
      return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;

    case Ia:
      return qj(c, e, f, b);

    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g = 10;
          break a;

        case Ca:
          g = 9;
          break a;

        case Da:
          g = 11;
          break a;

        case Ga:
          g = 14;
          break a;

        case Ha:
          g = 16;
          d = null;
          break a;
      }
      throw Error(p(130, null == a ? a : typeof a, ""));
  }
  b = Bg(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}

function Ah(a, b, c, d) {
  a = Bg(7, a, d, b);
  a.lanes = c;
  return a;
}

function qj(a, b, c, d) {
  a = Bg(22, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = {
    isHidden: !1
  };
  return a;
}

function xh(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}

function zh(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = {
    containerInfo: a.containerInfo,
    pendingChildren: null,
    implementation: a.implementation
  };
  return b;
}

function bl(a, b, c, d, e) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e;
  this.mutableSourceEagerHydrationData = null;
}

function cl(a, b, c, d, e, f, g, h, k) {
  a = new bl(a, b, c, h, k);
  1 === b ? (b = 1, !0 === f && (b |= 8)) : b = 0;
  f = Bg(3, null, null, b);
  a.current = f;
  f.stateNode = a;
  f.memoizedState = {
    element: d,
    isDehydrated: c,
    cache: null,
    transitions: null,
    pendingSuspenseBoundaries: null
  };
  ah(f);
  return a;
}

function dl(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: wa,
    key: null == d ? null : "" + d,
    children: a,
    containerInfo: b,
    implementation: c
  };
}

function el(a) {
  if (!a) return Vf;
  a = a._reactInternals;

  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
    var b = a;

    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;

        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }

      }

      b = b.return;
    } while (null !== b);

    throw Error(p(171));
  }

  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c)) return bg(a, c, b);
  }

  return b;
}

function fl(a, b, c, d, e, f, g, h, k) {
  a = cl(c, d, !0, a, e, f, g, h, k);
  a.context = el(null);
  c = a.current;
  d = L();
  e = lh(c);
  f = ch(d, e);
  f.callback = void 0 !== b && null !== b ? b : null;
  dh(c, f, e);
  a.current.lanes = e;
  Ac(a, e, d);
  Ek(a, d);
  return a;
}

function gl(a, b, c, d) {
  var e = b.current,
      f = L(),
      g = lh(e);
  c = el(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = ch(f, g);
  b.payload = {
    element: a
  };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  a = dh(e, b, g);
  null !== a && (mh(a, e, g, f), eh(a, e, g));
  return g;
}

function hl(a) {
  a = a.current;
  if (!a.child) return null;

  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;

    default:
      return a.child.stateNode;
  }
}

function il(a, b) {
  a = a.memoizedState;

  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}

function jl(a, b) {
  il(a, b);
  (a = a.alternate) && il(a, b);
}

function kl() {
  return null;
}

var ll = "function" === typeof reportError ? reportError : function (a) {
  console.error(a);
};

function ml(a) {
  this._internalRoot = a;
}

nl.prototype.render = ml.prototype.render = function (a) {
  var b = this._internalRoot;
  if (null === b) throw Error(p(409));
  gl(a, b, null, null);
};

nl.prototype.unmount = ml.prototype.unmount = function () {
  var a = this._internalRoot;

  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Sk(function () {
      gl(null, a, null, null);
    });
    b[uf] = null;
  }
};

function nl(a) {
  this._internalRoot = a;
}

nl.prototype.unstable_scheduleHydration = function (a) {
  if (a) {
    var b = Hc();
    a = {
      blockedOn: null,
      target: a,
      priority: b
    };

    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) {
      ;
    }

    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};

function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}

function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}

function ql() {}

function rl(a, b, c, d, e) {
  if (e) {
    if ("function" === typeof d) {
      var f = d;

      d = function d() {
        var a = hl(g);
        f.call(a);
      };
    }

    var g = fl(b, d, a, 0, null, !1, !1, "", ql);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g;
  }

  for (; e = a.lastChild;) {
    a.removeChild(e);
  }

  if ("function" === typeof d) {
    var h = d;

    d = function d() {
      var a = hl(k);
      h.call(a);
    };
  }

  var k = cl(a, 0, !1, null, null, !1, !1, "", ql);
  a._reactRootContainer = k;
  a[uf] = k.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function () {
    gl(b, k, c, d);
  });
  return k;
}

function sl(a, b, c, d, e) {
  var f = c._reactRootContainer;

  if (f) {
    var g = f;

    if ("function" === typeof e) {
      var h = e;

      e = function e() {
        var a = hl(g);
        h.call(a);
      };
    }

    gl(b, g, a, e);
  } else g = rl(c, b, a, e, d);

  return hl(g);
}

Ec = function Ec(a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;

      if (b.current.memoizedState.isDehydrated) {
        var c = tc(b.pendingLanes);
        0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }

      break;

    case 13:
      Sk(function () {
        var b = Zg(a, 1);

        if (null !== b) {
          var c = L();
          mh(b, a, 1, c);
        }
      }), jl(a, 1);
  }
};

Fc = function Fc(a) {
  if (13 === a.tag) {
    var b = Zg(a, 134217728);

    if (null !== b) {
      var c = L();
      mh(b, a, 134217728, c);
    }

    jl(a, 134217728);
  }
};

Gc = function Gc(a) {
  if (13 === a.tag) {
    var b = lh(a),
        c = Zg(a, b);

    if (null !== c) {
      var d = L();
      mh(c, a, b, d);
    }

    jl(a, b);
  }
};

Hc = function Hc() {
  return C;
};

Ic = function Ic(a, b) {
  var c = C;

  try {
    return C = a, b();
  } finally {
    C = c;
  }
};

yb = function yb(a, b, c) {
  switch (b) {
    case "input":
      bb(a, c);
      b = c.name;

      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode;) {
          c = c.parentNode;
        }

        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');

        for (b = 0; b < c.length; b++) {
          var d = c[b];

          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e) throw Error(p(90));
            Wa(d);
            bb(d, e);
          }
        }
      }

      break;

    case "textarea":
      ib(a, c);
      break;

    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, !1);
  }
};

Gb = Rk;
Hb = Sk;
var tl = {
  usingClientEntryPoint: !1,
  Events: [Cb, ue, Db, Eb, Fb, Rk]
},
    ul = {
  findFiberByHostInstance: Wc,
  bundleType: 0,
  version: "18.2.0",
  rendererPackageName: "react-dom"
};
var vl = {
  bundleType: ul.bundleType,
  version: ul.version,
  rendererPackageName: ul.rendererPackageName,
  rendererConfig: ul.rendererConfig,
  overrideHookState: null,
  overrideHookStateDeletePath: null,
  overrideHookStateRenamePath: null,
  overrideProps: null,
  overridePropsDeletePath: null,
  overridePropsRenamePath: null,
  setErrorHandler: null,
  setSuspenseHandler: null,
  scheduleUpdate: null,
  currentDispatcherRef: ua.ReactCurrentDispatcher,
  findHostInstanceByFiber: function findHostInstanceByFiber(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  },
  findFiberByHostInstance: ul.findFiberByHostInstance || kl,
  findHostInstancesForRefresh: null,
  scheduleRefresh: null,
  scheduleRoot: null,
  setRefreshHandler: null,
  getCurrentFiber: null,
  reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};

if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber) try {
    kc = wl.inject(vl), lc = wl;
  } catch (a) {}
}

exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;

exports.createPortal = function (a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b)) throw Error(p(200));
  return dl(a, b, null, c);
};

exports.createRoot = function (a, b) {
  if (!ol(a)) throw Error(p(299));
  var c = !1,
      d = "",
      e = ll;
  null !== b && void 0 !== b && (!0 === b.unstable_strictMode && (c = !0), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
  b = cl(a, 1, !1, null, null, c, !1, d, e);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b);
};

exports.findDOMNode = function (a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b = a._reactInternals;

  if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(p(188));
    a = Object.keys(a).join(",");
    throw Error(p(268, a));
  }

  a = Zb(b);
  a = null === a ? null : a.stateNode;
  return a;
};

exports.flushSync = function (a) {
  return Sk(a);
};

exports.hydrate = function (a, b, c) {
  if (!pl(b)) throw Error(p(200));
  return sl(null, a, b, !0, c);
};

exports.hydrateRoot = function (a, b, c) {
  if (!ol(a)) throw Error(p(405));
  var d = null != c && c.hydratedSources || null,
      e = !1,
      f = "",
      g = ll;
  null !== c && void 0 !== c && (!0 === c.unstable_strictMode && (e = !0), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b = fl(b, null, a, 1, null != c ? c : null, e, !1, f, g);
  a[uf] = b.current;
  sf(a);
  if (d) for (a = 0; a < d.length; a++) {
    c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
  }
  return new nl(b);
};

exports.render = function (a, b, c) {
  if (!pl(b)) throw Error(p(200));
  return sl(null, a, b, !1, c);
};

exports.unmountComponentAtNode = function (a) {
  if (!pl(a)) throw Error(p(40));
  return a._reactRootContainer ? (Sk(function () {
    sl(null, null, a, !1, function () {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), !0) : !1;
};

exports.unstable_batchedUpdates = Rk;

exports.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
  if (!pl(c)) throw Error(p(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p(38));
  return sl(a, b, c, !1, d);
};

exports.version = "18.2.0-next-9e3b772b8-20220608";

/***/ }),

/***/ 1250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var m = __webpack_require__(4164);

if (true) {
  exports.createRoot = m.createRoot;
  exports.hydrateRoot = m.hydrateRoot;
} else { var i; }

/***/ }),

/***/ 4164:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }

  if (false) {}

  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(4463);
} else {}

/***/ }),

/***/ 8340:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var l, s;

if (true) {
  l = __webpack_require__(1071);
  s = __webpack_require__(4424);
} else {}

exports.version = l.version;
exports.renderToString = l.renderToString;
exports.renderToStaticMarkup = l.renderToStaticMarkup;
exports.renderToNodeStream = l.renderToNodeStream;
exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
exports.renderToReadableStream = s.renderToReadableStream;

/***/ }),

/***/ 6195:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
} // A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.


var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
  this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
reservedProps.forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      name = _ref2[0],
      attributeName = _ref2[1];

  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function capitalize(token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
  false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
  false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
false);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true, // sanitizeURL
  true);
});

var _require = __webpack_require__(1590),
    CAMELCASE = _require.CAMELCASE,
    SAME = _require.SAME,
    possibleStandardNamesOptimized = _require.possibleStandardNames;

var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
/**
 * Checks whether a property name is a custom attribute.
 *
 * @see {@link https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/HTMLDOMPropertyConfig.js#L23-L25}
 *
 * @param {string}
 * @return {boolean}
 */

var isCustomAttribute = RegExp.prototype.test.bind( // eslint-disable-next-line no-misleading-character-class
new RegExp('^(data|aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$'));
var possibleStandardNames = Object.keys(possibleStandardNamesOptimized).reduce(function (accumulator, standardName) {
  var propName = possibleStandardNamesOptimized[standardName];

  if (propName === SAME) {
    accumulator[standardName] = standardName;
  } else if (propName === CAMELCASE) {
    accumulator[standardName.toLowerCase()] = standardName;
  } else {
    accumulator[standardName] = propName;
  }

  return accumulator;
}, {});
exports.BOOLEAN = BOOLEAN;
exports.BOOLEANISH_STRING = BOOLEANISH_STRING;
exports.NUMERIC = NUMERIC;
exports.OVERLOADED_BOOLEAN = OVERLOADED_BOOLEAN;
exports.POSITIVE_NUMERIC = POSITIVE_NUMERIC;
exports.RESERVED = RESERVED;
exports.STRING = STRING;
exports.getPropertyInfo = getPropertyInfo;
exports.isCustomAttribute = isCustomAttribute;
exports.possibleStandardNames = possibleStandardNames;

/***/ }),

/***/ 1590:
/***/ (function(__unused_webpack_module, exports) {

// An attribute in which the DOM/SVG standard name is the same as the React prop name (e.g., 'accept').
var SAME = 0;
exports.SAME = SAME; // An attribute in which the React prop name is the camelcased version of the DOM/SVG standard name (e.g., 'acceptCharset').

var CAMELCASE = 1;
exports.CAMELCASE = CAMELCASE;
exports.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  'accept-charset': 'acceptCharset',
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: 'className',
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: 'htmlFor',
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  'http-equiv': 'httpEquiv',
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  'accent-height': 'accentHeight',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  'alignment-baseline': 'alignmentBaseline',
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  'arabic-form': 'arabicForm',
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  'baseline-shift': 'baselineShift',
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  'cap-height': 'capHeight',
  clip: 0,
  clipPath: 1,
  'clip-path': 'clipPath',
  clipPathUnits: 1,
  clipRule: 1,
  'clip-rule': 'clipRule',
  color: 0,
  colorInterpolation: 1,
  'color-interpolation': 'colorInterpolation',
  colorInterpolationFilters: 1,
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorProfile: 1,
  'color-profile': 'colorProfile',
  colorRendering: 1,
  'color-rendering': 'colorRendering',
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  'dominant-baseline': 'dominantBaseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  'enable-background': 'enableBackground',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  'fill-opacity': 'fillOpacity',
  fillRule: 1,
  'fill-rule': 'fillRule',
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  'flood-opacity': 'floodOpacity',
  floodColor: 1,
  'flood-color': 'floodColor',
  focusable: 0,
  fontFamily: 1,
  'font-family': 'fontFamily',
  fontSize: 1,
  'font-size': 'fontSize',
  fontSizeAdjust: 1,
  'font-size-adjust': 'fontSizeAdjust',
  fontStretch: 1,
  'font-stretch': 'fontStretch',
  fontStyle: 1,
  'font-style': 'fontStyle',
  fontVariant: 1,
  'font-variant': 'fontVariant',
  fontWeight: 1,
  'font-weight': 'fontWeight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  'glyph-name': 'glyphName',
  glyphOrientationHorizontal: 1,
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphOrientationVertical: 1,
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  'horiz-adv-x': 'horizAdvX',
  horizOriginX: 1,
  'horiz-origin-x': 'horizOriginX',
  ideographic: 0,
  imageRendering: 1,
  'image-rendering': 'imageRendering',
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  'letter-spacing': 'letterSpacing',
  lightingColor: 1,
  'lighting-color': 'lightingColor',
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  'marker-end': 'markerEnd',
  markerHeight: 1,
  markerMid: 1,
  'marker-mid': 'markerMid',
  markerStart: 1,
  'marker-start': 'markerStart',
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  'overline-position': 'overlinePosition',
  overlineThickness: 1,
  'overline-thickness': 'overlineThickness',
  paintOrder: 1,
  'paint-order': 'paintOrder',
  panose1: 0,
  'panose-1': 'panose1',
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  'pointer-events': 'pointerEvents',
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  'rendering-intent': 'renderingIntent',
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  'shape-rendering': 'shapeRendering',
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  'stop-color': 'stopColor',
  stopOpacity: 1,
  'stop-opacity': 'stopOpacity',
  strikethroughPosition: 1,
  'strikethrough-position': 'strikethroughPosition',
  strikethroughThickness: 1,
  'strikethrough-thickness': 'strikethroughThickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  'stroke-dasharray': 'strokeDasharray',
  strokeDashoffset: 1,
  'stroke-dashoffset': 'strokeDashoffset',
  strokeLinecap: 1,
  'stroke-linecap': 'strokeLinecap',
  strokeLinejoin: 1,
  'stroke-linejoin': 'strokeLinejoin',
  strokeMiterlimit: 1,
  'stroke-miterlimit': 'strokeMiterlimit',
  strokeWidth: 1,
  'stroke-width': 'strokeWidth',
  strokeOpacity: 1,
  'stroke-opacity': 'strokeOpacity',
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  'text-anchor': 'textAnchor',
  textDecoration: 1,
  'text-decoration': 'textDecoration',
  textLength: 1,
  textRendering: 1,
  'text-rendering': 'textRendering',
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  'underline-position': 'underlinePosition',
  underlineThickness: 1,
  'underline-thickness': 'underlineThickness',
  unicode: 0,
  unicodeBidi: 1,
  'unicode-bidi': 'unicodeBidi',
  unicodeRange: 1,
  'unicode-range': 'unicodeRange',
  unitsPerEm: 1,
  'units-per-em': 'unitsPerEm',
  unselectable: 0,
  vAlphabetic: 1,
  'v-alphabetic': 'vAlphabetic',
  values: 0,
  vectorEffect: 1,
  'vector-effect': 'vectorEffect',
  version: 0,
  vertAdvY: 1,
  'vert-adv-y': 'vertAdvY',
  vertOriginX: 1,
  'vert-origin-x': 'vertOriginX',
  vertOriginY: 1,
  'vert-origin-y': 'vertOriginY',
  vHanging: 1,
  'v-hanging': 'vHanging',
  vIdeographic: 1,
  'v-ideographic': 'vIdeographic',
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  'v-mathematical': 'vMathematical',
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  'word-spacing': 'wordSpacing',
  writingMode: 1,
  'writing-mode': 'writingMode',
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  'x-height': 'xHeight',
  xlinkActuate: 1,
  'xlink:actuate': 'xlinkActuate',
  xlinkArcrole: 1,
  'xlink:arcrole': 'xlinkArcrole',
  xlinkHref: 1,
  'xlink:href': 'xlinkHref',
  xlinkRole: 1,
  'xlink:role': 'xlinkRole',
  xlinkShow: 1,
  'xlink:show': 'xlinkShow',
  xlinkTitle: 1,
  'xlink:title': 'xlinkTitle',
  xlinkType: 1,
  'xlink:type': 'xlinkType',
  xmlBase: 1,
  'xml:base': 'xmlBase',
  xmlLang: 1,
  'xml:lang': 'xmlLang',
  xmlns: 0,
  'xml:space': 'xmlSpace',
  xmlnsXlink: 1,
  'xmlns:xlink': 'xmlnsXlink',
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};

/***/ }),

/***/ 6374:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var f = __webpack_require__(2791),
    k = Symbol.for("react.element"),
    l = Symbol.for("react.fragment"),
    m = Object.prototype.hasOwnProperty,
    n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    p = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function q(c, a, g) {
  var b,
      d = {},
      e = null,
      h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);

  for (b in a) {
    m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  }

  if (c && c.defaultProps) for (b in a = c.defaultProps, a) {
    void 0 === d[b] && (d[b] = a[b]);
  }
  return {
    $$typeof: k,
    type: c,
    key: e,
    ref: h,
    props: d,
    _owner: n.current
  };
}

exports.Fragment = l;
exports.jsx = q;
exports.jsxs = q;

/***/ }),

/***/ 9117:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var l = Symbol.for("react.element"),
    n = Symbol.for("react.portal"),
    p = Symbol.for("react.fragment"),
    q = Symbol.for("react.strict_mode"),
    r = Symbol.for("react.profiler"),
    t = Symbol.for("react.provider"),
    u = Symbol.for("react.context"),
    v = Symbol.for("react.forward_ref"),
    w = Symbol.for("react.suspense"),
    x = Symbol.for("react.memo"),
    y = Symbol.for("react.lazy"),
    z = Symbol.iterator;

function A(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z && a[z] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

var B = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueForceUpdate: function enqueueForceUpdate() {},
  enqueueReplaceState: function enqueueReplaceState() {},
  enqueueSetState: function enqueueSetState() {}
},
    C = Object.assign,
    D = {};

function E(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}

E.prototype.isReactComponent = {};

E.prototype.setState = function (a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};

E.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function F() {}

F.prototype = E.prototype;

function G(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}

var H = G.prototype = new F();
H.constructor = G;
C(H, E.prototype);
H.isPureReactComponent = !0;
var I = Array.isArray,
    J = Object.prototype.hasOwnProperty,
    K = {
  current: null
},
    L = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function M(a, b, e) {
  var d,
      c = {},
      k = null,
      h = null;
  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) {
    J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
  }
  var g = arguments.length - 2;
  if (1 === g) c.children = e;else if (1 < g) {
    for (var f = Array(g), m = 0; m < g; m++) {
      f[m] = arguments[m + 2];
    }

    c.children = f;
  }
  if (a && a.defaultProps) for (d in g = a.defaultProps, g) {
    void 0 === c[d] && (c[d] = g[d]);
  }
  return {
    $$typeof: l,
    type: a,
    key: k,
    ref: h,
    props: c,
    _owner: K.current
  };
}

function N(a, b) {
  return {
    $$typeof: l,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}

function O(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l;
}

function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}

var P = /\/+/g;

function Q(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}

function R(a, b, e, d, c) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k) a = null;
  var h = !1;
  if (null === a) h = !0;else switch (k) {
    case "string":
    case "number":
      h = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case l:
        case n:
          h = !0;
      }

  }
  if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function (a) {
    return a;
  })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
  h = 0;
  d = "" === d ? "." : d + ":";
  if (I(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];
    var f = d + Q(k, g);
    h += R(k, b, e, f, c);
  } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) {
    k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
  } else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h;
}

function S(a, b, e) {
  if (null == a) return a;
  var d = [],
      c = 0;
  R(a, d, "", "", function (a) {
    return b.call(e, a, c++);
  });
  return d;
}

function T(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function (b) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
    }, function (b) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }

  if (1 === a._status) return a._result.default;
  throw a._result;
}

var U = {
  current: null
},
    V = {
  transition: null
},
    W = {
  ReactCurrentDispatcher: U,
  ReactCurrentBatchConfig: V,
  ReactCurrentOwner: K
};
exports.Children = {
  map: S,
  forEach: function forEach(a, b, e) {
    S(a, function () {
      b.apply(this, arguments);
    }, e);
  },
  count: function count(a) {
    var b = 0;
    S(a, function () {
      b++;
    });
    return b;
  },
  toArray: function toArray(a) {
    return S(a, function (a) {
      return a;
    }) || [];
  },
  only: function only(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  }
};
exports.Component = E;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = G;
exports.StrictMode = q;
exports.Suspense = w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;

exports.cloneElement = function (a, b, e) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C({}, a.props),
      c = a.key,
      k = a.ref,
      h = a._owner;

  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = K.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;

    for (f in b) {
      J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
  }

  var f = arguments.length - 2;
  if (1 === f) d.children = e;else if (1 < f) {
    g = Array(f);

    for (var m = 0; m < f; m++) {
      g[m] = arguments[m + 2];
    }

    d.children = g;
  }
  return {
    $$typeof: l,
    type: a.type,
    key: c,
    ref: k,
    props: d,
    _owner: h
  };
};

exports.createContext = function (a) {
  a = {
    $$typeof: u,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  };
  a.Provider = {
    $$typeof: t,
    _context: a
  };
  return a.Consumer = a;
};

exports.createElement = M;

exports.createFactory = function (a) {
  var b = M.bind(null, a);
  b.type = a;
  return b;
};

exports.createRef = function () {
  return {
    current: null
  };
};

exports.forwardRef = function (a) {
  return {
    $$typeof: v,
    render: a
  };
};

exports.isValidElement = O;

exports.lazy = function (a) {
  return {
    $$typeof: y,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: T
  };
};

exports.memo = function (a, b) {
  return {
    $$typeof: x,
    type: a,
    compare: void 0 === b ? null : b
  };
};

exports.startTransition = function (a) {
  var b = V.transition;
  V.transition = {};

  try {
    a();
  } finally {
    V.transition = b;
  }
};

exports.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};

exports.useCallback = function (a, b) {
  return U.current.useCallback(a, b);
};

exports.useContext = function (a) {
  return U.current.useContext(a);
};

exports.useDebugValue = function () {};

exports.useDeferredValue = function (a) {
  return U.current.useDeferredValue(a);
};

exports.useEffect = function (a, b) {
  return U.current.useEffect(a, b);
};

exports.useId = function () {
  return U.current.useId();
};

exports.useImperativeHandle = function (a, b, e) {
  return U.current.useImperativeHandle(a, b, e);
};

exports.useInsertionEffect = function (a, b) {
  return U.current.useInsertionEffect(a, b);
};

exports.useLayoutEffect = function (a, b) {
  return U.current.useLayoutEffect(a, b);
};

exports.useMemo = function (a, b) {
  return U.current.useMemo(a, b);
};

exports.useReducer = function (a, b, e) {
  return U.current.useReducer(a, b, e);
};

exports.useRef = function (a) {
  return U.current.useRef(a);
};

exports.useState = function (a) {
  return U.current.useState(a);
};

exports.useSyncExternalStore = function (a, b, e) {
  return U.current.useSyncExternalStore(a, b, e);
};

exports.useTransition = function () {
  return U.current.useTransition();
};

exports.version = "18.2.0";

/***/ }),

/***/ 2791:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(9117);
} else {}

/***/ }),

/***/ 184:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(6374);
} else {}

/***/ }),

/***/ 6813:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function f(a, b) {
  var c = a.length;
  a.push(b);

  a: for (; 0 < c;) {
    var d = c - 1 >>> 1,
        e = a[d];
    if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
  }
}

function h(a) {
  return 0 === a.length ? null : a[0];
}

function k(a) {
  if (0 === a.length) return null;
  var b = a[0],
      c = a.pop();

  if (c !== b) {
    a[0] = c;

    a: for (var d = 0, e = a.length, w = e >>> 1; d < w;) {
      var m = 2 * (d + 1) - 1,
          C = a[m],
          n = m + 1,
          x = a[n];
      if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;else break a;
    }
  }

  return b;
}

function g(a, b) {
  var c = a.sortIndex - b.sortIndex;
  return 0 !== c ? c : a.id - b.id;
}

if ("object" === typeof performance && "function" === typeof performance.now) {
  var l = performance;

  exports.unstable_now = function () {
    return l.now();
  };
} else {
  var p = Date,
      q = p.now();

  exports.unstable_now = function () {
    return p.now() - q;
  };
}

var r = [],
    t = [],
    u = 1,
    v = null,
    y = 3,
    z = !1,
    A = !1,
    B = !1,
    D = "function" === typeof setTimeout ? setTimeout : null,
    E = "function" === typeof clearTimeout ? clearTimeout : null,
    F = "undefined" !== typeof setImmediate ? setImmediate : null;
"undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);

function G(a) {
  for (var b = h(t); null !== b;) {
    if (null === b.callback) k(t);else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);else break;
    b = h(t);
  }
}

function H(a) {
  B = !1;
  G(a);
  if (!A) if (null !== h(r)) A = !0, I(J);else {
    var b = h(t);
    null !== b && K(H, b.startTime - a);
  }
}

function J(a, b) {
  A = !1;
  B && (B = !1, E(L), L = -1);
  z = !0;
  var c = y;

  try {
    G(b);

    for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());) {
      var d = v.callback;

      if ("function" === typeof d) {
        v.callback = null;
        y = v.priorityLevel;
        var e = d(v.expirationTime <= b);
        b = exports.unstable_now();
        "function" === typeof e ? v.callback = e : v === h(r) && k(r);
        G(b);
      } else k(r);

      v = h(r);
    }

    if (null !== v) var w = !0;else {
      var m = h(t);
      null !== m && K(H, m.startTime - b);
      w = !1;
    }
    return w;
  } finally {
    v = null, y = c, z = !1;
  }
}

var N = !1,
    O = null,
    L = -1,
    P = 5,
    Q = -1;

function M() {
  return exports.unstable_now() - Q < P ? !1 : !0;
}

function R() {
  if (null !== O) {
    var a = exports.unstable_now();
    Q = a;
    var b = !0;

    try {
      b = O(!0, a);
    } finally {
      b ? S() : (N = !1, O = null);
    }
  } else N = !1;
}

var S;
if ("function" === typeof F) S = function S() {
  F(R);
};else if ("undefined" !== typeof MessageChannel) {
  var T = new MessageChannel(),
      U = T.port2;
  T.port1.onmessage = R;

  S = function S() {
    U.postMessage(null);
  };
} else S = function S() {
  D(R, 0);
};

function I(a) {
  O = a;
  N || (N = !0, S());
}

function K(a, b) {
  L = D(function () {
    a(exports.unstable_now());
  }, b);
}

exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;

exports.unstable_cancelCallback = function (a) {
  a.callback = null;
};

exports.unstable_continueExecution = function () {
  A || z || (A = !0, I(J));
};

exports.unstable_forceFrameRate = function (a) {
  0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
};

exports.unstable_getCurrentPriorityLevel = function () {
  return y;
};

exports.unstable_getFirstCallbackNode = function () {
  return h(r);
};

exports.unstable_next = function (a) {
  switch (y) {
    case 1:
    case 2:
    case 3:
      var b = 3;
      break;

    default:
      b = y;
  }

  var c = y;
  y = b;

  try {
    return a();
  } finally {
    y = c;
  }
};

exports.unstable_pauseExecution = function () {};

exports.unstable_requestPaint = function () {};

exports.unstable_runWithPriority = function (a, b) {
  switch (a) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;

    default:
      a = 3;
  }

  var c = y;
  y = a;

  try {
    return b();
  } finally {
    y = c;
  }
};

exports.unstable_scheduleCallback = function (a, b, c) {
  var d = exports.unstable_now();
  "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;

  switch (a) {
    case 1:
      var e = -1;
      break;

    case 2:
      e = 250;
      break;

    case 5:
      e = 1073741823;
      break;

    case 4:
      e = 1E4;
      break;

    default:
      e = 5E3;
  }

  e = c + e;
  a = {
    id: u++,
    callback: b,
    priorityLevel: a,
    startTime: c,
    expirationTime: e,
    sortIndex: -1
  };
  c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = !0, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, I(J)));
  return a;
};

exports.unstable_shouldYield = M;

exports.unstable_wrapCallback = function (a) {
  var b = y;
  return function () {
    var c = y;
    y = b;

    try {
      return a.apply(this, arguments);
    } finally {
      y = c;
    }
  };
};

/***/ }),

/***/ 5296:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(6813);
} else {}

/***/ }),

/***/ 5792:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

exports.__esModule = true;

var style_to_object_1 = __importDefault(__webpack_require__(6426));

var utilities_1 = __webpack_require__(9483);

function StyleToJS(style, options) {
  var output = {};

  if (!style || typeof style !== 'string') {
    return output;
  }

  (0, style_to_object_1["default"])(style, function (property, value) {
    if (property && value) {
      output[(0, utilities_1.camelCase)(property, options)] = value;
    }
  });
  return output;
}

exports["default"] = StyleToJS;

/***/ }),

/***/ 9483:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.__esModule = true;
exports.camelCase = void 0;
var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;
var HYPHEN_REGEX = /-([a-z])/g;
var NO_HYPHEN_REGEX = /^[^-]+$/;
var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;

var skipCamelCase = function skipCamelCase(property) {
  return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
};

var capitalize = function capitalize(match, character) {
  return character.toUpperCase();
};

var trimHyphen = function trimHyphen(match, prefix) {
  return "".concat(prefix, "-");
};

var camelCase = function camelCase(property, options) {
  if (options === void 0) {
    options = {};
  }

  if (skipCamelCase(property)) {
    return property;
  }

  property = property.toLowerCase();

  if (options.reactCompat) {
    property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
  } else {
    property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
  }

  return property.replace(HYPHEN_REGEX, capitalize);
};

exports.camelCase = camelCase;

/***/ }),

/***/ 6426:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(1065);
/**
 * Parses inline style to object.
 *
 * @example
 * // returns { 'line-height': '42' }
 * StyleToObject('line-height: 42;');
 *
 * @param  {String}      style      - The inline style.
 * @param  {Function}    [iterator] - The iterator function.
 * @return {null|Object}
 */


function StyleToObject(style, iterator) {
  var output = null;

  if (!style || typeof style !== 'string') {
    return output;
  }

  var declaration;
  var declarations = parse(style);
  var hasIterator = typeof iterator === 'function';
  var property;
  var value;

  for (var i = 0, len = declarations.length; i < len; i++) {
    declaration = declarations[i];
    property = declaration.property;
    value = declaration.value;

    if (hasIterator) {
      iterator(property, value, declaration);
    } else if (value) {
      output || (output = {});
      output[property] = value;
    }
  }

  return output;
}

module.exports = StyleToObject;
module.exports["default"] = StyleToObject; // ESM support

/***/ }),

/***/ 3897:
/***/ (function(module) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 5372:
/***/ (function(module) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 3405:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(3897);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 3515:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(6015);

var isNativeReflectConstruct = __webpack_require__(9617);

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 4704:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var unsupportedIterableToArray = __webpack_require__(6116);

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 9617:
/***/ (function(module) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 9498:
/***/ (function(module) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 8872:
/***/ (function(module) {

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 2218:
/***/ (function(module) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 2281:
/***/ (function(module) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 6015:
/***/ (function(module) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 7424:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(5372);

var iterableToArrayLimit = __webpack_require__(8872);

var unsupportedIterableToArray = __webpack_require__(6116);

var nonIterableRest = __webpack_require__(2218);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 861:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(3405);

var iterableToArray = __webpack_require__(9498);

var unsupportedIterableToArray = __webpack_require__(6116);

var nonIterableSpread = __webpack_require__(2281);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 6116:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(3897);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	!function() {
/******/ 		var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });
/******/ 			}
/******/ 			def['default'] = function() { return value; };
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(2791);
var react_namespaceObject = /*#__PURE__*/__webpack_require__.t(react, 2);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(1250);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function slicedToArray_slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
function extends_extends() {
  extends_extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return extends_extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ./node_modules/history/index.js

/**
 * Actions represent the type of change to a location value.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action
 */

var Action;

(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));

var readOnly =  false ? 0 : function (obj) {
  return obj;
};

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== 'undefined') console.warn(message);

    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}

var BeforeUnloadEventType = 'beforeunload';
var HashChangeEventType = 'hashchange';
var PopStateEventType = 'popstate';
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */

function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$window = _options.window,
      window = _options$window === void 0 ? document.defaultView : _options$window;
  var globalHistory = window.history;

  function getIndexAndLocation() {
    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname: pathname,
      search: search,
      hash: hash,
      state: state.usr || null,
      key: state.key || 'default'
    })];
  }

  var blockedPopTx = null;

  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;

      var _getIndexAndLocation = getIndexAndLocation(),
          nextIndex = _getIndexAndLocation[0],
          nextLocation = _getIndexAndLocation[1];

      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;

          if (delta) {
            // Revert the POP
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          // Trying to POP to a location with no index. We did not create
          // this location, so we can't effectively block the navigation.
           false ? 0 : void 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }

  window.addEventListener(PopStateEventType, handlePop);
  var action = Action.Pop;

  var _getIndexAndLocation2 = getIndexAndLocation(),
      index = _getIndexAndLocation2[0],
      location = _getIndexAndLocation2[1];

  var listeners = createEvents();
  var blockers = createEvents();

  if (index == null) {
    index = 0;
    globalHistory.replaceState(extends_extends({}, globalHistory.state, {
      idx: index
    }), '');
  }

  function createHref(to) {
    return typeof to === 'string' ? to : history_createPath(to);
  } // state defaults to `null` because `window.history.state` does


  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }

    return readOnly(extends_extends({
      pathname: location.pathname,
      hash: '',
      search: ''
    }, typeof to === 'string' ? history_parsePath(to) : to, {
      state: state,
      key: createKey()
    }));
  }

  function getHistoryStateAndUrl(nextLocation, index) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index
    }, createHref(nextLocation)];
  }

  function allowTx(action, location, retry) {
    return !blockers.length || (blockers.call({
      action: action,
      location: location,
      retry: retry
    }), false);
  }

  function applyTx(nextAction) {
    action = nextAction;

    var _getIndexAndLocation3 = getIndexAndLocation();

    index = _getIndexAndLocation3[0];
    location = _getIndexAndLocation3[1];
    listeners.call({
      action: action,
      location: location
    });
  }

  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      push(to, state);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),
          historyState = _getHistoryStateAndUr[0],
          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading
      // try...catch because iOS limits us to 100 pushState calls :/


      try {
        globalHistory.pushState(historyState, '', url);
      } catch (error) {
        // They are going to lose state here, but there is no real
        // way to warn them about it since the page will refresh...
        window.location.assign(url);
      }

      applyTx(nextAction);
    }
  }

  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      replace(to, state);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),
          historyState = _getHistoryStateAndUr2[0],
          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading


      globalHistory.replaceState(historyState, '', url);
      applyTx(nextAction);
    }
  }

  function go(delta) {
    globalHistory.go(delta);
  }

  var history = {
    get action() {
      return action;
    },

    get location() {
      return location;
    },

    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);

      if (blockers.length === 1) {
        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }

      return function () {
        unblock(); // Remove the beforeunload listener so the document may
        // still be salvageable in the pagehide event.
        // See https://html.spec.whatwg.org/#unloading-documents

        if (!blockers.length) {
          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */


function history_createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }

  var _options2 = options,
      _options2$window = _options2.window,
      window = _options2$window === void 0 ? document.defaultView : _options2$window;
  var globalHistory = window.history;

  function getIndexAndLocation() {
    var _parsePath = history_parsePath(window.location.hash.substr(1)),
        _parsePath$pathname = _parsePath.pathname,
        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,
        _parsePath$search = _parsePath.search,
        search = _parsePath$search === void 0 ? '' : _parsePath$search,
        _parsePath$hash = _parsePath.hash,
        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;

    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname: pathname,
      search: search,
      hash: hash,
      state: state.usr || null,
      key: state.key || 'default'
    })];
  }

  var blockedPopTx = null;

  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;

      var _getIndexAndLocation4 = getIndexAndLocation(),
          nextIndex = _getIndexAndLocation4[0],
          nextLocation = _getIndexAndLocation4[1];

      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;

          if (delta) {
            // Revert the POP
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          // Trying to POP to a location with no index. We did not create
          // this location, so we can't effectively block the navigation.
           false ? 0 : void 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }

  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge
  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event

  window.addEventListener(HashChangeEventType, function () {
    var _getIndexAndLocation5 = getIndexAndLocation(),
        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.


    if (history_createPath(nextLocation) !== history_createPath(location)) {
      handlePop();
    }
  });
  var action = Action.Pop;

  var _getIndexAndLocation6 = getIndexAndLocation(),
      index = _getIndexAndLocation6[0],
      location = _getIndexAndLocation6[1];

  var listeners = createEvents();
  var blockers = createEvents();

  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), '');
  }

  function getBaseHref() {
    var base = document.querySelector('base');
    var href = '';

    if (base && base.getAttribute('href')) {
      var url = window.location.href;
      var hashIndex = url.indexOf('#');
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }

    return href;
  }

  function createHref(to) {
    return getBaseHref() + '#' + (typeof to === 'string' ? to : history_createPath(to));
  }

  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }

    return readOnly(_extends({
      pathname: location.pathname,
      hash: '',
      search: ''
    }, typeof to === 'string' ? history_parsePath(to) : to, {
      state: state,
      key: createKey()
    }));
  }

  function getHistoryStateAndUrl(nextLocation, index) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index
    }, createHref(nextLocation)];
  }

  function allowTx(action, location, retry) {
    return !blockers.length || (blockers.call({
      action: action,
      location: location,
      retry: retry
    }), false);
  }

  function applyTx(nextAction) {
    action = nextAction;

    var _getIndexAndLocation7 = getIndexAndLocation();

    index = _getIndexAndLocation7[0];
    location = _getIndexAndLocation7[1];
    listeners.call({
      action: action,
      location: location
    });
  }

  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      push(to, state);
    }

     false ? 0 : void 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),
          historyState = _getHistoryStateAndUr3[0],
          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading
      // try...catch because iOS limits us to 100 pushState calls :/


      try {
        globalHistory.pushState(historyState, '', url);
      } catch (error) {
        // They are going to lose state here, but there is no real
        // way to warn them about it since the page will refresh...
        window.location.assign(url);
      }

      applyTx(nextAction);
    }
  }

  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      replace(to, state);
    }

     false ? 0 : void 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),
          historyState = _getHistoryStateAndUr4[0],
          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading


      globalHistory.replaceState(historyState, '', url);
      applyTx(nextAction);
    }
  }

  function go(delta) {
    globalHistory.go(delta);
  }

  var history = {
    get action() {
      return action;
    },

    get location() {
      return location;
    },

    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);

      if (blockers.length === 1) {
        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }

      return function () {
        unblock(); // Remove the beforeunload listener so the document may
        // still be salvageable in the pagehide event.
        // See https://html.spec.whatwg.org/#unloading-documents

        if (!blockers.length) {
          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory
 */


function history_createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }

  var _options3 = options,
      _options3$initialEntr = _options3.initialEntries,
      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,
      initialIndex = _options3.initialIndex;
  var entries = initialEntries.map(function (entry) {
    var location = readOnly(_extends({
      pathname: '/',
      search: '',
      hash: '',
      state: null,
      key: createKey()
    }, typeof entry === 'string' ? history_parsePath(entry) : entry));
     false ? 0 : void 0;
    return location;
  });
  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);
  var action = Action.Pop;
  var location = entries[index];
  var listeners = createEvents();
  var blockers = createEvents();

  function createHref(to) {
    return typeof to === 'string' ? to : history_createPath(to);
  }

  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }

    return readOnly(_extends({
      pathname: location.pathname,
      search: '',
      hash: ''
    }, typeof to === 'string' ? history_parsePath(to) : to, {
      state: state,
      key: createKey()
    }));
  }

  function allowTx(action, location, retry) {
    return !blockers.length || (blockers.call({
      action: action,
      location: location,
      retry: retry
    }), false);
  }

  function applyTx(nextAction, nextLocation) {
    action = nextAction;
    location = nextLocation;
    listeners.call({
      action: action,
      location: location
    });
  }

  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      push(to, state);
    }

     false ? 0 : void 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      applyTx(nextAction, nextLocation);
    }
  }

  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      replace(to, state);
    }

     false ? 0 : void 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      entries[index] = nextLocation;
      applyTx(nextAction, nextLocation);
    }
  }

  function go(delta) {
    var nextIndex = clamp(index + delta, 0, entries.length - 1);
    var nextAction = Action.Pop;
    var nextLocation = entries[nextIndex];

    function retry() {
      go(delta);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      index = nextIndex;
      applyTx(nextAction, nextLocation);
    }
  }

  var history = {
    get index() {
      return index;
    },

    get action() {
      return action;
    },

    get location() {
      return location;
    },

    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      return blockers.push(blocker);
    }
  };
  return history;
} ////////////////////////////////////////////////////////////////////////////////
// UTILS
////////////////////////////////////////////////////////////////////////////////


function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}

function promptBeforeUnload(event) {
  // Cancel the event.
  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.

  event.returnValue = '';
}

function createEvents() {
  var handlers = [];
  return {
    get length() {
      return handlers.length;
    },

    push: function push(fn) {
      handlers.push(fn);
      return function () {
        handlers = handlers.filter(function (handler) {
          return handler !== fn;
        });
      };
    },
    call: function call(arg) {
      handlers.forEach(function (fn) {
        return fn && fn(arg);
      });
    }
  };
}

function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath
 */


function history_createPath(_ref) {
  var _ref$pathname = _ref.pathname,
      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,
      _ref$search = _ref.search,
      search = _ref$search === void 0 ? '' : _ref$search,
      _ref$hash = _ref.hash,
      hash = _ref$hash === void 0 ? '' : _ref$hash;
  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;
  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath
 */


function history_parsePath(path) {
  var parsedPath = {};

  if (path) {
    var hashIndex = path.indexOf('#');

    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }

    var searchIndex = path.indexOf('?');

    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }

    if (path) {
      parsedPath.pathname = path;
    }
  }

  return parsedPath;
}


;// CONCATENATED MODULE: ./node_modules/react-router/index.js


/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



var NavigationContext = /*#__PURE__*/(0,react.createContext)(null);

if (false) {}

var LocationContext = /*#__PURE__*/(0,react.createContext)(null);

if (false) {}

var RouteContext = /*#__PURE__*/(0,react.createContext)({
  outlet: null,
  matches: []
});

if (false) {}

function invariant(cond, message) {
  if (!cond) throw new Error(message);
}

function react_router_warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}

var alreadyWarned = {};

function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     false ? 0 : void 0;
  }
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/docs/en/v6/api#generatepath
 */


function generatePath(path, params) {
  if (params === void 0) {
    params = {};
  }

  return path.replace(/:(\w+)/g, function (_, key) {
    !(params[key] != null) ?  false ? 0 : invariant(false) : void 0;
    return params[key];
  }).replace(/\/*\*$/, function (_) {
    return params["*"] == null ? "" : params["*"].replace(/^\/*/, "/");
  });
}
/**
 * A RouteMatch contains info about how a route matched a URL.
 */

/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchroutes
 */


function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }

  var location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  var pathname = stripBasename(location.pathname || "/", basename);

  if (pathname == null) {
    return null;
  }

  var branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  var matches = null;

  for (var i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }

  return matches;
}

function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }

  if (parentsMeta === void 0) {
    parentsMeta = [];
  }

  if (parentPath === void 0) {
    parentPath = "";
  }

  routes.forEach(function (route, index) {
    var meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route: route
    };

    if (meta.relativePath.startsWith("/")) {
      !meta.relativePath.startsWith(parentPath) ?  false ? 0 : invariant(false) : void 0;
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }

    var path = joinPaths([parentPath, meta.relativePath]);
    var routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      !(route.index !== true) ?  false ? 0 : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.


    if (route.path == null && !route.index) {
      return;
    }

    branches.push({
      path: path,
      score: computeScore(path, route.index),
      routesMeta: routesMeta
    });
  });
  return branches;
}

function rankRouteBranches(branches) {
  branches.sort(function (a, b) {
    return a.score !== b.score ? b.score - a.score // Higher score first
    : compareIndexes(a.routesMeta.map(function (meta) {
      return meta.childrenIndex;
    }), b.routesMeta.map(function (meta) {
      return meta.childrenIndex;
    }));
  });
}

var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = (/* unused pure expression or super */ null && (-2));

var isSplat = function isSplat(s) {
  return s === "*";
};

function computeScore(path, index) {
  var segments = path.split("/");
  var initialScore = segments.length;

  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }

  if (index) {
    initialScore += indexRouteValue;
  }

  return segments.filter(function (s) {
    return !isSplat(s);
  }).reduce(function (score, segment) {
    return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue);
  }, initialScore);
}

function compareIndexes(a, b) {
  var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) {
    return n === b[i];
  });
  return siblings ? // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}

function matchRouteBranch(branch, pathname) {
  var routesMeta = branch.routesMeta;
  var matchedParams = {};
  var matchedPathname = "/";
  var matches = [];

  for (var i = 0; i < routesMeta.length; ++i) {
    var meta = routesMeta[i];
    var end = i === routesMeta.length - 1;
    var remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    var match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    var route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route: route
    });

    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }

  return matches;
}
/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */

/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchpath
 */


function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }

  var _compilePath = compilePath(pattern.path, pattern.caseSensitive, pattern.end),
      _compilePath2 = _slicedToArray(_compilePath, 2),
      matcher = _compilePath2[0],
      paramNames = _compilePath2[1];

  var match = pathname.match(matcher);
  if (!match) return null;
  var matchedPathname = match[0];
  var pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  var captureGroups = match.slice(1);
  var params = paramNames.reduce(function (memo, paramName, index) {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      var splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }

    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params: params,
    pathname: matchedPathname,
    pathnameBase: pathnameBase,
    pattern: pattern
  };
}

function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }

  if (end === void 0) {
    end = true;
  }

   false ? 0 : void 0;
  var paramNames = [];
  var regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/:(\w+)/g, function (_, paramName) {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });

  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else {
    regexpSource += end ? "\\/*$" // When matching to the end, ignore trailing slashes
    : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts
    // parent routes to matching only their own words and nothing more, e.g. parent
    // route "/home" should not match "/home2".
    // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,
    // but do not consume the character in the matched path so they can match against
    // nested paths.
    "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
  }

  var matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}

function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
     false ? 0 : void 0;
    return value;
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/docs/en/v6/api#resolvepath
 */


function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }

  var _ref5 = typeof to === "string" ? parsePath(to) : to,
      toPathname = _ref5.pathname,
      _ref5$search = _ref5.search,
      search = _ref5$search === void 0 ? "" : _ref5$search,
      _ref5$hash = _ref5.hash,
      hash = _ref5$hash === void 0 ? "" : _ref5$hash;

  var pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname: pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}

function resolvePathname(relativePath, fromPathname) {
  var segments = fromPathname.replace(/\/+$/, "").split("/");
  var relativeSegments = relativePath.split("/");
  relativeSegments.forEach(function (segment) {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}

function resolveTo(toArg, routePathnames, locationPathname) {
  var to = typeof toArg === "string" ? parsePath(toArg) : toArg;
  var toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname; // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  var from;

  if (toPathname == null) {
    from = locationPathname;
  } else {
    var routePathnameIndex = routePathnames.length - 1;

    if (toPathname.startsWith("..")) {
      var toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.


    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  var path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original to value had one.

  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }

  return path;
}

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;

  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }

  var nextChar = pathname.charAt(basename.length);

  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }

  return pathname.slice(basename.length) || "/";
}

var joinPaths = function joinPaths(paths) {
  return paths.join("/").replace(/\/\/+/g, "/");
};

var normalizePathname = function normalizePathname(pathname) {
  return pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
};

var normalizeSearch = function normalizeSearch(search) {
  return !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
};

var normalizeHash = function normalizeHash(hash) {
  return !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
};
/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usehref
 */


function react_router_useHref(to) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;

  var _useContext = useContext(NavigationContext),
      basename = _useContext.basename,
      navigator = _useContext.navigator;

  var _useResolvedPath = react_router_useResolvedPath(to),
      hash = _useResolvedPath.hash,
      pathname = _useResolvedPath.pathname,
      search = _useResolvedPath.search;

  var joinedPathname = pathname;

  if (basename !== "/") {
    var toPathname = getToPathname(to);
    var endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }

  return navigator.createHref({
    pathname: joinedPathname,
    search: search,
    hash: hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext
 */


function useInRouterContext() {
  return (0,react.useContext)(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/docs/en/v6/api#uselocation
 */


function react_router_useLocation() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  return useContext(LocationContext).location;
}
/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype
 */


function useNavigationType() {
  return useContext(LocationContext).navigationType;
}
/**
 * Returns true if the URL for the given "to" value matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usematch
 */


function useMatch(pattern) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;

  var _useLocation = react_router_useLocation(),
      pathname = _useLocation.pathname;

  return useMemo(function () {
    return matchPath(pattern, pathname);
  }, [pathname, pattern]);
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigate
 */


function react_router_useNavigate() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;

  var _useContext2 = useContext(NavigationContext),
      basename = _useContext2.basename,
      navigator = _useContext2.navigator;

  var _useContext3 = useContext(RouteContext),
      matches = _useContext3.matches;

  var _useLocation2 = react_router_useLocation(),
      locationPathname = _useLocation2.pathname;

  var routePathnamesJson = JSON.stringify(matches.map(function (match) {
    return match.pathnameBase;
  }));
  var activeRef = useRef(false);
  useEffect(function () {
    activeRef.current = true;
  });
  var navigate = useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }

     false ? 0 : void 0;
    if (!activeRef.current) return;

    if (typeof to === "number") {
      navigator.go(to);
      return;
    }

    var path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);

    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }

    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}

var OutletContext = /*#__PURE__*/(/* unused pure expression or super */ null && (createContext(null)));
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext
 */

function useOutletContext() {
  return useContext(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useoutlet
 */


function useOutlet(context) {
  var outlet = useContext(RouteContext).outlet;

  if (outlet) {
    return /*#__PURE__*/createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }

  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useparams
 */


function useParams() {
  var _useContext4 = useContext(RouteContext),
      matches = _useContext4.matches;

  var routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath
 */


function react_router_useResolvedPath(to) {
  var _useContext5 = useContext(RouteContext),
      matches = _useContext5.matches;

  var _useLocation3 = react_router_useLocation(),
      locationPathname = _useLocation3.pathname;

  var routePathnamesJson = JSON.stringify(matches.map(function (match) {
    return match.pathnameBase;
  }));
  return useMemo(function () {
    return resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
  }, [to, routePathnamesJson, locationPathname]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useroutes
 */


function useRoutes(routes, locationArg) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;

  var _useContext6 = useContext(RouteContext),
      parentMatches = _useContext6.matches;

  var routeMatch = parentMatches[parentMatches.length - 1];
  var parentParams = routeMatch ? routeMatch.params : {};
  var parentPathname = routeMatch ? routeMatch.pathname : "/";
  var parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  var parentRoute = routeMatch && routeMatch.route;

  if (false) { var parentPath; }

  var locationFromContext = react_router_useLocation();
  var location;

  if (locationArg) {
    var _parsedLocationArg$pa;

    var parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  false ? 0 : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }

  var pathname = location.pathname || "/";
  var remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  var matches = matchRoutes(routes, {
    pathname: remainingPathname
  });

  if (false) {}

  return _renderMatches(matches && matches.map(function (match) {
    return Object.assign({}, match, {
      params: Object.assign({}, parentParams, match.params),
      pathname: joinPaths([parentPathnameBase, match.pathname]),
      pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
    });
  }), parentMatches);
}

function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }

  if (matches == null) return null;
  return matches.reduceRight(function (outlet, match, index) {
    return /*#__PURE__*/createElement(RouteContext.Provider, {
      children: match.route.element !== undefined ? match.route.element : outlet,
      value: {
        outlet: outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/docs/en/v6/api#memoryrouter
 */


function MemoryRouter(_ref) {
  var basename = _ref.basename,
      children = _ref.children,
      initialEntries = _ref.initialEntries,
      initialIndex = _ref.initialIndex;
  var historyRef = useRef();

  if (historyRef.current == null) {
    historyRef.current = createMemoryHistory({
      initialEntries: initialEntries,
      initialIndex: initialIndex
    });
  }

  var history = historyRef.current;

  var _useState = useState({
    action: history.action,
    location: history.location
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  useLayoutEffect(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/createElement(react_router_Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/docs/en/v6/api#navigate
 */


function Navigate(_ref2) {
  var to = _ref2.to,
      replace = _ref2.replace,
      state = _ref2.state;
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
   false ? 0 : void 0;
  var navigate = react_router_useNavigate();
  useEffect(function () {
    navigate(to, {
      replace: replace,
      state: state
    });
  });
  return null;
}
/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/docs/en/v6/api#outlet
 */


function Outlet(props) {
  return useOutlet(props.context);
}
/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#route
 */


function Route(_props) {
   false ? 0 : invariant(false);
}
/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/docs/en/v6/api#router
 */


function react_router_Router(_ref3) {
  var _ref3$basename = _ref3.basename,
      basenameProp = _ref3$basename === void 0 ? "/" : _ref3$basename,
      _ref3$children = _ref3.children,
      children = _ref3$children === void 0 ? null : _ref3$children,
      locationProp = _ref3.location,
      _ref3$navigationType = _ref3.navigationType,
      navigationType = _ref3$navigationType === void 0 ? Action.Pop : _ref3$navigationType,
      navigator = _ref3.navigator,
      _ref3$static = _ref3.static,
      staticProp = _ref3$static === void 0 ? false : _ref3$static;
  !!useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  var basename = normalizePathname(basenameProp);
  var navigationContext = (0,react.useMemo)(function () {
    return {
      basename: basename,
      navigator: navigator,
      static: staticProp
    };
  }, [basename, navigator, staticProp]);

  if (typeof locationProp === "string") {
    locationProp = history_parsePath(locationProp);
  }

  var _locationProp = locationProp,
      _locationProp$pathnam = _locationProp.pathname,
      pathname = _locationProp$pathnam === void 0 ? "/" : _locationProp$pathnam,
      _locationProp$search = _locationProp.search,
      search = _locationProp$search === void 0 ? "" : _locationProp$search,
      _locationProp$hash = _locationProp.hash,
      hash = _locationProp$hash === void 0 ? "" : _locationProp$hash,
      _locationProp$state = _locationProp.state,
      state = _locationProp$state === void 0 ? null : _locationProp$state,
      _locationProp$key = _locationProp.key,
      key = _locationProp$key === void 0 ? "default" : _locationProp$key;
  var location = (0,react.useMemo)(function () {
    var trailingPathname = stripBasename(pathname, basename);

    if (trailingPathname == null) {
      return null;
    }

    return {
      pathname: trailingPathname,
      search: search,
      hash: hash,
      state: state,
      key: key
    };
  }, [basename, pathname, search, hash, state, key]);
   false ? 0 : void 0;

  if (location == null) {
    return null;
  }

  return /*#__PURE__*/(0,react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/(0,react.createElement)(LocationContext.Provider, {
    children: children,
    value: {
      location: location,
      navigationType: navigationType
    }
  }));
}
/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#routes
 */


function Routes(_ref4) {
  var children = _ref4.children,
      location = _ref4.location;
  return useRoutes(createRoutesFromChildren(children), location);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren
 */


function createRoutesFromChildren(children) {
  var routes = [];
  Children.forEach(children, function (element) {
    if (! /*#__PURE__*/isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }

    if (element.type === Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children));
      return;
    }

    !(element.type === Route) ?  false ? 0 : invariant(false) : void 0;
    var route = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };

    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children);
    }

    routes.push(route);
  });
  return routes;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */


function renderMatches(matches) {
  return _renderMatches(matches);
}


;// CONCATENATED MODULE: ./node_modules/react-router-dom/index.js



/**
 * React Router DOM v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */





function react_router_dom_extends() {
  react_router_dom_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return react_router_dom_extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = (/* unused pure expression or super */ null && (["onClick", "reloadDocument", "replace", "state", "target", "to"])),
    _excluded2 = (/* unused pure expression or super */ null && (["aria-current", "caseSensitive", "className", "end", "style", "to", "children"]));

function react_router_dom_warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
} ////////////////////////////////////////////////////////////////////////////////
// COMPONENTS
////////////////////////////////////////////////////////////////////////////////

/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */


function BrowserRouter(_ref) {
  var basename = _ref.basename,
      children = _ref.children,
      window = _ref.window;
  var historyRef = (0,react.useRef)();

  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window
    });
  }

  var history = historyRef.current;

  var _useState = (0,react.useState)({
    action: history.action,
    location: history.location
  }),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  (0,react.useLayoutEffect)(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/(0,react.createElement)(react_router_Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */


function HashRouter(_ref2) {
  var basename = _ref2.basename,
      children = _ref2.children,
      window = _ref2.window;
  var historyRef = useRef();

  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window
    });
  }

  var history = historyRef.current;

  var _useState3 = useState({
    action: history.action,
    location: history.location
  }),
      _useState4 = _slicedToArray(_useState3, 2),
      state = _useState4[0],
      setState = _useState4[1];

  useLayoutEffect(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */


function HistoryRouter(_ref3) {
  var basename = _ref3.basename,
      children = _ref3.children,
      history = _ref3.history;

  var _useState5 = useState({
    action: history.action,
    location: history.location
  }),
      _useState6 = _slicedToArray(_useState5, 2),
      state = _useState6[0],
      setState = _useState6[1];

  useLayoutEffect(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

if (false) {}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = /*#__PURE__*/(/* unused pure expression or super */ null && (forwardRef(function LinkWithRef(_ref4, ref) {
  var onClick = _ref4.onClick,
      reloadDocument = _ref4.reloadDocument,
      _ref4$replace = _ref4.replace,
      replace = _ref4$replace === void 0 ? false : _ref4$replace,
      state = _ref4.state,
      target = _ref4.target,
      to = _ref4.to,
      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  var href = useHref(to);
  var internalOnClick = useLinkClickHandler(to, {
    replace: replace,
    state: state,
    target: target
  });

  function handleClick(event) {
    if (onClick) onClick(event);

    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    createElement("a", react_router_dom_extends({}, rest, {
      href: href,
      onClick: handleClick,
      ref: ref,
      target: target
    }))
  );
})));

if (false) {}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


var NavLink = /*#__PURE__*/(/* unused pure expression or super */ null && (forwardRef(function NavLinkWithRef(_ref5, ref) {
  var _ref5$ariaCurrent = _ref5["aria-current"],
      ariaCurrentProp = _ref5$ariaCurrent === void 0 ? "page" : _ref5$ariaCurrent,
      _ref5$caseSensitive = _ref5.caseSensitive,
      caseSensitive = _ref5$caseSensitive === void 0 ? false : _ref5$caseSensitive,
      _ref5$className = _ref5.className,
      classNameProp = _ref5$className === void 0 ? "" : _ref5$className,
      _ref5$end = _ref5.end,
      end = _ref5$end === void 0 ? false : _ref5$end,
      styleProp = _ref5.style,
      to = _ref5.to,
      children = _ref5.children,
      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);

  var location = useLocation();
  var path = useResolvedPath(to);
  var locationPathname = location.pathname;
  var toPathname = path.pathname;

  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }

  var isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  var ariaCurrent = isActive ? ariaCurrentProp : undefined;
  var className;

  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive: isActive
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }

  var style = typeof styleProp === "function" ? styleProp({
    isActive: isActive
  }) : styleProp;
  return /*#__PURE__*/createElement(Link, react_router_dom_extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
  }), typeof children === "function" ? children({
    isActive: isActive
  }) : children);
})));

if (false) {} ////////////////////////////////////////////////////////////////////////////////
// HOOKS
////////////////////////////////////////////////////////////////////////////////

/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */


function useLinkClickHandler(to, _temp) {
  var _ref6 = _temp === void 0 ? {} : _temp,
      target = _ref6.target,
      replaceProp = _ref6.replace,
      state = _ref6.state;

  var navigate = useNavigate();
  var location = useLocation();
  var path = useResolvedPath(to);
  return useCallback(function (event) {
    if (event.button === 0 && ( // Ignore everything but left clicks
    !target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // Ignore clicks with modifier keys
    ) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here.

      var replace = !!replaceProp || createPath(location) === createPath(path);
      navigate(to, {
        replace: replace,
        state: state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */


function useSearchParams(defaultInit) {
   false ? 0 : void 0;
  var defaultSearchParamsRef = useRef(createSearchParams(defaultInit));
  var location = useLocation();
  var searchParams = useMemo(function () {
    var searchParams = createSearchParams(location.search);

    var _iterator = _createForOfIteratorHelper(defaultSearchParamsRef.current.keys()),
        _step;

    try {
      var _loop = function _loop() {
        var key = _step.value;

        if (!searchParams.has(key)) {
          defaultSearchParamsRef.current.getAll(key).forEach(function (value) {
            searchParams.append(key, value);
          });
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return searchParams;
  }, [location.search]);
  var navigate = useNavigate();
  var setSearchParams = useCallback(function (nextInit, navigateOptions) {
    navigate("?" + createSearchParams(nextInit), navigateOptions);
  }, [navigate]);
  return [searchParams, setSearchParams];
}
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */


function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }

  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce(function (memo, key) {
    var value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(function (v) {
      return [key, v];
    }) : [[key, value]]);
  }, []));
}


;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js


function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function objectSpread2_objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./node_modules/clsx/dist/clsx.m.js
function r(e) {
  var t,
      f,
      n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) {
    e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (t in e) {
    e[t] && (n && (n += " "), n += t);
  }
  return n;
}

function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length;) {
    (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  }

  return n;
}
/* harmony default export */ var clsx_m = (clsx);
;// CONCATENATED MODULE: ./node_modules/react-toastify/dist/react-toastify.esm.mjs





var react_toastify_esm_excluded = ["theme", "type"],
    react_toastify_esm_excluded2 = ["delay", "staleId"];



function isNum(v) {
  return typeof v === 'number' && !isNaN(v);
}

function isBool(v) {
  return typeof v === 'boolean';
}

function isStr(v) {
  return typeof v === 'string';
}

function isFn(v) {
  return typeof v === 'function';
}

function parseClassName(v) {
  return isStr(v) || isFn(v) ? v : null;
}

function isToastIdValid(toastId) {
  return toastId != null;
}

function getAutoCloseDelay(toastAutoClose, containerAutoClose) {
  return toastAutoClose === false || isNum(toastAutoClose) && toastAutoClose > 0 ? toastAutoClose : containerAutoClose;
}

function canBeRendered(content) {
  return (0,react.isValidElement)(content) || isStr(content) || isFn(content) || isNum(content);
}

var POSITION = {
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right',
  TOP_CENTER: 'top-center',
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  BOTTOM_CENTER: 'bottom-center'
};
var TYPE = {
  INFO: 'info',
  SUCCESS: 'success',
  WARNING: 'warning',
  ERROR: 'error',
  DEFAULT: 'default'
};
/**
 * Used to collapse toast after exit animation
 */

function collapseToast(node, done, duration
/* Default.COLLAPSE_DURATION */
) {
  if (duration === void 0) {
    duration = 300;
  }

  var scrollHeight = node.scrollHeight,
      style = node.style;
  requestAnimationFrame(function () {
    style.minHeight = 'initial';
    style.height = scrollHeight + 'px';
    style.transition = "all " + duration + "ms";
    requestAnimationFrame(function () {
      style.height = '0';
      style.padding = '0';
      style.margin = '0';
      setTimeout(done, duration);
    });
  });
}
/**
 * Css animation that just work.
 * You could use animate.css for instance
 *
 *
 * ```
 * cssTransition({
 *   enter: "animate__animated animate__bounceIn",
 *   exit: "animate__animated animate__bounceOut"
 * })
 * ```
 *
 */


function cssTransition(_ref) {
  var enter = _ref.enter,
      exit = _ref.exit,
      _ref$appendPosition = _ref.appendPosition,
      appendPosition = _ref$appendPosition === void 0 ? false : _ref$appendPosition,
      _ref$collapse = _ref.collapse,
      collapse = _ref$collapse === void 0 ? true : _ref$collapse,
      _ref$collapseDuration = _ref.collapseDuration,
      collapseDuration = _ref$collapseDuration === void 0 ? 300 : _ref$collapseDuration;
  return function ToastTransition(_ref2) {
    var children = _ref2.children,
        position = _ref2.position,
        preventExitTransition = _ref2.preventExitTransition,
        done = _ref2.done,
        nodeRef = _ref2.nodeRef,
        isIn = _ref2.isIn;
    var enterClassName = appendPosition ? enter + "--" + position : enter;
    var exitClassName = appendPosition ? exit + "--" + position : exit;
    var animationStep = (0,react.useRef)(0
    /* AnimationStep.Enter */
    );
    (0,react.useLayoutEffect)(function () {
      var node = nodeRef.current;
      var classToToken = enterClassName.split(' ');

      var onEntered = function onEntered(e) {
        if (e.target !== nodeRef.current) return;
        node.dispatchEvent(new Event("d"
        /* SyntheticEvent.ENTRANCE_ANIMATION_END */
        ));
        node.removeEventListener('animationend', onEntered);
        node.removeEventListener('animationcancel', onEntered);

        if (animationStep.current === 0
        /* AnimationStep.Enter */
        && e.type !== 'animationcancel') {
          var _node$classList;

          (_node$classList = node.classList).remove.apply(_node$classList, _toConsumableArray(classToToken));
        }
      };

      var onEnter = function onEnter() {
        var _node$classList2;

        (_node$classList2 = node.classList).add.apply(_node$classList2, _toConsumableArray(classToToken));

        node.addEventListener('animationend', onEntered);
        node.addEventListener('animationcancel', onEntered);
      };

      onEnter();
    }, []);
    (0,react.useEffect)(function () {
      var node = nodeRef.current;

      var onExited = function onExited() {
        node.removeEventListener('animationend', onExited);
        collapse ? collapseToast(node, done, collapseDuration) : done();
      };

      var onExit = function onExit() {
        animationStep.current = 1
        /* AnimationStep.Exit */
        ;
        node.className += " " + exitClassName;
        node.addEventListener('animationend', onExited);
      };

      if (!isIn) preventExitTransition ? onExited() : onExit();
    }, [isIn]);
    return react.createElement(react.Fragment, null, children);
  };
}

function toToastItem(toast, status) {
  return {
    content: toast.content,
    containerId: toast.props.containerId,
    id: toast.props.toastId,
    theme: toast.props.theme,
    type: toast.props.type,
    data: toast.props.data || {},
    isLoading: toast.props.isLoading,
    icon: toast.props.icon,
    status: status
  };
}

var eventManager = {
  list: new Map(),
  emitQueue: new Map(),
  on: function on(event, callback) {
    this.list.has(event) || this.list.set(event, []);
    this.list.get(event).push(callback);
    return this;
  },
  off: function off(event, callback) {
    if (callback) {
      var cb = this.list.get(event).filter(function (cb) {
        return cb !== callback;
      });
      this.list.set(event, cb);
      return this;
    }

    this.list.delete(event);
    return this;
  },
  cancelEmit: function cancelEmit(event) {
    var timers = this.emitQueue.get(event);

    if (timers) {
      timers.forEach(clearTimeout);
      this.emitQueue.delete(event);
    }

    return this;
  },

  /**
   * Enqueue the event at the end of the call stack
   * Doing so let the user call toast as follow:
   * toast('1')
   * toast('2')
   * toast('3')
   * Without setTimemout the code above will not work
   */
  emit: function emit(event) {
    var _arguments = arguments,
        _this = this;

    this.list.has(event) && this.list.get(event).forEach(function (callback) {
      var timer = setTimeout(function () {
        // @ts-ignore
        callback.apply(void 0, _toConsumableArray([].slice.call(_arguments, 1)));
      }, 0);
      _this.emitQueue.has(event) || _this.emitQueue.set(event, []);

      _this.emitQueue.get(event).push(timer);
    });
  }
};

var Svg = function Svg(_ref) {
  var theme = _ref.theme,
      type = _ref.type,
      rest = _objectWithoutProperties(_ref, react_toastify_esm_excluded);

  return react.createElement("svg", objectSpread2_objectSpread2({
    viewBox: "0 0 24 24",
    width: "100%",
    height: "100%",
    fill: theme === 'colored' ? 'currentColor' : "var(--toastify-icon-color-" + type + ")"
  }, rest));
};

function Warning(props) {
  return react.createElement(Svg, objectSpread2_objectSpread2({}, props), react.createElement("path", {
    d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
  }));
}

function Info(props) {
  return react.createElement(Svg, objectSpread2_objectSpread2({}, props), react.createElement("path", {
    d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
  }));
}

function Success(props) {
  return react.createElement(Svg, objectSpread2_objectSpread2({}, props), react.createElement("path", {
    d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
  }));
}

function react_toastify_esm_Error(props) {
  return react.createElement(Svg, objectSpread2_objectSpread2({}, props), react.createElement("path", {
    d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
  }));
}

function Spinner() {
  return react.createElement("div", {
    className: "Toastify"
    /* Default.CSS_NAMESPACE */
    + "__spinner"
  });
}

var Icons = {
  info: Info,
  warning: Warning,
  success: Success,
  error: react_toastify_esm_Error,
  spinner: Spinner
};

var maybeIcon = function maybeIcon(type) {
  return type in Icons;
};

function getIcon(_ref2) {
  var theme = _ref2.theme,
      type = _ref2.type,
      isLoading = _ref2.isLoading,
      icon = _ref2.icon;
  var Icon = null;
  var iconProps = {
    theme: theme,
    type: type
  };
  if (icon === false) ;else if (isFn(icon)) {
    Icon = icon(iconProps);
  } else if ((0,react.isValidElement)(icon)) {
    Icon = (0,react.cloneElement)(icon, iconProps);
  } else if (isStr(icon) || isNum(icon)) {
    Icon = icon;
  } else if (isLoading) {
    Icon = Icons.spinner();
  } else if (maybeIcon(type)) {
    Icon = Icons[type](iconProps);
  }
  return Icon;
}

function useToastContainer(props) {
  var _useReducer = (0,react.useReducer)(function (x) {
    return x + 1;
  }, 0),
      _useReducer2 = slicedToArray_slicedToArray(_useReducer, 2),
      forceUpdate = _useReducer2[1];

  var _useState = (0,react.useState)([]),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      toastIds = _useState2[0],
      setToastIds = _useState2[1];

  var containerRef = (0,react.useRef)(null);
  var toastToRender = (0,react.useRef)(new Map()).current;

  var isToastActive = function isToastActive(id) {
    return toastIds.indexOf(id) !== -1;
  };

  var instance = (0,react.useRef)({
    toastKey: 1,
    displayedToast: 0,
    count: 0,
    queue: [],
    props: props,
    containerId: null,
    isToastActive: isToastActive,
    getToast: function getToast(id) {
      return toastToRender.get(id);
    }
  }).current;
  (0,react.useEffect)(function () {
    instance.containerId = props.containerId;
    eventManager.cancelEmit(3
    /* Event.WillUnmount */
    ).on(0
    /* Event.Show */
    , buildToast).on(1
    /* Event.Clear */
    , function (toastId) {
      return containerRef.current && removeToast(toastId);
    }).on(5
    /* Event.ClearWaitingQueue */
    , clearWaitingQueue).emit(2
    /* Event.DidMount */
    , instance);
    return function () {
      toastToRender.clear();
      eventManager.emit(3
      /* Event.WillUnmount */
      , instance);
    };
  }, []);
  (0,react.useEffect)(function () {
    instance.props = props;
    instance.isToastActive = isToastActive;
    instance.displayedToast = toastIds.length;
  });

  function clearWaitingQueue(_ref) {
    var containerId = _ref.containerId;
    var limit = instance.props.limit;

    if (limit && (!containerId || instance.containerId === containerId)) {
      instance.count -= instance.queue.length;
      instance.queue = [];
    }
  }

  function removeToast(toastId) {
    setToastIds(function (state) {
      return isToastIdValid(toastId) ? state.filter(function (id) {
        return id !== toastId;
      }) : [];
    });
  }

  function dequeueToast() {
    var _instance$queue$shift = instance.queue.shift(),
        toastContent = _instance$queue$shift.toastContent,
        toastProps = _instance$queue$shift.toastProps,
        staleId = _instance$queue$shift.staleId;

    appendToast(toastContent, toastProps, staleId);
  }
  /**
   * check if a container is attached to the dom
   * check for multi-container, build only if associated
   * check for duplicate toastId if no update
   */


  function isNotValid(options) {
    return !containerRef.current || instance.props.enableMultiContainer && options.containerId !== instance.props.containerId || toastToRender.has(options.toastId) && options.updateId == null;
  } // this function and all the function called inside needs to rely on refs


  function buildToast(content, _ref2) {
    var delay = _ref2.delay,
        staleId = _ref2.staleId,
        options = _objectWithoutProperties(_ref2, react_toastify_esm_excluded2);

    if (!canBeRendered(content) || isNotValid(options)) return;
    var toastId = options.toastId,
        updateId = options.updateId,
        data = options.data;
    var props = instance.props;

    var closeToast = function closeToast() {
      return removeToast(toastId);
    };

    var isNotAnUpdate = updateId == null;
    if (isNotAnUpdate) instance.count++;
    var toastProps = {
      toastId: toastId,
      updateId: updateId,
      data: data,
      containerId: options.containerId,
      isLoading: options.isLoading,
      theme: options.theme || props.theme,
      icon: options.icon != null ? options.icon : props.icon,
      isIn: false,
      key: options.key || instance.toastKey++,
      type: options.type,
      closeToast: closeToast,
      closeButton: options.closeButton,
      rtl: props.rtl,
      position: options.position || props.position,
      transition: options.transition || props.transition,
      className: parseClassName(options.className || props.toastClassName),
      bodyClassName: parseClassName(options.bodyClassName || props.bodyClassName),
      style: options.style || props.toastStyle,
      bodyStyle: options.bodyStyle || props.bodyStyle,
      onClick: options.onClick || props.onClick,
      pauseOnHover: isBool(options.pauseOnHover) ? options.pauseOnHover : props.pauseOnHover,
      pauseOnFocusLoss: isBool(options.pauseOnFocusLoss) ? options.pauseOnFocusLoss : props.pauseOnFocusLoss,
      draggable: isBool(options.draggable) ? options.draggable : props.draggable,
      draggablePercent: options.draggablePercent || props.draggablePercent,
      draggableDirection: options.draggableDirection || props.draggableDirection,
      closeOnClick: isBool(options.closeOnClick) ? options.closeOnClick : props.closeOnClick,
      progressClassName: parseClassName(options.progressClassName || props.progressClassName),
      progressStyle: options.progressStyle || props.progressStyle,
      autoClose: options.isLoading ? false : getAutoCloseDelay(options.autoClose, props.autoClose),
      hideProgressBar: isBool(options.hideProgressBar) ? options.hideProgressBar : props.hideProgressBar,
      progress: options.progress,
      role: options.role || props.role,
      deleteToast: function deleteToast() {
        var removed = toToastItem(toastToRender.get(toastId), 'removed');
        toastToRender.delete(toastId);
        eventManager.emit(4
        /* Event.Change */
        , removed);
        var queueLen = instance.queue.length;
        instance.count = isToastIdValid(toastId) ? instance.count - 1 : instance.count - instance.displayedToast;
        if (instance.count < 0) instance.count = 0;

        if (queueLen > 0) {
          var freeSlot = isToastIdValid(toastId) ? 1 : instance.props.limit;

          if (queueLen === 1 || freeSlot === 1) {
            instance.displayedToast++;
            dequeueToast();
          } else {
            var toDequeue = freeSlot > queueLen ? queueLen : freeSlot;
            instance.displayedToast = toDequeue;

            for (var i = 0; i < toDequeue; i++) {
              dequeueToast();
            }
          }
        } else {
          forceUpdate();
        }
      }
    };
    toastProps.iconOut = getIcon(toastProps);
    if (isFn(options.onOpen)) toastProps.onOpen = options.onOpen;
    if (isFn(options.onClose)) toastProps.onClose = options.onClose;
    toastProps.closeButton = props.closeButton;

    if (options.closeButton === false || canBeRendered(options.closeButton)) {
      toastProps.closeButton = options.closeButton;
    } else if (options.closeButton === true) {
      toastProps.closeButton = canBeRendered(props.closeButton) ? props.closeButton : true;
    }

    var toastContent = content;

    if ((0,react.isValidElement)(content) && !isStr(content.type)) {
      toastContent = (0,react.cloneElement)(content, {
        closeToast: closeToast,
        toastProps: toastProps,
        data: data
      });
    } else if (isFn(content)) {
      toastContent = content({
        closeToast: closeToast,
        toastProps: toastProps,
        data: data
      });
    } // not handling limit + delay by design. Waiting for user feedback first


    if (props.limit && props.limit > 0 && instance.count > props.limit && isNotAnUpdate) {
      instance.queue.push({
        toastContent: toastContent,
        toastProps: toastProps,
        staleId: staleId
      });
    } else if (isNum(delay)) {
      setTimeout(function () {
        appendToast(toastContent, toastProps, staleId);
      }, delay);
    } else {
      appendToast(toastContent, toastProps, staleId);
    }
  }

  function appendToast(content, toastProps, staleId) {
    var toastId = toastProps.toastId;
    if (staleId) toastToRender.delete(staleId);
    var toast = {
      content: content,
      props: toastProps
    };
    toastToRender.set(toastId, toast);
    setToastIds(function (state) {
      return [].concat(_toConsumableArray(state), [toastId]).filter(function (id) {
        return id !== staleId;
      });
    });
    eventManager.emit(4
    /* Event.Change */
    , toToastItem(toast, toast.props.updateId == null ? 'added' : 'updated'));
  }

  function getToastToRender(cb) {
    var toRender = new Map();
    var collection = Array.from(toastToRender.values());
    if (props.newestOnTop) collection.reverse();
    collection.forEach(function (toast) {
      var position = toast.props.position;
      toRender.has(position) || toRender.set(position, []);
      toRender.get(position).push(toast);
    });
    return Array.from(toRender, function (p) {
      return cb(p[0], p[1]);
    });
  }

  return {
    getToastToRender: getToastToRender,
    containerRef: containerRef,
    isToastActive: isToastActive
  };
}

function getX(e) {
  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX;
}

function getY(e) {
  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY;
}

function useToast(props) {
  var _useState3 = (0,react.useState)(false),
      _useState4 = slicedToArray_slicedToArray(_useState3, 2),
      isRunning = _useState4[0],
      setIsRunning = _useState4[1];

  var _useState5 = (0,react.useState)(false),
      _useState6 = slicedToArray_slicedToArray(_useState5, 2),
      preventExitTransition = _useState6[0],
      setPreventExitTransition = _useState6[1];

  var toastRef = (0,react.useRef)(null);
  var drag = (0,react.useRef)({
    start: 0,
    x: 0,
    y: 0,
    delta: 0,
    removalDistance: 0,
    canCloseOnClick: true,
    canDrag: false,
    boundingRect: null,
    didMove: false
  }).current;
  var syncProps = (0,react.useRef)(props);
  var autoClose = props.autoClose,
      pauseOnHover = props.pauseOnHover,
      closeToast = props.closeToast,
      onClick = props.onClick,
      closeOnClick = props.closeOnClick;
  (0,react.useEffect)(function () {
    syncProps.current = props;
  });
  (0,react.useEffect)(function () {
    if (toastRef.current) toastRef.current.addEventListener("d"
    /* SyntheticEvent.ENTRANCE_ANIMATION_END */
    , playToast, {
      once: true
    });
    if (isFn(props.onOpen)) props.onOpen((0,react.isValidElement)(props.children) && props.children.props);
    return function () {
      var props = syncProps.current;
      if (isFn(props.onClose)) props.onClose((0,react.isValidElement)(props.children) && props.children.props);
    };
  }, []);
  (0,react.useEffect)(function () {
    props.pauseOnFocusLoss && bindFocusEvents();
    return function () {
      props.pauseOnFocusLoss && unbindFocusEvents();
    };
  }, [props.pauseOnFocusLoss]);

  function onDragStart(e) {
    if (props.draggable) {
      bindDragEvents();
      var _toast = toastRef.current;
      drag.canCloseOnClick = true;
      drag.canDrag = true;
      drag.boundingRect = _toast.getBoundingClientRect();
      _toast.style.transition = '';
      drag.x = getX(e.nativeEvent);
      drag.y = getY(e.nativeEvent);

      if (props.draggableDirection === "x"
      /* Direction.X */
      ) {
        drag.start = drag.x;
        drag.removalDistance = _toast.offsetWidth * (props.draggablePercent / 100);
      } else {
        drag.start = drag.y;
        drag.removalDistance = _toast.offsetHeight * (props.draggablePercent === 80
        /* Default.DRAGGABLE_PERCENT */
        ? props.draggablePercent * 1.5 : props.draggablePercent / 100);
      }
    }
  }

  function onDragTransitionEnd() {
    if (drag.boundingRect) {
      var _drag$boundingRect = drag.boundingRect,
          top = _drag$boundingRect.top,
          bottom = _drag$boundingRect.bottom,
          left = _drag$boundingRect.left,
          right = _drag$boundingRect.right;

      if (props.pauseOnHover && drag.x >= left && drag.x <= right && drag.y >= top && drag.y <= bottom) {
        pauseToast();
      } else {
        playToast();
      }
    }
  }

  function playToast() {
    setIsRunning(true);
  }

  function pauseToast() {
    setIsRunning(false);
  }

  function bindFocusEvents() {
    if (!document.hasFocus()) pauseToast();
    window.addEventListener('focus', playToast);
    window.addEventListener('blur', pauseToast);
  }

  function unbindFocusEvents() {
    window.removeEventListener('focus', playToast);
    window.removeEventListener('blur', pauseToast);
  }

  function bindDragEvents() {
    drag.didMove = false;
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);
    document.addEventListener('touchmove', onDragMove);
    document.addEventListener('touchend', onDragEnd);
  }

  function unbindDragEvents() {
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', onDragEnd);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('touchend', onDragEnd);
  }

  function onDragMove(e) {
    var toast = toastRef.current;

    if (drag.canDrag && toast) {
      drag.didMove = true;
      if (isRunning) pauseToast();
      drag.x = getX(e);
      drag.y = getY(e);

      if (props.draggableDirection === "x"
      /* Direction.X */
      ) {
        drag.delta = drag.x - drag.start;
      } else {
        drag.delta = drag.y - drag.start;
      } // prevent false positif during a toast click


      if (drag.start !== drag.x) drag.canCloseOnClick = false;
      toast.style.transform = "translate" + props.draggableDirection + "(" + drag.delta + "px)";
      toast.style.opacity = "" + (1 - Math.abs(drag.delta / drag.removalDistance));
    }
  }

  function onDragEnd() {
    unbindDragEvents();
    var toast = toastRef.current;

    if (drag.canDrag && drag.didMove && toast) {
      drag.canDrag = false;

      if (Math.abs(drag.delta) > drag.removalDistance) {
        setPreventExitTransition(true);
        props.closeToast();
        return;
      }

      toast.style.transition = 'transform 0.2s, opacity 0.2s';
      toast.style.transform = "translate" + props.draggableDirection + "(0)";
      toast.style.opacity = '1';
    }
  }

  var eventHandlers = {
    onMouseDown: onDragStart,
    onTouchStart: onDragStart,
    onMouseUp: onDragTransitionEnd,
    onTouchEnd: onDragTransitionEnd
  };

  if (autoClose && pauseOnHover) {
    eventHandlers.onMouseEnter = pauseToast;
    eventHandlers.onMouseLeave = playToast;
  } // prevent toast from closing when user drags the toast


  if (closeOnClick) {
    eventHandlers.onClick = function (e) {
      onClick && onClick(e);
      drag.canCloseOnClick && closeToast();
    };
  }

  return {
    playToast: playToast,
    pauseToast: pauseToast,
    isRunning: isRunning,
    preventExitTransition: preventExitTransition,
    toastRef: toastRef,
    eventHandlers: eventHandlers
  };
}

function CloseButton(_ref) {
  var closeToast = _ref.closeToast,
      theme = _ref.theme,
      _ref$ariaLabel = _ref.ariaLabel,
      ariaLabel = _ref$ariaLabel === void 0 ? 'close' : _ref$ariaLabel;
  return react.createElement("button", {
    className: "Toastify"
    /* Default.CSS_NAMESPACE */
    + "__close-button " + "Toastify"
    /* Default.CSS_NAMESPACE */
    + "__close-button--" + theme,
    type: "button",
    onClick: function onClick(e) {
      e.stopPropagation();
      closeToast(e);
    },
    "aria-label": ariaLabel
  }, react.createElement("svg", {
    "aria-hidden": "true",
    viewBox: "0 0 14 16"
  }, react.createElement("path", {
    fillRule: "evenodd",
    d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
  })));
}

function ProgressBar(_ref) {
  var delay = _ref.delay,
      isRunning = _ref.isRunning,
      closeToast = _ref.closeToast,
      type = _ref.type,
      hide = _ref.hide,
      className = _ref.className,
      userStyle = _ref.style,
      controlledProgress = _ref.controlledProgress,
      progress = _ref.progress,
      rtl = _ref.rtl,
      isIn = _ref.isIn,
      theme = _ref.theme;

  var style = objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, userStyle), {}, {
    animationDuration: delay + "ms",
    animationPlayState: isRunning ? 'running' : 'paused',
    opacity: hide ? 0 : 1
  });

  if (controlledProgress) style.transform = "scaleX(" + progress + ")";
  var defaultClassName = clsx_m("Toastify"
  /* Default.CSS_NAMESPACE */
  + "__progress-bar", controlledProgress ? "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__progress-bar--controlled" : "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__progress-bar--animated", "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__progress-bar-theme--" + theme, "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__progress-bar--" + type, _defineProperty({}, "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__progress-bar--rtl", rtl));
  var classNames = isFn(className) ? className({
    rtl: rtl,
    type: type,
    defaultClassName: defaultClassName
  }) : clsx_m(defaultClassName, className); // 🧐 controlledProgress is derived from progress
  // so if controlledProgress is set
  // it means that this is also the case for progress

  var animationEvent = _defineProperty({}, controlledProgress && progress >= 1 ? 'onTransitionEnd' : 'onAnimationEnd', controlledProgress && progress < 1 ? null : function () {
    isIn && closeToast();
  }); // TODO: add aria-valuenow, aria-valuemax, aria-valuemin


  return react.createElement("div", objectSpread2_objectSpread2({
    role: "progressbar",
    "aria-hidden": hide ? 'true' : 'false',
    "aria-label": "notification timer",
    className: classNames,
    style: style
  }, animationEvent));
}

ProgressBar.defaultProps = {
  type: TYPE.DEFAULT,
  hide: false
};

var Toast = function Toast(props) {
  var _useToast = useToast(props),
      isRunning = _useToast.isRunning,
      preventExitTransition = _useToast.preventExitTransition,
      toastRef = _useToast.toastRef,
      eventHandlers = _useToast.eventHandlers;

  var closeButton = props.closeButton,
      children = props.children,
      autoClose = props.autoClose,
      onClick = props.onClick,
      type = props.type,
      hideProgressBar = props.hideProgressBar,
      closeToast = props.closeToast,
      Transition = props.transition,
      position = props.position,
      className = props.className,
      style = props.style,
      bodyClassName = props.bodyClassName,
      bodyStyle = props.bodyStyle,
      progressClassName = props.progressClassName,
      progressStyle = props.progressStyle,
      updateId = props.updateId,
      role = props.role,
      progress = props.progress,
      rtl = props.rtl,
      toastId = props.toastId,
      deleteToast = props.deleteToast,
      isIn = props.isIn,
      isLoading = props.isLoading,
      iconOut = props.iconOut,
      theme = props.theme;
  var defaultClassName = clsx_m("Toastify"
  /* Default.CSS_NAMESPACE */
  + "__toast", "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__toast-theme--" + theme, "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__toast--" + type, _defineProperty({}, "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__toast--rtl", rtl));
  var cssClasses = isFn(className) ? className({
    rtl: rtl,
    position: position,
    type: type,
    defaultClassName: defaultClassName
  }) : clsx_m(defaultClassName, className);
  var isProgressControlled = !!progress;
  var closeButtonProps = {
    closeToast: closeToast,
    type: type,
    theme: theme
  };
  var Close = null;
  if (closeButton === false) ;else if (isFn(closeButton)) {
    Close = closeButton(closeButtonProps);
  } else if (react.isValidElement(closeButton)) {
    Close = react.cloneElement(closeButton, closeButtonProps);
  } else {
    Close = CloseButton(closeButtonProps);
  }
  return react.createElement(Transition, {
    isIn: isIn,
    done: deleteToast,
    position: position,
    preventExitTransition: preventExitTransition,
    nodeRef: toastRef
  }, react.createElement("div", objectSpread2_objectSpread2(objectSpread2_objectSpread2({
    id: toastId,
    onClick: onClick,
    className: cssClasses
  }, eventHandlers), {}, {
    style: style,
    ref: toastRef
  }), react.createElement("div", objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, isIn && {
    role: role
  }), {}, {
    className: isFn(bodyClassName) ? bodyClassName({
      type: type
    }) : clsx_m("Toastify"
    /* Default.CSS_NAMESPACE */
    + "__toast-body", bodyClassName),
    style: bodyStyle
  }), iconOut != null && react.createElement("div", {
    className: clsx_m("Toastify"
    /* Default.CSS_NAMESPACE */
    + "__toast-icon", _defineProperty({}, "Toastify"
    /* Default.CSS_NAMESPACE */
    + "--animate-icon " + "Toastify"
    /* Default.CSS_NAMESPACE */
    + "__zoom-enter", !isLoading))
  }, iconOut), react.createElement("div", null, children)), Close, (autoClose || isProgressControlled) && react.createElement(ProgressBar, objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, updateId && !isProgressControlled ? {
    key: "pb-" + updateId
  } : {}), {}, {
    rtl: rtl,
    theme: theme,
    delay: autoClose,
    isRunning: isRunning,
    isIn: isIn,
    closeToast: closeToast,
    hide: hideProgressBar,
    type: type,
    style: progressStyle,
    className: progressClassName,
    controlledProgress: isProgressControlled,
    progress: progress
  }))));
};

var Bounce = cssTransition({
  enter: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__bounce-enter",
  exit: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__bounce-exit",
  appendPosition: true
});
var Slide = cssTransition({
  enter: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__slide-enter",
  exit: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__slide-exit",
  appendPosition: true
});
var Zoom = cssTransition({
  enter: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__zoom-enter",
  exit: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__zoom-exit"
});
var Flip = cssTransition({
  enter: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__flip-enter",
  exit: "Toastify"
  /* Default.CSS_NAMESPACE */
  + "--animate " + "Toastify"
  /* Default.CSS_NAMESPACE */
  + "__flip-exit"
}); // https://github.com/yannickcr/eslint-plugin-react/issues/3140

var ToastContainer = (0,react.forwardRef)(function (props, ref) {
  var _useToastContainer = useToastContainer(props),
      getToastToRender = _useToastContainer.getToastToRender,
      containerRef = _useToastContainer.containerRef,
      isToastActive = _useToastContainer.isToastActive;

  var className = props.className,
      style = props.style,
      rtl = props.rtl,
      containerId = props.containerId;

  function getClassName(position) {
    var defaultClassName = clsx_m("Toastify"
    /* Default.CSS_NAMESPACE */
    + "__toast-container", "Toastify"
    /* Default.CSS_NAMESPACE */
    + "__toast-container--" + position, _defineProperty({}, "Toastify"
    /* Default.CSS_NAMESPACE */
    + "__toast-container--rtl", rtl));
    return isFn(className) ? className({
      position: position,
      rtl: rtl,
      defaultClassName: defaultClassName
    }) : clsx_m(defaultClassName, parseClassName(className));
  }

  (0,react.useEffect)(function () {
    if (ref) {
      ref.current = containerRef.current;
    }
  }, []);
  return react.createElement("div", {
    ref: containerRef,
    className: "Toastify"
    /* Default.CSS_NAMESPACE */
    ,
    id: containerId
  }, getToastToRender(function (position, toastList) {
    var containerStyle = !toastList.length ? objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, style), {}, {
      pointerEvents: 'none'
    }) : objectSpread2_objectSpread2({}, style);
    return react.createElement("div", {
      className: getClassName(position),
      style: containerStyle,
      key: "container-" + position
    }, toastList.map(function (_ref, i) {
      var content = _ref.content,
          toastProps = _ref.props;
      return react.createElement(Toast, objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, toastProps), {}, {
        isIn: isToastActive(toastProps.toastId),
        style: objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, toastProps.style), {}, {
          '--nth': i + 1,
          '--len': toastList.length
        }),
        key: "toast-" + toastProps.key
      }), content);
    }));
  }));
});
ToastContainer.displayName = 'ToastContainer';
ToastContainer.defaultProps = {
  position: POSITION.TOP_RIGHT,
  transition: Bounce,
  rtl: false,
  autoClose: 5000,
  hideProgressBar: false,
  closeButton: CloseButton,
  pauseOnHover: true,
  pauseOnFocusLoss: true,
  closeOnClick: true,
  newestOnTop: false,
  draggable: true,
  draggablePercent: 80
  /* Default.DRAGGABLE_PERCENT */
  ,
  draggableDirection: "x"
  /* Direction.X */
  ,
  role: 'alert',
  theme: 'light'
};
var containers = new Map();
var latestInstance;
var queue = [];
/**
 * Get the toast by id, given it's in the DOM, otherwise returns null
 */

function getToast(toastId, _ref) {
  var containerId = _ref.containerId;
  var container = containers.get(containerId || latestInstance);
  if (!container) return null;
  return container.getToast(toastId);
}
/**
 * Generate a random toastId
 */


function generateToastId() {
  return Math.random().toString(36).substring(2, 9);
}
/**
 * Generate a toastId or use the one provided
 */


function getToastId(options) {
  if (options && (isStr(options.toastId) || isNum(options.toastId))) {
    return options.toastId;
  }

  return generateToastId();
}
/**
 * If the container is not mounted, the toast is enqueued and
 * the container lazy mounted
 */


function dispatchToast(content, options) {
  if (containers.size > 0) {
    eventManager.emit(0
    /* Event.Show */
    , content, options);
  } else {
    queue.push({
      content: content,
      options: options
    });
  }

  return options.toastId;
}
/**
 * Merge provided options with the defaults settings and generate the toastId
 */


function mergeOptions(type, options) {
  return objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, options), {}, {
    type: options && options.type || type,
    toastId: getToastId(options)
  });
}

function createToastByType(type) {
  return function (content, options) {
    return dispatchToast(content, mergeOptions(type, options));
  };
}

function toast(content, options) {
  return dispatchToast(content, mergeOptions(TYPE.DEFAULT, options));
}

toast.loading = function (content, options) {
  return dispatchToast(content, mergeOptions(TYPE.DEFAULT, objectSpread2_objectSpread2({
    isLoading: true,
    autoClose: false,
    closeOnClick: false,
    closeButton: false,
    draggable: false
  }, options)));
};

function handlePromise(promise, _ref2, options) {
  var pending = _ref2.pending,
      error = _ref2.error,
      success = _ref2.success;
  var id;

  if (pending) {
    id = isStr(pending) ? toast.loading(pending, options) : toast.loading(pending.render, objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, options), pending));
  }

  var resetParams = {
    isLoading: null,
    autoClose: null,
    closeOnClick: null,
    closeButton: null,
    draggable: null,
    delay: 100
  };

  var resolver = function resolver(type, input, result) {
    // Remove the toast if the input has not been provided. This prevents the toast from hanging
    // in the pending state if a success/error toast has not been provided.
    if (input == null) {
      toast.dismiss(id);
      return;
    }

    var baseParams = objectSpread2_objectSpread2(objectSpread2_objectSpread2(objectSpread2_objectSpread2({
      type: type
    }, resetParams), options), {}, {
      data: result
    });

    var params = isStr(input) ? {
      render: input
    } : input; // if the id is set we know that it's an update

    if (id) {
      toast.update(id, objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, baseParams), params));
    } else {
      // using toast.promise without loading
      toast(params.render, objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, baseParams), params));
    }

    return result;
  };

  var p = isFn(promise) ? promise() : promise; //call the resolvers only when needed

  p.then(function (result) {
    return resolver('success', success, result);
  }).catch(function (err) {
    return resolver('error', error, err);
  });
  return p;
}

toast.promise = handlePromise;
toast.success = createToastByType(TYPE.SUCCESS);
toast.info = createToastByType(TYPE.INFO);
toast.error = createToastByType(TYPE.ERROR);
toast.warning = createToastByType(TYPE.WARNING);
toast.warn = toast.warning;

toast.dark = function (content, options) {
  return dispatchToast(content, mergeOptions(TYPE.DEFAULT, objectSpread2_objectSpread2({
    theme: 'dark'
  }, options)));
};
/**
 * Remove toast programmaticaly
 */


toast.dismiss = function (id) {
  if (containers.size > 0) {
    eventManager.emit(1
    /* Event.Clear */
    , id);
  } else {
    queue = queue.filter(function (t) {
      return isToastIdValid(id) && t.options.toastId !== id;
    });
  }
};
/**
 * Clear waiting queue when limit is used
 */


toast.clearWaitingQueue = function (params) {
  if (params === void 0) {
    params = {};
  }

  return eventManager.emit(5
  /* Event.ClearWaitingQueue */
  , params);
};
/**
 * return true if one container is displaying the toast
 */


toast.isActive = function (id) {
  var isToastActive = false;
  containers.forEach(function (container) {
    if (container.isToastActive && container.isToastActive(id)) {
      isToastActive = true;
    }
  });
  return isToastActive;
};

toast.update = function (toastId, options) {
  if (options === void 0) {
    options = {};
  } // if you call toast and toast.update directly nothing will be displayed
  // this is why I defered the update


  setTimeout(function () {
    var toast = getToast(toastId, options);

    if (toast) {
      var oldOptions = toast.props,
          oldContent = toast.content;

      var nextOptions = objectSpread2_objectSpread2(objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, oldOptions), options), {}, {
        toastId: options.toastId || toastId,
        updateId: generateToastId()
      });

      if (nextOptions.toastId !== toastId) nextOptions.staleId = toastId;
      var content = nextOptions.render || oldContent;
      delete nextOptions.render;
      dispatchToast(content, nextOptions);
    }
  }, 0);
};
/**
 * Used for controlled progress bar.
 */


toast.done = function (id) {
  toast.update(id, {
    progress: 1
  });
};
/**
 * Subscribe to change when a toast is added, removed and updated
 *
 * Usage:
 * ```
 * const unsubscribe = toast.onChange((payload) => {
 *   switch (payload.status) {
 *   case "added":
 *     // new toast added
 *     break;
 *   case "updated":
 *     // toast updated
 *     break;
 *   case "removed":
 *     // toast has been removed
 *     break;
 *   }
 * })
 * ```
 */


toast.onChange = function (callback) {
  eventManager.on(4
  /* Event.Change */
  , callback);
  return function () {
    eventManager.off(4
    /* Event.Change */
    , callback);
  };
};

toast.POSITION = POSITION;
toast.TYPE = TYPE;
/**
 * Wait until the ToastContainer is mounted to dispatch the toast
 * and attach isActive method
 */

eventManager.on(2
/* Event.DidMount */
, function (containerInstance) {
  latestInstance = containerInstance.containerId || containerInstance;
  containers.set(latestInstance, containerInstance);
  queue.forEach(function (item) {
    eventManager.emit(0
    /* Event.Show */
    , item.content, item.options);
  });
  queue = [];
}).on(3
/* Event.WillUnmount */
, function (containerInstance) {
  containers.delete(containerInstance.containerId || containerInstance);

  if (containers.size === 0) {
    eventManager.off(0
    /* Event.Show */
    ).off(1
    /* Event.Clear */
    ).off(5
    /* Event.ClearWaitingQueue */
    );
  }
});

// EXTERNAL MODULE: ./node_modules/dayjs/locale/da.js
var da = __webpack_require__(6794);
// EXTERNAL MODULE: ./node_modules/dayjs/dayjs.min.js
var dayjs_min = __webpack_require__(7892);
var dayjs_min_default = /*#__PURE__*/__webpack_require__.n(dayjs_min);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js

function _regeneratorRuntime() {
  "use strict";
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) {
            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
          }

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
        "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      }
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
;// CONCATENATED MODULE: ./src/util/config-loader.js
/** Config loader. */var ConfigLoader=/*#__PURE__*/function(){function ConfigLoader(){_classCallCheck(this,ConfigLoader);}_createClass(ConfigLoader,null,[{key:"loadConfig",value:function(){var _loadConfig=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){var _window,_window$drupalSetting;return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!((_window=window)!==null&&_window!==void 0&&(_window$drupalSetting=_window.drupalSettings)!==null&&_window$drupalSetting!==void 0&&_window$drupalSetting.booking_app)){_context.next=2;break;}return _context.abrupt("return",window.drupalSettings.booking_app);case 2:return _context.abrupt("return",fetch("config.json").then(function(response){return response.json();}).catch(function(){// Load defaults.
return{api_endpoint:"https://selvbetjening.local.itkdev.dk/",element_id:"booking",front_page_url:"https://selvbetjening.local.itkdev.dk/",license_key:"",enable_booking:true,enable_resource_tooltips:true,output_field_id:"submit-values",info_box_color:"#0C6EFD",info_box_header:"Bemærk Behandlingstid!",info_box_content:"Til godkendelse og nøgleudlevering. Det vil fremgå af lokalets information.",step_one:false,redirect_url:"http://google.com/",create_booking_mode:true,create_booking_url:"http://bookingapp.local.itkdev.dk/createbookingurl",change_booking_url:"http://bookingapp.local.itkdev.dk/changebookingurl"};}));case 3:case"end":return _context.stop();}}},_callee);}));function loadConfig(){return _loadConfig.apply(this,arguments);}return loadConfig;}()}]);return ConfigLoader;}();
;// CONCATENATED MODULE: ./src/components/author-fields.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var author_fields = ({});
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(184);
;// CONCATENATED MODULE: ./src/components/author-fields.js
/**
 * Author fields component.
 *
 * @param {object} props Props.
 * @param {object} props.authorFields Author fields.
 * @param {Function} props.setAuthorFields Set author fields function.
 * @returns {JSX.Element} Author fields component.
 */function AuthorFields(_ref){var authorFields=_ref.authorFields,setAuthorFields=_ref.setAuthorFields;var onChangeEmail=function onChangeEmail(event){setAuthorFields(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},authorFields),{},{email:event.target.value}));};var onChangeSubject=function onChangeSubject(event){setAuthorFields(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},authorFields),{},{subject:event.target.value}));};return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"col-md-12 author-fields-wrapper",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("h2",{className:"webform-section-title",children:"N\xF8dvendig information: "}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"webform-section-wrapper",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"form-item",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"subject-input",className:"form-item__label",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"form-item-label",children:"Booking emne"}),/*#__PURE__*/(0,jsx_runtime.jsx)("input",{id:"subject-input",type:"text",placeholder:"Booking emne",required:true,value:authorFields.subject,onChange:onChangeSubject,className:"form-element"})]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"form-item",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"email-input",className:"form-item__label",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"form-item-label",children:"E-mail"}),/*#__PURE__*/(0,jsx_runtime.jsx)("input",{id:"email-input",type:"email",autoComplete:"email",placeholder:"E-mail",required:true,value:authorFields.email,onChange:onChangeEmail,className:"form-element"})]})})]})]});}/* harmony default export */ var components_author_fields = (AuthorFields);
// EXTERNAL MODULE: ./node_modules/react-dom/server.browser.js
var server_browser = __webpack_require__(8340);
;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    }
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};


function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
/** @deprecated */

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
}
/** @deprecated */

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }

  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }

  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}
;

var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(4164);
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/react/dist/vdom.js


(typeof globalThis !== 'undefined' ? globalThis : window).FullCalendarVDom = {
  Component: react.Component,
  createElement: react.createElement,
  render: react_dom.render,
  createRef: react.createRef,
  Fragment: react.Fragment,
  createContext: react.createContext,
  createPortal: react_dom.createPortal,
  flushSync: flushSync,
  unmountComponentAtNode: react_dom.unmountComponentAtNode // never called by FullCalendar's React component

};
function flushSync(callback) {
  // always sync from top-level
  callback();
}
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/common/main.css
// extracted by mini-css-extract-plugin
/* harmony default export */ var main = ({});
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/common/vdom.js
/// <reference types="@fullcalendar/core-preact" />
if (typeof FullCalendarVDom === 'undefined') {
  throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');
}

var Component = FullCalendarVDom.Component;
var vdom_createElement = FullCalendarVDom.createElement;
var render = FullCalendarVDom.render;
var createRef = FullCalendarVDom.createRef;
var vdom_Fragment = FullCalendarVDom.Fragment;
var vdom_createContext = FullCalendarVDom.createContext;
var createPortal = FullCalendarVDom.createPortal;
var vdom_flushSync = FullCalendarVDom.flushSync;
var unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;
/* eslint-enable */


;// CONCATENATED MODULE: ./node_modules/@fullcalendar/common/main.js
/*!
FullCalendar v5.11.3
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/



 // no public types yet. when there are, export from:
// import {} from './api-type-deps'

var EventSourceApi =
/** @class */
function () {
  function EventSourceApi(context, internalEventSource) {
    this.context = context;
    this.internalEventSource = internalEventSource;
  }

  EventSourceApi.prototype.remove = function () {
    this.context.dispatch({
      type: 'REMOVE_EVENT_SOURCE',
      sourceId: this.internalEventSource.sourceId
    });
  };

  EventSourceApi.prototype.refetch = function () {
    this.context.dispatch({
      type: 'FETCH_EVENT_SOURCES',
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  };

  Object.defineProperty(EventSourceApi.prototype, "id", {
    get: function get() {
      return this.internalEventSource.publicId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventSourceApi.prototype, "url", {
    get: function get() {
      return this.internalEventSource.meta.url;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventSourceApi.prototype, "format", {
    get: function get() {
      return this.internalEventSource.meta.format; // TODO: bad. not guaranteed
    },
    enumerable: false,
    configurable: true
  });
  return EventSourceApi;
}();

function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
} // Querying
// ----------------------------------------------------------------------------------------------------------------


function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector); // really bad fallback for IE
    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
  }

  if (!document.documentElement.contains(el)) {
    return null;
  }

  do {
    if (elementMatches(el, selector)) {
      return el;
    }

    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);

  return null;
}

function elementMatches(el, selector) {
  var method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
} // accepts multiple subject els
// returns a real array. good for methods like forEach
// TODO: accept the document


function findElements(container, selector) {
  var containers = container instanceof HTMLElement ? [container] : container;
  var allMatches = [];

  for (var i = 0; i < containers.length; i += 1) {
    var matches = containers[i].querySelectorAll(selector);

    for (var j = 0; j < matches.length; j += 1) {
      allMatches.push(matches[j]);
    }
  }

  return allMatches;
} // accepts multiple subject els
// only queries direct child elements // TODO: rename to findDirectChildren!


function findDirectChildren(parent, selector) {
  var parents = parent instanceof HTMLElement ? [parent] : parent;
  var allMatches = [];

  for (var i = 0; i < parents.length; i += 1) {
    var childNodes = parents[i].children; // only ever elements

    for (var j = 0; j < childNodes.length; j += 1) {
      var childNode = childNodes[j];

      if (!selector || elementMatches(childNode, selector)) {
        allMatches.push(childNode);
      }
    }
  }

  return allMatches;
} // Style
// ----------------------------------------------------------------------------------------------------------------


var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;

function applyStyle(el, props) {
  for (var propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}

function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = '';
  } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {
    el.style[name] = val + "px";
  } else {
    el.style[name] = val;
  }
} // Event Handling
// ----------------------------------------------------------------------------------------------------------------
// if intercepting bubbled events at the document/window/body level,
// and want to see originating element (the 'target'), use this util instead
// of `ev.target` because it goes within web-component boundaries.


function getEventTargetViaRoot(ev) {
  var _a, _b;

  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
} // Shadow DOM consuderations
// ----------------------------------------------------------------------------------------------------------------


function getElRoot(el) {
  return el.getRootNode ? el.getRootNode() : document;
} // Unique ID for DOM attribute


var guid$1 = 0;

function getUniqueDomId() {
  guid$1 += 1;
  return 'fc-dom-' + guid$1;
} // Stops a mouse/touch event from doing it's native browser action


function preventDefault(ev) {
  ev.preventDefault();
} // Event Delegation
// ----------------------------------------------------------------------------------------------------------------


function buildDelegationHandler(selector, handler) {
  return function (ev) {
    var matchedChild = elementClosest(ev.target, selector);

    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}

function listenBySelector(container, eventType, selector, handler) {
  var attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return function () {
    container.removeEventListener(eventType, attachedHandler);
  };
}

function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  var currentMatchedChild;
  return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);

      var realOnMouseLeave_1 = function realOnMouseLeave_1(mouseLeaveEv) {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);
      }; // listen to the next mouseleave, and then unattach


      matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);
    }
  });
} // Animation
// ----------------------------------------------------------------------------------------------------------------


var transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes

function whenTransitionDone(el, callback) {
  var realCallback = function realCallback(ev) {
    callback(ev);
    transitionEventNames.forEach(function (eventName) {
      el.removeEventListener(eventName, realCallback);
    });
  };

  transitionEventNames.forEach(function (eventName) {
    el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes
  });
} // ARIA workarounds
// ----------------------------------------------------------------------------------------------------------------


function createAriaClickAttrs(handler) {
  return _assign({
    onClick: handler
  }, createAriaKeyboardAttrs(handler));
}

function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown: function onKeyDown(ev) {
      if (ev.key === 'Enter' || ev.key === ' ') {
        handler(ev);
        ev.preventDefault(); // if space, don't scroll down page
      }
    }
  };
}

var guidNumber = 0;

function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Make the mouse cursor express that an event is not allowed in the current area


function disableCursor() {
  document.body.classList.add('fc-not-allowed');
} // Returns the mouse cursor to its original look


function enableCursor() {
  document.body.classList.remove('fc-not-allowed');
}
/* Selection
----------------------------------------------------------------------------------------------------------------------*/


function preventSelection(el) {
  el.classList.add('fc-unselectable');
  el.addEventListener('selectstart', preventDefault);
}

function allowSelection(el) {
  el.classList.remove('fc-unselectable');
  el.removeEventListener('selectstart', preventDefault);
}
/* Context Menu
----------------------------------------------------------------------------------------------------------------------*/


function preventContextMenu(el) {
  el.addEventListener('contextmenu', preventDefault);
}

function allowContextMenu(el) {
  el.removeEventListener('contextmenu', preventDefault);
}

function parseFieldSpecs(input) {
  var specs = [];
  var tokens = [];
  var i;
  var token;

  if (typeof input === 'string') {
    tokens = input.split(/\s*,\s*/);
  } else if (typeof input === 'function') {
    tokens = [input];
  } else if (Array.isArray(input)) {
    tokens = input;
  }

  for (i = 0; i < tokens.length; i += 1) {
    token = tokens[i];

    if (typeof token === 'string') {
      specs.push(token.charAt(0) === '-' ? {
        field: token.substring(1),
        order: -1
      } : {
        field: token,
        order: 1
      });
    } else if (typeof token === 'function') {
      specs.push({
        func: token
      });
    }
  }

  return specs;
}

function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  var i;
  var cmp;

  for (i = 0; i < fieldSpecs.length; i += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);

    if (cmp) {
      return cmp;
    }
  }

  return 0;
}

function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }

  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}

function flexibleCompare(a, b) {
  if (!a && !b) {
    return 0;
  }

  if (b == null) {
    return -1;
  }

  if (a == null) {
    return 1;
  }

  if (typeof a === 'string' || typeof b === 'string') {
    return String(a).localeCompare(String(b));
  }

  return a - b;
}
/* String Utilities
----------------------------------------------------------------------------------------------------------------------*/


function padStart(val, len) {
  var s = String(val);
  return '000'.substr(0, len - s.length) + s;
}

function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === 'function') {
    return formatter.apply(void 0, args);
  }

  if (typeof formatter === 'string') {
    // non-blank string
    return args.reduce(function (str, arg, index) {
      return str.replace('$' + index, arg || '');
    }, formatter);
  }

  return fallbackText;
}
/* Number Utilities
----------------------------------------------------------------------------------------------------------------------*/


function compareNumbers(a, b) {
  return a - b;
}

function isInt(n) {
  return n % 1 === 0;
}
/* FC-specific DOM dimension stuff
----------------------------------------------------------------------------------------------------------------------*/


function computeSmallestCellWidth(cellEl) {
  var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');
  var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');

  if (!allWidthEl) {
    throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const
  }

  if (!contentWidthEl) {
    throw new Error('needs fc-scrollgrid-shrink-cushion className');
  }

  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
  contentWidthEl.getBoundingClientRect().width;
}

var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding

function addWeeks(m, n) {
  var a = dateToUtcArray(m);
  a[2] += n * 7;
  return arrayToUtcDate(a);
}

function addDays(m, n) {
  var a = dateToUtcArray(m);
  a[2] += n;
  return arrayToUtcDate(a);
}

function addMs(m, n) {
  var a = dateToUtcArray(m);
  a[6] += n;
  return arrayToUtcDate(a);
} // Diffing (all return floats)
// TODO: why not use ranges?


function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}

function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
}

function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
}

function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
}

function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1000;
}

function diffDayAndTime(m0, m1) {
  var m0day = startOfDay(m0);
  var m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
} // Diffing Whole Units


function diffWholeWeeks(m0, m1) {
  var d = diffWholeDays(m0, m1);

  if (d !== null && d % 7 === 0) {
    return d / 7;
  }

  return null;
}

function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }

  return null;
} // Start-Of


function startOfDay(m) {
  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);
}

function startOfHour(m) {
  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);
}

function startOfMinute(m) {
  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);
}

function startOfSecond(m) {
  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);
} // Week Computation


function weekOfYear(marker, dow, doy) {
  var y = marker.getUTCFullYear();
  var w = weekOfGivenYear(marker, y, dow, doy);

  if (w < 1) {
    return weekOfGivenYear(marker, y - 1, dow, doy);
  }

  var nextW = weekOfGivenYear(marker, y + 1, dow, doy);

  if (nextW >= 1) {
    return Math.min(w, nextW);
  }

  return w;
}

function weekOfGivenYear(marker, year, dow, doy) {
  var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
  var dayStart = startOfDay(marker);
  var days = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days / 7) + 1; // zero-indexed
} // start-of-first-week - start-of-year


function firstWeekOffset(year, dow, doy) {
  // first-week day -- which january is always in the first week (4 for iso, 1 for other)
  var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd

  var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
} // Array Conversion


function dateToLocalArray(date) {
  return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
}

function arrayToLocalDate(a) {
  return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month
  a[3] || 0, a[4] || 0, a[5] || 0);
}

function dateToUtcArray(date) {
  return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];
}

function arrayToUtcDate(a) {
  // according to web standards (and Safari), a month index is required.
  // massage if only given a year.
  if (a.length === 1) {
    a = a.concat([0]);
  }

  return new Date(Date.UTC.apply(Date, a));
} // Other Utils


function isValidDate(m) {
  return !isNaN(m.valueOf());
}

function timeAsMs(m) {
  return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();
}

function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId: defId,
    range: range,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}

var main_hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.

function mergeProps(propObjs, complexPropsMap) {
  var dest = {};

  if (complexPropsMap) {
    for (var name_1 in complexPropsMap) {
      var complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered

      for (var i = propObjs.length - 1; i >= 0; i -= 1) {
        var val = propObjs[i][name_1];

        if (typeof val === 'object' && val) {
          // non-null object
          complexObjs.unshift(val);
        } else if (val !== undefined) {
          dest[name_1] = val; // if there were no objects, this value will be used

          break;
        }
      } // if the trailing values were objects, use the merged value


      if (complexObjs.length) {
        dest[name_1] = mergeProps(complexObjs);
      }
    }
  } // copy values into the destination, going from last to first


  for (var i = propObjs.length - 1; i >= 0; i -= 1) {
    var props = propObjs[i];

    for (var name_2 in props) {
      if (!(name_2 in dest)) {
        // if already assigned by previous props or complex props, don't reassign
        dest[name_2] = props[name_2];
      }
    }
  }

  return dest;
}

function filterHash(hash, func) {
  var filtered = {};

  for (var key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }

  return filtered;
}

function mapHash(hash, func) {
  var newHash = {};

  for (var key in hash) {
    newHash[key] = func(hash[key], key);
  }

  return newHash;
}

function arrayToHash(a) {
  var hash = {};

  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
    var item = a_1[_i];
    hash[item] = true;
  }

  return hash;
}

function buildHashFromArray(a, func) {
  var hash = {};

  for (var i = 0; i < a.length; i += 1) {
    var tuple = func(a[i], i);
    hash[tuple[0]] = tuple[1];
  }

  return hash;
}

function hashValuesToArray(obj) {
  var a = [];

  for (var key in obj) {
    a.push(obj[key]);
  }

  return a;
}

function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }

  for (var key in obj0) {
    if (main_hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }

  for (var key in obj1) {
    if (main_hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }

  return true;
}

function getUnequalProps(obj0, obj1) {
  var keys = [];

  for (var key in obj0) {
    if (main_hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys.push(key);
      }
    }
  }

  for (var key in obj1) {
    if (main_hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys.push(key);
      }
    }
  }

  return keys;
}

function compareObjs(oldProps, newProps, equalityFuncs) {
  if (equalityFuncs === void 0) {
    equalityFuncs = {};
  }

  if (oldProps === newProps) {
    return true;
  }

  for (var key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;else {
      return false;
    }
  } // check for props that were omitted in the new


  for (var key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }

  return true;
}
/*
assumed "true" equality for handler names like "onReceiveSomething"
*/


function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }

  if (comparator) {
    return comparator(val0, val1);
  }

  return false;
}

function collectFromHash(hash, startIndex, endIndex, step) {
  if (startIndex === void 0) {
    startIndex = 0;
  }

  if (step === void 0) {
    step = 1;
  }

  var res = [];

  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }

  for (var i = startIndex; i < endIndex; i += step) {
    var val = hash[i];

    if (val !== undefined) {
      // will disregard undefined for sparse arrays
      res.push(val);
    }
  }

  return res;
}

function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (var i = 0; i < recurringTypes.length; i += 1) {
    var parsed = recurringTypes[i].parse(refined, dateEnv);

    if (parsed) {
      var allDay = refined.allDay;

      if (allDay == null) {
        allDay = defaultAllDay;

        if (allDay == null) {
          allDay = parsed.allDayGuess;

          if (allDay == null) {
            allDay = false;
          }
        }
      }

      return {
        allDay: allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i
      };
    }
  }

  return null;
}

function expandRecurring(eventStore, framingRange, context) {
  var dateEnv = context.dateEnv,
      pluginHooks = context.pluginHooks,
      options = context.options;
  var defs = eventStore.defs,
      instances = eventStore.instances; // remove existing recurring instances
  // TODO: bad. always expand events as a second step

  instances = filterHash(instances, function (instance) {
    return !defs[instance.defId].recurringDef;
  });

  for (var defId in defs) {
    var def = defs[defId];

    if (def.recurringDef) {
      var duration = def.recurringDef.duration;

      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }

      var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);

      for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {
        var start = starts_1[_i];
        var instance = createEventInstance(defId, {
          start: start,
          end: dateEnv.add(start, duration)
        });
        instances[instance.instanceId] = instance;
      }
    }
  }

  return {
    defs: defs,
    instances: instances
  };
}
/*
Event MUST have a recurringDef
*/


function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  var typeDef = recurringTypes[eventDef.recurringDef.typeId];
  var markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to

  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }

  return markers;
}

var INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/; // Parsing and Creation

function createDuration(input, unit) {
  var _a;

  if (typeof input === 'string') {
    return parseString(input);
  }

  if (typeof input === 'object' && input) {
    // non-null object
    return parseObject(input);
  }

  if (typeof input === 'number') {
    return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));
  }

  return null;
}

function parseString(s) {
  var m = PARSE_RE.exec(s);

  if (m) {
    var sign = m[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign * (m[2] ? parseInt(m[2], 10) : 0),
      milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours
      (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes
      (m[5] ? parseInt(m[5], 10) : 0) * 1000 + ( // seconds
      m[6] ? parseInt(m[6], 10) : 0) // ms
      )
    };
  }

  return null;
}

function parseObject(obj) {
  var duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours
    (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes
    (obj.seconds || obj.second || 0) * 1000 + ( // seconds
    obj.milliseconds || obj.millisecond || obj.ms || 0) // ms

  };
  var weeks = obj.weeks || obj.week;

  if (weeks) {
    duration.days += weeks * 7;
    duration.specifiedWeeks = true;
  }

  return duration;
} // Equality


function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}

function asCleanDays(dur) {
  if (!dur.years && !dur.months && !dur.milliseconds) {
    return dur.days;
  }

  return 0;
} // Simple Math


function addDurations(d0, d1) {
  return {
    years: d0.years + d1.years,
    months: d0.months + d1.months,
    days: d0.days + d1.days,
    milliseconds: d0.milliseconds + d1.milliseconds
  };
}

function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}

function multiplyDuration(d, n) {
  return {
    years: d.years * n,
    months: d.months * n,
    days: d.days * n,
    milliseconds: d.milliseconds * n
  };
} // Conversions
// "Rough" because they are based on average-case Gregorian months/years


function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}

function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}

function asRoughDays(dur) {
  return asRoughMs(dur) / 864e5;
}

function asRoughMinutes(dur) {
  return asRoughMs(dur) / (1000 * 60);
}

function asRoughSeconds(dur) {
  return asRoughMs(dur) / 1000;
}

function asRoughMs(dur) {
  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
} // Advanced Math


function wholeDivideDurations(numerator, denominator) {
  var res = null;

  for (var i = 0; i < INTERNAL_UNITS.length; i += 1) {
    var unit = INTERNAL_UNITS[i];

    if (denominator[unit]) {
      var localRes = numerator[unit] / denominator[unit];

      if (!isInt(localRes) || res !== null && res !== localRes) {
        return null;
      }

      res = localRes;
    } else if (numerator[unit]) {
      // needs to divide by something but can't!
      return null;
    }
  }

  return res;
}

function greatestDurationDenominator(dur) {
  var ms = dur.milliseconds;

  if (ms) {
    if (ms % 1000 !== 0) {
      return {
        unit: 'millisecond',
        value: ms
      };
    }

    if (ms % (1000 * 60) !== 0) {
      return {
        unit: 'second',
        value: ms / 1000
      };
    }

    if (ms % (1000 * 60 * 60) !== 0) {
      return {
        unit: 'minute',
        value: ms / (1000 * 60)
      };
    }

    if (ms) {
      return {
        unit: 'hour',
        value: ms / (1000 * 60 * 60)
      };
    }
  }

  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return {
        unit: 'week',
        value: dur.days / 7
      };
    }

    return {
      unit: 'day',
      value: dur.days
    };
  }

  if (dur.months) {
    return {
      unit: 'month',
      value: dur.months
    };
  }

  if (dur.years) {
    return {
      unit: 'year',
      value: dur.years
    };
  }

  return {
    unit: 'millisecond',
    value: 0
  };
} // timeZoneOffset is in minutes


function buildIsoString(marker, timeZoneOffset, stripZeroTime) {
  if (stripZeroTime === void 0) {
    stripZeroTime = false;
  }

  var s = marker.toISOString();
  s = s.replace('.000', '');

  if (stripZeroTime) {
    s = s.replace('T00:00:00Z', '');
  }

  if (s.length > 10) {
    // time part wasn't stripped, can add timezone info
    if (timeZoneOffset == null) {
      s = s.replace('Z', '');
    } else if (timeZoneOffset !== 0) {
      s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
    } // otherwise, its UTC-0 and we want to keep the Z

  }

  return s;
} // formats the date, but with no time part
// TODO: somehow merge with buildIsoString and stripZeroTime
// TODO: rename. omit "string"


function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, '');
} // TODO: use Date::toISOString and use everything after the T?


function formatIsoTimeString(marker) {
  return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);
}

function formatTimeZoneOffset(minutes, doIso) {
  if (doIso === void 0) {
    doIso = false;
  }

  var sign = minutes < 0 ? '-' : '+';
  var abs = Math.abs(minutes);
  var hours = Math.floor(abs / 60);
  var mins = Math.round(abs % 60);

  if (doIso) {
    return sign + padStart(hours, 2) + ":" + padStart(mins, 2);
  }

  return "GMT" + sign + hours + (mins ? ":" + padStart(mins, 2) : '');
} // TODO: new util arrayify?


function removeExact(array, exactVal) {
  var removeCnt = 0;
  var i = 0;

  while (i < array.length) {
    if (array[i] === exactVal) {
      array.splice(i, 1);
      removeCnt += 1;
    } else {
      i += 1;
    }
  }

  return removeCnt;
}

function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }

  var len = a0.length;
  var i;

  if (len !== a1.length) {
    // not array? or not same length?
    return false;
  }

  for (i = 0; i < len; i += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {
      return false;
    }
  }

  return true;
}

function memoize(workerFunc, resEquality, teardownFunc) {
  var currentArgs;
  var currentRes;
  return function () {
    var newArgs = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }

    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }

      var res = workerFunc.apply(this, newArgs);

      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }

    currentArgs = newArgs;
    return currentRes;
  };
}

function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  var _this = this;

  var currentArg;
  var currentRes;
  return function (newArg) {
    if (!currentArg) {
      currentRes = workerFunc.call(_this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }

      var res = workerFunc.call(_this, newArg);

      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }

    currentArg = newArg;
    return currentRes;
  };
}

function memoizeArraylike( // used at all?
workerFunc, resEquality, teardownFunc) {
  var _this = this;

  var currentArgSets = [];
  var currentResults = [];
  return function (newArgSets) {
    var currentLen = currentArgSets.length;
    var newLen = newArgSets.length;
    var i = 0;

    for (; i < currentLen; i += 1) {
      if (!newArgSets[i]) {
        // one of the old sets no longer exists
        if (teardownFunc) {
          teardownFunc(currentResults[i]);
        }
      } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {
        if (teardownFunc) {
          teardownFunc(currentResults[i]);
        }

        var res = workerFunc.apply(_this, newArgSets[i]);

        if (!resEquality || !resEquality(res, currentResults[i])) {
          currentResults[i] = res;
        }
      }
    }

    for (; i < newLen; i += 1) {
      currentResults[i] = workerFunc.apply(_this, newArgSets[i]);
    }

    currentArgSets = newArgSets;
    currentResults.splice(newLen); // remove excess

    return currentResults;
  };
}

function memoizeHashlike(workerFunc, resEquality, teardownFunc) {
  var _this = this;

  var currentArgHash = {};
  var currentResHash = {};
  return function (newArgHash) {
    var newResHash = {};

    for (var key in newArgHash) {
      if (!currentResHash[key]) {
        newResHash[key] = workerFunc.apply(_this, newArgHash[key]);
      } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {
        if (teardownFunc) {
          teardownFunc(currentResHash[key]);
        }

        var res = workerFunc.apply(_this, newArgHash[key]);
        newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;
      } else {
        newResHash[key] = currentResHash[key];
      }
    }

    currentArgHash = newArgHash;
    currentResHash = newResHash;
    return newResHash;
  };
}

var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 0,
  omitZeroMinute: 0,
  meridiem: 0,
  omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too

var COMMA_RE = /,/g; // we need re for globalness

var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g; // control character

var UTC_RE = /UTC|GMT/;

var NativeFormatter =
/** @class */
function () {
  function NativeFormatter(formatSettings) {
    var standardDateProps = {};
    var extendedSettings = {};
    var severity = 0;

    for (var name_1 in formatSettings) {
      if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name_1] = formatSettings[name_1];
        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);
      } else {
        standardDateProps[name_1] = formatSettings[name_1];

        if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {
          // TODO: what about hour12? no severity
          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);
        }
      }
    }

    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.severity = severity;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }

  NativeFormatter.prototype.format = function (date, context) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
  };

  NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
    var _a = this,
        standardDateProps = _a.standardDateProps,
        extendedSettings = _a.extendedSettings;

    var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);

    if (!diffSeverity) {
      return this.format(start, context);
    }

    var biggestUnitForPartial = diffSeverity;

    if (biggestUnitForPartial > 1 && ( // the two dates are different in a way that's larger scale than time
    standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {
      biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
    }

    var full0 = this.format(start, context);
    var full1 = this.format(end, context);

    if (full0 === full1) {
      return full0;
    }

    var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
    var partial0 = partialFormattingFunc(start);
    var partial1 = partialFormattingFunc(end);
    var insertion = findCommonInsertion(full0, partial0, full1, partial1);
    var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';

    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }

    return full0 + separator + full1;
  };

  NativeFormatter.prototype.getLargestUnit = function () {
    switch (this.severity) {
      case 7:
      case 6:
      case 5:
        return 'year';

      case 4:
        return 'month';

      case 3:
        return 'week';

      case 2:
        return 'day';

      default:
        return 'time';
      // really?
    }
  };

  return NativeFormatter;
}();

function buildFormattingFunc(standardDateProps, extendedSettings, context) {
  var standardDatePropCnt = Object.keys(standardDateProps).length;

  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {
    return function (date) {
      return formatTimeZoneOffset(date.timeZoneOffset);
    };
  }

  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return function (date) {
      return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
    };
  }

  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}

function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
  standardDateProps = _assign({}, standardDateProps); // copy

  extendedSettings = _assign({}, extendedSettings); // copy

  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers

  var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
  var zeroFormat; // needed?

  if (extendedSettings.omitZeroMinute) {
    var zeroProps = _assign({}, standardDateProps);

    delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings

    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
  }

  return function (date) {
    var marker = date.marker;
    var format;

    if (zeroFormat && !marker.getUTCMinutes()) {
      format = zeroFormat;
    } else {
      format = normalFormat;
    }

    var s = format.format(marker);
    return postProcess(s, date, standardDateProps, extendedSettings, context);
  };
}

function sanitizeSettings(standardDateProps, extendedSettings) {
  // deal with a browser inconsistency where formatting the timezone
  // requires that the hour/minute be present.
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = '2-digit';
    }

    if (!standardDateProps.minute) {
      standardDateProps.minute = '2-digit';
    }
  } // only support short timezone names


  if (standardDateProps.timeZoneName === 'long') {
    standardDateProps.timeZoneName = 'short';
  } // if requesting to display seconds, MUST display minutes


  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}

function postProcess(s, date, standardDateProps, extendedSettings, context) {
  s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes

  if (standardDateProps.timeZoneName === 'short') {
    s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does "GMT"
    formatTimeZoneOffset(date.timeZoneOffset));
  }

  if (extendedSettings.omitCommas) {
    s = s.replace(COMMA_RE, '').trim();
  }

  if (extendedSettings.omitZeroMinute) {
    s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
  } // ^ do anything that might create adjacent spaces before this point,
  // because MERIDIEM_RE likes to eat up loading spaces


  if (extendedSettings.meridiem === false) {
    s = s.replace(MERIDIEM_RE, '').trim();
  } else if (extendedSettings.meridiem === 'narrow') {
    // a/p
    s = s.replace(MERIDIEM_RE, function (m0, m1) {
      return m1.toLocaleLowerCase();
    });
  } else if (extendedSettings.meridiem === 'short') {
    // am/pm
    s = s.replace(MERIDIEM_RE, function (m0, m1) {
      return m1.toLocaleLowerCase() + "m";
    });
  } else if (extendedSettings.meridiem === 'lowercase') {
    // other meridiem transformers already converted to lowercase
    s = s.replace(MERIDIEM_RE, function (m0) {
      return m0.toLocaleLowerCase();
    });
  }

  s = s.replace(MULTI_SPACE_RE, ' ');
  s = s.trim();
  return s;
}

function injectTzoStr(s, tzoStr) {
  var replaced = false;
  s = s.replace(UTC_RE, function () {
    replaced = true;
    return tzoStr;
  }); // IE11 doesn't include UTC/GMT in the original string, so append to end

  if (!replaced) {
    s += " " + tzoStr;
  }

  return s;
}

function formatWeekNumber(num, weekText, weekTextLong, locale, display) {
  var parts = [];

  if (display === 'long') {
    parts.push(weekTextLong);
  } else if (display === 'short' || display === 'narrow') {
    parts.push(weekText);
  }

  if (display === 'long' || display === 'short') {
    parts.push(' ');
  }

  parts.push(locale.simpleNumberFormat.format(num));

  if (locale.options.direction === 'rtl') {
    // TODO: use control characters instead?
    parts.reverse();
  }

  return parts.join('');
} // Range Formatting Utils
// 0 = exactly the same
// 1 = different by time
// and bigger


function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }

  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }

  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }

  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }

  return 0;
}

function computePartialFormattingOptions(options, biggestUnit) {
  var partialOptions = {};

  for (var name_2 in options) {
    if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
    STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {
      partialOptions[name_2] = options[name_2];
    }
  }

  return partialOptions;
}

function findCommonInsertion(full0, partial0, full1, partial1) {
  var i0 = 0;

  while (i0 < full0.length) {
    var found0 = full0.indexOf(partial0, i0);

    if (found0 === -1) {
      break;
    }

    var before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    var after0 = full0.substr(i0);
    var i1 = 0;

    while (i1 < full1.length) {
      var found1 = full1.indexOf(partial1, i1);

      if (found1 === -1) {
        break;
      }

      var before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      var after1 = full1.substr(i1);

      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }

  return null;
}

function expandZonedMarker(dateInfo, calendarSystem) {
  var a = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a,
    year: a[0],
    month: a[1],
    day: a[2],
    hour: a[3],
    minute: a[4],
    second: a[5],
    millisecond: a[6]
  };
}

function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
  var startInfo = expandZonedMarker(start, context.calendarSystem);
  var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context.timeZone,
    localeCodes: context.locale.codes,
    defaultSeparator: betterDefaultSeparator || context.defaultSeparator
  };
}
/*
TODO: fix the terminology of "formatter" vs "formatting func"
*/

/*
At the time of instantiation, this object does not know which cmd-formatting system it will use.
It receives this at the time of formatting, as a setting.
*/


var CmdFormatter =
/** @class */
function () {
  function CmdFormatter(cmdStr) {
    this.cmdStr = cmdStr;
  }

  CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  };

  CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  };

  return CmdFormatter;
}();

var FuncFormatter =
/** @class */
function () {
  function FuncFormatter(func) {
    this.func = func;
  }

  FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  };

  FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  };

  return FuncFormatter;
}();

function createFormatter(input) {
  if (typeof input === 'object' && input) {
    // non-null object
    return new NativeFormatter(input);
  }

  if (typeof input === 'string') {
    return new CmdFormatter(input);
  }

  if (typeof input === 'function') {
    return new FuncFormatter(input);
  }

  return null;
} // base options
// ------------


var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity,
  navLinkWeekClick: identity,
  duration: createDuration,
  bootstrapFontAwesome: identity,
  buttonIcons: identity,
  customButtons: identity,
  defaultAllDayEventDuration: createDuration,
  defaultTimedEventDuration: createDuration,
  nextDayThreshold: createDuration,
  scrollTime: createDuration,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration,
  slotMaxTime: createDuration,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration,
  snapDuration: createDuration,
  headerToolbar: identity,
  footerToolbar: identity,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity,
  dayHeaderContent: identity,
  dayHeaderDidMount: identity,
  dayHeaderWillUnmount: identity,
  dayCellClassNames: identity,
  dayCellContent: identity,
  dayCellDidMount: identity,
  dayCellWillUnmount: identity,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity,
  weekNumbers: Boolean,
  weekNumberClassNames: identity,
  weekNumberContent: identity,
  weekNumberDidMount: identity,
  weekNumberWillUnmount: identity,
  editable: Boolean,
  viewClassNames: identity,
  viewDidMount: identity,
  viewWillUnmount: identity,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity,
  nowIndicatorContent: identity,
  nowIndicatorDidMount: identity,
  nowIndicatorWillUnmount: identity,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity,
  locale: identity,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity,
  contentHeight: identity,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity,
  initialDate: identity,
  now: identity,
  eventDataTransform: identity,
  stickyHeaderDates: identity,
  stickyFooterScrollbar: identity,
  viewHeight: identity,
  defaultAllDay: Boolean,
  eventSourceFailure: identity,
  eventSourceSuccess: identity,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity,
  eventConstraint: identity,
  eventAllow: identity,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity,
  eventContent: identity,
  eventDidMount: identity,
  eventWillUnmount: identity,
  selectConstraint: identity,
  selectOverlap: identity,
  selectAllow: identity,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity,
  slotLaneClassNames: identity,
  slotLaneContent: identity,
  slotLaneDidMount: identity,
  slotLaneWillUnmount: identity,
  slotLabelClassNames: identity,
  slotLabelContent: identity,
  slotLabelDidMount: identity,
  slotLabelWillUnmount: identity,
  dayMaxEvents: identity,
  dayMaxEventRows: identity,
  dayMinWidth: Number,
  slotLabelInterval: createDuration,
  allDayText: String,
  allDayClassNames: identity,
  allDayContent: identity,
  allDayDidMount: identity,
  allDayWillUnmount: identity,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity,
  moreLinkHint: identity,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration,
  hiddenDays: identity,
  monthMode: Boolean,
  fixedWeekCount: Boolean,
  validRange: identity,
  visibleRange: identity,
  titleFormat: identity,
  eventInteractive: Boolean,
  // only used by list-view, but languages define the value, so we need it in base options
  noEventsText: String,
  viewHint: identity,
  navLinkHint: identity,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity,
  moreLinkClassNames: identity,
  moreLinkContent: identity,
  moreLinkDidMount: identity,
  moreLinkWillUnmount: identity
}; // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.
// raw values.

var BASE_OPTION_DEFAULTS = {
  eventDisplay: 'auto',
  defaultRangeSeparator: ' - ',
  titleRangeSeparator: " \u2013 ",
  defaultTimedEventDuration: '01:00:00',
  defaultAllDayEventDuration: {
    day: 1
  },
  forceEventDuration: false,
  nextDayThreshold: '00:00:00',
  dayHeaders: true,
  initialView: '',
  aspectRatio: 1.35,
  headerToolbar: {
    start: 'title',
    center: '',
    end: 'today prev,next'
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: 'local',
  editable: false,
  nowIndicator: false,
  scrollTime: '06:00:00',
  scrollTimeReset: true,
  slotMinTime: '00:00:00',
  slotMaxTime: '24:00:00',
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: 'start',
  endParam: 'end',
  timeZoneParam: 'timeZone',
  timeZone: 'local',
  locales: [],
  locale: '',
  themeSystem: 'standard',
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: '*',
  eventOrder: 'start,-duration,allDay,title',
  dayPopoverFormat: {
    month: 'long',
    day: 'numeric',
    year: 'numeric'
  },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1000,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30
}; // calendar listeners
// ------------------

var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity,
  eventsSet: identity,
  eventAdd: identity,
  eventChange: identity,
  eventRemove: identity,
  windowResize: identity,
  eventClick: identity,
  eventMouseEnter: identity,
  eventMouseLeave: identity,
  select: identity,
  unselect: identity,
  loading: identity,
  // internal
  _unmount: identity,
  _beforeprint: identity,
  _afterprint: identity,
  _noEventDrop: identity,
  _noEventResize: identity,
  _resize: identity,
  _scrollRequest: identity
}; // calendar-specific options
// -------------------------

var CALENDAR_OPTION_REFINERS = {
  buttonText: identity,
  buttonHints: identity,
  views: identity,
  plugins: identity,
  initialEvents: identity,
  events: identity,
  eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual
};

function isMaybeObjectsEqual(a, b) {
  if (typeof a === 'object' && typeof b === 'object' && a && b) {
    // both non-null objects
    return isPropsEqual(a, b);
  }

  return a === b;
} // view-specific options
// ---------------------


var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity,
  usesMinMaxTime: Boolean,
  classNames: identity,
  content: identity,
  didMount: identity,
  willUnmount: identity
}; // util funcs
// ----------------------------------------------------------------------------------------------------

function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}

function refineProps(input, refiners) {
  var refined = {};
  var extra = {};

  for (var propName in refiners) {
    if (propName in input) {
      refined[propName] = refiners[propName](input[propName]);
    }
  }

  for (var propName in input) {
    if (!(propName in refiners)) {
      extra[propName] = input[propName];
    }
  }

  return {
    refined: refined,
    extra: extra
  };
}

function identity(raw) {
  return raw;
}

function parseEvents(rawEvents, eventSource, context, allowOpenRange) {
  var eventStore = createEmptyEventStore();
  var eventRefiners = buildEventRefiners(context);

  for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
    var rawEvent = rawEvents_1[_i];
    var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);

    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }

  return eventStore;
}

function eventTupleToStore(tuple, eventStore) {
  if (eventStore === void 0) {
    eventStore = createEmptyEventStore();
  }

  eventStore.defs[tuple.def.defId] = tuple.def;

  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }

  return eventStore;
} // retrieves events that have the same groupId as the instance specified by `instanceId`
// or they are the same as the instance.
// why might instanceId not be in the store? an event from another calendar?


function getRelevantEvents(eventStore, instanceId) {
  var instance = eventStore.instances[instanceId];

  if (instance) {
    var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group

    var newStore = filterEventStoreDefs(eventStore, function (lookDef) {
      return isEventDefsGrouped(def_1, lookDef);
    }); // add the original
    // TODO: wish we could use eventTupleToStore or something like it

    newStore.defs[def_1.defId] = def_1;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }

  return createEmptyEventStore();
}

function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}

function createEmptyEventStore() {
  return {
    defs: {},
    instances: {}
  };
}

function mergeEventStores(store0, store1) {
  return {
    defs: _assign(_assign({}, store0.defs), store1.defs),
    instances: _assign(_assign({}, store0.instances), store1.instances)
  };
}

function filterEventStoreDefs(eventStore, filterFunc) {
  var defs = filterHash(eventStore.defs, filterFunc);
  var instances = filterHash(eventStore.instances, function (instance) {
    return defs[instance.defId] // still exists?
    ;
  });
  return {
    defs: defs,
    instances: instances
  };
}

function excludeSubEventStore(master, sub) {
  var defs = master.defs,
      instances = master.instances;
  var filteredDefs = {};
  var filteredInstances = {};

  for (var defId in defs) {
    if (!sub.defs[defId]) {
      // not explicitly excluded
      filteredDefs[defId] = defs[defId];
    }
  }

  for (var instanceId in instances) {
    if (!sub.instances[instanceId] && // not explicitly excluded
    filteredDefs[instances[instanceId].defId] // def wasn't filtered away
    ) {
      filteredInstances[instanceId] = instances[instanceId];
    }
  }

  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}

function normalizeConstraint(input, context) {
  if (Array.isArray(input)) {
    return parseEvents(input, null, context, true); // allowOpenRange=true
  }

  if (typeof input === 'object' && input) {
    // non-null object
    return parseEvents([input], null, context, true); // allowOpenRange=true
  }

  if (input != null) {
    return String(input);
  }

  return null;
}

function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }

  if (typeof raw === 'string') {
    return raw.split(/\s+/);
  }

  return [];
} // TODO: better called "EventSettings" or "EventConfig"
// TODO: move this file into structs
// TODO: separate constraint/overlap/allow, because selection uses only that, not other props


var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity,
  overlap: identity,
  allow: identity,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: '',
  borderColor: '',
  textColor: '',
  classNames: []
};

function createEventUi(refined, context) {
  var constraint = normalizeConstraint(refined.constraint, context);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || '',
    borderColor: refined.borderColor || refined.color || '',
    textColor: refined.textColor || '',
    classNames: (refined.className || []).concat(refined.classNames || []) // join singular and plural

  };
} // TODO: prevent against problems with <2 args!


function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}

function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}

var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity,
  end: identity,
  date: identity,
  allDay: Boolean
};

var EVENT_REFINERS = _assign(_assign(_assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {
  extendedProps: identity
});

function parseEvent(raw, eventSource, context, allowOpenRange, refiners) {
  if (refiners === void 0) {
    refiners = buildEventRefiners(context);
  }

  var _a = refineEventDef(raw, context, refiners),
      refined = _a.refined,
      extra = _a.extra;

  var defaultAllDay = computeIsDefaultAllDay(eventSource, context);
  var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);

  if (recurringRes) {
    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return {
      def: def,
      instance: null
    };
  }

  var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);

  if (singleRes) {
    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);
    var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    return {
      def: def,
      instance: instance
    };
  }

  return null;
}

function refineEventDef(raw, context, refiners) {
  if (refiners === void 0) {
    refiners = buildEventRefiners(context);
  }

  return refineProps(raw, refiners);
}

function buildEventRefiners(context) {
  return _assign(_assign(_assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
/*
Will NOT populate extendedProps with the leftover properties.
Will NOT populate date-related props.
*/


function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {
  var def = {
    title: refined.title || '',
    groupId: refined.groupId || '',
    publicId: refined.id || '',
    url: refined.url || '',
    recurringDef: null,
    defId: guid(),
    sourceId: sourceId,
    allDay: allDay,
    hasEnd: hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context),
    extendedProps: _assign(_assign({}, refined.extendedProps || {}), extra)
  };

  for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {
    var memberAdder = _a[_i];

    _assign(def, memberAdder(refined));
  } // help out EventApi from having user modify props


  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}

function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
  var allDay = refined.allDay;
  var startMeta;
  var startMarker = null;
  var hasEnd = false;
  var endMeta;
  var endMarker = null;
  var startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context.dateEnv.createMarkerMeta(startInput);

  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }

  if (refined.end != null) {
    endMeta = context.dateEnv.createMarkerMeta(refined.end);
  }

  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      // fall back to the date props LAST
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }

  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }

  if (endMeta) {
    endMarker = endMeta.marker;

    if (allDay) {
      endMarker = startOfDay(endMarker);
    }

    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }

  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context.options.forceEventDuration || false;
    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
  }

  return {
    allDay: allDay,
    hasEnd: hasEnd,
    range: {
      start: startMarker,
      end: endMarker
    },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}

function computeIsDefaultAllDay(eventSource, context) {
  var res = null;

  if (eventSource) {
    res = eventSource.defaultAllDay;
  }

  if (res == null) {
    res = context.options.defaultAllDay;
  }

  return res;
}
/* Date stuff that doesn't belong in datelib core
----------------------------------------------------------------------------------------------------------------------*/
// given a timed range, computes an all-day range that has the same exact duration,
// but whose start time is aligned with the start of the day.


function computeAlignedDayRange(timedRange) {
  var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  var start = startOfDay(timedRange.start);
  var end = addDays(start, dayCnt);
  return {
    start: start,
    end: end
  };
} // given a timed range, computes an all-day range based on how for the end date bleeds into the next day
// TODO: give nextDayThreshold a default arg


function computeVisibleDayRange(timedRange, nextDayThreshold) {
  if (nextDayThreshold === void 0) {
    nextDayThreshold = createDuration(0);
  }

  var startDay = null;
  var endDay = null;

  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
    // If the end time is actually inclusively part of the next day and is equal to or
    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.

    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }

  if (timedRange.start) {
    startDay = startOfDay(timedRange.start); // the beginning of the day the range starts
    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.

    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }

  return {
    start: startDay,
    end: endDay
  };
} // spans from one day into another?


function isMultiDayRange(range) {
  var visibleRange = computeVisibleDayRange(range);
  return diffDays(visibleRange.start, visibleRange.end) > 1;
}

function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === 'year') {
    return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
  }

  if (largeUnit === 'month') {
    return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
  }

  return diffDayAndTime(date0, date1); // returns a duration
}

function parseRange(input, dateEnv) {
  var start = null;
  var end = null;

  if (input.start) {
    start = dateEnv.createMarker(input.start);
  }

  if (input.end) {
    end = dateEnv.createMarker(input.end);
  }

  if (!start && !end) {
    return null;
  }

  if (start && end && end < start) {
    return null;
  }

  return {
    start: start,
    end: end
  };
} // SIDE-EFFECT: will mutate ranges.
// Will return a new array result.


function invertRanges(ranges, constraintRange) {
  var invertedRanges = [];
  var start = constraintRange.start; // the end of the previous range. the start of the new range

  var i;
  var dateRange; // ranges need to be in order. required for our date-walking algorithm

  ranges.sort(compareRanges);

  for (i = 0; i < ranges.length; i += 1) {
    dateRange = ranges[i]; // add the span of time before the event (if there is any)

    if (dateRange.start > start) {
      // compare millisecond time (skip any ambig logic)
      invertedRanges.push({
        start: start,
        end: dateRange.start
      });
    }

    if (dateRange.end > start) {
      start = dateRange.end;
    }
  } // add the span of time after the last event (if there is any)


  if (start < constraintRange.end) {
    // compare millisecond time (skip any ambig logic)
    invertedRanges.push({
      start: start,
      end: constraintRange.end
    });
  }

  return invertedRanges;
}

function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
}

function intersectRanges(range0, range1) {
  var start = range0.start,
      end = range0.end;
  var newRange = null;

  if (range1.start !== null) {
    if (start === null) {
      start = range1.start;
    } else {
      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
    }
  }

  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }

  if (start === null || end === null || start < end) {
    newRange = {
      start: start,
      end: end
    };
  }

  return newRange;
}

function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}

function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}

function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}

function rangeContainsMarker(range, date) {
  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
} // If the given date is not within the given range, move it inside.
// (If it's past the end, make it one millisecond before the end).


function constrainMarkerToRange(date, range) {
  if (range.start != null && date < range.start) {
    return range.start;
  }

  if (range.end != null && date >= range.end) {
    return new Date(range.end.valueOf() - 1);
  }

  return date;
}
/*
Specifying nextDayThreshold signals that all-day ranges should be sliced.
*/


function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  var inverseBgByGroupId = {};
  var inverseBgByDefId = {};
  var defByGroupId = {};
  var bgRanges = [];
  var fgRanges = [];
  var eventUis = compileEventUis(eventStore.defs, eventUiBases);

  for (var defId in eventStore.defs) {
    var def = eventStore.defs[defId];
    var ui = eventUis[def.defId];

    if (ui.display === 'inverse-background') {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];

        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }

  for (var instanceId in eventStore.instances) {
    var instance = eventStore.instances[instanceId];
    var def = eventStore.defs[instance.defId];
    var ui = eventUis[def.defId];
    var origRange = instance.range;
    var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    var slicedRange = intersectRanges(normalRange, framingRange);

    if (slicedRange) {
      if (ui.display === 'inverse-background') {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui.display !== 'none') {
        (ui.display === 'background' ? bgRanges : fgRanges).push({
          def: def,
          ui: ui,
          instance: instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }

  for (var groupId in inverseBgByGroupId) {
    // BY GROUP
    var ranges = inverseBgByGroupId[groupId];
    var invertedRanges = invertRanges(ranges, framingRange);

    for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {
      var invertedRange = invertedRanges_1[_i];
      var def = defByGroupId[groupId];
      var ui = eventUis[def.defId];
      bgRanges.push({
        def: def,
        ui: ui,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }

  for (var defId in inverseBgByDefId) {
    var ranges = inverseBgByDefId[defId];
    var invertedRanges = invertRanges(ranges, framingRange);

    for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {
      var invertedRange = invertedRanges_2[_a];
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }

  return {
    bg: bgRanges,
    fg: fgRanges
  };
}

function hasBgRendering(def) {
  return def.ui.display === 'background' || def.ui.display === 'inverse-background';
}

function setElSeg(el, seg) {
  el.fcSeg = seg;
}

function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || // for the harness
  null;
} // event ui computation


function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, function (eventDef) {
    return compileEventUi(eventDef, eventUiBases);
  });
}

function compileEventUi(eventDef, eventUiBases) {
  var uis = [];

  if (eventUiBases['']) {
    uis.push(eventUiBases['']);
  }

  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }

  uis.push(eventDef.ui);
  return combineEventUis(uis);
}

function sortEventSegs(segs, eventOrderSpecs) {
  var objs = segs.map(buildSegCompareObj);
  objs.sort(function (obj0, obj1) {
    return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);
  });
  return objs.map(function (c) {
    return c._seg;
  });
} // returns a object with all primitive props that can be compared


function buildSegCompareObj(seg) {
  var eventRange = seg.eventRange;
  var eventDef = eventRange.def;
  var range = eventRange.instance ? eventRange.instance.range : eventRange.range;
  var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events

  var end = range.end ? range.end.valueOf() : 0; // "

  return _assign(_assign(_assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start: start,
    end: end,
    duration: end - start,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}

function computeSegDraggable(seg, context) {
  var pluginHooks = context.pluginHooks;
  var transformers = pluginHooks.isDraggableTransformers;
  var _a = seg.eventRange,
      def = _a.def,
      ui = _a.ui;
  var val = ui.startEditable;

  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
    var transformer = transformers_1[_i];
    val = transformer(val, def, ui, context);
  }

  return val;
}

function computeSegStartResizable(seg, context) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}

function computeSegEndResizable(seg, context) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}

function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true
defaultDisplayEventEnd, // defaults to true
startOverride, endOverride) {
  var dateEnv = context.dateEnv,
      options = context.options;
  var displayEventTime = options.displayEventTime,
      displayEventEnd = options.displayEventEnd;
  var eventDef = seg.eventRange.def;
  var eventInstance = seg.eventRange.instance;

  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }

  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }

  var wholeEventStart = eventInstance.range.start;
  var wholeEventEnd = eventInstance.range.end;
  var segStart = startOverride || seg.start || seg.eventRange.range.start;
  var segEnd = endOverride || seg.end || seg.eventRange.range.end;
  var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();

  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;

    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }

    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo // nooooo, same

    });
  }

  return '';
}

function getSegMeta(seg, todayRange, nowDate) {
  var segRange = seg.eventRange.range;
  return {
    isPast: segRange.end < (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}

function getEventClassNames(props) {
  var classNames = ['fc-event'];

  if (props.isMirror) {
    classNames.push('fc-event-mirror');
  }

  if (props.isDraggable) {
    classNames.push('fc-event-draggable');
  }

  if (props.isStartResizable || props.isEndResizable) {
    classNames.push('fc-event-resizable');
  }

  if (props.isDragging) {
    classNames.push('fc-event-dragging');
  }

  if (props.isResizing) {
    classNames.push('fc-event-resizing');
  }

  if (props.isSelected) {
    classNames.push('fc-event-selected');
  }

  if (props.isStart) {
    classNames.push('fc-event-start');
  }

  if (props.isEnd) {
    classNames.push('fc-event-end');
  }

  if (props.isPast) {
    classNames.push('fc-event-past');
  }

  if (props.isToday) {
    classNames.push('fc-event-today');
  }

  if (props.isFuture) {
    classNames.push('fc-event-future');
  }

  return classNames;
}

function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + ":" + eventRange.range.start.toISOString(); // inverse-background events don't have specific instances. TODO: better solution
}

function getSegAnchorAttrs(seg, context) {
  var _a = seg.eventRange,
      def = _a.def,
      instance = _a.instance;
  var url = def.url;

  if (url) {
    return {
      href: url
    };
  }

  var emitter = context.emitter,
      options = context.options;
  var eventInteractive = options.eventInteractive;

  if (eventInteractive == null) {
    eventInteractive = def.interactive;

    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers('eventClick'));
    }
  } // mock what happens in EventClicking


  if (eventInteractive) {
    // only attach keyboard-related handlers because click handler is already done in EventClicking
    return createAriaKeyboardAttrs(function (ev) {
      emitter.trigger('eventClick', {
        el: ev.target,
        event: new EventApi(context, def, instance),
        jsEvent: ev,
        view: context.viewApi
      });
    });
  }

  return {};
}

var STANDARD_PROPS = {
  start: identity,
  end: identity,
  allDay: Boolean
};

function parseDateSpan(raw, dateEnv, defaultDuration) {
  var span = parseOpenDateSpan(raw, dateEnv);
  var range = span.range;

  if (!range.start) {
    return null;
  }

  if (!range.end) {
    if (defaultDuration == null) {
      return null;
    }

    range.end = dateEnv.add(range.start, defaultDuration);
  }

  return span;
}
/*
TODO: somehow combine with parseRange?
Will return null if the start/end props were present but parsed invalidly.
*/


function parseOpenDateSpan(raw, dateEnv) {
  var _a = refineProps(raw, STANDARD_PROPS),
      standardProps = _a.refined,
      extra = _a.extra;

  var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  var allDay = standardProps.allDay;

  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }

  return _assign({
    range: {
      start: startMeta ? startMeta.marker : null,
      end: endMeta ? endMeta.marker : null
    },
    allDay: allDay
  }, extra);
}

function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
} // the NON-DATE-RELATED props


function isSpanPropsEqual(span0, span1) {
  for (var propName in span1) {
    if (propName !== 'range' && propName !== 'allDay') {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  } // are there any props that span0 has that span1 DOESN'T have?
  // both have range/allDay, so no need to special-case.


  for (var propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }

  return true;
}

function buildDateSpanApi(span, dateEnv) {
  return _assign(_assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {
    allDay: span.allDay
  });
}

function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
  return _assign(_assign({}, buildRangeApi(range, dateEnv, omitTime)), {
    timeZone: dateEnv.timeZone
  });
}

function buildRangeApi(range, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range.start),
    end: dateEnv.toDate(range.end),
    startStr: dateEnv.formatIso(range.start, {
      omitTime: omitTime
    }),
    endStr: dateEnv.formatIso(range.end, {
      omitTime: omitTime
    })
  };
}

function fabricateEventRange(dateSpan, eventUiBases, context) {
  var res = refineEventDef({
    editable: false
  }, context);
  var def = parseEventDef(res.refined, res.extra, '', // sourceId
  dateSpan.allDay, true, // hasEnd
  context);
  return {
    def: def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}

function triggerDateSelect(selection, pev, context) {
  context.emitter.trigger('select', _assign(_assign({}, buildDateSpanApiWithContext(selection, context)), {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  }));
}

function triggerDateUnselect(pev, context) {
  context.emitter.trigger('unselect', {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  });
}

function buildDateSpanApiWithContext(dateSpan, context) {
  var props = {};

  for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {
    var transform = _a[_i];

    _assign(props, transform(dateSpan, context));
  }

  _assign(props, buildDateSpanApi(dateSpan, context.dateEnv));

  return props;
} // Given an event's allDay status and start date, return what its fallback end date should be.
// TODO: rename to computeDefaultEventEnd


function getDefaultEventEnd(allDay, marker, context) {
  var dateEnv = context.dateEnv,
      options = context.options;
  var end = marker;

  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }

  return end;
} // applies the mutation to ALL defs/instances within the event store


function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
  var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  var dest = createEmptyEventStore();

  for (var defId in eventStore.defs) {
    var def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
  }

  for (var instanceId in eventStore.instances) {
    var instance = eventStore.instances[instanceId];
    var def = dest.defs[instance.defId]; // important to grab the newly modified def

    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
  }

  return dest;
}

function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
  var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.
  // if duration will change, there's no way the default duration will persist,
  // and thus, we need to mark the event as having a real end

  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true; // TODO: is this mutation okay?
  }

  var copy = _assign(_assign(_assign({}, eventDef), standardProps), {
    ui: _assign(_assign({}, eventDef.ui), standardProps.ui)
  });

  if (mutation.extendedProps) {
    copy.extendedProps = _assign(_assign({}, copy.extendedProps), mutation.extendedProps);
  }

  for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {
    var applier = _a[_i];
    applier(copy, mutation, context);
  }

  if (!copy.hasEnd && context.options.forceEventDuration) {
    copy.hasEnd = true;
  }

  return copy;
}

function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef
eventConfig, mutation, context) {
  var dateEnv = context.dateEnv;
  var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;

  var copy = _assign({}, eventInstance);

  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }

  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }

  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }

  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }

  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
  } // in case event was all-day but the supplied deltas were not
  // better util for this?


  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  } // handle invalid durations


  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
  }

  return copy;
} // no public types yet. when there are, export from:
// import {} from './api-type-deps'


var ViewApi =
/** @class */
function () {
  function ViewApi(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }

  Object.defineProperty(ViewApi.prototype, "calendar", {
    get: function get() {
      return this.getCurrentData().calendarApi;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewApi.prototype, "title", {
    get: function get() {
      return this.getCurrentData().viewTitle;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewApi.prototype, "activeStart", {
    get: function get() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewApi.prototype, "activeEnd", {
    get: function get() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewApi.prototype, "currentStart", {
    get: function get() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewApi.prototype, "currentEnd", {
    get: function get() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
    },
    enumerable: false,
    configurable: true
  });

  ViewApi.prototype.getOption = function (name) {
    return this.getCurrentData().options[name]; // are the view-specific options
  };

  return ViewApi;
}();

var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity,
  eventDataTransform: identity,
  // for any network-related sources
  success: identity,
  failure: identity
};

function parseEventSource(raw, context, refiners) {
  if (refiners === void 0) {
    refiners = buildEventSourceRefiners(context);
  }

  var rawObj;

  if (typeof raw === 'string') {
    rawObj = {
      url: raw
    };
  } else if (typeof raw === 'function' || Array.isArray(raw)) {
    rawObj = {
      events: raw
    };
  } else if (typeof raw === 'object' && raw) {
    // not null
    rawObj = raw;
  }

  if (rawObj) {
    var _a = refineProps(rawObj, refiners),
        refined = _a.refined,
        extra = _a.extra;

    var metaRes = buildEventSourceMeta(refined, context);

    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: '',
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || '',
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context),
        extendedProps: extra
      };
    }
  }

  return null;
}

function buildEventSourceRefiners(context) {
  return _assign(_assign(_assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}

function buildEventSourceMeta(raw, context) {
  var defs = context.pluginHooks.eventSourceDefs;

  for (var i = defs.length - 1; i >= 0; i -= 1) {
    // later-added plugins take precedence
    var def = defs[i];
    var meta = def.parseMeta(raw);

    if (meta) {
      return {
        sourceDefId: i,
        meta: meta
      };
    }
  }

  return null;
}

function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case 'CHANGE_DATE':
      return action.dateMarker;

    default:
      return currentDate;
  }
}

function getInitialDate(options, dateEnv) {
  var initialDateInput = options.initialDate; // compute the initial ambig-timezone date

  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }

  return getNow(options.now, dateEnv); // getNow already returns unzoned
}

function getNow(nowInput, dateEnv) {
  if (typeof nowInput === 'function') {
    nowInput = nowInput();
  }

  if (nowInput == null) {
    return dateEnv.createNowMarker();
  }

  return dateEnv.createMarker(nowInput);
}

var CalendarApi =
/** @class */
function () {
  function CalendarApi() {}

  CalendarApi.prototype.getCurrentData = function () {
    return this.currentDataManager.getCurrentData();
  };

  CalendarApi.prototype.dispatch = function (action) {
    return this.currentDataManager.dispatch(action);
  };

  Object.defineProperty(CalendarApi.prototype, "view", {
    get: function get() {
      return this.getCurrentData().viewApi;
    } // for public API
    ,
    enumerable: false,
    configurable: true
  });

  CalendarApi.prototype.batchRendering = function (callback) {
    callback();
  };

  CalendarApi.prototype.updateSize = function () {
    this.trigger('_resize', true);
  }; // Options
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.setOption = function (name, val) {
    this.dispatch({
      type: 'SET_OPTION',
      optionName: name,
      rawOptionValue: val
    });
  };

  CalendarApi.prototype.getOption = function (name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  };

  CalendarApi.prototype.getAvailableLocaleCodes = function () {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }; // Trigger
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.on = function (handlerName, handler) {
    var currentDataManager = this.currentDataManager;

    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn("Unknown listener name '" + handlerName + "'");
    }
  };

  CalendarApi.prototype.off = function (handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }; // not meant for public use


  CalendarApi.prototype.trigger = function (handlerName) {
    var _a;

    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    (_a = this.currentDataManager.emitter).trigger.apply(_a, __spreadArray([handlerName], args));
  }; // View
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.changeView = function (viewType, dateOrRange) {
    var _this = this;

    this.batchRendering(function () {
      _this.unselect();

      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          // a range
          _this.dispatch({
            type: 'CHANGE_VIEW_TYPE',
            viewType: viewType
          });

          _this.dispatch({
            type: 'SET_OPTION',
            optionName: 'visibleRange',
            rawOptionValue: dateOrRange
          });
        } else {
          var dateEnv = _this.getCurrentData().dateEnv;

          _this.dispatch({
            type: 'CHANGE_VIEW_TYPE',
            viewType: viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        _this.dispatch({
          type: 'CHANGE_VIEW_TYPE',
          viewType: viewType
        });
      }
    });
  }; // Forces navigation to a view for the given date.
  // `viewType` can be a specific view name or a generic one like "week" or "day".
  // needs to change


  CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {
    var state = this.getCurrentData();
    var spec;
    viewType = viewType || 'day'; // day is default zoom

    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();

    if (spec) {
      this.dispatch({
        type: 'CHANGE_VIEW_TYPE',
        viewType: spec.type,
        dateMarker: dateMarker
      });
    } else {
      this.dispatch({
        type: 'CHANGE_DATE',
        dateMarker: dateMarker
      });
    }
  }; // Given a duration singular unit, like "week" or "day", finds a matching view spec.
  // Preference is given to views that have corresponding buttons.


  CalendarApi.prototype.getUnitViewSpec = function (unit) {
    var _a = this.getCurrentData(),
        viewSpecs = _a.viewSpecs,
        toolbarConfig = _a.toolbarConfig;

    var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    var i;
    var spec;

    for (var viewType in viewSpecs) {
      viewTypes.push(viewType);
    }

    for (i = 0; i < viewTypes.length; i += 1) {
      spec = viewSpecs[viewTypes[i]];

      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }

    return null;
  }; // Current Date
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.prev = function () {
    this.unselect();
    this.dispatch({
      type: 'PREV'
    });
  };

  CalendarApi.prototype.next = function () {
    this.unselect();
    this.dispatch({
      type: 'NEXT'
    });
  };

  CalendarApi.prototype.prevYear = function () {
    var state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: 'CHANGE_DATE',
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  };

  CalendarApi.prototype.nextYear = function () {
    var state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: 'CHANGE_DATE',
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  };

  CalendarApi.prototype.today = function () {
    var state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: 'CHANGE_DATE',
      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
    });
  };

  CalendarApi.prototype.gotoDate = function (zonedDateInput) {
    var state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: 'CHANGE_DATE',
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  };

  CalendarApi.prototype.incrementDate = function (deltaInput) {
    var state = this.getCurrentData();
    var delta = createDuration(deltaInput);

    if (delta) {
      // else, warn about invalid input?
      this.unselect();
      this.dispatch({
        type: 'CHANGE_DATE',
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }; // for external API


  CalendarApi.prototype.getDate = function () {
    var state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }; // Date Formatting Utils
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.formatDate = function (d, formatter) {
    var dateEnv = this.getCurrentData().dateEnv;
    return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
  }; // `settings` is for formatter AND isEndExclusive


  CalendarApi.prototype.formatRange = function (d0, d1, settings) {
    var dateEnv = this.getCurrentData().dateEnv;
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  };

  CalendarApi.prototype.formatIso = function (d, omitTime) {
    var dateEnv = this.getCurrentData().dateEnv;
    return dateEnv.formatIso(dateEnv.createMarker(d), {
      omitTime: omitTime
    });
  }; // Date Selection / Event Selection / DayClick
  // -----------------------------------------------------------------------------------------------------------------
  // this public method receives start/end dates in any format, with any timezone
  // NOTE: args were changed from v3


  CalendarApi.prototype.select = function (dateOrObj, endDate) {
    var selectionInput;

    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }

    var state = this.getCurrentData();
    var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({
      days: 1
    }));

    if (selection) {
      // throw parse error otherwise?
      this.dispatch({
        type: 'SELECT_DATES',
        selection: selection
      });
      triggerDateSelect(selection, null, state);
    }
  }; // public method


  CalendarApi.prototype.unselect = function (pev) {
    var state = this.getCurrentData();

    if (state.dateSelection) {
      this.dispatch({
        type: 'UNSELECT_DATES'
      });
      triggerDateUnselect(pev, state);
    }
  }; // Public Events API
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {
    if (eventInput instanceof EventApi) {
      var def = eventInput._def;
      var instance = eventInput._instance;
      var currentData = this.getCurrentData(); // not already present? don't want to add an old snapshot

      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: 'ADD_EVENTS',
          eventStore: eventTupleToStore({
            def: def,
            instance: instance
          }) // TODO: better util for two args?

        });
        this.triggerEventAdd(eventInput);
      }

      return eventInput;
    }

    var state = this.getCurrentData();
    var eventSource;

    if (sourceInput instanceof EventSourceApi) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === 'boolean') {
      if (sourceInput) {
        // true. part of the first event source
        eventSource = hashValuesToArray(state.eventSources)[0];
      }
    } else if (sourceInput != null) {
      // an ID. accepts a number too
      var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function

      if (!sourceApi) {
        console.warn("Could not find an event source with ID \"" + sourceInput + "\""); // TODO: test

        return null;
      }

      eventSource = sourceApi.internalEventSource;
    }

    var tuple = parseEvent(eventInput, eventSource, state, false);

    if (tuple) {
      var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: 'ADD_EVENTS',
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }

    return null;
  };

  CalendarApi.prototype.triggerEventAdd = function (eventApi) {
    var _this = this;

    var emitter = this.getCurrentData().emitter;
    emitter.trigger('eventAdd', {
      event: eventApi,
      relatedEvents: [],
      revert: function revert() {
        _this.dispatch({
          type: 'REMOVE_EVENTS',
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }; // TODO: optimize


  CalendarApi.prototype.getEventById = function (id) {
    var state = this.getCurrentData();
    var _a = state.eventStore,
        defs = _a.defs,
        instances = _a.instances;
    id = String(id);

    for (var defId in defs) {
      var def = defs[defId];

      if (def.publicId === id) {
        if (def.recurringDef) {
          return new EventApi(state, def, null);
        }

        for (var instanceId in instances) {
          var instance = instances[instanceId];

          if (instance.defId === def.defId) {
            return new EventApi(state, def, instance);
          }
        }
      }
    }

    return null;
  };

  CalendarApi.prototype.getEvents = function () {
    var currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  };

  CalendarApi.prototype.removeAllEvents = function () {
    this.dispatch({
      type: 'REMOVE_ALL_EVENTS'
    });
  }; // Public Event Sources API
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.getEventSources = function () {
    var state = this.getCurrentData();
    var sourceHash = state.eventSources;
    var sourceApis = [];

    for (var internalId in sourceHash) {
      sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));
    }

    return sourceApis;
  };

  CalendarApi.prototype.getEventSourceById = function (id) {
    var state = this.getCurrentData();
    var sourceHash = state.eventSources;
    id = String(id);

    for (var sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id) {
        return new EventSourceApi(state, sourceHash[sourceId]);
      }
    }

    return null;
  };

  CalendarApi.prototype.addEventSource = function (sourceInput) {
    var state = this.getCurrentData();

    if (sourceInput instanceof EventSourceApi) {
      // not already present? don't want to add an old snapshot
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: 'ADD_EVENT_SOURCES',
          sources: [sourceInput.internalEventSource]
        });
      }

      return sourceInput;
    }

    var eventSource = parseEventSource(sourceInput, state);

    if (eventSource) {
      // TODO: error otherwise?
      this.dispatch({
        type: 'ADD_EVENT_SOURCES',
        sources: [eventSource]
      });
      return new EventSourceApi(state, eventSource);
    }

    return null;
  };

  CalendarApi.prototype.removeAllEventSources = function () {
    this.dispatch({
      type: 'REMOVE_ALL_EVENT_SOURCES'
    });
  };

  CalendarApi.prototype.refetchEvents = function () {
    this.dispatch({
      type: 'FETCH_EVENT_SOURCES',
      isRefetch: true
    });
  }; // Scroll
  // -----------------------------------------------------------------------------------------------------------------


  CalendarApi.prototype.scrollToTime = function (timeInput) {
    var time = createDuration(timeInput);

    if (time) {
      this.trigger('_scrollRequest', {
        time: time
      });
    }
  };

  return CalendarApi;
}();

var EventApi =
/** @class */
function () {
  // instance will be null if expressing a recurring event that has no current instances,
  // OR if trying to validate an incoming external event that has no dates assigned
  function EventApi(context, def, instance) {
    this._context = context;
    this._def = def;
    this._instance = instance || null;
  }
  /*
  TODO: make event struct more responsible for this
  */


  EventApi.prototype.setProp = function (name, val) {
    var _a, _b;

    if (name in EVENT_DATE_REFINERS) {
      console.warn('Could not set date-related prop \'name\'. Use one of the date-related methods instead.'); // TODO: make proper aliasing system?
    } else if (name === 'id') {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: {
          publicId: val
        } // hardcoded internal name

      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: (_a = {}, _a[name] = val, _a)
      });
    } else if (name in EVENT_UI_REFINERS) {
      var ui = EVENT_UI_REFINERS[name](val);

      if (name === 'color') {
        ui = {
          backgroundColor: val,
          borderColor: val
        };
      } else if (name === 'editable') {
        ui = {
          startEditable: val,
          durationEditable: val
        };
      } else {
        ui = (_b = {}, _b[name] = val, _b);
      }

      this.mutate({
        standardProps: {
          ui: ui
        }
      });
    } else {
      console.warn("Could not set prop '" + name + "'. Use setExtendedProp instead.");
    }
  };

  EventApi.prototype.setExtendedProp = function (name, val) {
    var _a;

    this.mutate({
      extendedProps: (_a = {}, _a[name] = val, _a)
    });
  };

  EventApi.prototype.setStart = function (startInput, options) {
    if (options === void 0) {
      options = {};
    }

    var dateEnv = this._context.dateEnv;
    var start = dateEnv.createMarker(startInput);

    if (start && this._instance) {
      // TODO: warning if parsed bad
      var instanceRange = this._instance.range;
      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?

      if (options.maintainDuration) {
        this.mutate({
          datesDelta: startDelta
        });
      } else {
        this.mutate({
          startDelta: startDelta
        });
      }
    }
  };

  EventApi.prototype.setEnd = function (endInput, options) {
    if (options === void 0) {
      options = {};
    }

    var dateEnv = this._context.dateEnv;
    var end;

    if (endInput != null) {
      end = dateEnv.createMarker(endInput);

      if (!end) {
        return; // TODO: warning if parsed bad
      }
    }

    if (this._instance) {
      if (end) {
        var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({
          endDelta: endDelta
        });
      } else {
        this.mutate({
          standardProps: {
            hasEnd: false
          }
        });
      }
    }
  };

  EventApi.prototype.setDates = function (startInput, endInput, options) {
    if (options === void 0) {
      options = {};
    }

    var dateEnv = this._context.dateEnv;
    var standardProps = {
      allDay: options.allDay
    };
    var start = dateEnv.createMarker(startInput);
    var end;

    if (!start) {
      return; // TODO: warning if parsed bad
    }

    if (endInput != null) {
      end = dateEnv.createMarker(endInput);

      if (!end) {
        // TODO: warning if parsed bad
        return;
      }
    }

    if (this._instance) {
      var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,
      // compute diff off of the all-day values the way event-mutation does.

      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }

      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);

      if (end) {
        var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);

        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({
            datesDelta: startDelta,
            standardProps: standardProps
          });
        } else {
          this.mutate({
            startDelta: startDelta,
            endDelta: endDelta,
            standardProps: standardProps
          });
        }
      } else {
        // means "clear the end"
        standardProps.hasEnd = false;
        this.mutate({
          datesDelta: startDelta,
          standardProps: standardProps
        });
      }
    }
  };

  EventApi.prototype.moveStart = function (deltaInput) {
    var delta = createDuration(deltaInput);

    if (delta) {
      // TODO: warning if parsed bad
      this.mutate({
        startDelta: delta
      });
    }
  };

  EventApi.prototype.moveEnd = function (deltaInput) {
    var delta = createDuration(deltaInput);

    if (delta) {
      // TODO: warning if parsed bad
      this.mutate({
        endDelta: delta
      });
    }
  };

  EventApi.prototype.moveDates = function (deltaInput) {
    var delta = createDuration(deltaInput);

    if (delta) {
      // TODO: warning if parsed bad
      this.mutate({
        datesDelta: delta
      });
    }
  };

  EventApi.prototype.setAllDay = function (allDay, options) {
    if (options === void 0) {
      options = {};
    }

    var standardProps = {
      allDay: allDay
    };
    var maintainDuration = options.maintainDuration;

    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }

    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }

    this.mutate({
      standardProps: standardProps
    });
  };

  EventApi.prototype.formatRange = function (formatInput) {
    var dateEnv = this._context.dateEnv;
    var instance = this._instance;
    var formatter = createFormatter(formatInput);

    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }

    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  };

  EventApi.prototype.mutate = function (mutation) {
    var instance = this._instance;

    if (instance) {
      var def = this._def;
      var context_1 = this._context;
      var eventStore_1 = context_1.getCurrentData().eventStore;
      var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);
      var eventConfigBase = {
        '': {
          display: '',
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: '',
          borderColor: '',
          textColor: '',
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);
      var oldEvent = new EventApi(context_1, def, instance); // snapshot

      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context_1.dispatch({
        type: 'MERGE_EVENTS',
        eventStore: relevantEvents
      });
      context_1.emitter.trigger('eventChange', {
        oldEvent: oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context_1, instance),
        revert: function revert() {
          context_1.dispatch({
            type: 'RESET_EVENTS',
            eventStore: eventStore_1
          });
        }
      });
    }
  };

  EventApi.prototype.remove = function () {
    var context = this._context;
    var asStore = eventApiToStore(this);
    context.dispatch({
      type: 'REMOVE_EVENTS',
      eventStore: asStore
    });
    context.emitter.trigger('eventRemove', {
      event: this,
      relatedEvents: [],
      revert: function revert() {
        context.dispatch({
          type: 'MERGE_EVENTS',
          eventStore: asStore
        });
      }
    });
  };

  Object.defineProperty(EventApi.prototype, "source", {
    get: function get() {
      var sourceId = this._def.sourceId;

      if (sourceId) {
        return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);
      }

      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "start", {
    get: function get() {
      return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "end", {
    get: function get() {
      return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "startStr", {
    get: function get() {
      var instance = this._instance;

      if (instance) {
        return this._context.dateEnv.formatIso(instance.range.start, {
          omitTime: this._def.allDay,
          forcedTzo: instance.forcedStartTzo
        });
      }

      return '';
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "endStr", {
    get: function get() {
      var instance = this._instance;

      if (instance && this._def.hasEnd) {
        return this._context.dateEnv.formatIso(instance.range.end, {
          omitTime: this._def.allDay,
          forcedTzo: instance.forcedEndTzo
        });
      }

      return '';
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "id", {
    // computable props that all access the def
    // TODO: find a TypeScript-compatible way to do this at scale
    get: function get() {
      return this._def.publicId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "groupId", {
    get: function get() {
      return this._def.groupId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "allDay", {
    get: function get() {
      return this._def.allDay;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "title", {
    get: function get() {
      return this._def.title;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "url", {
    get: function get() {
      return this._def.url;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "display", {
    get: function get() {
      return this._def.ui.display || 'auto';
    } // bad. just normalize the type earlier
    ,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "startEditable", {
    get: function get() {
      return this._def.ui.startEditable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "durationEditable", {
    get: function get() {
      return this._def.ui.durationEditable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "constraint", {
    get: function get() {
      return this._def.ui.constraints[0] || null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "overlap", {
    get: function get() {
      return this._def.ui.overlap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "allow", {
    get: function get() {
      return this._def.ui.allows[0] || null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "backgroundColor", {
    get: function get() {
      return this._def.ui.backgroundColor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "borderColor", {
    get: function get() {
      return this._def.ui.borderColor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "textColor", {
    get: function get() {
      return this._def.ui.textColor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "classNames", {
    // NOTE: user can't modify these because Object.freeze was called in event-def parsing
    get: function get() {
      return this._def.ui.classNames;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventApi.prototype, "extendedProps", {
    get: function get() {
      return this._def.extendedProps;
    },
    enumerable: false,
    configurable: true
  });

  EventApi.prototype.toPlainObject = function (settings) {
    if (settings === void 0) {
      settings = {};
    }

    var def = this._def;
    var ui = def.ui;

    var _a = this,
        startStr = _a.startStr,
        endStr = _a.endStr;

    var res = {};

    if (def.title) {
      res.title = def.title;
    }

    if (startStr) {
      res.start = startStr;
    }

    if (endStr) {
      res.end = endStr;
    }

    if (def.publicId) {
      res.id = def.publicId;
    }

    if (def.groupId) {
      res.groupId = def.groupId;
    }

    if (def.url) {
      res.url = def.url;
    }

    if (ui.display && ui.display !== 'auto') {
      res.display = ui.display;
    } // TODO: what about recurring-event properties???
    // TODO: include startEditable/durationEditable/constraint/overlap/allow


    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.color = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.backgroundColor = ui.backgroundColor;
      }

      if (ui.borderColor) {
        res.borderColor = ui.borderColor;
      }
    }

    if (ui.textColor) {
      res.textColor = ui.textColor;
    }

    if (ui.classNames.length) {
      res.classNames = ui.classNames;
    }

    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        _assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }

    return res;
  };

  EventApi.prototype.toJSON = function () {
    return this.toPlainObject();
  };

  return EventApi;
}();

function eventApiToStore(eventApi) {
  var _a, _b;

  var def = eventApi._def;
  var instance = eventApi._instance;
  return {
    defs: (_a = {}, _a[def.defId] = def, _a),
    instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}
  };
}

function buildEventApis(eventStore, context, excludeInstance) {
  var defs = eventStore.defs,
      instances = eventStore.instances;
  var eventApis = [];
  var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';

  for (var id in instances) {
    var instance = instances[id];
    var def = defs[instance.defId];

    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventApi(context, def, instance));
    }
  }

  return eventApis;
}

var calendarSystemClassMap = {};

function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}

function createCalendarSystem(name) {
  return new calendarSystemClassMap[name]();
}

var GregorianCalendarSystem =
/** @class */
function () {
  function GregorianCalendarSystem() {}

  GregorianCalendarSystem.prototype.getMarkerYear = function (d) {
    return d.getUTCFullYear();
  };

  GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {
    return d.getUTCMonth();
  };

  GregorianCalendarSystem.prototype.getMarkerDay = function (d) {
    return d.getUTCDate();
  };

  GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {
    return arrayToUtcDate(arr);
  };

  GregorianCalendarSystem.prototype.markerToArray = function (marker) {
    return dateToUtcArray(marker);
  };

  return GregorianCalendarSystem;
}();

registerCalendarSystem('gregory', GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;

function parse(str) {
  var m = ISO_RE.exec(str);

  if (m) {
    var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number("0." + m[12]) * 1000 : 0));

    if (isValidDate(marker)) {
      var timeZoneOffset = null;

      if (m[13]) {
        timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));
      }

      return {
        marker: marker,
        isTimeUnspecified: !m[6],
        timeZoneOffset: timeZoneOffset
      };
    }
  }

  return null;
}

var DateEnv =
/** @class */
function () {
  function DateEnv(settings) {
    var timeZone = this.timeZone = settings.timeZone;
    var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';

    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }

    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;

    if (settings.weekNumberCalculation === 'ISO') {
      this.weekDow = 1;
      this.weekDoy = 4;
    }

    if (typeof settings.firstDay === 'number') {
      this.weekDow = settings.firstDay;
    }

    if (typeof settings.weekNumberCalculation === 'function') {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }

    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  } // Creating / Parsing


  DateEnv.prototype.createMarker = function (input) {
    var meta = this.createMarkerMeta(input);

    if (meta === null) {
      return null;
    }

    return meta.marker;
  };

  DateEnv.prototype.createNowMarker = function () {
    if (this.canComputeOffset) {
      return this.timestampToMarker(new Date().valueOf());
    } // if we can't compute the current date val for a timezone,
    // better to give the current local date vals than UTC


    return arrayToUtcDate(dateToLocalArray(new Date()));
  };

  DateEnv.prototype.createMarkerMeta = function (input) {
    if (typeof input === 'string') {
      return this.parse(input);
    }

    var marker = null;

    if (typeof input === 'number') {
      marker = this.timestampToMarker(input);
    } else if (input instanceof Date) {
      input = input.valueOf();

      if (!isNaN(input)) {
        marker = this.timestampToMarker(input);
      }
    } else if (Array.isArray(input)) {
      marker = arrayToUtcDate(input);
    }

    if (marker === null || !isValidDate(marker)) {
      return null;
    }

    return {
      marker: marker,
      isTimeUnspecified: false,
      forcedTzo: null
    };
  };

  DateEnv.prototype.parse = function (s) {
    var parts = parse(s);

    if (parts === null) {
      return null;
    }

    var marker = parts.marker;
    var forcedTzo = null;

    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }

    return {
      marker: marker,
      isTimeUnspecified: parts.isTimeUnspecified,
      forcedTzo: forcedTzo
    };
  }; // Accessors


  DateEnv.prototype.getYear = function (marker) {
    return this.calendarSystem.getMarkerYear(marker);
  };

  DateEnv.prototype.getMonth = function (marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }; // Adding / Subtracting


  DateEnv.prototype.add = function (marker, dur) {
    var a = this.calendarSystem.markerToArray(marker);
    a[0] += dur.years;
    a[1] += dur.months;
    a[2] += dur.days;
    a[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a);
  };

  DateEnv.prototype.subtract = function (marker, dur) {
    var a = this.calendarSystem.markerToArray(marker);
    a[0] -= dur.years;
    a[1] -= dur.months;
    a[2] -= dur.days;
    a[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a);
  };

  DateEnv.prototype.addYears = function (marker, n) {
    var a = this.calendarSystem.markerToArray(marker);
    a[0] += n;
    return this.calendarSystem.arrayToMarker(a);
  };

  DateEnv.prototype.addMonths = function (marker, n) {
    var a = this.calendarSystem.markerToArray(marker);
    a[1] += n;
    return this.calendarSystem.arrayToMarker(a);
  }; // Diffing Whole Units


  DateEnv.prototype.diffWholeYears = function (m0, m1) {
    var calendarSystem = this.calendarSystem;

    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }

    return null;
  };

  DateEnv.prototype.diffWholeMonths = function (m0, m1) {
    var calendarSystem = this.calendarSystem;

    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }

    return null;
  }; // Range / Duration


  DateEnv.prototype.greatestWholeUnit = function (m0, m1) {
    var n = this.diffWholeYears(m0, m1);

    if (n !== null) {
      return {
        unit: 'year',
        value: n
      };
    }

    n = this.diffWholeMonths(m0, m1);

    if (n !== null) {
      return {
        unit: 'month',
        value: n
      };
    }

    n = diffWholeWeeks(m0, m1);

    if (n !== null) {
      return {
        unit: 'week',
        value: n
      };
    }

    n = diffWholeDays(m0, m1);

    if (n !== null) {
      return {
        unit: 'day',
        value: n
      };
    }

    n = diffHours(m0, m1);

    if (isInt(n)) {
      return {
        unit: 'hour',
        value: n
      };
    }

    n = diffMinutes(m0, m1);

    if (isInt(n)) {
      return {
        unit: 'minute',
        value: n
      };
    }

    n = diffSeconds(m0, m1);

    if (isInt(n)) {
      return {
        unit: 'second',
        value: n
      };
    }

    return {
      unit: 'millisecond',
      value: m1.valueOf() - m0.valueOf()
    };
  };

  DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {
    // TODO: can use greatestWholeUnit
    var diff;

    if (d.years) {
      diff = this.diffWholeYears(m0, m1);

      if (diff !== null) {
        return diff / asRoughYears(d);
      }
    }

    if (d.months) {
      diff = this.diffWholeMonths(m0, m1);

      if (diff !== null) {
        return diff / asRoughMonths(d);
      }
    }

    if (d.days) {
      diff = diffWholeDays(m0, m1);

      if (diff !== null) {
        return diff / asRoughDays(d);
      }
    }

    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
  }; // Start-Of
  // these DON'T return zoned-dates. only UTC start-of dates


  DateEnv.prototype.startOf = function (m, unit) {
    if (unit === 'year') {
      return this.startOfYear(m);
    }

    if (unit === 'month') {
      return this.startOfMonth(m);
    }

    if (unit === 'week') {
      return this.startOfWeek(m);
    }

    if (unit === 'day') {
      return startOfDay(m);
    }

    if (unit === 'hour') {
      return startOfHour(m);
    }

    if (unit === 'minute') {
      return startOfMinute(m);
    }

    if (unit === 'second') {
      return startOfSecond(m);
    }

    return null;
  };

  DateEnv.prototype.startOfYear = function (m) {
    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);
  };

  DateEnv.prototype.startOfMonth = function (m) {
    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);
  };

  DateEnv.prototype.startOfWeek = function (m) {
    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);
  }; // Week Number


  DateEnv.prototype.computeWeekNumber = function (marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }

    return weekOfYear(marker, this.weekDow, this.weekDoy);
  }; // TODO: choke on timeZoneName: long


  DateEnv.prototype.format = function (marker, formatter, dateOptions) {
    if (dateOptions === void 0) {
      dateOptions = {};
    }

    return formatter.format({
      marker: marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  };

  DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {
    if (dateOptions === void 0) {
      dateOptions = {};
    }

    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }

    return formatter.formatRange({
      marker: start,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  };
  /*
  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
  might as well use buildIsoString or some other util directly
  */


  DateEnv.prototype.formatIso = function (marker, extraOptions) {
    if (extraOptions === void 0) {
      extraOptions = {};
    }

    var timeZoneOffset = null;

    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }

    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }; // TimeZone


  DateEnv.prototype.timestampToMarker = function (ms) {
    if (this.timeZone === 'local') {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }

    if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }

    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  };

  DateEnv.prototype.offsetForMarker = function (m) {
    if (this.timeZone === 'local') {
      return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
    }

    if (this.timeZone === 'UTC') {
      return 0;
    }

    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
    }

    return null;
  }; // Conversion


  DateEnv.prototype.toDate = function (m, forcedTzo) {
    if (this.timeZone === 'local') {
      return arrayToLocalDate(dateToUtcArray(m));
    }

    if (this.timeZone === 'UTC') {
      return new Date(m.valueOf()); // make sure it's a copy
    }

    if (!this.namedTimeZoneImpl) {
      return new Date(m.valueOf() - (forcedTzo || 0));
    }

    return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);
  };

  return DateEnv;
}();

var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: 'en',
  week: {
    dow: 0,
    doy: 4 // 4 days need to be within the year to be considered the first week

  },
  direction: 'ltr',
  buttonText: {
    prev: 'prev',
    next: 'next',
    prevYear: 'prev year',
    nextYear: 'next year',
    year: 'year',
    today: 'today',
    month: 'month',
    week: 'week',
    day: 'day',
    list: 'list'
  },
  weekText: 'W',
  weekTextLong: 'Week',
  closeHint: 'Close',
  timeHint: 'Time',
  eventHint: 'Event',
  allDayText: 'all-day',
  moreLinkText: 'more',
  noEventsText: 'No events to display'
};

var RAW_EN_LOCALE = _assign(_assign({}, MINIMAL_RAW_EN_LOCALE), {
  // Includes things we don't want other locales to inherit,
  // things that derive from other translatable strings.
  buttonHints: {
    prev: 'Previous $0',
    next: 'Next $0',
    today: function today(buttonText, unit) {
      return unit === 'day' ? 'Today' : "This " + buttonText;
    }
  },
  viewHint: '$0 view',
  navLinkHint: 'Go to $0',
  moreLinkHint: function moreLinkHint(eventCnt) {
    return "Show " + eventCnt + " more event" + (eventCnt === 1 ? '' : 's');
  }
});

function organizeRawLocales(explicitRawLocales) {
  var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
  var allRawLocales = globalLocales.concat(explicitRawLocales);
  var rawLocaleMap = {
    en: RAW_EN_LOCALE
  };

  for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {
    var rawLocale = allRawLocales_1[_i];
    rawLocaleMap[rawLocale.code] = rawLocale;
  }

  return {
    map: rawLocaleMap,
    defaultCode: defaultCode
  };
}

function buildLocale(inputSingular, available) {
  if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }

  return queryLocale(inputSingular, available);
}

function queryLocale(codeArg, available) {
  var codes = [].concat(codeArg || []); // will convert to array

  var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}

function queryRawLocale(codes, available) {
  for (var i = 0; i < codes.length; i += 1) {
    var parts = codes[i].toLocaleLowerCase().split('-');

    for (var j = parts.length; j > 0; j -= 1) {
      var simpleId = parts.slice(0, j).join('-');

      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }

  return null;
}

function parseLocale(codeArg, codes, raw) {
  var merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ['buttonText']);
  delete merged.code; // don't want this part of the options

  var week = merged.week;
  delete merged.week;
  return {
    codeArg: codeArg,
    codes: codes,
    week: week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}

function formatDate(dateInput, options) {
  if (options === void 0) {
    options = {};
  }

  var dateEnv = buildDateEnv$1(options);
  var formatter = createFormatter(options);
  var dateMeta = dateEnv.createMarkerMeta(dateInput);

  if (!dateMeta) {
    // TODO: warning?
    return '';
  }

  return dateEnv.format(dateMeta.marker, formatter, {
    forcedTzo: dateMeta.forcedTzo
  });
}

function formatRange(startInput, endInput, options) {
  var dateEnv = buildDateEnv$1(typeof options === 'object' && options ? options : {}); // pass in if non-null object

  var formatter = createFormatter(options);
  var startMeta = dateEnv.createMarkerMeta(startInput);
  var endMeta = dateEnv.createMarkerMeta(endInput);

  if (!startMeta || !endMeta) {
    // TODO: warning?
    return '';
  }

  return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {
    forcedStartTzo: startMeta.forcedTzo,
    forcedEndTzo: endMeta.forcedTzo,
    isEndExclusive: options.isEndExclusive,
    defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator
  });
} // TODO: more DRY and optimized


function buildDateEnv$1(settings) {
  var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere

  return new DateEnv(__assign(__assign({
    timeZone: BASE_OPTION_DEFAULTS.timeZone,
    calendarSystem: 'gregory'
  }, settings), {
    locale: locale
  }));
}

var DEF_DEFAULTS = {
  startTime: '09:00',
  endTime: '17:00',
  daysOfWeek: [1, 2, 3, 4, 5],
  display: 'inverse-background',
  classNames: 'fc-non-business',
  groupId: '_businessHours' // so multiple defs get grouped

};
/*
TODO: pass around as EventDefHash!!!
*/

function parseBusinessHours(input, context) {
  return parseEvents(refineInputs(input), null, context);
}

function refineInputs(input) {
  var rawDefs;

  if (input === true) {
    rawDefs = [{}]; // will get DEF_DEFAULTS verbatim
  } else if (Array.isArray(input)) {
    // if specifying an array, every sub-definition NEEDS a day-of-week
    rawDefs = input.filter(function (rawDef) {
      return rawDef.daysOfWeek;
    });
  } else if (typeof input === 'object' && input) {
    // non-null object
    rawDefs = [input];
  } else {
    // is probably false
    rawDefs = [];
  }

  rawDefs = rawDefs.map(function (rawDef) {
    return _assign(_assign({}, DEF_DEFAULTS), rawDef);
  });
  return rawDefs;
}

function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
} // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false


function intersectRects(rect1, rect2) {
  var res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };

  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }

  return false;
}

function translateRect(rect, deltaX, deltaY) {
  return {
    left: rect.left + deltaX,
    right: rect.right + deltaX,
    top: rect.top + deltaY,
    bottom: rect.bottom + deltaY
  };
} // Returns a new point that will have been moved to reside within the given rectangle


function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
} // Returns a point that is the center of the given rectangle


function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
} // Subtracts point2's coordinates from point1's coordinates, returning a delta


function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}

var canVGrowWithinCell;

function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }

  return canVGrowWithinCell;
}

function computeCanVGrowWithinCell() {
  // for SSR, because this function is call immediately at top-level
  // TODO: just make this logic execute top-level, immediately, instead of doing lazily
  if (typeof document === 'undefined') {
    return true;
  }

  var el = document.createElement('div');
  el.style.position = 'absolute';
  el.style.top = '0px';
  el.style.left = '0px';
  el.innerHTML = '<table><tr><td><div></div></td></tr></table>';
  el.querySelector('table').style.height = '100px';
  el.querySelector('div').style.height = '100%';
  document.body.appendChild(el);
  var div = el.querySelector('div');
  var possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}

var EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere

var Splitter =
/** @class */
function () {
  function Splitter() {
    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
    this.splitDateSelection = memoize(this._splitDateSpan);
    this.splitEventStore = memoize(this._splitEventStore);
    this.splitIndividualUi = memoize(this._splitIndividualUi);
    this.splitEventDrag = memoize(this._splitInteraction);
    this.splitEventResize = memoize(this._splitInteraction);
    this.eventUiBuilders = {}; // TODO: typescript protection
  }

  Splitter.prototype.splitProps = function (props) {
    var _this = this;

    var keyInfos = this.getKeyInfo(props);
    var defKeys = this.getKeysForEventDefs(props.eventStore);
    var dateSelections = this.splitDateSelection(props.dateSelection);
    var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*

    var eventStores = this.splitEventStore(props.eventStore, defKeys);
    var eventDrags = this.splitEventDrag(props.eventDrag);
    var eventResizes = this.splitEventResize(props.eventResize);
    var splitProps = {};
    this.eventUiBuilders = mapHash(keyInfos, function (info, key) {
      return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);
    });

    for (var key in keyInfos) {
      var keyInfo = keyInfos[key];
      var eventStore = eventStores[key] || EMPTY_EVENT_STORE;
      var buildEventUi = this.eventUiBuilders[key];
      splitProps[key] = {
        businessHours: keyInfo.businessHours || props.businessHours,
        dateSelection: dateSelections[key] || null,
        eventStore: eventStore,
        eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),
        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',
        eventDrag: eventDrags[key] || null,
        eventResize: eventResizes[key] || null
      };
    }

    return splitProps;
  };

  Splitter.prototype._splitDateSpan = function (dateSpan) {
    var dateSpans = {};

    if (dateSpan) {
      var keys = this.getKeysForDateSpan(dateSpan);

      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        dateSpans[key] = dateSpan;
      }
    }

    return dateSpans;
  };

  Splitter.prototype._getKeysForEventDefs = function (eventStore) {
    var _this = this;

    return mapHash(eventStore.defs, function (eventDef) {
      return _this.getKeysForEventDef(eventDef);
    });
  };

  Splitter.prototype._splitEventStore = function (eventStore, defKeys) {
    var defs = eventStore.defs,
        instances = eventStore.instances;
    var splitStores = {};

    for (var defId in defs) {
      for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
        var key = _a[_i];

        if (!splitStores[key]) {
          splitStores[key] = createEmptyEventStore();
        }

        splitStores[key].defs[defId] = defs[defId];
      }
    }

    for (var instanceId in instances) {
      var instance = instances[instanceId];

      for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {
        var key = _c[_b];

        if (splitStores[key]) {
          // must have already been created
          splitStores[key].instances[instanceId] = instance;
        }
      }
    }

    return splitStores;
  };

  Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {
    var splitHashes = {};

    for (var defId in eventUiBases) {
      if (defId) {
        // not the '' key
        for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
          var key = _a[_i];

          if (!splitHashes[key]) {
            splitHashes[key] = {};
          }

          splitHashes[key][defId] = eventUiBases[defId];
        }
      }
    }

    return splitHashes;
  };

  Splitter.prototype._splitInteraction = function (interaction) {
    var splitStates = {};

    if (interaction) {
      var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents)); // can't rely on defKeys because event data is mutated


      var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);

      var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);

      var populate = function populate(key) {
        if (!splitStates[key]) {
          splitStates[key] = {
            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,
            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,
            isEvent: interaction.isEvent
          };
        }
      };

      for (var key in affectedStores_1) {
        populate(key);
      }

      for (var key in mutatedStores_1) {
        populate(key);
      }
    }

    return splitStates;
  };

  return Splitter;
}();

function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
  var baseParts = [];

  if (allUi) {
    baseParts.push(allUi);
  }

  if (eventUiForKey) {
    baseParts.push(eventUiForKey);
  }

  var stuff = {
    '': combineEventUis(baseParts)
  };

  if (individualUi) {
    _assign(stuff, individualUi);
  }

  return stuff;
}

function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}

function getDayClassNames(meta, theme) {
  var classNames = ['fc-day', "fc-day-" + DAY_IDS[meta.dow]];

  if (meta.isDisabled) {
    classNames.push('fc-day-disabled');
  } else {
    if (meta.isToday) {
      classNames.push('fc-day-today');
      classNames.push(theme.getClass('today'));
    }

    if (meta.isPast) {
      classNames.push('fc-day-past');
    }

    if (meta.isFuture) {
      classNames.push('fc-day-future');
    }

    if (meta.isOther) {
      classNames.push('fc-day-other');
    }
  }

  return classNames;
}

function getSlotClassNames(meta, theme) {
  var classNames = ['fc-slot', "fc-slot-" + DAY_IDS[meta.dow]];

  if (meta.isDisabled) {
    classNames.push('fc-slot-disabled');
  } else {
    if (meta.isToday) {
      classNames.push('fc-slot-today');
      classNames.push(theme.getClass('today'));
    }

    if (meta.isPast) {
      classNames.push('fc-slot-past');
    }

    if (meta.isFuture) {
      classNames.push('fc-slot-future');
    }
  }

  return classNames;
}

var DAY_FORMAT = createFormatter({
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});
var WEEK_FORMAT = createFormatter({
  week: 'long'
});

function buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {
  if (viewType === void 0) {
    viewType = 'day';
  }

  if (isTabbable === void 0) {
    isTabbable = true;
  }

  var dateEnv = context.dateEnv,
      options = context.options,
      calendarApi = context.calendarApi;
  var dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);

  if (options.navLinks) {
    var zonedDate = dateEnv.toDate(dateMarker);

    var handleInteraction = function handleInteraction(ev) {
      var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;

      if (typeof customAction === 'function') {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === 'string') {
          viewType = customAction;
        }

        calendarApi.zoomTo(dateMarker, viewType);
      }
    };

    return _assign({
      title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr),
      'data-navlink': ''
    }, isTabbable ? createAriaClickAttrs(handleInteraction) : {
      onClick: handleInteraction
    });
  }

  return {
    'aria-label': dateStr
  };
}

var _isRtlScrollbarOnLeft = null;

function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }

  return _isRtlScrollbarOnLeft;
}

function computeIsRtlScrollbarOnLeft() {
  var outerEl = document.createElement('div');
  applyStyle(outerEl, {
    position: 'absolute',
    top: -1000,
    left: 0,
    border: 0,
    padding: 0,
    overflow: 'scroll',
    direction: 'rtl'
  });
  outerEl.innerHTML = '<div></div>';
  document.body.appendChild(outerEl);
  var innerEl = outerEl.firstChild;
  var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}

var _scrollbarWidths;

function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }

  return _scrollbarWidths;
}

function computeScrollbarWidths() {
  var el = document.createElement('div');
  el.style.overflow = 'scroll';
  el.style.position = 'absolute';
  el.style.top = '-9999px';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  var res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
} // WARNING: will include border


function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}

function computeEdges(el, getPadding) {
  if (getPadding === void 0) {
    getPadding = false;
  }

  var computedStyle = window.getComputedStyle(el);
  var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!

  var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  var res = {
    borderLeft: borderLeft,
    borderRight: borderRight,
    borderTop: borderTop,
    borderBottom: borderBottom,
    scrollbarBottom: scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };

  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {
    // is the scrollbar on the left side?
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }

  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }

  return res;
}

function computeInnerRect(el, goWithinPadding, doFromWindowViewport) {
  if (goWithinPadding === void 0) {
    goWithinPadding = false;
  }

  var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  var edges = computeEdges(el, goWithinPadding);
  var res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };

  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }

  return res;
}

function computeRect(el) {
  var rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.pageXOffset,
    top: rect.top + window.pageYOffset,
    right: rect.right + window.pageXOffset,
    bottom: rect.bottom + window.pageYOffset
  };
}

function computeClippedClientRect(el) {
  var clippingParents = getClippingParents(el);
  var rect = el.getBoundingClientRect();

  for (var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++) {
    var clippingParent = clippingParents_1[_i];
    var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());

    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }

  return rect;
}

function computeHeightAndMargins(el) {
  return el.getBoundingClientRect().height + computeVMargins(el);
}

function computeVMargins(el) {
  var computed = window.getComputedStyle(el);
  return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);
} // does not return window


function getClippingParents(el) {
  var parents = [];

  while (el instanceof HTMLElement) {
    // will stop when gets to document or null
    var computedStyle = window.getComputedStyle(el);

    if (computedStyle.position === 'fixed') {
      break;
    }

    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }

    el = el.parentNode;
  }

  return parents;
} // given a function that resolves a result asynchronously.
// the function can either call passed-in success and failure callbacks,
// or it can return a promise.
// if you need to pass additional params to func, bind them first.


function unpromisify(func, success, failure) {
  // guard against success/failure callbacks being called more than once
  // and guard against a promise AND callback being used together.
  var isResolved = false;

  var wrappedSuccess = function wrappedSuccess() {
    if (!isResolved) {
      isResolved = true;
      success.apply(this, arguments); // eslint-disable-line prefer-rest-params
    }
  };

  var wrappedFailure = function wrappedFailure() {
    if (!isResolved) {
      isResolved = true;

      if (failure) {
        failure.apply(this, arguments); // eslint-disable-line prefer-rest-params
      }
    }
  };

  var res = func(wrappedSuccess, wrappedFailure);

  if (res && typeof res.then === 'function') {
    res.then(wrappedSuccess, wrappedFailure);
  }
}

var Emitter =
/** @class */
function () {
  function Emitter() {
    this.handlers = {};
    this.thisContext = null;
  }

  Emitter.prototype.setThisContext = function (thisContext) {
    this.thisContext = thisContext;
  };

  Emitter.prototype.setOptions = function (options) {
    this.options = options;
  };

  Emitter.prototype.on = function (type, handler) {
    addToHash(this.handlers, type, handler);
  };

  Emitter.prototype.off = function (type, handler) {
    removeFromHash(this.handlers, type, handler);
  };

  Emitter.prototype.trigger = function (type) {
    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    var attachedHandlers = this.handlers[type] || [];
    var optionHandler = this.options && this.options[type];
    var handlers = [].concat(optionHandler || [], attachedHandlers);

    for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {
      var handler = handlers_1[_a];
      handler.apply(this.thisContext, args);
    }
  };

  Emitter.prototype.hasHandlers = function (type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  };

  return Emitter;
}();

function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}

function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter(function (func) {
        return func !== handler;
      });
    }
  } else {
    delete hash[type]; // remove all handler funcs for this type
  }
}
/*
Records offset information for a set of elements, relative to an origin element.
Can record the left/right OR the top/bottom OR both.
Provides methods for querying the cache by position.
*/


var PositionCache =
/** @class */
function () {
  function PositionCache(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left

    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }

    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  } // Populates the left/right internal coordinate arrays


  PositionCache.prototype.buildElHorizontals = function (originClientLeft) {
    var lefts = [];
    var rights = [];

    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
      var el = _a[_i];
      var rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }

    this.lefts = lefts;
    this.rights = rights;
  }; // Populates the top/bottom internal coordinate arrays


  PositionCache.prototype.buildElVerticals = function (originClientTop) {
    var tops = [];
    var bottoms = [];

    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
      var el = _a[_i];
      var rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }

    this.tops = tops;
    this.bottoms = bottoms;
  }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
  // If no intersection is made, returns undefined.


  PositionCache.prototype.leftToIndex = function (leftPosition) {
    var _a = this,
        lefts = _a.lefts,
        rights = _a.rights;

    var len = lefts.length;
    var i;

    for (i = 0; i < len; i += 1) {
      if (leftPosition >= lefts[i] && leftPosition < rights[i]) {
        return i;
      }
    }

    return undefined; // TODO: better
  }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.
  // If no intersection is made, returns undefined.


  PositionCache.prototype.topToIndex = function (topPosition) {
    var _a = this,
        tops = _a.tops,
        bottoms = _a.bottoms;

    var len = tops.length;
    var i;

    for (i = 0; i < len; i += 1) {
      if (topPosition >= tops[i] && topPosition < bottoms[i]) {
        return i;
      }
    }

    return undefined; // TODO: better
  }; // Gets the width of the element at the given index


  PositionCache.prototype.getWidth = function (leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }; // Gets the height of the element at the given index


  PositionCache.prototype.getHeight = function (topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  };

  return PositionCache;
}();
/* eslint max-classes-per-file: "off" */

/*
An object for getting/setting scroll-related information for an element.
Internally, this is done very differently for window versus DOM element,
so this object serves as a common interface.
*/


var ScrollController =
/** @class */
function () {
  function ScrollController() {}

  ScrollController.prototype.getMaxScrollTop = function () {
    return this.getScrollHeight() - this.getClientHeight();
  };

  ScrollController.prototype.getMaxScrollLeft = function () {
    return this.getScrollWidth() - this.getClientWidth();
  };

  ScrollController.prototype.canScrollVertically = function () {
    return this.getMaxScrollTop() > 0;
  };

  ScrollController.prototype.canScrollHorizontally = function () {
    return this.getMaxScrollLeft() > 0;
  };

  ScrollController.prototype.canScrollUp = function () {
    return this.getScrollTop() > 0;
  };

  ScrollController.prototype.canScrollDown = function () {
    return this.getScrollTop() < this.getMaxScrollTop();
  };

  ScrollController.prototype.canScrollLeft = function () {
    return this.getScrollLeft() > 0;
  };

  ScrollController.prototype.canScrollRight = function () {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  };

  return ScrollController;
}();

var ElementScrollController =
/** @class */
function (_super) {
  __extends(ElementScrollController, _super);

  function ElementScrollController(el) {
    var _this = _super.call(this) || this;

    _this.el = el;
    return _this;
  }

  ElementScrollController.prototype.getScrollTop = function () {
    return this.el.scrollTop;
  };

  ElementScrollController.prototype.getScrollLeft = function () {
    return this.el.scrollLeft;
  };

  ElementScrollController.prototype.setScrollTop = function (top) {
    this.el.scrollTop = top;
  };

  ElementScrollController.prototype.setScrollLeft = function (left) {
    this.el.scrollLeft = left;
  };

  ElementScrollController.prototype.getScrollWidth = function () {
    return this.el.scrollWidth;
  };

  ElementScrollController.prototype.getScrollHeight = function () {
    return this.el.scrollHeight;
  };

  ElementScrollController.prototype.getClientHeight = function () {
    return this.el.clientHeight;
  };

  ElementScrollController.prototype.getClientWidth = function () {
    return this.el.clientWidth;
  };

  return ElementScrollController;
}(ScrollController);

var WindowScrollController =
/** @class */
function (_super) {
  __extends(WindowScrollController, _super);

  function WindowScrollController() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  WindowScrollController.prototype.getScrollTop = function () {
    return window.pageYOffset;
  };

  WindowScrollController.prototype.getScrollLeft = function () {
    return window.pageXOffset;
  };

  WindowScrollController.prototype.setScrollTop = function (n) {
    window.scroll(window.pageXOffset, n);
  };

  WindowScrollController.prototype.setScrollLeft = function (n) {
    window.scroll(n, window.pageYOffset);
  };

  WindowScrollController.prototype.getScrollWidth = function () {
    return document.documentElement.scrollWidth;
  };

  WindowScrollController.prototype.getScrollHeight = function () {
    return document.documentElement.scrollHeight;
  };

  WindowScrollController.prototype.getClientHeight = function () {
    return document.documentElement.clientHeight;
  };

  WindowScrollController.prototype.getClientWidth = function () {
    return document.documentElement.clientWidth;
  };

  return WindowScrollController;
}(ScrollController);

var Theme =
/** @class */
function () {
  function Theme(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }

  Theme.prototype.setIconOverride = function (iconOverrideHash) {
    var iconClassesCopy;
    var buttonName;

    if (typeof iconOverrideHash === 'object' && iconOverrideHash) {
      // non-null object
      iconClassesCopy = _assign({}, this.iconClasses);

      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }

      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  };

  Theme.prototype.applyIconOverridePrefix = function (className) {
    var prefix = this.iconOverridePrefix;

    if (prefix && className.indexOf(prefix) !== 0) {
      // if not already present
      className = prefix + className;
    }

    return className;
  };

  Theme.prototype.getClass = function (key) {
    return this.classes[key] || '';
  };

  Theme.prototype.getIconClass = function (buttonName, isRtl) {
    var className;

    if (isRtl && this.rtlIconClasses) {
      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className = this.iconClasses[buttonName];
    }

    if (className) {
      return this.baseIconClass + " " + className;
    }

    return '';
  };

  Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
    var className;

    if (this.iconOverrideCustomButtonOption) {
      className = customButtonProps[this.iconOverrideCustomButtonOption];

      if (className) {
        return this.baseIconClass + " " + this.applyIconOverridePrefix(className);
      }
    }

    return '';
  };

  return Theme;
}();

Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = '';
Theme.prototype.iconOverridePrefix = '';

var ScrollResponder =
/** @class */
function () {
  function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {
    var _this = this;

    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;

    this.handleScrollRequest = function (request) {
      _this.queuedRequest = _assign({}, _this.queuedRequest || {}, request);

      _this.drain();
    };

    emitter.on('_scrollRequest', this.handleScrollRequest);
    this.fireInitialScroll();
  }

  ScrollResponder.prototype.detach = function () {
    this.emitter.off('_scrollRequest', this.handleScrollRequest);
  };

  ScrollResponder.prototype.update = function (isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll(); // will drain
    } else {
      this.drain();
    }
  };

  ScrollResponder.prototype.fireInitialScroll = function () {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  };

  ScrollResponder.prototype.drain = function () {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  };

  return ScrollResponder;
}();

var ViewContextType = vdom_createContext({}); // for Components

function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv: dateEnv,
    options: viewOptions,
    pluginHooks: pluginHooks,
    emitter: emitter,
    dispatch: dispatch,
    getCurrentData: getCurrentData,
    calendarApi: calendarApi,
    viewSpec: viewSpec,
    viewApi: viewApi,
    dateProfileGenerator: dateProfileGenerator,
    theme: theme,
    isRtl: viewOptions.direction === 'rtl',
    addResizeHandler: function addResizeHandler(handler) {
      emitter.on('_resize', handler);
    },
    removeResizeHandler: function removeResizeHandler(handler) {
      emitter.off('_resize', handler);
    },
    createScrollResponder: function createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent: registerInteractiveComponent,
    unregisterInteractiveComponent: unregisterInteractiveComponent
  };
}
/* eslint max-classes-per-file: off */


var PureComponent =
/** @class */
function (_super) {
  __extends(PureComponent, _super);

  function PureComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
    if (this.debug) {
      // eslint-disable-next-line no-console
      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
    }

    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
  }; // HACK for freakin' React StrictMode


  PureComponent.prototype.safeSetState = function (newState) {
    if (!compareObjs(this.state, _assign(_assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  };

  PureComponent.addPropsEquality = addPropsEquality;
  PureComponent.addStateEquality = addStateEquality;
  PureComponent.contextType = ViewContextType;
  return PureComponent;
}(Component);

PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};

var BaseComponent =
/** @class */
function (_super) {
  __extends(BaseComponent, _super);

  function BaseComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  BaseComponent.contextType = ViewContextType;
  return BaseComponent;
}(PureComponent);

function addPropsEquality(propEquality) {
  var hash = Object.create(this.prototype.propEquality);

  _assign(hash, propEquality);

  this.prototype.propEquality = hash;
}

function addStateEquality(stateEquality) {
  var hash = Object.create(this.prototype.stateEquality);

  _assign(hash, stateEquality);

  this.prototype.stateEquality = hash;
} // use other one


function setRef(ref, current) {
  if (typeof ref === 'function') {
    ref(current);
  } else if (ref) {
    // see https://github.com/facebook/react/issues/13029
    ref.current = current;
  }
}
/*
an INTERACTABLE date component

PURPOSES:
- hook up to fg, fill, and mirror renderers
- interface for dragging and hits
*/


var DateComponent =
/** @class */
function (_super) {
  __extends(DateComponent, _super);

  function DateComponent() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.uid = guid();
    return _this;
  } // Hit System
  // -----------------------------------------------------------------------------------------------------------------


  DateComponent.prototype.prepareHits = function () {};

  DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
    return null; // this should be abstract
  }; // Pointer Interaction Utils
  // -----------------------------------------------------------------------------------------------------------------


  DateComponent.prototype.isValidSegDownEl = function (el) {
    return !this.props.eventDrag && // HACK
    !this.props.eventResize && // HACK
    !elementClosest(el, '.fc-event-mirror');
  };

  DateComponent.prototype.isValidDateDownEl = function (el) {
    return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a "more.." link
    !elementClosest(el, 'a[data-navlink]') && // a clickable nav link
    !elementClosest(el, '.fc-popover'); // hack
  };

  return DateComponent;
}(BaseComponent); // TODO: easier way to add new hooks? need to update a million things


function createPlugin(input) {
  return {
    id: guid(),
    deps: input.deps || [],
    reducers: input.reducers || [],
    isLoadingFuncs: input.isLoadingFuncs || [],
    contextInit: [].concat(input.contextInit || []),
    eventRefiners: input.eventRefiners || {},
    eventDefMemberAdders: input.eventDefMemberAdders || [],
    eventSourceRefiners: input.eventSourceRefiners || {},
    isDraggableTransformers: input.isDraggableTransformers || [],
    eventDragMutationMassagers: input.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input.eventDefMutationAppliers || [],
    dateSelectionTransformers: input.dateSelectionTransformers || [],
    datePointTransforms: input.datePointTransforms || [],
    dateSpanTransforms: input.dateSpanTransforms || [],
    views: input.views || {},
    viewPropsTransformers: input.viewPropsTransformers || [],
    isPropsValid: input.isPropsValid || null,
    externalDefTransforms: input.externalDefTransforms || [],
    viewContainerAppends: input.viewContainerAppends || [],
    eventDropTransformers: input.eventDropTransformers || [],
    componentInteractions: input.componentInteractions || [],
    calendarInteractions: input.calendarInteractions || [],
    themeClasses: input.themeClasses || {},
    eventSourceDefs: input.eventSourceDefs || [],
    cmdFormatter: input.cmdFormatter,
    recurringTypes: input.recurringTypes || [],
    namedTimeZonedImpl: input.namedTimeZonedImpl,
    initialView: input.initialView || '',
    elementDraggingImpl: input.elementDraggingImpl,
    optionChangeHandlers: input.optionChangeHandlers || {},
    scrollGridImpl: input.scrollGridImpl || null,
    contentTypeHandlers: input.contentTypeHandlers || {},
    listenerRefiners: input.listenerRefiners || {},
    optionRefiners: input.optionRefiners || {},
    propSetHandlers: input.propSetHandlers || {}
  };
}

function buildPluginHooks(pluginDefs, globalDefs) {
  var isAdded = {};
  var hooks = {
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: '',
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    contentTypeHandlers: {},
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };

  function addDefs(defs) {
    for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {
      var def = defs_1[_i];

      if (!isAdded[def.id]) {
        isAdded[def.id] = true;
        addDefs(def.deps);
        hooks = combineHooks(hooks, def);
      }
    }
  }

  if (pluginDefs) {
    addDefs(pluginDefs);
  }

  addDefs(globalDefs);
  return hooks;
}

function buildBuildPluginHooks() {
  var currentOverrideDefs = [];
  var currentGlobalDefs = [];
  var currentHooks;
  return function (overrideDefs, globalDefs) {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }

    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}

function combineHooks(hooks0, hooks1) {
  return {
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: _assign(_assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: _assign(_assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: _assign(_assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: _assign(_assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: _assign(_assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    contentTypeHandlers: _assign(_assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),
    listenerRefiners: _assign(_assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: _assign(_assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: _assign(_assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}

var StandardTheme =
/** @class */
function (_super) {
  __extends(StandardTheme, _super);

  function StandardTheme() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return StandardTheme;
}(Theme);

StandardTheme.prototype.classes = {
  root: 'fc-theme-standard',
  tableCellShaded: 'fc-cell-shaded',
  buttonGroup: 'fc-button-group',
  button: 'fc-button fc-button-primary',
  buttonActive: 'fc-button-active'
};
StandardTheme.prototype.baseIconClass = 'fc-icon';
StandardTheme.prototype.iconClasses = {
  close: 'fc-icon-x',
  prev: 'fc-icon-chevron-left',
  next: 'fc-icon-chevron-right',
  prevYear: 'fc-icon-chevrons-left',
  nextYear: 'fc-icon-chevrons-right'
};
StandardTheme.prototype.rtlIconClasses = {
  prev: 'fc-icon-chevron-right',
  next: 'fc-icon-chevron-left',
  prevYear: 'fc-icon-chevrons-right',
  nextYear: 'fc-icon-chevrons-left'
};
StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly

StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';

function compileViewDefs(defaultConfigs, overrideConfigs) {
  var hash = {};
  var viewType;

  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }

  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }

  return hash;
}

function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }

  var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);

  if (viewDef) {
    hash[viewType] = viewDef;
  }

  return viewDef;
}

function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  var defaultConfig = defaultConfigs[viewType];
  var overrideConfig = overrideConfigs[viewType];

  var queryProp = function queryProp(name) {
    return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  };

  var theComponent = queryProp('component');
  var superType = queryProp('superType');
  var superDef = null;

  if (superType) {
    if (superType === viewType) {
      throw new Error('Can\'t have a custom view type that references itself');
    }

    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }

  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }

  if (!theComponent) {
    return null; // don't throw a warning, might be settings for a single-unit view
  }

  return {
    type: viewType,
    component: theComponent,
    defaults: _assign(_assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: _assign(_assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
/* eslint max-classes-per-file: off */
// NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???


var RenderHook =
/** @class */
function (_super) {
  __extends(RenderHook, _super);

  function RenderHook() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();

    _this.handleRootEl = function (el) {
      setRef(_this.rootElRef, el);

      if (_this.props.elRef) {
        setRef(_this.props.elRef, el);
      }
    };

    return _this;
  }

  RenderHook.prototype.render = function () {
    var _this = this;

    var props = this.props;
    var hookProps = props.hookProps;
    return vdom_createElement(MountHook, {
      hookProps: hookProps,
      didMount: props.didMount,
      willUnmount: props.willUnmount,
      elRef: this.handleRootEl
    }, function (rootElRef) {
      return vdom_createElement(ContentHook, {
        hookProps: hookProps,
        content: props.content,
        defaultContent: props.defaultContent,
        backupElRef: _this.rootElRef
      }, function (innerElRef, innerContent) {
        return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);
      });
    });
  };

  return RenderHook;
}(BaseComponent); // TODO: rename to be about function, not default. use in above type
// for forcing rerender of components that use the ContentHook


var CustomContentRenderContext = vdom_createContext(0);

function ContentHook(props) {
  return vdom_createElement(CustomContentRenderContext.Consumer, null, function (renderId) {
    return vdom_createElement(ContentHookInner, _assign({
      renderId: renderId
    }, props));
  });
}

var ContentHookInner =
/** @class */
function (_super) {
  __extends(ContentHookInner, _super);

  function ContentHookInner() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.innerElRef = createRef();
    return _this;
  }

  ContentHookInner.prototype.render = function () {
    return this.props.children(this.innerElRef, this.renderInnerContent());
  };

  ContentHookInner.prototype.componentDidMount = function () {
    this.updateCustomContent();
  };

  ContentHookInner.prototype.componentDidUpdate = function () {
    this.updateCustomContent();
  };

  ContentHookInner.prototype.componentWillUnmount = function () {
    if (this.customContentInfo && this.customContentInfo.destroy) {
      this.customContentInfo.destroy();
    }
  };

  ContentHookInner.prototype.renderInnerContent = function () {
    var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)

    var innerContent = this.getInnerContent();
    var meta = this.getContentMeta(innerContent); // initial run, or content-type changing? (from vue -> react for example)

    if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {
      // clearing old value
      if (customContentInfo) {
        if (customContentInfo.destroy) {
          customContentInfo.destroy();
        }

        customContentInfo = this.customContentInfo = null;
      } // assigning new value


      if (meta.contentKey) {
        customContentInfo = this.customContentInfo = _assign({
          contentKey: meta.contentKey,
          contentVal: innerContent[meta.contentKey]
        }, meta.buildLifecycleFuncs());
      } // updating

    } else if (customContentInfo) {
      customContentInfo.contentVal = innerContent[meta.contentKey];
    }

    return customContentInfo ? [] // signal that something was specified
    : innerContent; // assume a [p]react vdom node. use it
  };

  ContentHookInner.prototype.getInnerContent = function () {
    var props = this.props;
    var innerContent = normalizeContent(props.content, props.hookProps);

    if (innerContent === undefined) {
      // use the default
      innerContent = normalizeContent(props.defaultContent, props.hookProps);
    }

    return innerContent == null ? null : innerContent; // convert undefined to null (better for React)
  };

  ContentHookInner.prototype.getContentMeta = function (innerContent) {
    var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;
    var contentKey = '';
    var buildLifecycleFuncs = null;

    if (innerContent) {
      // allowed to be null, for convenience to caller
      for (var searchKey in contentTypeHandlers) {
        if (innerContent[searchKey] !== undefined) {
          contentKey = searchKey;
          buildLifecycleFuncs = contentTypeHandlers[searchKey];
          break;
        }
      }
    }

    return {
      contentKey: contentKey,
      buildLifecycleFuncs: buildLifecycleFuncs
    };
  };

  ContentHookInner.prototype.updateCustomContent = function () {
    if (this.customContentInfo) {
      // for non-[p]react
      this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into
      this.customContentInfo.contentVal);
    }
  };

  return ContentHookInner;
}(BaseComponent);

var MountHook =
/** @class */
function (_super) {
  __extends(MountHook, _super);

  function MountHook() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.handleRootEl = function (rootEl) {
      _this.rootEl = rootEl;

      if (_this.props.elRef) {
        setRef(_this.props.elRef, rootEl);
      }
    };

    return _this;
  }

  MountHook.prototype.render = function () {
    return this.props.children(this.handleRootEl);
  };

  MountHook.prototype.componentDidMount = function () {
    var callback = this.props.didMount;

    if (callback) {
      callback(_assign(_assign({}, this.props.hookProps), {
        el: this.rootEl
      }));
    }
  };

  MountHook.prototype.componentWillUnmount = function () {
    var callback = this.props.willUnmount;

    if (callback) {
      callback(_assign(_assign({}, this.props.hookProps), {
        el: this.rootEl
      }));
    }
  };

  return MountHook;
}(BaseComponent);

function buildClassNameNormalizer() {
  var currentGenerator;
  var currentHookProps;
  var currentClassNames = [];
  return function (generator, hookProps) {
    if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {
      currentGenerator = generator;
      currentHookProps = hookProps;
      currentClassNames = normalizeClassNames(generator, hookProps);
    }

    return currentClassNames;
  };
}

function normalizeClassNames(classNames, hookProps) {
  if (typeof classNames === 'function') {
    classNames = classNames(hookProps);
  }

  return parseClassNames(classNames);
}

function normalizeContent(input, hookProps) {
  if (typeof input === 'function') {
    return input(hookProps, vdom_createElement); // give the function the vdom-creation func
  }

  return input;
}

var ViewRoot =
/** @class */
function (_super) {
  __extends(ViewRoot, _super);

  function ViewRoot() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.normalizeClassNames = buildClassNameNormalizer();
    return _this;
  }

  ViewRoot.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options;
    var hookProps = {
      view: context.viewApi
    };
    var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);
    return vdom_createElement(MountHook, {
      hookProps: hookProps,
      didMount: options.viewDidMount,
      willUnmount: options.viewWillUnmount,
      elRef: props.elRef
    }, function (rootElRef) {
      return props.children(rootElRef, ["fc-" + props.viewSpec.type + "-view", 'fc-view'].concat(customClassNames));
    });
  };

  return ViewRoot;
}(BaseComponent);

function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}

function parseViewConfig(input) {
  var rawOptions = typeof input === 'function' ? {
    component: input
  } : input;
  var component = rawOptions.component;

  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions); // TODO: remove content/classNames/didMount/etc from options?
  }

  return {
    superType: rawOptions.type,
    component: component,
    rawOptions: rawOptions
  };
}

function createViewHookComponent(options) {
  return function (viewProps) {
    return vdom_createElement(ViewContextType.Consumer, null, function (context) {
      return vdom_createElement(ViewRoot, {
        viewSpec: context.viewSpec
      }, function (viewElRef, viewClassNames) {
        var hookProps = _assign(_assign({}, viewProps), {
          nextDayThreshold: context.options.nextDayThreshold
        });

        return vdom_createElement(RenderHook, {
          hookProps: hookProps,
          classNames: options.classNames,
          content: options.content,
          didMount: options.didMount,
          willUnmount: options.willUnmount,
          elRef: viewElRef
        }, function (rootElRef, customClassNames, innerElRef, innerContent) {
          return vdom_createElement("div", {
            className: viewClassNames.concat(customClassNames).join(' '),
            ref: rootElRef
          }, innerContent);
        });
      });
    });
  };
}

function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  var defaultConfigs = parseViewConfigs(defaultInputs);
  var overrideConfigs = parseViewConfigs(optionOverrides.views);
  var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, function (viewDef) {
    return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);
  });
}

function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  var duration = null;
  var durationUnit = '';
  var singleUnit = '';
  var singleUnitOverrides = {};

  if (durationInput) {
    duration = createDurationCached(durationInput);

    if (duration) {
      // valid?
      var denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;

      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }

  var queryButtonText = function queryButtonText(optionsSubset) {
    var buttonTextMap = optionsSubset.buttonText || {};
    var buttonTextKey = viewDef.defaults.buttonTextKey;

    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }

    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }

    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }

    return null;
  };

  var queryButtonTitle = function queryButtonTitle(optionsSubset) {
    var buttonHints = optionsSubset.buttonHints || {};
    var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text

    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }

    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }

    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }

    return null;
  };

  return {
    type: viewDef.type,
    component: viewDef.component,
    duration: duration,
    durationUnit: durationUnit,
    singleUnit: singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: _assign(_assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
    viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    // not DRY
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS) // will eventually fall back to buttonText

  };
} // hack to get memoization working


var durationInputMap = {};

function createDurationCached(durationInput) {
  var json = JSON.stringify(durationInput);
  var res = durationInputMap[json];

  if (res === undefined) {
    res = createDuration(durationInput);
    durationInputMap[json] = res;
  }

  return res;
}

var DateProfileGenerator =
/** @class */
function () {
  function DateProfileGenerator(props) {
    this.props = props;
    this.nowDate = getNow(props.nowInput, props.dateEnv);
    this.initHiddenDays();
  }
  /* Date Range Computation
  ------------------------------------------------------------------------------------------------------------------*/
  // Builds a structure with info about what the dates/ranges will be for the "prev" view.


  DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {
    var dateEnv = this.props.dateEnv;
    var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
    currentDateProfile.dateIncrement);
    return this.build(prevDate, -1, forceToValid);
  }; // Builds a structure with info about what the dates/ranges will be for the "next" view.


  DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {
    var dateEnv = this.props.dateEnv;
    var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
    currentDateProfile.dateIncrement);
    return this.build(nextDate, 1, forceToValid);
  }; // Builds a structure holding dates/ranges for rendering around the given date.
  // Optional direction param indicates whether the date is being incremented/decremented
  // from its previous value. decremented = -1, incremented = 1 (default).


  DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {
    if (forceToValid === void 0) {
      forceToValid = true;
    }

    var props = this.props;
    var validRange;
    var currentInfo;
    var isRangeAllDay;
    var renderRange;
    var activeRange;
    var isValid;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);

    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }

    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;

    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }

    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange); // might return null
    // it's invalid if the originally requested date is not contained,
    // or if the range is completely outside of the valid range.

    isValid = rangesIntersect(currentInfo.range, validRange);
    return {
      // constraint for where prev/next operations can go and where events can be dragged/resized to.
      // an object with optional start and end properties.
      validRange: validRange,
      // range the view is formally responsible for.
      // for example, a month view might have 1st-31st, excluding padded dates
      currentRange: currentInfo.range,
      // name of largest unit being displayed, like "month" or "week"
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay: isRangeAllDay,
      // dates that display events and accept drag-n-drop
      // will be `null` if no dates accept events
      activeRange: activeRange,
      // date range with a rendered skeleton
      // includes not-active days that need some sort of DOM
      renderRange: renderRange,
      // Duration object that denotes the first visible time of any given day
      slotMinTime: props.slotMinTime,
      // Duration object that denotes the exclusive visible end time of any given day
      slotMaxTime: props.slotMaxTime,
      isValid: isValid,
      // how far the current date will move for a prev/next operation
      dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^

    };
  }; // Builds an object with optional start/end properties.
  // Indicates the minimum/maximum dates to display.
  // not responsible for trimming hidden days.


  DateProfileGenerator.prototype.buildValidRange = function () {
    var input = this.props.validRangeInput;
    var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;
    return this.refineRange(simpleInput) || {
      start: null,
      end: null
    }; // completely open-ended
  }; // Builds a structure with info about the "current" range, the range that is
  // highlighted as being the current month for example.
  // See build() for a description of `direction`.
  // Guaranteed to have `range` and `unit` properties. `duration` is optional.


  DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
    var props = this.props;
    var duration = null;
    var unit = null;
    var range = null;
    var dayCount;

    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = 'day';
      range = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    }

    return {
      duration: duration,
      unit: unit,
      range: range
    };
  };

  DateProfileGenerator.prototype.getFallbackDuration = function () {
    return createDuration({
      day: 1
    });
  }; // Returns a new activeRange to have time values (un-ambiguate)
  // slotMinTime or slotMaxTime causes the range to expand.


  DateProfileGenerator.prototype.adjustActiveRange = function (range) {
    var _a = this.props,
        dateEnv = _a.dateEnv,
        usesMinMaxTime = _a.usesMinMaxTime,
        slotMinTime = _a.slotMinTime,
        slotMaxTime = _a.slotMaxTime;
    var start = range.start,
        end = range.end;

    if (usesMinMaxTime) {
      // expand active range if slotMinTime is negative (why not when positive?)
      if (asRoughDays(slotMinTime) < 0) {
        start = startOfDay(start); // necessary?

        start = dateEnv.add(start, slotMinTime);
      } // expand active range if slotMaxTime is beyond one day (why not when negative?)


      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end); // necessary?

        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }

    return {
      start: start,
      end: end
    };
  }; // Builds the "current" range when it is specified as an explicit duration.
  // `unit` is the already-computed greatestDurationDenominator unit of duration.


  DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
    var _a = this.props,
        dateEnv = _a.dateEnv,
        dateAlignment = _a.dateAlignment;
    var start;
    var end;
    var res; // compute what the alignment should be

    if (!dateAlignment) {
      var dateIncrement = this.props.dateIncrement;

      if (dateIncrement) {
        // use the smaller of the two units
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    } // if the view displays a single day or smaller


    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start)) {
        start = this.skipHiddenDays(start, direction);
        start = startOfDay(start);
      }
    }

    function computeRes() {
      start = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start, duration);
      res = {
        start: start,
        end: end
      };
    }

    computeRes(); // if range is completely enveloped by hidden days, go past the hidden days

    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }

    return res;
  }; // Builds the "current" range when a dayCount is specified.


  DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
    var _a = this.props,
        dateEnv = _a.dateEnv,
        dateAlignment = _a.dateAlignment;
    var runningCount = 0;
    var start = date;
    var end;

    if (dateAlignment) {
      start = dateEnv.startOf(start, dateAlignment);
    }

    start = startOfDay(start);
    start = this.skipHiddenDays(start, direction);
    end = start;

    do {
      end = addDays(end, 1);

      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);

    return {
      start: start,
      end: end
    };
  }; // Builds a normalized range object for the "visible" range,
  // which is a way to define the currentRange and activeRange at the same time.


  DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
    var props = this.props;
    var input = props.visibleRangeInput;
    var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
    var range = this.refineRange(simpleInput);

    if (range && (range.start == null || range.end == null)) {
      return null;
    }

    return range;
  }; // Computes the range that will represent the element/cells for *rendering*,
  // but which may have voided days/times.
  // not responsible for trimming hidden days.


  DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }; // Compute the duration value that should be added/substracted to the current date
  // when a prev/next operation happens.


  DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
    var dateIncrement = this.props.dateIncrement;
    var customAlignment;

    if (dateIncrement) {
      return dateIncrement;
    }

    if (customAlignment = this.props.dateAlignment) {
      return createDuration(1, customAlignment);
    }

    if (fallback) {
      return fallback;
    }

    return createDuration({
      days: 1
    });
  };

  DateProfileGenerator.prototype.refineRange = function (rangeInput) {
    if (rangeInput) {
      var range = parseRange(rangeInput, this.props.dateEnv);

      if (range) {
        range = computeVisibleDayRange(range);
      }

      return range;
    }

    return null;
  };
  /* Hidden Days
  ------------------------------------------------------------------------------------------------------------------*/
  // Initializes internal variables related to calculating hidden days-of-week


  DateProfileGenerator.prototype.initHiddenDays = function () {
    var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden

    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)

    var dayCnt = 0;
    var i;

    if (this.props.weekends === false) {
      hiddenDays.push(0, 6); // 0=sunday, 6=saturday
    }

    for (i = 0; i < 7; i += 1) {
      if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {
        dayCnt += 1;
      }
    }

    if (!dayCnt) {
      throw new Error('invalid hiddenDays'); // all days were hidden? bad.
    }

    this.isHiddenDayHash = isHiddenDayHash;
  }; // Remove days from the beginning and end of the range that are computed as hidden.
  // If the whole range is trimmed off, returns null


  DateProfileGenerator.prototype.trimHiddenDays = function (range) {
    var start = range.start,
        end = range.end;

    if (start) {
      start = this.skipHiddenDays(start);
    }

    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }

    if (start == null || end == null || start < end) {
      return {
        start: start,
        end: end
      };
    }

    return null;
  }; // Is the current day hidden?
  // `day` is a day-of-week index (0-6), or a Date (used for UTC)


  DateProfileGenerator.prototype.isHiddenDay = function (day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }

    return this.isHiddenDayHash[day];
  }; // Incrementing the current day until it is no longer a hidden day, returning a copy.
  // DOES NOT CONSIDER validRange!
  // If the initial value of `date` is not a hidden day, don't do anything.
  // Pass `isExclusive` as `true` if you are dealing with an end date.
  // `inc` defaults to `1` (increment one day forward each time)


  DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {
    if (inc === void 0) {
      inc = 1;
    }

    if (isExclusive === void 0) {
      isExclusive = false;
    }

    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }

    return date;
  };

  return DateProfileGenerator;
}();

function reduceViewType(viewType, action) {
  switch (action.type) {
    case 'CHANGE_VIEW_TYPE':
      viewType = action.viewType;
  }

  return viewType;
}

function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  var _a;

  switch (action.type) {
    case 'SET_OPTION':
      return _assign(_assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));

    default:
      return dynamicOptionOverrides;
  }
}

function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  var dp;

  switch (action.type) {
    case 'CHANGE_VIEW_TYPE':
      return dateProfileGenerator.build(action.dateMarker || currentDate);

    case 'CHANGE_DATE':
      return dateProfileGenerator.build(action.dateMarker);

    case 'PREV':
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);

      if (dp.isValid) {
        return dp;
      }

      break;

    case 'NEXT':
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);

      if (dp.isValid) {
        return dp;
      }

      break;
  }

  return currentDateProfile;
}

function initEventSources(calendarOptions, dateProfile, context) {
  var activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}

function reduceEventSources(eventSources, action, dateProfile, context) {
  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?

  switch (action.type) {
    case 'ADD_EVENT_SOURCES':
      // already parsed
      return addSources(eventSources, action.sources, activeRange, context);

    case 'REMOVE_EVENT_SOURCE':
      return removeSource(eventSources, action.sourceId);

    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

    case 'NEXT':
    case 'CHANGE_DATE':
    case 'CHANGE_VIEW_TYPE':
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context);
      }

      return eventSources;

    case 'FETCH_EVENT_SOURCES':
      return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?
      arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);

    case 'RECEIVE_EVENTS':
    case 'RECEIVE_EVENT_ERROR':
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);

    case 'REMOVE_ALL_EVENT_SOURCES':
      return {};

    default:
      return eventSources;
  }
}

function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?

  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}

function computeEventSourcesLoading(eventSources) {
  for (var sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }

  return false;
}

function addSources(eventSourceHash, sources, fetchRange, context) {
  var hash = {};

  for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
    var source = sources_1[_i];
    hash[source.sourceId] = source;
  }

  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context);
  }

  return _assign(_assign({}, eventSourceHash), hash);
}

function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, function (eventSource) {
    return eventSource.sourceId !== sourceId;
  });
}

function fetchDirtySources(sourceHash, fetchRange, context) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {
    return isSourceDirty(eventSource, fetchRange, context);
  }), fetchRange, false, context);
}

function isSourceDirty(eventSource, fetchRange, context) {
  if (!doesSourceNeedRange(eventSource, context)) {
    return !eventSource.latestFetchId;
  }

  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}

function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
  var nextSources = {};

  for (var sourceId in prevSources) {
    var source = prevSources[sourceId];

    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
    } else {
      nextSources[sourceId] = source;
    }
  }

  return nextSources;
}

function fetchSource(eventSource, fetchRange, isRefetch, context) {
  var options = context.options,
      calendarApi = context.calendarApi;
  var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  var fetchId = guid();
  sourceDef.fetch({
    eventSource: eventSource,
    range: fetchRange,
    isRefetch: isRefetch,
    context: context
  }, function (res) {
    var rawEvents = res.rawEvents;

    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;
    }

    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;
    }

    context.dispatch({
      type: 'RECEIVE_EVENTS',
      sourceId: eventSource.sourceId,
      fetchId: fetchId,
      fetchRange: fetchRange,
      rawEvents: rawEvents
    });
  }, function (error) {
    console.warn(error.message, error);

    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error);
    }

    if (eventSource.failure) {
      eventSource.failure(error);
    }

    context.dispatch({
      type: 'RECEIVE_EVENT_ERROR',
      sourceId: eventSource.sourceId,
      fetchId: fetchId,
      fetchRange: fetchRange,
      error: error
    });
  });
  return _assign(_assign({}, eventSource), {
    isFetching: true,
    latestFetchId: fetchId
  });
}

function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  var _a;

  var eventSource = sourceHash[sourceId];

  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    return _assign(_assign({}, sourceHash), (_a = {}, _a[sourceId] = _assign(_assign({}, eventSource), {
      isFetching: false,
      fetchRange: fetchRange
    }), _a));
  }

  return sourceHash;
}

function excludeStaticSources(eventSources, context) {
  return filterHash(eventSources, function (eventSource) {
    return doesSourceNeedRange(eventSource, context);
  });
}

function parseInitialSources(rawOptions, context) {
  var refiners = buildEventSourceRefiners(context);
  var rawSources = [].concat(rawOptions.eventSources || []);
  var sources = []; // parsed

  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }

  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }

  for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {
    var rawSource = rawSources_1[_i];
    var source = parseEventSource(rawSource, context, refiners);

    if (source) {
      sources.push(source);
    }
  }

  return sources;
}

function doesSourceNeedRange(eventSource, context) {
  var defs = context.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}

function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
  switch (action.type) {
    case 'RECEIVE_EVENTS':
      // raw
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);

    case 'ADD_EVENTS':
      // already parsed, but not expanded
      return addEvent(eventStore, action.eventStore, // new ones
      dateProfile ? dateProfile.activeRange : null, context);

    case 'RESET_EVENTS':
      return action.eventStore;

    case 'MERGE_EVENTS':
      // already parsed and expanded
      return mergeEventStores(eventStore, action.eventStore);

    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

    case 'NEXT':
    case 'CHANGE_DATE':
    case 'CHANGE_VIEW_TYPE':
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context);
      }

      return eventStore;

    case 'REMOVE_EVENTS':
      return excludeSubEventStore(eventStore, action.eventStore);

    case 'REMOVE_EVENT_SOURCE':
      return excludeEventsBySourceId(eventStore, action.sourceId);

    case 'REMOVE_ALL_EVENT_SOURCES':
      return filterEventStoreDefs(eventStore, function (eventDef) {
        return !eventDef.sourceId // only keep events with no source id
        ;
      });

    case 'REMOVE_ALL_EVENTS':
      return createEmptyEventStore();

    default:
      return eventStore;
  }
}

function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
  ) {
    var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);

    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context);
    }

    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }

  return eventStore;
}

function transformRawEvents(rawEvents, eventSource, context) {
  var calEachTransform = context.options.eventDataTransform;
  var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;

  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }

  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }

  return rawEvents;
}

function transformEachRawEvent(rawEvents, func) {
  var refinedEvents;

  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];

    for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
      var rawEvent = rawEvents_1[_i];
      var refinedEvent = func(rawEvent);

      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      } // if a different falsy value, do nothing

    }
  }

  return refinedEvents;
}

function addEvent(eventStore, subset, expandRange, context) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context);
  }

  return mergeEventStores(eventStore, subset);
}

function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  var defs = eventStore.defs;
  var instances = mapHash(eventStore.instances, function (instance) {
    var def = defs[instance.defId];

    if (def.allDay || def.recurringDef) {
      return instance; // isn't dependent on timezone
    }

    return _assign(_assign({}, instance), {
      range: {
        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
      },
      forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,
      forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo
    });
  });
  return {
    defs: defs,
    instances: instances
  };
}

function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, function (eventDef) {
    return eventDef.sourceId !== sourceId;
  });
} // QUESTION: why not just return instances? do a general object-property-exclusion util


function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, function (instance) {
      return !removals[instance.instanceId];
    })
  };
}

function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case 'UNSELECT_DATES':
      return null;

    case 'SELECT_DATES':
      return action.selection;

    default:
      return currentSelection;
  }
}

function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case 'UNSELECT_EVENT':
      return '';

    case 'SELECT_EVENT':
      return action.eventInstanceId;

    default:
      return currentInstanceId;
  }
}

function reduceEventDrag(currentDrag, action) {
  var newDrag;

  switch (action.type) {
    case 'UNSET_EVENT_DRAG':
      return null;

    case 'SET_EVENT_DRAG':
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };

    default:
      return currentDrag;
  }
}

function reduceEventResize(currentResize, action) {
  var newResize;

  switch (action.type) {
    case 'UNSET_EVENT_RESIZE':
      return null;

    case 'SET_EVENT_RESIZE':
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };

    default:
      return currentResize;
  }
}

function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return {
    header: header,
    footer: footer
  };
}

function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  var sectionWidgets = {};
  var viewsWithButtons = [];
  var hasTitle = false;

  for (var sectionName in sectionStrHash) {
    var sectionStr = sectionStrHash[sectionName];
    var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }

  return {
    sectionWidgets: sectionWidgets,
    viewsWithButtons: viewsWithButtons,
    hasTitle: hasTitle
  };
}
/*
BAD: querying icons and text here. should be done at render time
*/


function parseSection(sectionStr, calendarOptions, // defaults+overrides, then refined
calendarOptionOverrides, // overrides only!, unrefined :(
theme, viewSpecs, calendarApi) {
  var isRtl = calendarOptions.direction === 'rtl';
  var calendarCustomButtons = calendarOptions.customButtons || {};
  var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  var calendarButtonText = calendarOptions.buttonText || {};
  var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  var calendarButtonHints = calendarOptions.buttonHints || {};
  var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];
  var viewsWithButtons = [];
  var hasTitle = false;
  var widgets = sectionSubstrs.map(function (buttonGroupStr) {
    return buttonGroupStr.split(',').map(function (buttonName) {
      if (buttonName === 'title') {
        hasTitle = true;
        return {
          buttonName: buttonName
        };
      }

      var customButtonProps;
      var viewSpec;
      var buttonClick;
      var buttonIcon; // only one of these will be set

      var buttonText; // "

      var buttonHint; // ^ for the title="" attribute, for accessibility

      if (customButtonProps = calendarCustomButtons[buttonName]) {
        buttonClick = function buttonClick(ev) {
          if (customButtonProps.click) {
            customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?
          }
        };

        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
        buttonHint = customButtonProps.hint || customButtonProps.text;
      } else if (viewSpec = viewSpecs[buttonName]) {
        viewsWithButtons.push(buttonName);

        buttonClick = function buttonClick() {
          calendarApi.changeView(buttonName);
        };

        (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
        var textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
        buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [textFallback, buttonName], // view-name = buttonName
        textFallback);
      } else if (calendarApi[buttonName]) {
        // a calendarApi method
        buttonClick = function buttonClick() {
          calendarApi[buttonName]();
        };

        (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default

        if (buttonName === 'prevYear' || buttonName === 'nextYear') {
          var prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';
          buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [calendarButtonText.year || 'year', 'year'], calendarButtonText[buttonName]);
        } else {
          buttonHint = function buttonHint(navUnit) {
            return formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [calendarButtonText[navUnit] || navUnit, navUnit], calendarButtonText[buttonName]);
          };
        }
      }

      return {
        buttonName: buttonName,
        buttonClick: buttonClick,
        buttonIcon: buttonIcon,
        buttonText: buttonText,
        buttonHint: buttonHint
      };
    });
  });
  return {
    widgets: widgets,
    viewsWithButtons: viewsWithButtons,
    hasTitle: hasTitle
  };
}

var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta: function parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }

    return null;
  },
  fetch: function fetch(arg, success) {
    success({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta: function parseMeta(refined) {
    if (typeof refined.events === 'function') {
      return refined.events;
    }

    return null;
  },
  fetch: function fetch(arg, success, failure) {
    var dateEnv = arg.context.dateEnv;
    var func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {
      success({
        rawEvents: rawEvents
      }); // needs an object response
    }, failure);
  }
};
var funcEventSourcePlugin = createPlugin({
  eventSourceDefs: [eventSourceDef$1]
});

function requestJson(method, url, params, successCallback, failureCallback) {
  method = method.toUpperCase();
  var body = null;

  if (method === 'GET') {
    url = injectQueryStringParams(url, params);
  } else {
    body = encodeParams(params);
  }

  var xhr = new XMLHttpRequest();
  xhr.open(method, url, true);

  if (method !== 'GET') {
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  }

  xhr.onload = function () {
    if (xhr.status >= 200 && xhr.status < 400) {
      var parsed = false;
      var res = void 0;

      try {
        res = JSON.parse(xhr.responseText);
        parsed = true;
      } catch (err) {// will handle parsed=false
      }

      if (parsed) {
        successCallback(res, xhr);
      } else {
        failureCallback('Failure parsing JSON', xhr);
      }
    } else {
      failureCallback('Request failed', xhr);
    }
  };

  xhr.onerror = function () {
    failureCallback('Request failed', xhr);
  };

  xhr.send(body);
}

function injectQueryStringParams(url, params) {
  return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);
}

function encodeParams(params) {
  var parts = [];

  for (var key in params) {
    parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
  }

  return parts.join('&');
}

var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta: function parseMeta(refined) {
    if (refined.url && (refined.format === 'json' || !refined.format)) {
      return {
        url: refined.url,
        format: 'json',
        method: (refined.method || 'GET').toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }

    return null;
  },
  fetch: function fetch(arg, success, failure) {
    var meta = arg.eventSource.meta;
    var requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {
      success({
        rawEvents: rawEvents,
        xhr: xhr
      });
    }, function (errorMessage, xhr) {
      failure({
        message: errorMessage,
        xhr: xhr
      });
    });
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});

function buildRequestParams(meta, range, context) {
  var dateEnv = context.dateEnv,
      options = context.options;
  var startParam;
  var endParam;
  var timeZoneParam;
  var customRequestParams;
  var params = {};
  startParam = meta.startParam;

  if (startParam == null) {
    startParam = options.startParam;
  }

  endParam = meta.endParam;

  if (endParam == null) {
    endParam = options.endParam;
  }

  timeZoneParam = meta.timeZoneParam;

  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  } // retrieve any outbound GET/POST data from the options


  if (typeof meta.extraParams === 'function') {
    // supplied as a function that returns a key/value object
    customRequestParams = meta.extraParams();
  } else {
    // probably supplied as a straight key/value object
    customRequestParams = meta.extraParams || {};
  }

  _assign(params, customRequestParams);

  params[startParam] = dateEnv.formatIso(range.start);
  params[endParam] = dateEnv.formatIso(range.end);

  if (dateEnv.timeZone !== 'local') {
    params[timeZoneParam] = dateEnv.timeZone;
  }

  return params;
}

var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity,
  startTime: createDuration,
  endTime: createDuration,
  duration: createDuration,
  startRecur: identity,
  endRecur: identity
};
var recurring = {
  parse: function parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      var recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
      };
      var duration = void 0;

      if (refined.duration) {
        duration = refined.duration;
      }

      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }

      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration: duration,
        typeData: recurringData // doesn't need endTime anymore but oh well

      };
    }

    return null;
  },
  expand: function expand(typeData, framingRange, dateEnv) {
    var clippedFramingRange = intersectRanges(framingRange, {
      start: typeData.startRecur,
      end: typeData.endRecur
    });

    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
    }

    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});

function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
  var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
  var dayMarker = startOfDay(framingRange.start);
  var endMarker = framingRange.end;
  var instanceStarts = [];

  while (dayMarker < endMarker) {
    var instanceStart // if everyday, or this particular day-of-week
    = void 0; // if everyday, or this particular day-of-week

    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = dateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }

      instanceStarts.push(instanceStart);
    }

    dayMarker = addDays(dayMarker, 1);
  }

  return instanceStarts;
}

var changeHandlerPlugin = createPlugin({
  optionChangeHandlers: {
    events: function events(_events, context) {
      handleEventSources([_events], context);
    },
    eventSources: handleEventSources
  }
});
/*
BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out
*/

function handleEventSources(inputs, context) {
  var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
  var newInputs = [];

  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
    var input = inputs_1[_i];
    var inputFound = false;

    for (var i = 0; i < unfoundSources.length; i += 1) {
      if (unfoundSources[i]._raw === input) {
        unfoundSources.splice(i, 1); // delete

        inputFound = true;
        break;
      }
    }

    if (!inputFound) {
      newInputs.push(input);
    }
  }

  for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {
    var unfoundSource = unfoundSources_1[_a];
    context.dispatch({
      type: 'REMOVE_EVENT_SOURCE',
      sourceId: unfoundSource.sourceId
    });
  }

  for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {
    var newInput = newInputs_1[_b];
    context.calendarApi.addEventSource(newInput);
  }
}

function handleDateProfile(dateProfile, context) {
  context.emitter.trigger('datesSet', _assign(_assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {
    view: context.viewApi
  }));
}

function handleEventStore(eventStore, context) {
  var emitter = context.emitter;

  if (emitter.hasHandlers('eventsSet')) {
    emitter.trigger('eventsSet', buildEventApis(eventStore, context));
  }
}
/*
this array is exposed on the root namespace so that UMD plugins can add to it.
see the rollup-bundles script.
*/


var globalPlugins = [arrayEventSourcePlugin, funcEventSourcePlugin, jsonFeedEventSourcePlugin, simpleRecurringEventsPlugin, changeHandlerPlugin, createPlugin({
  isLoadingFuncs: [function (state) {
    return computeEventSourcesLoading(state.eventSources);
  }],
  contentTypeHandlers: {
    html: buildHtmlRenderer,
    domNodes: buildDomNodeRenderer
  },
  propSetHandlers: {
    dateProfile: handleDateProfile,
    eventStore: handleEventStore
  }
})];

function buildHtmlRenderer() {
  var currentEl = null;
  var currentHtml = '';

  function render(el, html) {
    if (el !== currentEl || html !== currentHtml) {
      el.innerHTML = html;
    }

    currentEl = el;
    currentHtml = html;
  }

  function destroy() {
    currentEl.innerHTML = '';
    currentEl = null;
    currentHtml = '';
  }

  return {
    render: render,
    destroy: destroy
  };
}

function buildDomNodeRenderer() {
  var currentEl = null;
  var currentDomNodes = [];

  function render(el, domNodes) {
    var newDomNodes = Array.prototype.slice.call(domNodes);

    if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {
      // append first, remove second (for scroll resetting)
      for (var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++) {
        var newNode = newDomNodes_1[_i];
        el.appendChild(newNode);
      }

      destroy();
    }

    currentEl = el;
    currentDomNodes = newDomNodes;
  }

  function destroy() {
    currentDomNodes.forEach(removeElement);
    currentDomNodes = [];
    currentEl = null;
  }

  return {
    render: render,
    destroy: destroy
  };
}

var DelayedRunner =
/** @class */
function () {
  function DelayedRunner(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }

  DelayedRunner.prototype.request = function (delay) {
    this.isDirty = true;

    if (!this.isPaused()) {
      this.clearTimeout();

      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout( // NOT OPTIMAL! TODO: look at debounce
        this.tryDrain.bind(this), delay);
      }
    }
  };

  DelayedRunner.prototype.pause = function (scope) {
    if (scope === void 0) {
      scope = '';
    }

    var pauseDepths = this.pauseDepths;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  };

  DelayedRunner.prototype.resume = function (scope, force) {
    if (scope === void 0) {
      scope = '';
    }

    var pauseDepths = this.pauseDepths;

    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        var depth = pauseDepths[scope];

        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }

      this.tryDrain();
    }
  };

  DelayedRunner.prototype.isPaused = function () {
    return Object.keys(this.pauseDepths).length;
  };

  DelayedRunner.prototype.tryDrain = function () {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;

      while (this.isDirty) {
        this.isDirty = false;
        this.drained(); // might set isDirty to true again
      }

      this.isRunning = false;
    }
  };

  DelayedRunner.prototype.clear = function () {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  };

  DelayedRunner.prototype.clearTimeout = function () {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  };

  DelayedRunner.prototype.drained = function () {
    if (this.drainedOption) {
      this.drainedOption();
    }
  };

  return DelayedRunner;
}();

var TaskRunner =
/** @class */
function () {
  function TaskRunner(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }

  TaskRunner.prototype.request = function (task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  };

  TaskRunner.prototype.pause = function (scope) {
    this.delayedRunner.pause(scope);
  };

  TaskRunner.prototype.resume = function (scope, force) {
    this.delayedRunner.resume(scope, force);
  };

  TaskRunner.prototype.drain = function () {
    var queue = this.queue;

    while (queue.length) {
      var completedTasks = [];
      var task = void 0;

      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }

      this.drained(completedTasks);
    } // keep going, in case new tasks were added in the drained handler

  };

  TaskRunner.prototype.runTask = function (task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  };

  TaskRunner.prototype.drained = function (completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  };

  return TaskRunner;
}(); // Computes what the title at the top of the calendarApi should be for this view


function buildTitle(dateProfile, viewOptions, dateEnv) {
  var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after

  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range = dateProfile.currentRange;
  } else {
    // for day units or smaller, use the actual day range
    range = dateProfile.activeRange;
  }

  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
} // Generates the format string that should be used to generate the title for the current date range.
// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.


function buildTitleFormat(dateProfile) {
  var currentRangeUnit = dateProfile.currentRangeUnit;

  if (currentRangeUnit === 'year') {
    return {
      year: 'numeric'
    };
  }

  if (currentRangeUnit === 'month') {
    return {
      year: 'numeric',
      month: 'long'
    }; // like "September 2014"
  }

  var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);

  if (days !== null && days > 1) {
    // multi-day range. shorter, like "Sep 9 - 10 2014"
    return {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    };
  } // one day. longer, like "September 9 2014"


  return {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  };
} // in future refactor, do the redux-style function(state=initial) for initial-state
// also, whatever is happening in constructor, have it happen in action queue too


var CalendarDataManager =
/** @class */
function () {
  function CalendarDataManager(props) {
    var _this = this;

    this.computeOptionsData = memoize(this._computeOptionsData);
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.emitter = new Emitter();
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};

    this.getCurrentData = function () {
      return _this.data;
    };

    this.dispatch = function (action) {
      _this.actionRunner.request(action); // protects against recursive calls to _handleAction

    };

    this.props = props;
    this.actionRunner.pause();
    var dynamicOptionOverrides = {};
    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up
    // TODO: not DRY

    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
    var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);

    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }

    var calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    }; // needs to be after setThisContext

    for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {
      var callback = _a[_i];
      callback(calendarContext);
    } // NOT DRY


    var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    var initialState = {
      dynamicOptionOverrides: dynamicOptionOverrides,
      currentViewType: currentViewType,
      currentDate: currentDate,
      dateProfile: dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources: eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: '',
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };

    var contextAndState = _assign(_assign({}, calendarContext), initialState);

    for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {
      var reducer = _c[_b];

      _assign(initialState, reducer(null, null, contextAndState));
    }

    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger('loading', true); // NOT DRY
    }

    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }

  CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {
    var props = this.props;
    props.optionOverrides = append ? _assign(_assign({}, props.optionOverrides), optionOverrides) : optionOverrides;
    this.actionRunner.request({
      type: 'NOTHING'
    });
  };

  CalendarDataManager.prototype._handleAction = function (action) {
    var _a = this,
        props = _a.props,
        state = _a.state,
        emitter = _a.emitter;

    var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    var currentViewType = reduceViewType(state.currentViewType, action);
    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up
    // TODO: not DRY

    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    var calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: emitter,
      getCurrentData: this.getCurrentData
    };
    var currentDate = state.currentDate,
        dateProfile = state.dateProfile;

    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      // hack
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }

    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);

    if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator
    action.type === 'NEXT' || // "
    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }

    var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading

    var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : // try from previous state
    eventStore;

    var _b = this.buildViewUiProps(calendarContext),
        eventUiSingleBase = _b.eventUiSingleBase,
        selectionConfig = _b.selectionConfig; // will memoize obj


    var eventUiBySource = this.buildEventUiBySource(eventSources);
    var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    var newState = {
      dynamicOptionOverrides: dynamicOptionOverrides,
      currentViewType: currentViewType,
      currentDate: currentDate,
      dateProfile: dateProfile,
      eventSources: eventSources,
      eventStore: eventStore,
      renderableEventStore: renderableEventStore,
      selectionConfig: selectionConfig,
      eventUiBases: eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };

    var contextAndState = _assign(_assign({}, calendarContext), newState);

    for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {
      var reducer = _c[_i];

      _assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value

    }

    var wasLoading = computeIsLoading(state, calendarContext);
    var isLoading = computeIsLoading(newState, calendarContext); // TODO: use propSetHandlers in plugin system

    if (!wasLoading && isLoading) {
      emitter.trigger('loading', true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger('loading', false);
    }

    this.state = newState;

    if (props.onAction) {
      props.onAction(action);
    }
  };

  CalendarDataManager.prototype.updateData = function () {
    var _a = this,
        props = _a.props,
        state = _a.state;

    var oldData = this.data;
    var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);

    var data = this.data = _assign(_assign(_assign({
      viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    }, optionsData), currentViewData), state);

    var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    var oldCalendarOptions = oldData && oldData.calendarOptions;
    var newCalendarOptions = optionsData.calendarOptions;

    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        // hack
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
      }

      for (var optionName in changeHandlers) {
        if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }

    if (props.onData) {
      props.onData(data);
    }
  };

  CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {
    // TODO: blacklist options that are handled by optionChangeHandlers
    var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides),
        refinedOptions = _a.refinedOptions,
        pluginHooks = _a.pluginHooks,
        localeDefaults = _a.localeDefaults,
        availableLocaleData = _a.availableLocaleData,
        extra = _a.extra;

    warnUnknownOptions(extra);
    var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);
    var theme = this.buildTheme(refinedOptions, pluginHooks);
    var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);
    return {
      calendarOptions: refinedOptions,
      pluginHooks: pluginHooks,
      dateEnv: dateEnv,
      viewSpecs: viewSpecs,
      theme: theme,
      toolbarConfig: toolbarConfig,
      localeDefaults: localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }; // always called from behind a memoizer


  CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {
    var _a = mergeRawOptions([BASE_OPTION_DEFAULTS, optionOverrides, dynamicOptionOverrides]),
        locales = _a.locales,
        locale = _a.locale;

    var availableLocaleData = this.organizeRawLocales(locales);
    var availableRawLocales = availableLocaleData.map;
    var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
    var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);

    var refiners = this.currentCalendarOptionsRefiners = _assign(_assign(_assign(_assign(_assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);

    var extra = {};
    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, localeDefaults, optionOverrides, dynamicOptionOverrides]);
    var refined = {};
    var currentRaw = this.currentCalendarOptionsInput;
    var currentRefined = this.currentCalendarOptionsRefined;
    var anyChanges = false;

    for (var optionName in raw) {
      if (optionName !== 'plugins') {
        // because plugins is special-cased
        if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {
          refined[optionName] = currentRefined[optionName];
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
          anyChanges = true;
        } else {
          extra[optionName] = currentRaw[optionName];
        }
      }
    }

    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
    }

    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks: pluginHooks,
      availableLocaleData: availableLocaleData,
      localeDefaults: localeDefaults,
      extra: extra
    };
  };

  CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    var viewSpec = optionsData.viewSpecs[viewType];

    if (!viewSpec) {
      throw new Error("viewType \"" + viewType + "\" is not available. Please make sure you've loaded all neccessary plugins");
    }

    var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides),
        refinedOptions = _a.refinedOptions,
        extra = _a.extra;

    warnUnknownOptions(extra);
    var dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      nowInput: refinedOptions.now,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      monthMode: refinedOptions.monthMode,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return {
      viewSpec: viewSpec,
      options: refinedOptions,
      dateProfileGenerator: dateProfileGenerator,
      viewApi: viewApi
    };
  };

  CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, viewSpec.optionDefaults, localeDefaults, optionOverrides, viewSpec.optionOverrides, dynamicOptionOverrides]);

    var refiners = _assign(_assign(_assign(_assign(_assign(_assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);

    var refined = {};
    var currentRaw = this.currentViewOptionsInput;
    var currentRefined = this.currentViewOptionsRefined;
    var anyChanges = false;
    var extra = {};

    for (var optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            // might be an "extra" prop
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }

        anyChanges = true;
      }
    }

    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }

    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra: extra
    };
  };

  return CalendarDataManager;
}();

function buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: 'gregory',
    timeZone: timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale: locale,
    weekNumberCalculation: weekNumberCalculation,
    firstDay: firstDay,
    weekText: weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator: defaultSeparator
  });
}

function buildTheme(options, pluginHooks) {
  var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}

function buildDateProfileGenerator(props) {
  var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}

function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewApi(type, getCurrentData, dateEnv);
}

function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, function (eventSource) {
    return eventSource.ui;
  });
}

function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  var eventUiBases = {
    '': eventUiSingleBase
  };

  for (var defId in eventDefs) {
    var def = eventDefs[defId];

    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }

  return eventUiBases;
}

function buildViewUiProps(calendarContext) {
  var options = calendarContext.options;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor // classNames: options.eventClassNames // render hook will handle this

    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,
      allow: options.selectAllow
    }, calendarContext)
  };
}

function computeIsLoading(state, context) {
  for (var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++) {
    var isLoadingFunc = _a[_i];

    if (isLoadingFunc(state)) {
      return true;
    }
  }

  return false;
}

function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}

function warnUnknownOptions(options, viewName) {
  for (var optionName in options) {
    console.warn("Unknown option '" + optionName + "'" + (viewName ? " for view '" + viewName + "'" : ''));
  }
} // TODO: move this to react plugin?


var CalendarDataProvider =
/** @class */
function (_super) {
  __extends(CalendarDataProvider, _super);

  function CalendarDataProvider(props) {
    var _this = _super.call(this, props) || this;

    _this.handleData = function (data) {
      if (!_this.dataManager) {
        // still within initial run, before assignment in constructor
        // eslint-disable-next-line react/no-direct-mutation-state
        _this.state = data; // can't use setState yet
      } else {
        _this.setState(data);
      }
    };

    _this.dataManager = new CalendarDataManager({
      optionOverrides: props.optionOverrides,
      calendarApi: props.calendarApi,
      onData: _this.handleData
    });
    return _this;
  }

  CalendarDataProvider.prototype.render = function () {
    return this.props.children(this.state);
  };

  CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {
    var newOptionOverrides = this.props.optionOverrides;

    if (newOptionOverrides !== prevProps.optionOverrides) {
      // prevent recursive handleData
      this.dataManager.resetOptions(newOptionOverrides);
    }
  };

  return CalendarDataProvider;
}(Component); // HELPERS

/*
if nextDayThreshold is specified, slicing is done in an all-day fashion.
you can get nextDayThreshold from context.nextDayThreshold
*/


function sliceEvents(props, allDay) {
  return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;
}

var NamedTimeZoneImpl =
/** @class */
function () {
  function NamedTimeZoneImpl(timeZoneName) {
    this.timeZoneName = timeZoneName;
  }

  return NamedTimeZoneImpl;
}();

var SegHierarchy =
/** @class */
function () {
  function SegHierarchy() {
    // settings
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1; // -1 means no max

    this.maxStackCnt = -1; // -1 means no max

    this.levelCoords = []; // ordered

    this.entriesByLevel = []; // parallel with levelCoords

    this.stackCnts = {}; // TODO: use better technique!?
  }

  SegHierarchy.prototype.addSegs = function (inputs) {
    var hiddenEntries = [];

    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
      var input = inputs_1[_i];
      this.insertEntry(input, hiddenEntries);
    }

    return hiddenEntries;
  };

  SegHierarchy.prototype.insertEntry = function (entry, hiddenEntries) {
    var insertion = this.findInsertion(entry);

    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
      return 1;
    }

    return this.handleInvalidInsertion(insertion, entry, hiddenEntries);
  };

  SegHierarchy.prototype.isInsertionValid = function (insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }; // returns number of new entries inserted


  SegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    }

    hiddenEntries.push(entry);
    return 0;
  };

  SegHierarchy.prototype.splitEntry = function (entry, barrier, hiddenEntries) {
    var partCnt = 0;
    var splitHiddenEntries = [];
    var entrySpan = entry.span;
    var barrierSpan = barrier.span;

    if (entrySpan.start < barrierSpan.start) {
      partCnt += this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: {
          start: entrySpan.start,
          end: barrierSpan.start
        }
      }, splitHiddenEntries);
    }

    if (entrySpan.end > barrierSpan.end) {
      partCnt += this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: {
          start: barrierSpan.end,
          end: entrySpan.end
        }
      }, splitHiddenEntries);
    }

    if (partCnt) {
      hiddenEntries.push.apply(hiddenEntries, __spreadArray([{
        index: entry.index,
        thickness: entry.thickness,
        span: intersectSpans(barrierSpan, entrySpan) // guaranteed to intersect

      }], splitHiddenEntries));
      return partCnt;
    }

    hiddenEntries.push(entry);
    return 0;
  };

  SegHierarchy.prototype.insertEntryAt = function (entry, insertion) {
    var _a = this,
        entriesByLevel = _a.entriesByLevel,
        levelCoords = _a.levelCoords;

    if (insertion.lateral === -1) {
      // create a new level
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      // insert into existing level
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }

    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  };

  SegHierarchy.prototype.findInsertion = function (newEntry) {
    var _a = this,
        levelCoords = _a.levelCoords,
        entriesByLevel = _a.entriesByLevel,
        strictOrder = _a.strictOrder,
        stackCnts = _a.stackCnts;

    var levelCnt = levelCoords.length;
    var candidateCoord = 0;
    var touchingLevel = -1;
    var touchingLateral = -1;
    var touchingEntry = null;
    var stackCnt = 0;

    for (var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
      var trackingCoord = levelCoords[trackingLevel]; // if the current level is past the placed entry, we have found a good empty space and can stop.
      // if strictOrder, keep finding more lateral intersections.

      if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {
        break;
      }

      var trackingEntries = entriesByLevel[trackingLevel];
      var trackingEntry = void 0;
      var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end

      var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one

      while ( // loop through entries that horizontally intersect
      (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
      trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry
      ) {
        var trackingEntryBottom = trackingCoord + trackingEntry.thickness; // intersects into the top of the candidate?

        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        } // butts up against top of candidate? (will happen if just intersected as well)


        if (trackingEntryBottom === candidateCoord) {
          // accumulate the highest possible stackCnt of the trackingEntries that butt up
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }

        lateralIndex += 1;
      }
    } // the destination level will be after touchingEntry's level. find it


    var destLevel = 0;

    if (touchingEntry) {
      destLevel = touchingLevel + 1;

      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    } // if adding to an existing level, find where to insert


    var destLateral = -1;

    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }

    return {
      touchingLevel: touchingLevel,
      touchingLateral: touchingLateral,
      touchingEntry: touchingEntry,
      stackCnt: stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }; // sorted by levelCoord (lowest to highest)


  SegHierarchy.prototype.toRects = function () {
    var _a = this,
        entriesByLevel = _a.entriesByLevel,
        levelCoords = _a.levelCoords;

    var levelCnt = entriesByLevel.length;
    var rects = [];

    for (var level = 0; level < levelCnt; level += 1) {
      var entries = entriesByLevel[level];
      var levelCoord = levelCoords[level];

      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i];
        rects.push(_assign(_assign({}, entry), {
          levelCoord: levelCoord
        }));
      }
    }

    return rects;
  };

  return SegHierarchy;
}();

function getEntrySpanEnd(entry) {
  return entry.span.end;
}

function buildEntryKey(entry) {
  return entry.index + ':' + entry.span.start;
} // returns groups with entries sorted by input order


function groupIntersectingEntries(entries) {
  var merges = [];

  for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {
    var entry = entries_2[_i];
    var filteredMerges = [];
    var hungryMerge = {
      span: entry.span,
      entries: [entry]
    };

    for (var _a = 0, merges_1 = merges; _a < merges_1.length; _a++) {
      var merge = merges_1[_a];

      if (intersectSpans(merge.span, hungryMerge.span)) {
        hungryMerge = {
          entries: merge.entries.concat(hungryMerge.entries),
          span: joinSpans(merge.span, hungryMerge.span)
        };
      } else {
        filteredMerges.push(merge);
      }
    }

    filteredMerges.push(hungryMerge);
    merges = filteredMerges;
  }

  return merges;
}

function joinSpans(span0, span1) {
  return {
    start: Math.min(span0.start, span1.start),
    end: Math.max(span0.end, span1.end)
  };
}

function intersectSpans(span0, span1) {
  var start = Math.max(span0.start, span1.start);
  var end = Math.min(span0.end, span1.end);

  if (start < end) {
    return {
      start: start,
      end: end
    };
  }

  return null;
} // general util
// ---------------------------------------------------------------------------------------------------------------------


function insertAt(arr, index, item) {
  arr.splice(index, 0, item);
}

function binarySearch(a, searchVal, getItemVal) {
  var startIndex = 0;
  var endIndex = a.length; // exclusive

  if (!endIndex || searchVal < getItemVal(a[startIndex])) {
    // no items OR before first item
    return [0, 0];
  }

  if (searchVal > getItemVal(a[endIndex - 1])) {
    // after last item
    return [endIndex, 0];
  }

  while (startIndex < endIndex) {
    var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    var middleVal = getItemVal(a[middleIndex]);

    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      // equal!
      return [middleIndex, 1];
    }
  }

  return [startIndex, 0];
}

var Interaction =
/** @class */
function () {
  function Interaction(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }

  Interaction.prototype.destroy = function () {};

  return Interaction;
}();

function parseInteractionSettings(component, input) {
  return {
    component: component,
    el: input.el,
    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
    isHitComboAllowed: input.isHitComboAllowed || null
  };
}

function interactionSettingsToStore(settings) {
  var _a;

  return _a = {}, _a[settings.component.uid] = settings, _a;
} // global state


var interactionSettingsStore = {};
/*
An abstraction for a dragging interaction originating on an event.
Does higher-level things than PointerDragger, such as possibly:
- a "mirror" that moves with the pointer
- a minimum number of pixels or other criteria for a true drag to begin

subclasses must emit:
- pointerdown
- dragstart
- dragmove
- pointerup
- dragend
*/

var ElementDragging =
/** @class */
function () {
  function ElementDragging(el, selector) {
    this.emitter = new Emitter();
  }

  ElementDragging.prototype.destroy = function () {};

  ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror
  };

  ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror
  };

  ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional
  };

  return ElementDragging;
}(); // TODO: get rid of this in favor of options system,
// tho it's really easy to access this globally rather than pass thru options.


var config = {};
/*
Information about what will happen when an external element is dragged-and-dropped
onto a calendar. Contains information for creating an event.
*/

var DRAG_META_REFINERS = {
  startTime: createDuration,
  duration: createDuration,
  create: Boolean,
  sourceId: String
};

function parseDragMeta(raw) {
  var _a = refineProps(raw, DRAG_META_REFINERS),
      refined = _a.refined,
      extra = _a.extra;

  return {
    startTime: refined.startTime || null,
    duration: refined.duration || null,
    create: refined.create != null ? refined.create : true,
    sourceId: refined.sourceId,
    leftoverProps: extra
  };
}

var ToolbarSection =
/** @class */
function (_super) {
  __extends(ToolbarSection, _super);

  function ToolbarSection() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ToolbarSection.prototype.render = function () {
    var _this = this;

    var children = this.props.widgetGroups.map(function (widgetGroup) {
      return _this.renderWidgetGroup(widgetGroup);
    });
    return vdom_createElement.apply(void 0, __spreadArray(['div', {
      className: 'fc-toolbar-chunk'
    }], children));
  };

  ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {
    var props = this.props;
    var theme = this.context.theme;
    var children = [];
    var isOnlyButtons = true;

    for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {
      var widget = widgetGroup_1[_i];
      var buttonName = widget.buttonName,
          buttonClick = widget.buttonClick,
          buttonText = widget.buttonText,
          buttonIcon = widget.buttonIcon,
          buttonHint = widget.buttonHint;

      if (buttonName === 'title') {
        isOnlyButtons = false;
        children.push(vdom_createElement("h2", {
          className: "fc-toolbar-title",
          id: props.titleId
        }, props.title));
      } else {
        var isPressed = buttonName === props.activeButton;
        var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';
        var buttonClasses = ["fc-" + buttonName + "-button", theme.getClass('button')];

        if (isPressed) {
          buttonClasses.push(theme.getClass('buttonActive'));
        }

        children.push(vdom_createElement("button", {
          type: "button",
          title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint,
          disabled: isDisabled,
          "aria-pressed": isPressed,
          className: buttonClasses.join(' '),
          onClick: buttonClick
        }, buttonText || (buttonIcon ? vdom_createElement("span", {
          className: buttonIcon
        }) : '')));
      }
    }

    if (children.length > 1) {
      var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';
      return vdom_createElement.apply(void 0, __spreadArray(['div', {
        className: groupClassName
      }], children));
    }

    return children[0];
  };

  return ToolbarSection;
}(BaseComponent);

var Toolbar =
/** @class */
function (_super) {
  __extends(Toolbar, _super);

  function Toolbar() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Toolbar.prototype.render = function () {
    var _a = this.props,
        model = _a.model,
        extraClassName = _a.extraClassName;
    var forceLtr = false;
    var startContent;
    var endContent;
    var sectionWidgets = model.sectionWidgets;
    var centerContent = sectionWidgets.center;

    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }

    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }

    var classNames = [extraClassName || '', 'fc-toolbar', forceLtr ? 'fc-toolbar-ltr' : ''];
    return vdom_createElement("div", {
      className: classNames.join(' ')
    }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));
  };

  Toolbar.prototype.renderSection = function (key, widgetGroups) {
    var props = this.props;
    return vdom_createElement(ToolbarSection, {
      key: key,
      widgetGroups: widgetGroups,
      title: props.title,
      navUnit: props.navUnit,
      activeButton: props.activeButton,
      isTodayEnabled: props.isTodayEnabled,
      isPrevEnabled: props.isPrevEnabled,
      isNextEnabled: props.isNextEnabled,
      titleId: props.titleId
    });
  };

  return Toolbar;
}(BaseComponent); // TODO: do function component?


var ViewContainer =
/** @class */
function (_super) {
  __extends(ViewContainer, _super);

  function ViewContainer() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      availableWidth: null
    };

    _this.handleEl = function (el) {
      _this.el = el;
      setRef(_this.props.elRef, el);

      _this.updateAvailableWidth();
    };

    _this.handleResize = function () {
      _this.updateAvailableWidth();
    };

    return _this;
  }

  ViewContainer.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state;

    var aspectRatio = props.aspectRatio;
    var classNames = ['fc-view-harness', aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height
    : 'fc-view-harness-passive' // let the view do the height
    ];
    var height = '';
    var paddingBottom = '';

    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        // while waiting to know availableWidth, we can't set height to *zero*
        // because will cause lots of unnecessary scrollbars within scrollgrid.
        // BETTER: don't start rendering ANYTHING yet until we know container width
        // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)
        paddingBottom = 1 / aspectRatio * 100 + "%";
      }
    } else {
      height = props.height || '';
    }

    return vdom_createElement("div", {
      "aria-labelledby": props.labeledById,
      ref: this.handleEl,
      className: classNames.join(' '),
      style: {
        height: height,
        paddingBottom: paddingBottom
      }
    }, props.children);
  };

  ViewContainer.prototype.componentDidMount = function () {
    this.context.addResizeHandler(this.handleResize);
  };

  ViewContainer.prototype.componentWillUnmount = function () {
    this.context.removeResizeHandler(this.handleResize);
  };

  ViewContainer.prototype.updateAvailableWidth = function () {
    if (this.el && // needed. but why?
    this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth
    ) {
      this.setState({
        availableWidth: this.el.offsetWidth
      });
    }
  };

  return ViewContainer;
}(BaseComponent);
/*
Detects when the user clicks on an event within a DateComponent
*/


var EventClicking =
/** @class */
function (_super) {
  __extends(EventClicking, _super);

  function EventClicking(settings) {
    var _this = _super.call(this, settings) || this;

    _this.handleSegClick = function (ev, segEl) {
      var component = _this.component;
      var context = component.context;
      var seg = getElSeg(segEl);

      if (seg && // might be the <div> surrounding the more link
      component.isValidSegDownEl(ev.target)) {
        // our way to simulate a link click for elements that can't be <a> tags
        // grab before trigger fired in case trigger trashes DOM thru rerendering
        var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');
        var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
        context.emitter.trigger('eventClick', {
          el: segEl,
          event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });

        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };

    _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events
    _this.handleSegClick);
    return _this;
  }

  return EventClicking;
}(Interaction);
/*
Triggers events and adds/removes core classNames when the user's pointer
enters/leaves event-elements of a component.
*/


var EventHovering =
/** @class */
function (_super) {
  __extends(EventHovering, _super);

  function EventHovering(settings) {
    var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it


    _this.handleEventElRemove = function (el) {
      if (el === _this.currentSegEl) {
        _this.handleSegLeave(null, _this.currentSegEl);
      }
    };

    _this.handleSegEnter = function (ev, segEl) {
      if (getElSeg(segEl)) {
        // TODO: better way to make sure not hovering over more+ link or its wrapper
        _this.currentSegEl = segEl;

        _this.triggerEvent('eventMouseEnter', ev, segEl);
      }
    };

    _this.handleSegLeave = function (ev, segEl) {
      if (_this.currentSegEl) {
        _this.currentSegEl = null;

        _this.triggerEvent('eventMouseLeave', ev, segEl);
      }
    };

    _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events
    _this.handleSegEnter, _this.handleSegLeave);
    return _this;
  }

  EventHovering.prototype.destroy = function () {
    this.removeHoverListeners();
  };

  EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {
    var component = this.component;
    var context = component.context;
    var seg = getElSeg(segEl);

    if (!ev || component.isValidSegDownEl(ev.target)) {
      context.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context.viewApi
      });
    }
  };

  return EventHovering;
}(Interaction);

var CalendarContent =
/** @class */
function (_super) {
  __extends(CalendarContent, _super);

  function CalendarContent() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buildViewContext = memoize(buildViewContext);
    _this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    _this.buildToolbarProps = memoize(buildToolbarProps);
    _this.headerRef = createRef();
    _this.footerRef = createRef();
    _this.interactionsStore = {}; // eslint-disable-next-line

    _this.state = {
      viewLabelId: getUniqueDomId()
    }; // Component Registration
    // -----------------------------------------------------------------------------------------------------------------

    _this.registerInteractiveComponent = function (component, settingsInput) {
      var settings = parseInteractionSettings(component, settingsInput);
      var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];
      var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);
      var interactions = interactionClasses.map(function (TheInteractionClass) {
        return new TheInteractionClass(settings);
      });
      _this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };

    _this.unregisterInteractiveComponent = function (component) {
      var listeners = _this.interactionsStore[component.uid];

      if (listeners) {
        for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
          var listener = listeners_1[_i];
          listener.destroy();
        }

        delete _this.interactionsStore[component.uid];
      }

      delete interactionSettingsStore[component.uid];
    }; // Resizing
    // -----------------------------------------------------------------------------------------------------------------


    _this.resizeRunner = new DelayedRunner(function () {
      _this.props.emitter.trigger('_resize', true); // should window resizes be considered "forced" ?


      _this.props.emitter.trigger('windowResize', {
        view: _this.props.viewApi
      });
    });

    _this.handleWindowResize = function (ev) {
      var options = _this.props.options;

      if (options.handleWindowResize && ev.target === window // avoid jqui events
      ) {
        _this.resizeRunner.request(options.windowResizeDelay);
      }
    };

    return _this;
  }
  /*
  renders INSIDE of an outer div
  */


  CalendarContent.prototype.render = function () {
    var props = this.props;
    var toolbarConfig = props.toolbarConfig,
        options = props.options;
    var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????
    props.viewTitle);
    var viewVGrow = false;
    var viewHeight = '';
    var viewAspectRatio;

    if (props.isHeightAuto || props.forPrint) {
      viewHeight = '';
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall
    }

    var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    var viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : '';
    return vdom_createElement(ViewContextType.Provider, {
      value: viewContext
    }, toolbarConfig.header && vdom_createElement(Toolbar, _assign({
      ref: this.headerRef,
      extraClassName: "fc-header-toolbar",
      model: toolbarConfig.header,
      titleId: viewLabelId
    }, toolbarProps)), vdom_createElement(ViewContainer, {
      liquid: viewVGrow,
      height: viewHeight,
      aspectRatio: viewAspectRatio,
      labeledById: viewLabelId
    }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && vdom_createElement(Toolbar, _assign({
      ref: this.footerRef,
      extraClassName: "fc-footer-toolbar",
      model: toolbarConfig.footer,
      titleId: ""
    }, toolbarProps)));
  };

  CalendarContent.prototype.componentDidMount = function () {
    var props = this.props;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function (CalendarInteractionClass) {
      return new CalendarInteractionClass(props);
    });
    window.addEventListener('resize', this.handleWindowResize);
    var propSetHandlers = props.pluginHooks.propSetHandlers;

    for (var propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  };

  CalendarContent.prototype.componentDidUpdate = function (prevProps) {
    var props = this.props;
    var propSetHandlers = props.pluginHooks.propSetHandlers;

    for (var propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  };

  CalendarContent.prototype.componentWillUnmount = function () {
    window.removeEventListener('resize', this.handleWindowResize);
    this.resizeRunner.clear();

    for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {
      var interaction = _a[_i];
      interaction.destroy();
    }

    this.props.emitter.trigger('_unmount');
  };

  CalendarContent.prototype.buildAppendContent = function () {
    var props = this.props;
    var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) {
      return buildAppendContent(props);
    });
    return vdom_createElement.apply(void 0, __spreadArray([vdom_Fragment, {}], children));
  };

  CalendarContent.prototype.renderView = function (props) {
    var pluginHooks = props.pluginHooks;
    var viewSpec = props.viewSpec;
    var viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);

    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
      var transformer = transformers_1[_i];

      _assign(viewProps, transformer.transform(viewProps, props));
    }

    var ViewComponent = viewSpec.component;
    return vdom_createElement(ViewComponent, _assign({}, viewProps));
  };

  return CalendarContent;
}(PureComponent);

function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
  // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid
  var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason

  var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title: title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
} // Plugin
// -----------------------------------------------------------------------------------------------------------------


function buildViewPropTransformers(theClasses) {
  return theClasses.map(function (TheClass) {
    return new TheClass();
  });
}

var CalendarRoot =
/** @class */
function (_super) {
  __extends(CalendarRoot, _super);

  function CalendarRoot() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      forPrint: false
    };

    _this.handleBeforePrint = function () {
      _this.setState({
        forPrint: true
      });
    };

    _this.handleAfterPrint = function () {
      _this.setState({
        forPrint: false
      });
    };

    return _this;
  }

  CalendarRoot.prototype.render = function () {
    var props = this.props;
    var options = props.options;
    var forPrint = this.state.forPrint;
    var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';
    var height = !isHeightAuto && options.height != null ? options.height : '';
    var classNames = ['fc', forPrint ? 'fc-media-print' : 'fc-media-screen', "fc-direction-" + options.direction, props.theme.getClass('root')];

    if (!getCanVGrowWithinCell()) {
      classNames.push('fc-liquid-hack');
    }

    return props.children(classNames, height, isHeightAuto, forPrint);
  };

  CalendarRoot.prototype.componentDidMount = function () {
    var emitter = this.props.emitter;
    emitter.on('_beforeprint', this.handleBeforePrint);
    emitter.on('_afterprint', this.handleAfterPrint);
  };

  CalendarRoot.prototype.componentWillUnmount = function () {
    var emitter = this.props.emitter;
    emitter.off('_beforeprint', this.handleBeforePrint);
    emitter.off('_afterprint', this.handleAfterPrint);
  };

  return CalendarRoot;
}(BaseComponent); // Computes a default column header formatting string if `colFormat` is not explicitly defined


function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  // if more than one week row, or if there are a lot of columns with not much space,
  // put just the day numbers will be in each cell
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({
      weekday: 'short'
    }); // "Sat"
  }

  if (dayCnt > 1) {
    return createFormatter({
      weekday: 'short',
      month: 'numeric',
      day: 'numeric',
      omitCommas: true
    }); // "Sat 11/12"
  }

  return createFormatter({
    weekday: 'long'
  }); // "Saturday"
}

var CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no

function renderInner$1(hookProps) {
  return hookProps.text;
}

var TableDateCell =
/** @class */
function (_super) {
  __extends(TableDateCell, _super);

  function TableDateCell() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TableDateCell.prototype.render = function () {
    var _a = this.context,
        dateEnv = _a.dateEnv,
        options = _a.options,
        theme = _a.theme,
        viewApi = _a.viewApi;
    var props = this.props;
    var date = props.date,
        dateProfile = props.dateProfile;
    var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    var text = dateEnv.format(date, props.dayHeaderFormat); // if colCnt is 1, we are already in a day-view and don't need a navlink

    var navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};

    var hookProps = _assign(_assign(_assign({
      date: dateEnv.toDate(date),
      view: viewApi
    }, props.extraHookProps), {
      text: text
    }), dayMeta);

    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.dayHeaderClassNames,
      content: options.dayHeaderContent,
      defaultContent: renderInner$1,
      didMount: options.dayHeaderDidMount,
      willUnmount: options.dayHeaderWillUnmount
    }, function (rootElRef, customClassNames, innerElRef, innerContent) {
      return vdom_createElement("th", _assign({
        ref: rootElRef,
        role: "columnheader",
        className: classNames.concat(customClassNames).join(' '),
        "data-date": !dayMeta.isDisabled ? formatDayString(date) : undefined,
        colSpan: props.colSpan
      }, props.extraDataAttrs), vdom_createElement("div", {
        className: "fc-scrollgrid-sync-inner"
      }, !dayMeta.isDisabled && vdom_createElement("a", _assign({
        ref: innerElRef,
        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' ')
      }, navLinkAttrs), innerContent)));
    });
  };

  return TableDateCell;
}(BaseComponent);

var WEEKDAY_FORMAT = createFormatter({
  weekday: 'long'
});

var TableDowCell =
/** @class */
function (_super) {
  __extends(TableDowCell, _super);

  function TableDowCell() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TableDowCell.prototype.render = function () {
    var props = this.props;
    var _a = this.context,
        dateEnv = _a.dateEnv,
        theme = _a.theme,
        viewApi = _a.viewApi,
        options = _a.options;
    var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT

    var dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);
    var text = dateEnv.format(date, props.dayHeaderFormat);

    var hookProps = _assign(_assign(_assign(_assign({
      // TODO: make this public?
      date: date
    }, dateMeta), {
      view: viewApi
    }), props.extraHookProps), {
      text: text
    });

    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.dayHeaderClassNames,
      content: options.dayHeaderContent,
      defaultContent: renderInner$1,
      didMount: options.dayHeaderDidMount,
      willUnmount: options.dayHeaderWillUnmount
    }, function (rootElRef, customClassNames, innerElRef, innerContent) {
      return vdom_createElement("th", _assign({
        ref: rootElRef,
        role: "columnheader",
        className: classNames.concat(customClassNames).join(' '),
        colSpan: props.colSpan
      }, props.extraDataAttrs), vdom_createElement("div", {
        className: "fc-scrollgrid-sync-inner"
      }, vdom_createElement("a", {
        "aria-label": dateEnv.format(date, WEEKDAY_FORMAT),
        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),
        ref: innerElRef
      }, innerContent)));
    });
  };

  return TableDowCell;
}(BaseComponent);

var NowTimer =
/** @class */
function (_super) {
  __extends(NowTimer, _super);

  function NowTimer(props, context) {
    var _this = _super.call(this, props, context) || this;

    _this.initialNowDate = getNow(context.options.now, context.dateEnv);
    _this.initialNowQueriedMs = new Date().valueOf();
    _this.state = _this.computeTiming().currentState;
    return _this;
  }

  NowTimer.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state;

    return props.children(state.nowDate, state.todayRange);
  };

  NowTimer.prototype.componentDidMount = function () {
    this.setTimeout();
  };

  NowTimer.prototype.componentDidUpdate = function (prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  };

  NowTimer.prototype.componentWillUnmount = function () {
    this.clearTimeout();
  };

  NowTimer.prototype.computeTiming = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
    var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
    var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
    var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf(); // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)
    // ensure no longer than a day

    waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);
    return {
      currentState: {
        nowDate: currentUnitStart,
        todayRange: buildDayRange(currentUnitStart)
      },
      nextState: {
        nowDate: nextUnitStart,
        todayRange: buildDayRange(nextUnitStart)
      },
      waitMs: waitMs
    };
  };

  NowTimer.prototype.setTimeout = function () {
    var _this = this;

    var _a = this.computeTiming(),
        nextState = _a.nextState,
        waitMs = _a.waitMs;

    this.timeoutId = setTimeout(function () {
      _this.setState(nextState, function () {
        _this.setTimeout();
      });
    }, waitMs);
  };

  NowTimer.prototype.clearTimeout = function () {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  };

  NowTimer.contextType = ViewContextType;
  return NowTimer;
}(Component);

function buildDayRange(date) {
  var start = startOfDay(date);
  var end = addDays(start, 1);
  return {
    start: start,
    end: end
  };
}

var DayHeader =
/** @class */
function (_super) {
  __extends(DayHeader, _super);

  function DayHeader() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
    return _this;
  }

  DayHeader.prototype.render = function () {
    var context = this.context;
    var _a = this.props,
        dates = _a.dates,
        dateProfile = _a.dateProfile,
        datesRepDistinctDays = _a.datesRepDistinctDays,
        renderIntro = _a.renderIntro;
    var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return vdom_createElement(NowTimer, {
      unit: "day"
    }, function (nowDate, todayRange) {
      return vdom_createElement("tr", {
        role: "row"
      }, renderIntro && renderIntro('day'), dates.map(function (date) {
        return datesRepDistinctDays ? vdom_createElement(TableDateCell, {
          key: date.toISOString(),
          date: date,
          dateProfile: dateProfile,
          todayRange: todayRange,
          colCnt: dates.length,
          dayHeaderFormat: dayHeaderFormat
        }) : vdom_createElement(TableDowCell, {
          key: date.getUTCDay(),
          dow: date.getUTCDay(),
          dayHeaderFormat: dayHeaderFormat
        });
      }));
    });
  };

  return DayHeader;
}(BaseComponent);

function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}

var DaySeriesModel =
/** @class */
function () {
  function DaySeriesModel(range, dateProfileGenerator) {
    var date = range.start;
    var end = range.end;
    var indices = [];
    var dates = [];
    var dayIndex = -1;

    while (date < end) {
      // loop each day from start to end
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5); // mark that it's between indices
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }

      date = addDays(date, 1);
    }

    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }

  DaySeriesModel.prototype.sliceRange = function (range) {
    var firstIndex = this.getDateDayIndex(range.start); // inclusive first index

    var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index

    var clippedFirstIndex = Math.max(0, firstIndex);
    var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices

    clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell

    clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell

    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }

    return null;
  }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.
  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
  // If before the first offset, returns a negative number.
  // If after the last offset, returns an offset past the last cell offset.
  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.


  DaySeriesModel.prototype.getDateDayIndex = function (date) {
    var indices = this.indices;
    var dayOffset = Math.floor(diffDays(this.dates[0], date));

    if (dayOffset < 0) {
      return indices[0] - 1;
    }

    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }

    return indices[dayOffset];
  };

  return DaySeriesModel;
}();

var DayTableModel =
/** @class */
function () {
  function DayTableModel(daySeries, breakOnWeeks) {
    var dates = daySeries.dates;
    var daysPerRow;
    var firstDay;
    var rowCnt;

    if (breakOnWeeks) {
      // count columns until the day-of-week repeats
      firstDay = dates[0].getUTCDay();

      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }

      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }

    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }

  DayTableModel.prototype.buildCells = function () {
    var rows = [];

    for (var row = 0; row < this.rowCnt; row += 1) {
      var cells = [];

      for (var col = 0; col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }

      rows.push(cells);
    }

    return rows;
  };

  DayTableModel.prototype.buildCell = function (row, col) {
    var date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date: date
    };
  };

  DayTableModel.prototype.buildHeaderDates = function () {
    var dates = [];

    for (var col = 0; col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }

    return dates;
  };

  DayTableModel.prototype.sliceRange = function (range) {
    var colCnt = this.colCnt;
    var seriesSeg = this.daySeries.sliceRange(range);
    var segs = [];

    if (seriesSeg) {
      var firstIndex = seriesSeg.firstIndex,
          lastIndex = seriesSeg.lastIndex;
      var index = firstIndex;

      while (index <= lastIndex) {
        var row = Math.floor(index / colCnt);
        var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row: row,
          firstCol: index % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index = nextIndex;
      }
    }

    return segs;
  };

  return DayTableModel;
}();

var Slicer =
/** @class */
function () {
  function Slicer() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false; // hack
  }

  Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {
    var extraArgs = [];

    for (var _i = 4; _i < arguments.length; _i++) {
      extraArgs[_i - 4] = arguments[_i];
    }

    var eventUiBases = props.eventUiBases;
    var eventSegs = this.sliceEventStore.apply(this, __spreadArray([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));
    return {
      dateSelectionSegs: this.sliceDateSelection.apply(this, __spreadArray([props.dateSelection, eventUiBases, context], extraArgs)),
      businessHourSegs: this.sliceBusinessHours.apply(this, __spreadArray([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag.apply(this, __spreadArray([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),
      eventResize: this.sliceEventResize.apply(this, __spreadArray([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),
      eventSelection: props.eventSelection
    }; // TODO: give interactionSegs?
  };

  Slicer.prototype.sliceNowDate = function ( // does not memoize
  date, context) {
    var extraArgs = [];

    for (var _i = 2; _i < arguments.length; _i++) {
      extraArgs[_i - 2] = arguments[_i];
    }

    return this._sliceDateSpan.apply(this, __spreadArray([{
      range: {
        start: date,
        end: addMs(date, 1)
      },
      allDay: false
    }, {}, context], extraArgs));
  };

  Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {
    var extraArgs = [];

    for (var _i = 4; _i < arguments.length; _i++) {
      extraArgs[_i - 4] = arguments[_i];
    }

    if (!businessHours) {
      return [];
    }

    return this._sliceEventStore.apply(this, __spreadArray([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold], extraArgs)).bg;
  };

  Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {
    var extraArgs = [];

    for (var _i = 4; _i < arguments.length; _i++) {
      extraArgs[_i - 4] = arguments[_i];
    }

    if (eventStore) {
      var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }

    return {
      bg: [],
      fg: []
    };
  };

  Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {
    var extraArgs = [];

    for (var _i = 4; _i < arguments.length; _i++) {
      extraArgs[_i - 4] = arguments[_i];
    }

    if (!interaction) {
      return null;
    }

    var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  };

  Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {
    var extraArgs = [];

    for (var _i = 3; _i < arguments.length; _i++) {
      extraArgs[_i - 3] = arguments[_i];
    }

    if (!dateSpan) {
      return [];
    }

    var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
    var segs = this.sliceRange.apply(this, __spreadArray([dateSpan.range], extraArgs));

    for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {
      var seg = segs_1[_a];
      seg.eventRange = eventRange;
    }

    return segs;
  };
  /*
  "complete" seg means it has component and eventRange
  */


  Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {
    var segs = [];

    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
      var eventRange = eventRanges_1[_i];
      segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));
    }

    return segs;
  };
  /*
  "complete" seg means it has component and eventRange
  */


  Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {
    var dateRange = eventRange.range; // hack to make multi-day events that are being force-displayed as list-items to take up only one day

    if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }

    var segs = this.sliceRange.apply(this, __spreadArray([dateRange], extraArgs));

    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
      var seg = segs_2[_i];
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }

    return segs;
  };

  return Slicer;
}();
/*
for incorporating slotMinTime/slotMaxTime if appropriate
TODO: should be part of DateProfile!
TimelineDateProfile already does this btw
*/


function computeActiveRange(dateProfile, isComponentAllDay) {
  var range = dateProfile.activeRange;

  if (isComponentAllDay) {
    return range;
  }

  return {
    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5) // 864e5 = ms in a day

  };
} // high-level segmenting-aware tester functions
// ------------------------------------------------------------------------------------------------------------------------


function isInteractionValid(interaction, dateProfile, context) {
  var instances = interaction.mutatedEvents.instances;

  for (var instanceId in instances) {
    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
      return false;
    }
  }

  return isNewPropsValid({
    eventDrag: interaction
  }, context); // HACK: the eventDrag props is used for ALL interactions
}

function isDateSelectionValid(dateSelection, dateProfile, context) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }

  return isNewPropsValid({
    dateSelection: dateSelection
  }, context);
}

function isNewPropsValid(newProps, context) {
  var calendarState = context.getCurrentData();

  var props = _assign({
    businessHours: calendarState.businessHours,
    dateSelection: '',
    eventStore: calendarState.eventStore,
    eventUiBases: calendarState.eventUiBases,
    eventSelection: '',
    eventDrag: null,
    eventResize: null
  }, newProps);

  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}

function isPropsValid(state, context, dateSpanMeta, filterConfig) {
  if (dateSpanMeta === void 0) {
    dateSpanMeta = {};
  }

  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }

  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }

  return true;
} // Moving Event Validation
// ------------------------------------------------------------------------------------------------------------------------


function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
  var currentState = context.getCurrentData();
  var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions

  var subjectEventStore = interaction.mutatedEvents;
  var subjectDefs = subjectEventStore.defs;
  var subjectInstances = subjectEventStore.instances;
  var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {
    '': currentState.selectionConfig
  });

  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  } // exclude the subject events. TODO: exclude defs too?


  var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  var otherDefs = otherEventStore.defs;
  var otherInstances = otherEventStore.instances;
  var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);

  for (var subjectInstanceId in subjectInstances) {
    var subjectInstance = subjectInstances[subjectInstanceId];
    var subjectRange = subjectInstance.range;
    var subjectConfig = subjectConfigs[subjectInstance.defId];
    var subjectDef = subjectDefs[subjectInstance.defId]; // constraint

    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
      return false;
    } // overlap


    var eventOverlap = context.options.eventOverlap;
    var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;

    for (var otherInstanceId in otherInstances) {
      var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate

      if (rangesIntersect(subjectRange, otherInstance.range)) {
        var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a "real" event

        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }

        if (subjectConfig.overlap === false) {
          return false;
        }

        if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event
        new EventApi(context, subjectDef, subjectInstance))) {
          return false;
        }
      }
    } // allow (a function)


    var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state

    for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {
      var subjectAllow = _a[_i];

      var subjectDateSpan = _assign(_assign({}, dateSpanMeta), {
        range: subjectInstance.range,
        allDay: subjectDef.allDay
      });

      var origDef = calendarEventStore.defs[subjectDef.defId];
      var origInstance = calendarEventStore.instances[subjectInstanceId];
      var eventApi = void 0;

      if (origDef) {
        // was previously in the calendar
        eventApi = new EventApi(context, origDef, origInstance);
      } else {
        // was an external event
        eventApi = new EventApi(context, subjectDef); // no instance, because had no dates
      }

      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
        return false;
      }
    }
  }

  return true;
} // Date Selection Validation
// ------------------------------------------------------------------------------------------------------------------------


function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
  var relevantEventStore = state.eventStore;
  var relevantDefs = relevantEventStore.defs;
  var relevantInstances = relevantEventStore.instances;
  var selection = state.dateSelection;
  var selectionRange = selection.range;
  var selectionConfig = context.getCurrentData().selectionConfig;

  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  } // constraint


  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
    return false;
  } // overlap


  var selectOverlap = context.options.selectOverlap;
  var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;

  for (var relevantInstanceId in relevantInstances) {
    var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate

    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }

      if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  } // allow (a function)


  for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {
    var selectionAllow = _a[_i];

    var fullDateSpan = _assign(_assign({}, dateSpanMeta), selection);

    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
      return false;
    }
  }

  return true;
} // Constraint Utils
// ------------------------------------------------------------------------------------------------------------------------


function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {
    var constraint = constraints_1[_i];

    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
      return false;
    }
  }

  return true;
}

function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours
otherEventStore, // for if constraint is an even group ID
businessHoursUnexpanded, // for if constraint is 'businessHours'
context) {
  if (constraint === 'businessHours') {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
  }

  if (typeof constraint === 'string') {
    // an group ID
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {
      return eventDef.groupId === constraint;
    }));
  }

  if (typeof constraint === 'object' && constraint) {
    // non-null object
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
  }

  return []; // if it's false
} // TODO: move to event-store file?


function eventStoreToRanges(eventStore) {
  var instances = eventStore.instances;
  var ranges = [];

  for (var instanceId in instances) {
    ranges.push(instances[instanceId].range);
  }

  return ranges;
} // TODO: move to geom file?


function anyRangesContainRange(outerRanges, innerRange) {
  for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {
    var outerRange = outerRanges_1[_i];

    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }

  return false;
}

var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;

var Scroller =
/** @class */
function (_super) {
  __extends(Scroller, _super);

  function Scroller() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.handleEl = function (el) {
      _this.el = el;
      setRef(_this.props.elRef, el);
    };

    return _this;
  }

  Scroller.prototype.render = function () {
    var props = this.props;
    var liquid = props.liquid,
        liquidIsAbsolute = props.liquidIsAbsolute;
    var isAbsolute = liquid && liquidIsAbsolute;
    var className = ['fc-scroller'];

    if (liquid) {
      if (liquidIsAbsolute) {
        className.push('fc-scroller-liquid-absolute');
      } else {
        className.push('fc-scroller-liquid');
      }
    }

    return vdom_createElement("div", {
      ref: this.handleEl,
      className: className.join(' '),
      style: {
        overflowX: props.overflowX,
        overflowY: props.overflowY,
        left: isAbsolute && -(props.overcomeLeft || 0) || '',
        right: isAbsolute && -(props.overcomeRight || 0) || '',
        bottom: isAbsolute && -(props.overcomeBottom || 0) || '',
        marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',
        marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',
        marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',
        maxHeight: props.maxHeight || ''
      }
    }, props.children);
  };

  Scroller.prototype.needsXScrolling = function () {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    } // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.
    // much more reliable to see if children are taller than the scroller, even tho doesn't account for
    // inner-child margins and absolute positioning


    var el = this.el;
    var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    var children = el.children;

    for (var i = 0; i < children.length; i += 1) {
      var childEl = children[i];

      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }

    return false;
  };

  Scroller.prototype.needsYScrolling = function () {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    } // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.
    // much more reliable to see if children are taller than the scroller, even tho doesn't account for
    // inner-child margins and absolute positioning


    var el = this.el;
    var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    var children = el.children;

    for (var i = 0; i < children.length; i += 1) {
      var childEl = children[i];

      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }

    return false;
  };

  Scroller.prototype.getXScrollbarWidth = function () {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }

    return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?
  };

  Scroller.prototype.getYScrollbarWidth = function () {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }

    return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?
  };

  return Scroller;
}(BaseComponent);
/*
TODO: somehow infer OtherArgs from masterCallback?
TODO: infer RefType from masterCallback if provided
*/


var RefMap =
/** @class */
function () {
  function RefMap(masterCallback) {
    var _this = this;

    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};

    this.handleValue = function (val, key) {
      var _a = _this,
          depths = _a.depths,
          currentMap = _a.currentMap;
      var removed = false;
      var added = false;

      if (val !== null) {
        // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;

        if (!depths[key]) {
          delete currentMap[key];
          delete _this.callbackMap[key];
          removed = true;
        }
      }

      if (_this.masterCallback) {
        if (removed) {
          _this.masterCallback(null, String(key));
        }

        if (added) {
          _this.masterCallback(val, String(key));
        }
      }
    };
  }

  RefMap.prototype.createRef = function (key) {
    var _this = this;

    var refCallback = this.callbackMap[key];

    if (!refCallback) {
      refCallback = this.callbackMap[key] = function (val) {
        _this.handleValue(val, String(key));
      };
    }

    return refCallback;
  }; // TODO: check callers that don't care about order. should use getAll instead
  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"


  RefMap.prototype.collect = function (startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  };

  RefMap.prototype.getAll = function () {
    return hashValuesToArray(this.currentMap);
  };

  return RefMap;
}();

function computeShrinkWidth(chunkEls) {
  var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');
  var largestWidth = 0;

  for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {
    var shrinkCell = shrinkCells_1[_i];
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }

  return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits
}

function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)
}

function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
  getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars
} // TODO: ONLY use `arg`. force out internal function to use same API


function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  var expandRows = arg.expandRows;
  var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : vdom_createElement('table', {
    role: 'presentation',
    className: [chunkConfig.tableClassName, sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : '' // css `height` on a <table> serves as a min-height

    }
  }, arg.tableColGroupNode, vdom_createElement(isHeader ? 'thead' : 'tbody', {
    role: 'presentation'
  }, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}

function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}

function renderMicroColGroup(cols, shrinkWidth) {
  var colNodes = [];
  /*
  for ColProps with spans, it would have been great to make a single <col span="">
  HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.
  SOLUTION: making individual <col> elements makes Chrome behave.
  */

  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {
    var colProps = cols_1[_i];
    var span = colProps.span || 1;

    for (var i = 0; i < span; i += 1) {
      colNodes.push(vdom_createElement("col", {
        style: {
          width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',
          minWidth: colProps.minWidth || ''
        }
      }));
    }
  }

  return vdom_createElement.apply(void 0, __spreadArray(['colgroup', {}], colNodes));
}

function sanitizeShrinkWidth(shrinkWidth) {
  /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth
  4 accounts for 2 2-pixel borders. TODO: better solution? */
  return shrinkWidth == null ? 4 : shrinkWidth;
}

function hasShrinkWidth(cols) {
  for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {
    var col = cols_2[_i];

    if (col.width === 'shrink') {
      return true;
    }
  }

  return false;
}

function getScrollGridClassNames(liquid, context) {
  var classNames = ['fc-scrollgrid', context.theme.getClass('table')];

  if (liquid) {
    classNames.push('fc-scrollgrid-liquid');
  }

  return classNames;
}

function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  var classNames = ['fc-scrollgrid-section', "fc-scrollgrid-section-" + sectionConfig.type, sectionConfig.className // used?
  ];

  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push('fc-scrollgrid-section-liquid');
  }

  if (sectionConfig.isSticky) {
    classNames.push('fc-scrollgrid-section-sticky');
  }

  return classNames;
}

function renderScrollShim(arg) {
  return vdom_createElement("div", {
    className: "fc-scrollgrid-sticky-shim",
    style: {
      width: arg.clientWidth,
      minWidth: arg.tableMinWidth
    }
  });
}

function getStickyHeaderDates(options) {
  var stickyHeaderDates = options.stickyHeaderDates;

  if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {
    stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';
  }

  return stickyHeaderDates;
}

function getStickyFooterScrollbar(options) {
  var stickyFooterScrollbar = options.stickyFooterScrollbar;

  if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {
    stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';
  }

  return stickyFooterScrollbar;
}

var SimpleScrollGrid =
/** @class */
function (_super) {
  __extends(SimpleScrollGrid, _super);

  function SimpleScrollGrid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.processCols = memoize(function (a) {
      return a;
    }, isColPropsEqual); // so we get same `cols` props every time
    // yucky to memoize VNodes, but much more efficient for consumers

    _this.renderMicroColGroup = memoize(renderMicroColGroup);
    _this.scrollerRefs = new RefMap();
    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));
    _this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    }; // TODO: can do a really simple print-view. dont need to join rows

    _this.handleSizing = function () {
      _this.safeSetState(_assign({
        shrinkWidth: _this.computeShrinkWidth()
      }, _this.computeScrollerDims()));
    };

    return _this;
  }

  SimpleScrollGrid.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var sectionConfigs = props.sections || [];
    var cols = this.processCols(props.cols);
    var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    var classNames = getScrollGridClassNames(props.liquid, context);

    if (props.collapsibleWidth) {
      classNames.push('fc-scrollgrid-collapsible');
    } // TODO: make DRY


    var configCnt = sectionConfigs.length;
    var configI = 0;
    var currentConfig;
    var headSectionNodes = [];
    var bodySectionNodes = [];
    var footSectionNodes = [];

    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }

    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }

    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    } // firefox bug: when setting height on table and there is a thead or tfoot,
    // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)
    // use getCanVGrowWithinCell as a way to detect table-stupid firefox.
    // if so, use a simpler dom structure, jam everything into a lone tbody.


    var isBuggy = !getCanVGrowWithinCell();
    var roleAttrs = {
      role: 'rowgroup'
    };
    return vdom_createElement('table', {
      role: 'grid',
      className: classNames.join(' '),
      style: {
        height: props.height
      }
    }, Boolean(!isBuggy && headSectionNodes.length) && vdom_createElement.apply(void 0, __spreadArray(['thead', roleAttrs], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && vdom_createElement.apply(void 0, __spreadArray(['tbody', roleAttrs], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && vdom_createElement.apply(void 0, __spreadArray(['tfoot', roleAttrs], footSectionNodes)), isBuggy && vdom_createElement.apply(void 0, __spreadArray(__spreadArray(__spreadArray(['tbody', roleAttrs], headSectionNodes), bodySectionNodes), footSectionNodes)));
  };

  SimpleScrollGrid.prototype.renderSection = function (sectionConfig, microColGroupNode, isHeader) {
    if ('outerContent' in sectionConfig) {
      return vdom_createElement(vdom_Fragment, {
        key: sectionConfig.key
      }, sectionConfig.outerContent);
    }

    return vdom_createElement("tr", {
      key: sectionConfig.key,
      role: "presentation",
      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')
    }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  };

  SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ('outerContent' in chunkConfig) {
      return chunkConfig.outerContent;
    }

    var props = this.props;
    var _a = this.state,
        forceYScrollbars = _a.forceYScrollbars,
        scrollerClientWidths = _a.scrollerClientWidths,
        scrollerClientHeights = _a.scrollerClientHeights;
    var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?

    var isLiquid = getSectionHasLiquidHeight(props, sectionConfig); // for `!props.liquid` - is WHOLE scrollgrid natural height?
    // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars

    var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';
    var sectionKey = sectionConfig.key;
    var content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: '',
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: function reportRowHeightChange() {}
    }, isHeader);
    return vdom_createElement(isHeader ? 'th' : 'td', {
      ref: chunkConfig.elRef,
      role: 'presentation'
    }, vdom_createElement("div", {
      className: "fc-scroller-harness" + (isLiquid ? ' fc-scroller-harness-liquid' : '')
    }, vdom_createElement(Scroller, {
      ref: this.scrollerRefs.createRef(sectionKey),
      elRef: this.scrollerElRefs.createRef(sectionKey),
      overflowY: overflowY,
      overflowX: !props.liquid ? 'visible' : 'hidden'
      /* natural height? */
      ,
      maxHeight: sectionConfig.maxHeight,
      liquid: isLiquid,
      liquidIsAbsolute // because its within a harness
      : true
    }, content)));
  };

  SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {
    var section = getSectionByKey(this.props.sections, key);

    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  };

  SimpleScrollGrid.prototype.componentDidMount = function () {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  };

  SimpleScrollGrid.prototype.componentDidUpdate = function () {
    // TODO: need better solution when state contains non-sizing things
    this.handleSizing();
  };

  SimpleScrollGrid.prototype.componentWillUnmount = function () {
    this.context.removeResizeHandler(this.handleSizing);
  };

  SimpleScrollGrid.prototype.computeShrinkWidth = function () {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  };

  SimpleScrollGrid.prototype.computeScrollerDims = function () {
    var scrollbarWidth = getScrollbarWidths();

    var _a = this,
        scrollerRefs = _a.scrollerRefs,
        scrollerElRefs = _a.scrollerElRefs;

    var forceYScrollbars = false;
    var scrollerClientWidths = {};
    var scrollerClientHeights = {};

    for (var sectionKey in scrollerRefs.currentMap) {
      var scroller = scrollerRefs.currentMap[sectionKey];

      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }

    for (var _i = 0, _b = this.props.sections; _i < _b.length; _i++) {
      var section = _b[_i];
      var sectionKey = section.key;
      var scrollerEl = scrollerElRefs.currentMap[sectionKey];

      if (scrollerEl) {
        var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders

        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future
        : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }

    return {
      forceYScrollbars: forceYScrollbars,
      scrollerClientWidths: scrollerClientWidths,
      scrollerClientHeights: scrollerClientHeights
    };
  };

  return SimpleScrollGrid;
}(BaseComponent);

SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});

function getSectionByKey(sections, key) {
  for (var _i = 0, sections_1 = sections; _i < sections_1.length; _i++) {
    var section = sections_1[_i];

    if (section.key === key) {
      return section;
    }
  }

  return null;
}

var EventRoot =
/** @class */
function (_super) {
  __extends(EventRoot, _super);

  function EventRoot() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.elRef = createRef();
    return _this;
  }

  EventRoot.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options;
    var seg = props.seg;
    var eventRange = seg.eventRange;
    var ui = eventRange.ui;
    var hookProps = {
      event: new EventApi(context, eventRange.def, eventRange.instance),
      view: context.viewApi,
      timeText: props.timeText,
      textColor: ui.textColor,
      backgroundColor: ui.backgroundColor,
      borderColor: ui.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);
    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.eventClassNames,
      content: options.eventContent,
      defaultContent: props.defaultContent,
      didMount: options.eventDidMount,
      willUnmount: options.eventWillUnmount,
      elRef: this.elRef
    }, function (rootElRef, customClassNames, innerElRef, innerContent) {
      return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);
    });
  };

  EventRoot.prototype.componentDidMount = function () {
    setElSeg(this.elRef.current, this.props.seg);
  };
  /*
  need to re-assign seg to the element if seg changes, even if the element is the same
  */


  EventRoot.prototype.componentDidUpdate = function (prevProps) {
    var seg = this.props.seg;

    if (seg !== prevProps.seg) {
      setElSeg(this.elRef.current, seg);
    }
  };

  return EventRoot;
}(BaseComponent); // should not be a purecomponent


var StandardEvent =
/** @class */
function (_super) {
  __extends(StandardEvent, _super);

  function StandardEvent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  StandardEvent.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var seg = props.seg;
    var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;
    var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return vdom_createElement(EventRoot, {
      seg: seg,
      timeText: timeText,
      disableDragging: props.disableDragging,
      disableResizing: props.disableResizing,
      defaultContent: props.defaultContent || renderInnerContent$1,
      isDragging: props.isDragging,
      isResizing: props.isResizing,
      isDateSelecting: props.isDateSelecting,
      isSelected: props.isSelected,
      isPast: props.isPast,
      isFuture: props.isFuture,
      isToday: props.isToday
    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {
      return vdom_createElement("a", _assign({
        className: props.extraClassNames.concat(classNames).join(' '),
        style: {
          borderColor: hookProps.borderColor,
          backgroundColor: hookProps.backgroundColor
        },
        ref: rootElRef
      }, getSegAnchorAttrs(seg, context)), vdom_createElement("div", {
        className: "fc-event-main",
        ref: innerElRef,
        style: {
          color: hookProps.textColor
        }
      }, innerContent), hookProps.isStartResizable && vdom_createElement("div", {
        className: "fc-event-resizer fc-event-resizer-start"
      }), hookProps.isEndResizable && vdom_createElement("div", {
        className: "fc-event-resizer fc-event-resizer-end"
      }));
    });
  };

  return StandardEvent;
}(BaseComponent);

function renderInnerContent$1(innerProps) {
  return vdom_createElement("div", {
    className: "fc-event-main-frame"
  }, innerProps.timeText && vdom_createElement("div", {
    className: "fc-event-time"
  }, innerProps.timeText), vdom_createElement("div", {
    className: "fc-event-title-container"
  }, vdom_createElement("div", {
    className: "fc-event-title fc-sticky"
  }, innerProps.event.title || vdom_createElement(vdom_Fragment, null, "\xA0"))));
}

var NowIndicatorRoot = function NowIndicatorRoot(props) {
  return vdom_createElement(ViewContextType.Consumer, null, function (context) {
    var options = context.options;
    var hookProps = {
      isAxis: props.isAxis,
      date: context.dateEnv.toDate(props.date),
      view: context.viewApi
    };
    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.nowIndicatorClassNames,
      content: options.nowIndicatorContent,
      didMount: options.nowIndicatorDidMount,
      willUnmount: options.nowIndicatorWillUnmount
    }, props.children);
  });
};

var DAY_NUM_FORMAT = createFormatter({
  day: 'numeric'
});

var DayCellContent =
/** @class */
function (_super) {
  __extends(DayCellContent, _super);

  function DayCellContent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DayCellContent.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options;
    var hookProps = refineDayCellHookProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      showDayNumber: props.showDayNumber,
      extraProps: props.extraHookProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv
    });
    return vdom_createElement(ContentHook, {
      hookProps: hookProps,
      content: options.dayCellContent,
      defaultContent: props.defaultContent
    }, props.children);
  };

  return DayCellContent;
}(BaseComponent);

function refineDayCellHookProps(raw) {
  var date = raw.date,
      dateEnv = raw.dateEnv;
  var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);
  return _assign(_assign(_assign({
    date: dateEnv.toDate(date),
    view: raw.viewApi
  }, dayMeta), {
    dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''
  }), raw.extraProps);
}

var DayCellRoot =
/** @class */
function (_super) {
  __extends(DayCellRoot, _super);

  function DayCellRoot() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);
    _this.normalizeClassNames = buildClassNameNormalizer();
    return _this;
  }

  DayCellRoot.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options;
    var hookProps = this.refineHookProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      showDayNumber: props.showDayNumber,
      extraProps: props.extraHookProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv
    });
    var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled
    : this.normalizeClassNames(options.dayCellClassNames, hookProps));
    var dataAttrs = hookProps.isDisabled ? {} : {
      'data-date': formatDayString(props.date)
    };
    return vdom_createElement(MountHook, {
      hookProps: hookProps,
      didMount: options.dayCellDidMount,
      willUnmount: options.dayCellWillUnmount,
      elRef: props.elRef
    }, function (rootElRef) {
      return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);
    });
  };

  return DayCellRoot;
}(BaseComponent);

function renderFill(fillType) {
  return vdom_createElement("div", {
    className: "fc-" + fillType
  });
}

var BgEvent = function BgEvent(props) {
  return vdom_createElement(EventRoot, {
    defaultContent: renderInnerContent,
    seg: props.seg
    /* uselesss i think */
    ,
    timeText: "",
    disableDragging: true,
    disableResizing: true,
    isDragging: false,
    isResizing: false,
    isDateSelecting: false,
    isSelected: false,
    isPast: props.isPast,
    isFuture: props.isFuture,
    isToday: props.isToday
  }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {
    return vdom_createElement("div", {
      ref: rootElRef,
      className: ['fc-bg-event'].concat(classNames).join(' '),
      style: {
        backgroundColor: hookProps.backgroundColor
      }
    }, innerContent);
  });
};

function renderInnerContent(props) {
  var title = props.event.title;
  return title && vdom_createElement("div", {
    className: "fc-event-title"
  }, props.event.title);
}

var WeekNumberRoot = function WeekNumberRoot(props) {
  return vdom_createElement(ViewContextType.Consumer, null, function (context) {
    var dateEnv = context.dateEnv,
        options = context.options;
    var date = props.date;
    var format = options.weekNumberFormat || props.defaultFormat;
    var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?

    var text = dateEnv.format(date, format);
    var hookProps = {
      num: num,
      text: text,
      date: date
    };
    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.weekNumberClassNames,
      content: options.weekNumberContent,
      defaultContent: renderInner,
      didMount: options.weekNumberDidMount,
      willUnmount: options.weekNumberWillUnmount
    }, props.children);
  });
};

function renderInner(innerProps) {
  return innerProps.text;
}

var PADDING_FROM_VIEWPORT = 10;

var Popover =
/** @class */
function (_super) {
  __extends(Popover, _super);

  function Popover() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      titleId: getUniqueDomId()
    };

    _this.handleRootEl = function (el) {
      _this.rootEl = el;

      if (_this.props.elRef) {
        setRef(_this.props.elRef, el);
      }
    }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature


    _this.handleDocumentMouseDown = function (ev) {
      // only hide the popover if the click happened outside the popover
      var target = getEventTargetViaRoot(ev);

      if (!_this.rootEl.contains(target)) {
        _this.handleCloseClick();
      }
    };

    _this.handleDocumentKeyDown = function (ev) {
      if (ev.key === 'Escape') {
        _this.handleCloseClick();
      }
    };

    _this.handleCloseClick = function () {
      var onClose = _this.props.onClose;

      if (onClose) {
        onClose();
      }
    };

    return _this;
  }

  Popover.prototype.render = function () {
    var _a = this.context,
        theme = _a.theme,
        options = _a.options;

    var _b = this,
        props = _b.props,
        state = _b.state;

    var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);
    return createPortal(vdom_createElement("div", _assign({
      id: props.id,
      className: classNames.join(' '),
      "aria-labelledby": state.titleId
    }, props.extraAttrs, {
      ref: this.handleRootEl
    }), vdom_createElement("div", {
      className: 'fc-popover-header ' + theme.getClass('popoverHeader')
    }, vdom_createElement("span", {
      className: "fc-popover-title",
      id: state.titleId
    }, props.title), vdom_createElement("span", {
      className: 'fc-popover-close ' + theme.getIconClass('close'),
      title: options.closeHint,
      onClick: this.handleCloseClick
    })), vdom_createElement("div", {
      className: 'fc-popover-body ' + theme.getClass('popoverContent')
    }, props.children)), props.parentEl);
  };

  Popover.prototype.componentDidMount = function () {
    document.addEventListener('mousedown', this.handleDocumentMouseDown);
    document.addEventListener('keydown', this.handleDocumentKeyDown);
    this.updateSize();
  };

  Popover.prototype.componentWillUnmount = function () {
    document.removeEventListener('mousedown', this.handleDocumentMouseDown);
    document.removeEventListener('keydown', this.handleDocumentKeyDown);
  };

  Popover.prototype.updateSize = function () {
    var isRtl = this.context.isRtl;
    var _a = this.props,
        alignmentEl = _a.alignmentEl,
        alignGridTop = _a.alignGridTop;
    var rootEl = this.rootEl;
    var alignmentRect = computeClippedClientRect(alignmentEl);

    if (alignmentRect) {
      var popoverDims = rootEl.getBoundingClientRect(); // position relative to viewport

      var popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;
      var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left; // constrain

      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      var origin_1 = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin_1.top,
        left: popoverLeft - origin_1.left
      });
    }
  };

  return Popover;
}(BaseComponent);

var MorePopover =
/** @class */
function (_super) {
  __extends(MorePopover, _super);

  function MorePopover() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.handleRootEl = function (rootEl) {
      _this.rootEl = rootEl;

      if (rootEl) {
        _this.context.registerInteractiveComponent(_this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        _this.context.unregisterInteractiveComponent(_this);
      }
    };

    return _this;
  }

  MorePopover.prototype.render = function () {
    var _a = this.context,
        options = _a.options,
        dateEnv = _a.dateEnv;
    var props = this.props;
    var startDate = props.startDate,
        todayRange = props.todayRange,
        dateProfile = props.dateProfile;
    var title = dateEnv.format(startDate, options.dayPopoverFormat);
    return vdom_createElement(DayCellRoot, {
      date: startDate,
      dateProfile: dateProfile,
      todayRange: todayRange,
      elRef: this.handleRootEl
    }, function (rootElRef, dayClassNames, dataAttrs) {
      return vdom_createElement(Popover, {
        elRef: rootElRef,
        id: props.id,
        title: title,
        extraClassNames: ['fc-more-popover'].concat(dayClassNames),
        extraAttrs: dataAttrs
        /* TODO: make these time-based when not whole-day? */
        ,
        parentEl: props.parentEl,
        alignmentEl: props.alignmentEl,
        alignGridTop: props.alignGridTop,
        onClose: props.onClose
      }, vdom_createElement(DayCellContent, {
        date: startDate,
        dateProfile: dateProfile,
        todayRange: todayRange
      }, function (innerElRef, innerContent) {
        return innerContent && vdom_createElement("div", {
          className: "fc-more-popover-misc",
          ref: innerElRef
        }, innerContent);
      }), props.children);
    });
  };

  MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
    var _a = this,
        rootEl = _a.rootEl,
        props = _a.props;

    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: _assign({
          allDay: true,
          range: {
            start: props.startDate,
            end: props.endDate
          }
        }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1 // important when comparing with hits from other components

      };
    }

    return null;
  };

  return MorePopover;
}(DateComponent);

var MoreLinkRoot =
/** @class */
function (_super) {
  __extends(MoreLinkRoot, _super);

  function MoreLinkRoot() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.linkElRef = createRef();
    _this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };

    _this.handleClick = function (ev) {
      var _a = _this,
          props = _a.props,
          context = _a.context;
      var moreLinkClick = context.options.moreLinkClick;
      var date = computeRange(props).start;

      function buildPublicSeg(seg) {
        var _a = seg.eventRange,
            def = _a.def,
            instance = _a.instance,
            range = _a.range;
        return {
          event: new EventApi(context, def, instance),
          start: context.dateEnv.toDate(range.start),
          end: context.dateEnv.toDate(range.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }

      if (typeof moreLinkClick === 'function') {
        moreLinkClick = moreLinkClick({
          date: date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context.viewApi
        });
      }

      if (!moreLinkClick || moreLinkClick === 'popover') {
        _this.setState({
          isPopoverOpen: true
        });
      } else if (typeof moreLinkClick === 'string') {
        // a view name
        context.calendarApi.zoomTo(date, moreLinkClick);
      }
    };

    _this.handlePopoverClose = function () {
      _this.setState({
        isPopoverOpen: false
      });
    };

    return _this;
  }

  MoreLinkRoot.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        state = _a.state;

    return vdom_createElement(ViewContextType.Consumer, null, function (context) {
      var viewApi = context.viewApi,
          options = context.options,
          calendarApi = context.calendarApi;
      var moreLinkText = options.moreLinkText;
      var moreCnt = props.moreCnt;
      var range = computeRange(props);
      var text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals
      ? moreLinkText.call(calendarApi, moreCnt) : "+" + moreCnt + " " + moreLinkText;
      var title = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      var hookProps = {
        num: moreCnt,
        shortText: "+" + moreCnt,
        text: text,
        view: viewApi
      };
      return vdom_createElement(vdom_Fragment, null, Boolean(props.moreCnt) && vdom_createElement(RenderHook, {
        elRef: _this.linkElRef,
        hookProps: hookProps,
        classNames: options.moreLinkClassNames,
        content: options.moreLinkContent,
        defaultContent: props.defaultContent || renderMoreLinkInner,
        didMount: options.moreLinkDidMount,
        willUnmount: options.moreLinkWillUnmount
      }, function (rootElRef, customClassNames, innerElRef, innerContent) {
        return props.children(rootElRef, ['fc-more-link'].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : '');
      }), state.isPopoverOpen && vdom_createElement(MorePopover, {
        id: state.popoverId,
        startDate: range.start,
        endDate: range.end,
        dateProfile: props.dateProfile,
        todayRange: props.todayRange,
        extraDateSpan: props.extraDateSpan,
        parentEl: _this.parentEl,
        alignmentEl: props.alignmentElRef.current,
        alignGridTop: props.alignGridTop,
        onClose: _this.handlePopoverClose
      }, props.popoverContent()));
    });
  };

  MoreLinkRoot.prototype.componentDidMount = function () {
    this.updateParentEl();
  };

  MoreLinkRoot.prototype.componentDidUpdate = function () {
    this.updateParentEl();
  };

  MoreLinkRoot.prototype.updateParentEl = function () {
    if (this.linkElRef.current) {
      this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');
    }
  };

  return MoreLinkRoot;
}(BaseComponent);

function renderMoreLinkInner(props) {
  return props.text;
}

function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }

  var hiddenSegs = props.hiddenSegs;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}

function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}

function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}

function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}

function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
} // exports
// --------------------------------------------------------------------------------------------------


var version = '5.11.3'; // important to type it, so .d.ts has generic string


;// CONCATENATED MODULE: ./node_modules/@fullcalendar/react/dist/main.js





var FullCalendar =
/** @class */
function (_super) {
  __extends(FullCalendar, _super);

  function FullCalendar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._calendarApi = new CalendarApi();
    return _this;
  }

  FullCalendar.prototype.render = function () {
    return react.createElement(CalendarDataProvider, {
      optionOverrides: this.props,
      calendarApi: this._calendarApi
    }, function (data) {
      return react.createElement(CalendarRoot, {
        options: data.calendarOptions,
        theme: data.theme,
        emitter: data.emitter
      }, function (classNames, height, isHeightAuto, forPrint) {
        return react.createElement("div", {
          className: classNames.join(' '),
          style: {
            height: height
          }
        }, react.createElement(CalendarContent, _assign({
          isHeightAuto: isHeightAuto,
          forPrint: forPrint
        }, data)));
      });
    });
  };

  FullCalendar.prototype.getApi = function () {
    return this._calendarApi;
  };

  return FullCalendar;
}(react.Component);

/* harmony default export */ var dist_main = (FullCalendar); // export all important utils/types


;// CONCATENATED MODULE: ./node_modules/@fullcalendar/interaction/main.js
/*!
FullCalendar v5.11.3
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/


config.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
/*
Uses a "pointer" abstraction, which monitors UI events for both mouse and touch.
Tracks when the pointer "drags" on a certain element, meaning down+move+up.

Also, tracks if there was touch-scrolling.
Also, can prevent touch-scrolling from happening.
Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.

emits:
- pointerdown
- pointermove
- pointerup
*/

var PointerDragging =
/** @class */
function () {
  function PointerDragging(containerEl) {
    var _this = this;

    this.subjectEl = null; // options that can be directly assigned by caller

    this.selector = ''; // will cause subjectEl in all emitted events to be this element

    this.handleSelector = '';
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true; // for simulating pointermove on scroll
    // internal states

    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false; // Mouse
    // ----------------------------------------------------------------------------------------------------

    this.handleMouseDown = function (ev) {
      if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {
        var pev = _this.createEventFromMouse(ev, true);

        _this.emitter.trigger('pointerdown', pev);

        _this.initScrollWatch(pev);

        if (!_this.shouldIgnoreMove) {
          document.addEventListener('mousemove', _this.handleMouseMove);
        }

        document.addEventListener('mouseup', _this.handleMouseUp);
      }
    };

    this.handleMouseMove = function (ev) {
      var pev = _this.createEventFromMouse(ev);

      _this.recordCoords(pev);

      _this.emitter.trigger('pointermove', pev);
    };

    this.handleMouseUp = function (ev) {
      document.removeEventListener('mousemove', _this.handleMouseMove);
      document.removeEventListener('mouseup', _this.handleMouseUp);

      _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));

      _this.cleanup(); // call last so that pointerup has access to props

    }; // Touch
    // ----------------------------------------------------------------------------------------------------


    this.handleTouchStart = function (ev) {
      if (_this.tryStart(ev)) {
        _this.isTouchDragging = true;

        var pev = _this.createEventFromTouch(ev, true);

        _this.emitter.trigger('pointerdown', pev);

        _this.initScrollWatch(pev); // unlike mouse, need to attach to target, not document
        // https://stackoverflow.com/a/45760014


        var targetEl = ev.target;

        if (!_this.shouldIgnoreMove) {
          targetEl.addEventListener('touchmove', _this.handleTouchMove);
        }

        targetEl.addEventListener('touchend', _this.handleTouchEnd);
        targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end
        // attach a handler to get called when ANY scroll action happens on the page.
        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
        // http://stackoverflow.com/a/32954565/96342

        window.addEventListener('scroll', _this.handleTouchScroll, true);
      }
    };

    this.handleTouchMove = function (ev) {
      var pev = _this.createEventFromTouch(ev);

      _this.recordCoords(pev);

      _this.emitter.trigger('pointermove', pev);
    };

    this.handleTouchEnd = function (ev) {
      if (_this.isDragging) {
        // done to guard against touchend followed by touchcancel
        var targetEl = ev.target;
        targetEl.removeEventListener('touchmove', _this.handleTouchMove);
        targetEl.removeEventListener('touchend', _this.handleTouchEnd);
        targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);
        window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true

        _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));

        _this.cleanup(); // call last so that pointerup has access to props


        _this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };

    this.handleTouchScroll = function () {
      _this.wasTouchScroll = true;
    };

    this.handleScroll = function (ev) {
      if (!_this.shouldIgnoreMove) {
        var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;
        var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;

        _this.emitter.trigger('pointermove', {
          origEvent: ev,
          isTouch: _this.isTouchDragging,
          subjectEl: _this.subjectEl,
          pageX: pageX,
          pageY: pageY,
          deltaX: pageX - _this.origPageX,
          deltaY: pageY - _this.origPageY
        });
      }
    };

    this.containerEl = containerEl;
    this.emitter = new Emitter();
    containerEl.addEventListener('mousedown', this.handleMouseDown);
    containerEl.addEventListener('touchstart', this.handleTouchStart, {
      passive: true
    });
    listenerCreated();
  }

  PointerDragging.prototype.destroy = function () {
    this.containerEl.removeEventListener('mousedown', this.handleMouseDown);
    this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {
      passive: true
    });
    listenerDestroyed();
  };

  PointerDragging.prototype.tryStart = function (ev) {
    var subjectEl = this.querySubjectEl(ev);
    var downEl = ev.target;

    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true; // do this first so cancelTouchScroll will work

      this.wasTouchScroll = false;
      return true;
    }

    return false;
  };

  PointerDragging.prototype.cleanup = function () {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null; // keep wasTouchScroll around for later access

    this.destroyScrollWatch();
  };

  PointerDragging.prototype.querySubjectEl = function (ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }

    return this.containerEl;
  };

  PointerDragging.prototype.shouldIgnoreMouse = function () {
    return ignoreMouseDepth || this.isTouchDragging;
  }; // can be called by user of this class, to cancel touch-based scrolling for the current drag


  PointerDragging.prototype.cancelTouchScroll = function () {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }; // Scrolling that simulates pointermoves
  // ----------------------------------------------------------------------------------------------------


  PointerDragging.prototype.initScrollWatch = function (ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener('scroll', this.handleScroll, true); // useCapture=true
    }
  };

  PointerDragging.prototype.recordCoords = function (ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.pageXOffset;
      this.prevScrollY = window.pageYOffset;
    }
  };

  PointerDragging.prototype.destroyScrollWatch = function () {
    if (this.shouldWatchScroll) {
      window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true
    }
  }; // Event Normalization
  // ----------------------------------------------------------------------------------------------------


  PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {
    var deltaX = 0;
    var deltaY = 0; // TODO: repeat code

    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }

    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX: deltaX,
      deltaY: deltaY
    };
  };

  PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {
    var touches = ev.touches;
    var pageX;
    var pageY;
    var deltaX = 0;
    var deltaY = 0; // if touch coords available, prefer,
    // because FF would give bad ev.pageX ev.pageY

    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    } // TODO: repeat code


    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }

    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX: pageX,
      pageY: pageY,
      deltaX: deltaX,
      deltaY: deltaY
    };
  };

  return PointerDragging;
}(); // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)


function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
} // Ignoring fake mouse events generated by touch
// ----------------------------------------------------------------------------------------------------


function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(function () {
    ignoreMouseDepth -= 1;
  }, config.touchMouseIgnoreWait);
} // We want to attach touchmove as early as possible for Safari
// ----------------------------------------------------------------------------------------------------


function listenerCreated() {
  listenerCnt += 1;

  if (listenerCnt === 1) {
    window.addEventListener('touchmove', onWindowTouchMove, {
      passive: false
    });
  }
}

function listenerDestroyed() {
  listenerCnt -= 1;

  if (!listenerCnt) {
    window.removeEventListener('touchmove', onWindowTouchMove, {
      passive: false
    });
  }
}

function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}
/*
An effect in which an element follows the movement of a pointer across the screen.
The moving element is a clone of some other element.
Must call start + handleMove + stop.
*/


var ElementMirror =
/** @class */
function () {
  function ElementMirror() {
    this.isVisible = false; // must be explicitly enabled

    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null; // screen coords relative to viewport
    // options that can be set directly by caller

    this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues

    this.zIndex = 9999;
    this.revertDuration = 0;
  }

  ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.pageXOffset;
    this.origScreenY = pageY - window.pageYOffset;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  };

  ElementMirror.prototype.handleMove = function (pageX, pageY) {
    this.deltaX = pageX - window.pageXOffset - this.origScreenX;
    this.deltaY = pageY - window.pageYOffset - this.origScreenY;
    this.updateElPosition();
  }; // can be called before start


  ElementMirror.prototype.setIsVisible = function (bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = '';
        }

        this.isVisible = bool; // needs to happen before updateElPosition

        this.updateElPosition(); // because was not updating the position while invisible
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = 'none';
      }

      this.isVisible = bool;
    }
  }; // always async


  ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {
    var _this = this;

    var done = function done() {
      _this.cleanup();

      callback();
    };

    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && ( // if 0, transition won't work
    this.deltaX || this.deltaY) // if same coords, transition won't work
    ) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  };

  ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {
    var mirrorEl = this.mirrorEl;
    var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened

    mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, function () {
      mirrorEl.style.transition = '';
      callback();
    });
  };

  ElementMirror.prototype.cleanup = function () {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }

    this.sourceEl = null;
  };

  ElementMirror.prototype.updateElPosition = function () {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  };

  ElementMirror.prototype.getMirrorEl = function () {
    var sourceElRect = this.sourceElRect;
    var mirrorEl = this.mirrorEl;

    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true
      // we don't want long taps or any mouse interaction causing selection/menus.
      // would use preventSelection(), but that prevents selectstart, causing problems.

      mirrorEl.classList.add('fc-unselectable');
      mirrorEl.classList.add('fc-event-dragging');
      applyStyle(mirrorEl, {
        position: 'fixed',
        zIndex: this.zIndex,
        visibility: '',
        boxSizing: 'border-box',
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: 'auto',
        bottom: 'auto',
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }

    return mirrorEl;
  };

  return ElementMirror;
}();
/*
Is a cache for a given element's scroll information (all the info that ScrollController stores)
in addition the "client rectangle" of the element.. the area within the scrollbars.

The cache can be in one of two modes:
- doesListening:false - ignores when the container is scrolled by someone else
- doesListening:true - watch for scrolling and update the cache
*/


var ScrollGeomCache =
/** @class */
function (_super) {
  __extends(ScrollGeomCache, _super);

  function ScrollGeomCache(scrollController, doesListening) {
    var _this = _super.call(this) || this;

    _this.handleScroll = function () {
      _this.scrollTop = _this.scrollController.getScrollTop();
      _this.scrollLeft = _this.scrollController.getScrollLeft();

      _this.handleScrollChange();
    };

    _this.scrollController = scrollController;
    _this.doesListening = doesListening;
    _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();
    _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();
    _this.scrollWidth = scrollController.getScrollWidth();
    _this.scrollHeight = scrollController.getScrollHeight();
    _this.clientWidth = scrollController.getClientWidth();
    _this.clientHeight = scrollController.getClientHeight();
    _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values

    if (_this.doesListening) {
      _this.getEventTarget().addEventListener('scroll', _this.handleScroll);
    }

    return _this;
  }

  ScrollGeomCache.prototype.destroy = function () {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener('scroll', this.handleScroll);
    }
  };

  ScrollGeomCache.prototype.getScrollTop = function () {
    return this.scrollTop;
  };

  ScrollGeomCache.prototype.getScrollLeft = function () {
    return this.scrollLeft;
  };

  ScrollGeomCache.prototype.setScrollTop = function (top) {
    this.scrollController.setScrollTop(top);

    if (!this.doesListening) {
      // we are not relying on the element to normalize out-of-bounds scroll values
      // so we need to sanitize ourselves
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  };

  ScrollGeomCache.prototype.setScrollLeft = function (top) {
    this.scrollController.setScrollLeft(top);

    if (!this.doesListening) {
      // we are not relying on the element to normalize out-of-bounds scroll values
      // so we need to sanitize ourselves
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  };

  ScrollGeomCache.prototype.getClientWidth = function () {
    return this.clientWidth;
  };

  ScrollGeomCache.prototype.getClientHeight = function () {
    return this.clientHeight;
  };

  ScrollGeomCache.prototype.getScrollWidth = function () {
    return this.scrollWidth;
  };

  ScrollGeomCache.prototype.getScrollHeight = function () {
    return this.scrollHeight;
  };

  ScrollGeomCache.prototype.handleScrollChange = function () {};

  return ScrollGeomCache;
}(ScrollController);

var ElementScrollGeomCache =
/** @class */
function (_super) {
  __extends(ElementScrollGeomCache, _super);

  function ElementScrollGeomCache(el, doesListening) {
    return _super.call(this, new ElementScrollController(el), doesListening) || this;
  }

  ElementScrollGeomCache.prototype.getEventTarget = function () {
    return this.scrollController.el;
  };

  ElementScrollGeomCache.prototype.computeClientRect = function () {
    return computeInnerRect(this.scrollController.el);
  };

  return ElementScrollGeomCache;
}(ScrollGeomCache);

var WindowScrollGeomCache =
/** @class */
function (_super) {
  __extends(WindowScrollGeomCache, _super);

  function WindowScrollGeomCache(doesListening) {
    return _super.call(this, new WindowScrollController(), doesListening) || this;
  }

  WindowScrollGeomCache.prototype.getEventTarget = function () {
    return window;
  };

  WindowScrollGeomCache.prototype.computeClientRect = function () {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }; // the window is the only scroll object that changes it's rectangle relative
  // to the document's topleft as it scrolls


  WindowScrollGeomCache.prototype.handleScrollChange = function () {
    this.clientRect = this.computeClientRect();
  };

  return WindowScrollGeomCache;
}(ScrollGeomCache); // If available we are using native "performance" API instead of "Date"
// Read more about it on MDN:
// https://developer.mozilla.org/en-US/docs/Web/API/Performance


var getTime = typeof performance === 'function' ? performance.now : Date.now;
/*
For a pointer interaction, automatically scrolls certain scroll containers when the pointer
approaches the edge.

The caller must call start + handleMove + stop.
*/

var AutoScroller =
/** @class */
function () {
  function AutoScroller() {
    var _this = this; // options that can be set by caller


    this.isEnabled = true;
    this.scrollQuery = [window, '.fc-scroller'];
    this.edgeThreshold = 50; // pixels

    this.maxVelocity = 300; // pixels per second
    // internal state

    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null; // protect against the initial pointerdown being too close to an edge and starting the scroll

    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;

    this.animate = function () {
      if (_this.isAnimating) {
        // wasn't cancelled between animation calls
        var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);

        if (edge) {
          var now = getTime();

          _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);

          _this.requestAnimation(now);
        } else {
          _this.isAnimating = false; // will stop animation
        }
      }
    };
  }

  AutoScroller.prototype.start = function (pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  };

  AutoScroller.prototype.handleMove = function (pageX, pageY) {
    if (this.isEnabled) {
      var pointerScreenX = pageX - window.pageXOffset;
      var pointerScreenY = pageY - window.pageYOffset;
      var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;

      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }

      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }

      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;

      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  };

  AutoScroller.prototype.stop = function () {
    if (this.isEnabled) {
      this.isAnimating = false; // will stop animation

      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
        var scrollCache = _a[_i];
        scrollCache.destroy();
      }

      this.scrollCaches = null;
    }
  };

  AutoScroller.prototype.requestAnimation = function (now) {
    this.msSinceRequest = now;
    requestAnimationFrame(this.animate);
  };

  AutoScroller.prototype.handleSide = function (edge, seconds) {
    var scrollCache = edge.scrollCache;
    var edgeThreshold = this.edgeThreshold;
    var invDistance = edgeThreshold - edge.distance;
    var velocity = // the closer to the edge, the faster we scroll
    invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
    this.maxVelocity * seconds;
    var sign = 1;

    switch (edge.name) {
      case 'left':
        sign = -1;
      // falls through

      case 'right':
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
        break;

      case 'top':
        sign = -1;
      // falls through

      case 'bottom':
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
        break;
    }
  }; // left/top are relative to document topleft


  AutoScroller.prototype.computeBestEdge = function (left, top) {
    var edgeThreshold = this.edgeThreshold;
    var bestSide = null;
    var scrollCaches = this.scrollCaches || [];

    for (var _i = 0, scrollCaches_1 = scrollCaches; _i < scrollCaches_1.length; _i++) {
      var scrollCache = scrollCaches_1[_i];
      var rect = scrollCache.clientRect;
      var leftDist = left - rect.left;
      var rightDist = rect.right - left;
      var topDist = top - rect.top;
      var bottomDist = rect.bottom - top; // completely within the rect?

      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = {
            scrollCache: scrollCache,
            name: 'top',
            distance: topDist
          };
        }

        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = {
            scrollCache: scrollCache,
            name: 'bottom',
            distance: bottomDist
          };
        }

        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = {
            scrollCache: scrollCache,
            name: 'left',
            distance: leftDist
          };
        }

        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = {
            scrollCache: scrollCache,
            name: 'right',
            distance: rightDist
          };
        }
      }
    }

    return bestSide;
  };

  AutoScroller.prototype.buildCaches = function (scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map(function (el) {
      if (el === window) {
        return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls
      }

      return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls
    });
  };

  AutoScroller.prototype.queryScrollEls = function (scrollStartEl) {
    var els = [];

    for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {
      var query = _a[_i];

      if (typeof query === 'object') {
        els.push(query);
      } else {
        els.push.apply(els, Array.prototype.slice.call(getElRoot(scrollStartEl).querySelectorAll(query)));
      }
    }

    return els;
  };

  return AutoScroller;
}();
/*
Monitors dragging on an element. Has a number of high-level features:
- minimum distance required before dragging
- minimum wait time ("delay") before dragging
- a mirror element that follows the pointer
*/


var FeaturefulElementDragging =
/** @class */
function (_super) {
  __extends(FeaturefulElementDragging, _super);

  function FeaturefulElementDragging(containerEl, selector) {
    var _this = _super.call(this, containerEl) || this;

    _this.containerEl = containerEl; // options that can be directly set by caller
    // the caller can also set the PointerDragging's options as well

    _this.delay = null;
    _this.minDistance = 0;
    _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag

    _this.mirrorNeedsRevert = false;
    _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup

    _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation

    _this.isDelayEnded = false;
    _this.isDistanceSurpassed = false;
    _this.delayTimeoutId = null;

    _this.onPointerDown = function (ev) {
      if (!_this.isDragging) {
        // so new drag doesn't happen while revert animation is going
        _this.isInteracting = true;
        _this.isDelayEnded = false;
        _this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body); // prevent links from being visited if there's an eventual drag.
        // also prevents selection in older browsers (maybe?).
        // not necessary for touch, besides, browser would complain about passiveness.

        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }

        _this.emitter.trigger('pointerdown', ev);

        if (_this.isInteracting && // not destroyed via pointerdown handler
        !_this.pointer.shouldIgnoreMove) {
          // actions related to initiating dragstart+dragmove+dragend...
          _this.mirror.setIsVisible(false); // reset. caller must set-visible


          _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down


          _this.startDelay(ev);

          if (!_this.minDistance) {
            _this.handleDistanceSurpassed(ev);
          }
        }
      }
    };

    _this.onPointerMove = function (ev) {
      if (_this.isInteracting) {
        _this.emitter.trigger('pointermove', ev);

        if (!_this.isDistanceSurpassed) {
          var minDistance = _this.minDistance;
          var distanceSq = void 0; // current distance from the origin, squared

          var deltaX = ev.deltaX,
              deltaY = ev.deltaY;
          distanceSq = deltaX * deltaX + deltaY * deltaY;

          if (distanceSq >= minDistance * minDistance) {
            // use pythagorean theorem
            _this.handleDistanceSurpassed(ev);
          }
        }

        if (_this.isDragging) {
          // a real pointer move? (not one simulated by scrolling)
          if (ev.origEvent.type !== 'scroll') {
            _this.mirror.handleMove(ev.pageX, ev.pageY);

            _this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }

          _this.emitter.trigger('dragmove', ev);
        }
      }
    };

    _this.onPointerUp = function (ev) {
      if (_this.isInteracting) {
        _this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);

        _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert


        if (_this.isDragging) {
          _this.autoScroller.stop();

          _this.tryStopDrag(ev); // which will stop the mirror

        }

        if (_this.delayTimeoutId) {
          clearTimeout(_this.delayTimeoutId);
          _this.delayTimeoutId = null;
        }
      }
    };

    var pointer = _this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on('pointerdown', _this.onPointerDown);
    pointer.emitter.on('pointermove', _this.onPointerMove);
    pointer.emitter.on('pointerup', _this.onPointerUp);

    if (selector) {
      pointer.selector = selector;
    }

    _this.mirror = new ElementMirror();
    _this.autoScroller = new AutoScroller();
    return _this;
  }

  FeaturefulElementDragging.prototype.destroy = function () {
    this.pointer.destroy(); // HACK: simulate a pointer-up to end the current drag
    // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)

    this.onPointerUp({});
  };

  FeaturefulElementDragging.prototype.startDelay = function (ev) {
    var _this = this;

    if (typeof this.delay === 'number') {
      this.delayTimeoutId = setTimeout(function () {
        _this.delayTimeoutId = null;

        _this.handleDelayEnd(ev);
      }, this.delay); // not assignable to number!
    } else {
      this.handleDelayEnd(ev);
    }
  };

  FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  };

  FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  };

  FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger('dragstart', ev);

        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  };

  FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {
    // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events
    // that come from the document to fire beforehand. much more convenient this way.
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  };

  FeaturefulElementDragging.prototype.stopDrag = function (ev) {
    this.isDragging = false;
    this.emitter.trigger('dragend', ev);
  }; // fill in the implementations...


  FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {
    this.pointer.shouldIgnoreMove = bool;
  };

  FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {
    this.mirror.setIsVisible(bool);
  };

  FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {
    this.mirrorNeedsRevert = bool;
  };

  FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {
    this.autoScroller.isEnabled = bool;
  };

  return FeaturefulElementDragging;
}(ElementDragging);
/*
When this class is instantiated, it records the offset of an element (relative to the document topleft),
and continues to monitor scrolling, updating the cached coordinates if it needs to.
Does not access the DOM after instantiation, so highly performant.

Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element
and an determine if a given point is inside the combined clipping rectangle.
*/


var OffsetTracker =
/** @class */
function () {
  function OffsetTracker(el) {
    this.origRect = computeRect(el); // will work fine for divs that have overflow:hidden

    this.scrollCaches = getClippingParents(el).map(function (scrollEl) {
      return new ElementScrollGeomCache(scrollEl, true);
    });
  }

  OffsetTracker.prototype.destroy = function () {
    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
      var scrollCache = _a[_i];
      scrollCache.destroy();
    }
  };

  OffsetTracker.prototype.computeLeft = function () {
    var left = this.origRect.left;

    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
      var scrollCache = _a[_i];
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }

    return left;
  };

  OffsetTracker.prototype.computeTop = function () {
    var top = this.origRect.top;

    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
      var scrollCache = _a[_i];
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }

    return top;
  };

  OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {
    var point = {
      left: pageX,
      top: pageY
    };

    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
      var scrollCache = _a[_i];

      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }

    return true;
  };

  return OffsetTracker;
}(); // certain clipping containers should never constrain interactions, like <html> and <body>
// https://github.com/fullcalendar/fullcalendar/issues/3615


function isIgnoredClipping(node) {
  var tagName = node.tagName;
  return tagName === 'HTML' || tagName === 'BODY';
}
/*
Tracks movement over multiple droppable areas (aka "hits")
that exist in one or more DateComponents.
Relies on an existing draggable.

emits:
- pointerdown
- dragstart
- hitchange - fires initially, even if not over a hit
- pointerup
- (hitchange - again, to null, if ended over a hit)
- dragend
*/


var HitDragging =
/** @class */
function () {
  function HitDragging(dragging, droppableStore) {
    var _this = this; // options that can be set by caller


    this.useSubjectCenter = false;
    this.requireInitial = true; // if doesn't start out on a hit, won't emit any events

    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null; // won't ever be populated if shouldIgnoreMove

    this.handlePointerDown = function (ev) {
      var dragging = _this.dragging;
      _this.initialHit = null;
      _this.movingHit = null;
      _this.finalHit = null;

      _this.prepareHits();

      _this.processFirstCoord(ev);

      if (_this.initialHit || !_this.requireInitial) {
        dragging.setIgnoreMove(false); // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(

        _this.emitter.trigger('pointerdown', ev);
      } else {
        dragging.setIgnoreMove(true);
      }
    };

    this.handleDragStart = function (ev) {
      _this.emitter.trigger('dragstart', ev);

      _this.handleMove(ev, true); // force = fire even if initially null

    };

    this.handleDragMove = function (ev) {
      _this.emitter.trigger('dragmove', ev);

      _this.handleMove(ev);
    };

    this.handlePointerUp = function (ev) {
      _this.releaseHits();

      _this.emitter.trigger('pointerup', ev);
    };

    this.handleDragEnd = function (ev) {
      if (_this.movingHit) {
        _this.emitter.trigger('hitupdate', null, true, ev);
      }

      _this.finalHit = _this.movingHit;
      _this.movingHit = null;

      _this.emitter.trigger('dragend', ev);
    };

    this.droppableStore = droppableStore;
    dragging.emitter.on('pointerdown', this.handlePointerDown);
    dragging.emitter.on('dragstart', this.handleDragStart);
    dragging.emitter.on('dragmove', this.handleDragMove);
    dragging.emitter.on('pointerup', this.handlePointerUp);
    dragging.emitter.on('dragend', this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter();
  } // sets initialHit
  // sets coordAdjust


  HitDragging.prototype.processFirstCoord = function (ev) {
    var origPoint = {
      left: ev.pageX,
      top: ev.pageY
    };
    var adjustedPoint = origPoint;
    var subjectEl = ev.subjectEl;
    var subjectRect;

    if (subjectEl instanceof HTMLElement) {
      // i.e. not a Document/ShadowRoot
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }

    var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);

    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        var slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);

        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }

      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = {
        left: 0,
        top: 0
      };
    }
  };

  HitDragging.prototype.handleMove = function (ev, forceHandle) {
    var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);

    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger('hitupdate', hit, false, ev);
    }
  };

  HitDragging.prototype.prepareHits = function () {
    this.offsetTrackers = mapHash(this.droppableStore, function (interactionSettings) {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  };

  HitDragging.prototype.releaseHits = function () {
    var offsetTrackers = this.offsetTrackers;

    for (var id in offsetTrackers) {
      offsetTrackers[id].destroy();
    }

    this.offsetTrackers = {};
  };

  HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {
    var _a = this,
        droppableStore = _a.droppableStore,
        offsetTrackers = _a.offsetTrackers;

    var bestHit = null;

    for (var id in droppableStore) {
      var component = droppableStore[id].component;
      var offsetTracker = offsetTrackers[id];

      if (offsetTracker && // wasn't destroyed mid-drag
      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        var originLeft = offsetTracker.computeLeft();
        var originTop = offsetTracker.computeTop();
        var positionLeft = offsetLeft - originLeft;
        var positionTop = offsetTop - originTop;
        var origRect = offsetTracker.origRect;
        var width = origRect.right - origRect.left;
        var height = origRect.bottom - origRect.top;

        if ( // must be within the element's bounds
        positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {
          var hit = component.queryHit(positionLeft, positionTop, width, height);

          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
          rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id;
            hit.context = component.context; // TODO: better way to re-orient rectangle

            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }

    return bestHit;
  };

  return HitDragging;
}();

function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }

  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }

  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}

function buildDatePointApiWithContext(dateSpan, context) {
  var props = {};

  for (var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++) {
    var transform = _a[_i];

    _assign(props, transform(dateSpan, context));
  }

  _assign(props, buildDatePointApi(dateSpan, context.dateEnv));

  return props;
}

function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, {
      omitTime: span.allDay
    }),
    allDay: span.allDay
  };
}
/*
Monitors when the user clicks on a specific date/time of a component.
A pointerdown+pointerup on the same "hit" constitutes a click.
*/


var DateClicking =
/** @class */
function (_super) {
  __extends(DateClicking, _super);

  function DateClicking(settings) {
    var _this = _super.call(this, settings) || this;

    _this.handlePointerDown = function (pev) {
      var dragging = _this.dragging;
      var downEl = pev.origEvent.target; // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired

      dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));
    }; // won't even fire if moving was ignored


    _this.handleDragEnd = function (ev) {
      var component = _this.component;
      var pointer = _this.dragging.pointer;

      if (!pointer.wasTouchScroll) {
        var _a = _this.hitDragging,
            initialHit = _a.initialHit,
            finalHit = _a.finalHit;

        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          var context = component.context;

          var arg = _assign(_assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {
            dayEl: initialHit.dayEl,
            jsEvent: ev.origEvent,
            view: context.viewApi || context.calendarApi.view
          });

          context.emitter.trigger('dateClick', arg);
        }
      }
    }; // we DO want to watch pointer moves because otherwise finalHit won't get populated


    _this.dragging = new FeaturefulElementDragging(settings.el);
    _this.dragging.autoScroller.isEnabled = false;
    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
    hitDragging.emitter.on('dragend', _this.handleDragEnd);
    return _this;
  }

  DateClicking.prototype.destroy = function () {
    this.dragging.destroy();
  };

  return DateClicking;
}(Interaction);
/*
Tracks when the user selects a portion of time of a component,
constituted by a drag over date cells, with a possible delay at the beginning of the drag.
*/


var DateSelecting =
/** @class */
function (_super) {
  __extends(DateSelecting, _super);

  function DateSelecting(settings) {
    var _this = _super.call(this, settings) || this;

    _this.dragSelection = null;

    _this.handlePointerDown = function (ev) {
      var _a = _this,
          component = _a.component,
          dragging = _a.dragging;
      var options = component.context.options;
      var canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target); // don't bother to watch expensive moves if component won't do selection

      dragging.setIgnoreMove(!canSelect); // if touch, require user to hold down

      dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;
    };

    _this.handleDragStart = function (ev) {
      _this.component.context.calendarApi.unselect(ev); // unselect previous selections

    };

    _this.handleHitUpdate = function (hit, isFinal) {
      var context = _this.component.context;
      var dragSelection = null;
      var isInvalid = false;

      if (hit) {
        var initialHit = _this.hitDragging.initialHit;
        var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);

        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
        }

        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
          isInvalid = true;
          dragSelection = null;
        }
      }

      if (dragSelection) {
        context.dispatch({
          type: 'SELECT_DATES',
          selection: dragSelection
        });
      } else if (!isFinal) {
        // only unselect if moved away while dragging
        context.dispatch({
          type: 'UNSELECT_DATES'
        });
      }

      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }

      if (!isFinal) {
        _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging
      }
    };

    _this.handlePointerUp = function (pev) {
      if (_this.dragSelection) {
        // selection is already rendered, so just need to report selection
        triggerDateSelect(_this.dragSelection, pev, _this.component.context);
        _this.dragSelection = null;
      }
    };

    var component = settings.component;
    var options = component.context.options;
    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
    hitDragging.emitter.on('dragstart', _this.handleDragStart);
    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
    hitDragging.emitter.on('pointerup', _this.handlePointerUp);
    return _this;
  }

  DateSelecting.prototype.destroy = function () {
    this.dragging.destroy();
  };

  return DateSelecting;
}(Interaction);

function getComponentTouchDelay$1(component) {
  var options = component.context.options;
  var delay = options.selectLongPressDelay;

  if (delay == null) {
    delay = options.longPressDelay;
  }

  return delay;
}

function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  var dateSpan0 = hit0.dateSpan;
  var dateSpan1 = hit1.dateSpan;
  var ms = [dateSpan0.range.start, dateSpan0.range.end, dateSpan1.range.start, dateSpan1.range.end];
  ms.sort(compareNumbers);
  var props = {};

  for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {
    var transformer = dateSelectionTransformers_1[_i];
    var res = transformer(hit0, hit1);

    if (res === false) {
      return null;
    }

    if (res) {
      _assign(props, res);
    }
  }

  props.range = {
    start: ms[0],
    end: ms[3]
  };
  props.allDay = dateSpan0.allDay;
  return props;
}

var EventDragging =
/** @class */
function (_super) {
  __extends(EventDragging, _super);

  function EventDragging(settings) {
    var _this = _super.call(this, settings) || this; // internal state


    _this.subjectEl = null;
    _this.subjectSeg = null; // the seg being selected/dragged

    _this.isDragging = false;
    _this.eventRange = null;
    _this.relevantEvents = null; // the events being dragged

    _this.receivingContext = null;
    _this.validMutation = null;
    _this.mutatedRelevantEvents = null;

    _this.handlePointerDown = function (ev) {
      var origTarget = ev.origEvent.target;
      var _a = _this,
          component = _a.component,
          dragging = _a.dragging;
      var mirror = dragging.mirror;
      var options = component.context.options;
      var initialContext = component.context;
      _this.subjectEl = ev.subjectEl;
      var subjectSeg = _this.subjectSeg = getElSeg(ev.subjectEl);
      var eventRange = _this.eventRange = subjectSeg.eventRange;
      var eventInstanceId = eventRange.instance.instanceId;
      _this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;
      dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet
      ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;

      if (options.fixedMirrorParent) {
        mirror.parentNode = options.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, '.fc');
      }

      mirror.revertDuration = options.dragRevertDuration;
      var isValid = component.isValidSegDownEl(origTarget) && !elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer

      dragging.setIgnoreMove(!isValid); // disable dragging for elements that are resizable (ie, selectable)
      // but are not draggable

      _this.isDragging = isValid && ev.subjectEl.classList.contains('fc-event-draggable');
    };

    _this.handleDragStart = function (ev) {
      var initialContext = _this.component.context;
      var eventRange = _this.eventRange;
      var eventInstanceId = eventRange.instance.instanceId;

      if (ev.isTouch) {
        // need to select a different event?
        if (eventInstanceId !== _this.component.props.eventSelection) {
          initialContext.dispatch({
            type: 'SELECT_EVENT',
            eventInstanceId: eventInstanceId
          });
        }
      } else {
        // if now using mouse, but was previous touch interaction, clear selected event
        initialContext.dispatch({
          type: 'UNSELECT_EVENT'
        });
      }

      if (_this.isDragging) {
        initialContext.calendarApi.unselect(ev); // unselect *date* selection

        initialContext.emitter.trigger('eventDragStart', {
          el: _this.subjectEl,
          event: new EventApi(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };

    _this.handleHitUpdate = function (hit, isFinal) {
      if (!_this.isDragging) {
        return;
      }

      var relevantEvents = _this.relevantEvents;
      var initialHit = _this.hitDragging.initialHit;
      var initialContext = _this.component.context; // states based on new hit

      var receivingContext = null;
      var mutation = null;
      var mutatedRelevantEvents = null;
      var isInvalid = false;
      var interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };

      if (hit) {
        receivingContext = hit.context;
        var receivingOptions = receivingContext.options;

        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);

          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;

            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }

      _this.displayDrag(receivingContext, interaction);

      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }

      if (!isFinal) {
        if (initialContext === receivingContext && // TODO: write test for this
        isHitsEqual(initialHit, hit)) {
          mutation = null;
        }

        _this.dragging.setMirrorNeedsRevert(!mutation); // render the mirror if no already-rendered mirror
        // TODO: wish we could somehow wait for dispatch to guarantee render


        _this.dragging.setMirrorIsVisible(!hit || !getElRoot(_this.subjectEl).querySelector('.fc-event-mirror')); // assign states based on new hit


        _this.receivingContext = receivingContext;
        _this.validMutation = mutation;
        _this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };

    _this.handlePointerUp = function () {
      if (!_this.isDragging) {
        _this.cleanup(); // because handleDragEnd won't fire

      }
    };

    _this.handleDragEnd = function (ev) {
      if (_this.isDragging) {
        var initialContext_1 = _this.component.context;
        var initialView = initialContext_1.viewApi;
        var _a = _this,
            receivingContext_1 = _a.receivingContext,
            validMutation = _a.validMutation;
        var eventDef = _this.eventRange.def;
        var eventInstance = _this.eventRange.instance;
        var eventApi = new EventApi(initialContext_1, eventDef, eventInstance);
        var relevantEvents_1 = _this.relevantEvents;
        var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;
        var finalHit = _this.hitDragging.finalHit;

        _this.clearDrag(); // must happen after revert animation


        initialContext_1.emitter.trigger('eventDragStop', {
          el: _this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });

        if (validMutation) {
          // dropped within same calendar
          if (receivingContext_1 === initialContext_1) {
            var updatedEventApi = new EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);
            initialContext_1.dispatch({
              type: 'MERGE_EVENTS',
              eventStore: mutatedRelevantEvents_1
            });
            var eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents_1, initialContext_1, eventInstance),
              revert: function revert() {
                initialContext_1.dispatch({
                  type: 'MERGE_EVENTS',
                  eventStore: relevantEvents_1 // the pre-change data

                });
              }
            };
            var transformed = {};

            for (var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++) {
              var transformer = _b[_i];

              _assign(transformed, transformer(validMutation, initialContext_1));
            }

            initialContext_1.emitter.trigger('eventDrop', _assign(_assign(_assign({}, eventChangeArg), transformed), {
              el: ev.subjectEl,
              delta: validMutation.datesDelta,
              jsEvent: ev.origEvent,
              view: initialView
            }));
            initialContext_1.emitter.trigger('eventChange', eventChangeArg); // dropped in different calendar
          } else if (receivingContext_1) {
            var eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents_1, initialContext_1, eventInstance),
              revert: function revert() {
                initialContext_1.dispatch({
                  type: 'MERGE_EVENTS',
                  eventStore: relevantEvents_1
                });
              }
            };
            initialContext_1.emitter.trigger('eventLeave', _assign(_assign({}, eventRemoveArg), {
              draggedEl: ev.subjectEl,
              view: initialView
            }));
            initialContext_1.dispatch({
              type: 'REMOVE_EVENTS',
              eventStore: relevantEvents_1
            });
            initialContext_1.emitter.trigger('eventRemove', eventRemoveArg);
            var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];
            var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];
            var addedEventApi = new EventApi(receivingContext_1, addedEventDef, addedEventInstance);
            receivingContext_1.dispatch({
              type: 'MERGE_EVENTS',
              eventStore: mutatedRelevantEvents_1
            });
            var eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),
              revert: function revert() {
                receivingContext_1.dispatch({
                  type: 'REMOVE_EVENTS',
                  eventStore: mutatedRelevantEvents_1
                });
              }
            };
            receivingContext_1.emitter.trigger('eventAdd', eventAddArg);

            if (ev.isTouch) {
              receivingContext_1.dispatch({
                type: 'SELECT_EVENT',
                eventInstanceId: eventInstance.instanceId
              });
            }

            receivingContext_1.emitter.trigger('drop', _assign(_assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), {
              draggedEl: ev.subjectEl,
              jsEvent: ev.origEvent,
              view: finalHit.context.viewApi
            }));
            receivingContext_1.emitter.trigger('eventReceive', _assign(_assign({}, eventAddArg), {
              draggedEl: ev.subjectEl,
              view: finalHit.context.viewApi
            }));
          }
        } else {
          initialContext_1.emitter.trigger('_noEventDrop');
        }
      }

      _this.cleanup();
    };

    var component = _this.component;
    var options = component.context.options;
    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
    hitDragging.emitter.on('dragstart', _this.handleDragStart);
    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
    hitDragging.emitter.on('pointerup', _this.handlePointerUp);
    hitDragging.emitter.on('dragend', _this.handleDragEnd);
    return _this;
  }

  EventDragging.prototype.destroy = function () {
    this.dragging.destroy();
  }; // render a drag state on the next receivingCalendar


  EventDragging.prototype.displayDrag = function (nextContext, state) {
    var initialContext = this.component.context;
    var prevContext = this.receivingContext; // does the previous calendar need to be cleared?

    if (prevContext && prevContext !== nextContext) {
      // does the initial calendar need to be cleared?
      // if so, don't clear all the way. we still need to to hide the affectedEvents
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: 'SET_EVENT_DRAG',
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        }); // completely clear the old calendar if it wasn't the initial
      } else {
        prevContext.dispatch({
          type: 'UNSET_EVENT_DRAG'
        });
      }
    }

    if (nextContext) {
      nextContext.dispatch({
        type: 'SET_EVENT_DRAG',
        state: state
      });
    }
  };

  EventDragging.prototype.clearDrag = function () {
    var initialCalendar = this.component.context;
    var receivingContext = this.receivingContext;

    if (receivingContext) {
      receivingContext.dispatch({
        type: 'UNSET_EVENT_DRAG'
      });
    } // the initial calendar might have an dummy drag state from displayDrag


    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({
        type: 'UNSET_EVENT_DRAG'
      });
    }
  };

  EventDragging.prototype.cleanup = function () {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }; // TODO: test this in IE11
  // QUESTION: why do we need it on the resizable???


  EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';
  return EventDragging;
}(Interaction);

function computeEventMutation(hit0, hit1, massagers) {
  var dateSpan0 = hit0.dateSpan;
  var dateSpan1 = hit1.dateSpan;
  var date0 = dateSpan0.range.start;
  var date1 = dateSpan1.range.start;
  var standardProps = {};

  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;

    if (dateSpan1.allDay) {
      // means date1 is already start-of-day,
      // but date0 needs to be converted
      date0 = startOfDay(date0);
    }
  }

  var delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);

  if (delta.milliseconds) {
    // has hours/minutes/seconds
    standardProps.allDay = false;
  }

  var mutation = {
    datesDelta: delta,
    standardProps: standardProps
  };

  for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {
    var massager = massagers_1[_i];
    massager(mutation, hit0, hit1);
  }

  return mutation;
}

function getComponentTouchDelay(component) {
  var options = component.context.options;
  var delay = options.eventLongPressDelay;

  if (delay == null) {
    delay = options.longPressDelay;
  }

  return delay;
}

var EventResizing =
/** @class */
function (_super) {
  __extends(EventResizing, _super);

  function EventResizing(settings) {
    var _this = _super.call(this, settings) || this; // internal state


    _this.draggingSegEl = null;
    _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?

    _this.eventRange = null;
    _this.relevantEvents = null;
    _this.validMutation = null;
    _this.mutatedRelevantEvents = null;

    _this.handlePointerDown = function (ev) {
      var component = _this.component;

      var segEl = _this.querySegEl(ev);

      var seg = getElSeg(segEl);
      var eventRange = _this.eventRange = seg.eventRange;
      _this.dragging.minDistance = component.context.options.eventDragMinDistance; // if touch, need to be working with a selected event

      _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId);
    };

    _this.handleDragStart = function (ev) {
      var context = _this.component.context;
      var eventRange = _this.eventRange;
      _this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);

      var segEl = _this.querySegEl(ev);

      _this.draggingSegEl = segEl;
      _this.draggingSeg = getElSeg(segEl);
      context.calendarApi.unselect();
      context.emitter.trigger('eventResizeStart', {
        el: segEl,
        event: new EventApi(context, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
    };

    _this.handleHitUpdate = function (hit, isFinal, ev) {
      var context = _this.component.context;
      var relevantEvents = _this.relevantEvents;
      var initialHit = _this.hitDragging.initialHit;
      var eventInstance = _this.eventRange.instance;
      var mutation = null;
      var mutatedRelevantEvents = null;
      var isInvalid = false;
      var interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };

      if (hit) {
        var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);

        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);
        }
      }

      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
        interaction.mutatedEvents = mutatedRelevantEvents;

        if (!isInteractionValid(interaction, hit.dateProfile, context)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }

      if (mutatedRelevantEvents) {
        context.dispatch({
          type: 'SET_EVENT_RESIZE',
          state: interaction
        });
      } else {
        context.dispatch({
          type: 'UNSET_EVENT_RESIZE'
        });
      }

      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }

      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }

        _this.validMutation = mutation;
        _this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };

    _this.handleDragEnd = function (ev) {
      var context = _this.component.context;
      var eventDef = _this.eventRange.def;
      var eventInstance = _this.eventRange.instance;
      var eventApi = new EventApi(context, eventDef, eventInstance);
      var relevantEvents = _this.relevantEvents;
      var mutatedRelevantEvents = _this.mutatedRelevantEvents;
      context.emitter.trigger('eventResizeStop', {
        el: _this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context.viewApi
      });

      if (_this.validMutation) {
        var updatedEventApi = new EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context.dispatch({
          type: 'MERGE_EVENTS',
          eventStore: mutatedRelevantEvents
        });
        var eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
          revert: function revert() {
            context.dispatch({
              type: 'MERGE_EVENTS',
              eventStore: relevantEvents // the pre-change events

            });
          }
        };
        context.emitter.trigger('eventResize', _assign(_assign({}, eventChangeArg), {
          el: _this.draggingSegEl,
          startDelta: _this.validMutation.startDelta || createDuration(0),
          endDelta: _this.validMutation.endDelta || createDuration(0),
          jsEvent: ev.origEvent,
          view: context.viewApi
        }));
        context.emitter.trigger('eventChange', eventChangeArg);
      } else {
        context.emitter.trigger('_noEventResize');
      } // reset all internal state


      _this.draggingSeg = null;
      _this.relevantEvents = null;
      _this.validMutation = null; // okay to keep eventInstance around. useful to set it in handlePointerDown
    };

    var component = settings.component;
    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = '.fc-event-resizer';
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
    hitDragging.emitter.on('dragstart', _this.handleDragStart);
    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
    hitDragging.emitter.on('dragend', _this.handleDragEnd);
    return _this;
  }

  EventResizing.prototype.destroy = function () {
    this.dragging.destroy();
  };

  EventResizing.prototype.querySegEl = function (ev) {
    return elementClosest(ev.subjectEl, '.fc-event');
  };

  return EventResizing;
}(Interaction);

function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  var dateEnv = hit0.context.dateEnv;
  var date0 = hit0.dateSpan.range.start;
  var date1 = hit1.dateSpan.range.start;
  var delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);

  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return {
        startDelta: delta
      };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return {
      endDelta: delta
    };
  }

  return null;
}

var UnselectAuto =
/** @class */
function () {
  function UnselectAuto(context) {
    var _this = this;

    this.context = context;
    this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system

    this.matchesCancel = false;
    this.matchesEvent = false;

    this.onSelect = function (selectInfo) {
      if (selectInfo.jsEvent) {
        _this.isRecentPointerDateSelect = true;
      }
    };

    this.onDocumentPointerDown = function (pev) {
      var unselectCancel = _this.context.options.unselectCancel;
      var downEl = getEventTargetViaRoot(pev.origEvent);
      _this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      _this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?
    };

    this.onDocumentPointerUp = function (pev) {
      var context = _this.context;
      var documentPointer = _this.documentPointer;
      var calendarState = context.getCurrentData(); // touch-scrolling should never unfocus any type of selection

      if (!documentPointer.wasTouchScroll) {
        if (calendarState.dateSelection && // an existing date selection?
        !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?
        ) {
          var unselectAuto = context.options.unselectAuto;

          if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {
            context.calendarApi.unselect(pev);
          }
        }

        if (calendarState.eventSelection && // an existing event selected?
        !_this.matchesEvent // interaction DIDN'T start on an event
        ) {
          context.dispatch({
            type: 'UNSELECT_EVENT'
          });
        }
      }

      _this.isRecentPointerDateSelect = false;
    };

    var documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);
    documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);
    /*
    TODO: better way to know about whether there was a selection with the pointer
    */

    context.emitter.on('select', this.onSelect);
  }

  UnselectAuto.prototype.destroy = function () {
    this.context.emitter.off('select', this.onSelect);
    this.documentPointer.destroy();
  };

  return UnselectAuto;
}();

var OPTION_REFINERS = {
  fixedMirrorParent: identity
};
var LISTENER_REFINERS = {
  dateClick: identity,
  eventDragStart: identity,
  eventDragStop: identity,
  eventDrop: identity,
  eventResizeStart: identity,
  eventResizeStop: identity,
  eventResize: identity,
  drop: identity,
  eventReceive: identity,
  eventLeave: identity
};
/*
Given an already instantiated draggable object for one-or-more elements,
Interprets any dragging as an attempt to drag an events that lives outside
of a calendar onto a calendar.
*/

var ExternalElementDragging =
/** @class */
function () {
  function ExternalElementDragging(dragging, suppliedDragMeta) {
    var _this = this;

    this.receivingContext = null;
    this.droppableEvent = null; // will exist for all drags, even if create:false

    this.suppliedDragMeta = null;
    this.dragMeta = null;

    this.handleDragStart = function (ev) {
      _this.dragMeta = _this.buildDragMeta(ev.subjectEl);
    };

    this.handleHitUpdate = function (hit, isFinal, ev) {
      var dragging = _this.hitDragging.dragging;
      var receivingContext = null;
      var droppableEvent = null;
      var isInvalid = false;
      var interaction = {
        affectedEvents: createEmptyEventStore(),
        mutatedEvents: createEmptyEventStore(),
        isEvent: _this.dragMeta.create
      };

      if (hit) {
        receivingContext = hit.context;

        if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {
          droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);
          interaction.mutatedEvents = eventTupleToStore(droppableEvent);
          isInvalid = !isInteractionValid(interaction, hit.dateProfile, receivingContext);

          if (isInvalid) {
            interaction.mutatedEvents = createEmptyEventStore();
            droppableEvent = null;
          }
        }
      }

      _this.displayDrag(receivingContext, interaction); // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)
      // TODO: wish we could somehow wait for dispatch to guarantee render


      dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));

      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }

      if (!isFinal) {
        dragging.setMirrorNeedsRevert(!droppableEvent);
        _this.receivingContext = receivingContext;
        _this.droppableEvent = droppableEvent;
      }
    };

    this.handleDragEnd = function (pev) {
      var _a = _this,
          receivingContext = _a.receivingContext,
          droppableEvent = _a.droppableEvent;

      _this.clearDrag();

      if (receivingContext && droppableEvent) {
        var finalHit = _this.hitDragging.finalHit;
        var finalView = finalHit.context.viewApi;
        var dragMeta = _this.dragMeta;
        receivingContext.emitter.trigger('drop', _assign(_assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {
          draggedEl: pev.subjectEl,
          jsEvent: pev.origEvent,
          view: finalView
        }));

        if (dragMeta.create) {
          var addingEvents_1 = eventTupleToStore(droppableEvent);
          receivingContext.dispatch({
            type: 'MERGE_EVENTS',
            eventStore: addingEvents_1
          });

          if (pev.isTouch) {
            receivingContext.dispatch({
              type: 'SELECT_EVENT',
              eventInstanceId: droppableEvent.instance.instanceId
            });
          } // signal that an external event landed


          receivingContext.emitter.trigger('eventReceive', {
            event: new EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),
            relatedEvents: [],
            revert: function revert() {
              receivingContext.dispatch({
                type: 'REMOVE_EVENTS',
                eventStore: addingEvents_1
              });
            },
            draggedEl: pev.subjectEl,
            view: finalView
          });
        }
      }

      _this.receivingContext = null;
      _this.droppableEvent = null;
    };

    var hitDragging = this.hitDragging = new HitDragging(dragging, interactionSettingsStore);
    hitDragging.requireInitial = false; // will start outside of a component

    hitDragging.emitter.on('dragstart', this.handleDragStart);
    hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
    hitDragging.emitter.on('dragend', this.handleDragEnd);
    this.suppliedDragMeta = suppliedDragMeta;
  }

  ExternalElementDragging.prototype.buildDragMeta = function (subjectEl) {
    if (typeof this.suppliedDragMeta === 'object') {
      return parseDragMeta(this.suppliedDragMeta);
    }

    if (typeof this.suppliedDragMeta === 'function') {
      return parseDragMeta(this.suppliedDragMeta(subjectEl));
    }

    return getDragMetaFromEl(subjectEl);
  };

  ExternalElementDragging.prototype.displayDrag = function (nextContext, state) {
    var prevContext = this.receivingContext;

    if (prevContext && prevContext !== nextContext) {
      prevContext.dispatch({
        type: 'UNSET_EVENT_DRAG'
      });
    }

    if (nextContext) {
      nextContext.dispatch({
        type: 'SET_EVENT_DRAG',
        state: state
      });
    }
  };

  ExternalElementDragging.prototype.clearDrag = function () {
    if (this.receivingContext) {
      this.receivingContext.dispatch({
        type: 'UNSET_EVENT_DRAG'
      });
    }
  };

  ExternalElementDragging.prototype.canDropElOnCalendar = function (el, receivingContext) {
    var dropAccept = receivingContext.options.dropAccept;

    if (typeof dropAccept === 'function') {
      return dropAccept.call(receivingContext.calendarApi, el);
    }

    if (typeof dropAccept === 'string' && dropAccept) {
      return Boolean(elementMatches(el, dropAccept));
    }

    return true;
  };

  return ExternalElementDragging;
}(); // Utils for computing event store from the DragMeta
// ----------------------------------------------------------------------------------------------------


function computeEventForDateSpan(dateSpan, dragMeta, context) {
  var defProps = _assign({}, dragMeta.leftoverProps);

  for (var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++) {
    var transform = _a[_i];

    _assign(defProps, transform(dateSpan, dragMeta));
  }

  var _b = refineEventDef(defProps, context),
      refined = _b.refined,
      extra = _b.extra;

  var def = parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), // hasEnd
  context);
  var start = dateSpan.range.start; // only rely on time info if drop zone is all-day,
  // otherwise, we already know the time

  if (dateSpan.allDay && dragMeta.startTime) {
    start = context.dateEnv.add(start, dragMeta.startTime);
  }

  var end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : getDefaultEventEnd(dateSpan.allDay, start, context);
  var instance = createEventInstance(def.defId, {
    start: start,
    end: end
  });
  return {
    def: def,
    instance: instance
  };
} // Utils for extracting data from element
// ----------------------------------------------------------------------------------------------------


function getDragMetaFromEl(el) {
  var str = getEmbeddedElData(el, 'event');
  var obj = str ? JSON.parse(str) : {
    create: false
  }; // if no embedded data, assume no event creation

  return parseDragMeta(obj);
}

config.dataAttrPrefix = '';

function getEmbeddedElData(el, name) {
  var prefix = config.dataAttrPrefix;
  var prefixedName = (prefix ? prefix + '-' : '') + name;
  return el.getAttribute('data-' + prefixedName) || '';
}
/*
Makes an element (that is *external* to any calendar) draggable.
Can pass in data that determines how an event will be created when dropped onto a calendar.
Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.
*/


var ExternalDraggable =
/** @class */
function () {
  function ExternalDraggable(el, settings) {
    var _this = this;

    if (settings === void 0) {
      settings = {};
    }

    this.handlePointerDown = function (ev) {
      var dragging = _this.dragging;
      var _a = _this.settings,
          minDistance = _a.minDistance,
          longPressDelay = _a.longPressDelay;
      dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : BASE_OPTION_DEFAULTS.eventDragMinDistance;
      dragging.delay = ev.isTouch ? // TODO: eventually read eventLongPressDelay instead vvv
      longPressDelay != null ? longPressDelay : BASE_OPTION_DEFAULTS.longPressDelay : 0;
    };

    this.handleDragStart = function (ev) {
      if (ev.isTouch && _this.dragging.delay && ev.subjectEl.classList.contains('fc-event')) {
        _this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');
      }
    };

    this.settings = settings;
    var dragging = this.dragging = new FeaturefulElementDragging(el);
    dragging.touchScrollAllowed = false;

    if (settings.itemSelector != null) {
      dragging.pointer.selector = settings.itemSelector;
    }

    if (settings.appendTo != null) {
      dragging.mirror.parentNode = settings.appendTo; // TODO: write tests
    }

    dragging.emitter.on('pointerdown', this.handlePointerDown);
    dragging.emitter.on('dragstart', this.handleDragStart);
    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new
  }

  ExternalDraggable.prototype.destroy = function () {
    this.dragging.destroy();
  };

  return ExternalDraggable;
}();
/*
Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.
The third-party system is responsible for drawing the visuals effects of the drag.
This class simply monitors for pointer movements and fires events.
It also has the ability to hide the moving element (the "mirror") during the drag.
*/


var InferredElementDragging =
/** @class */
function (_super) {
  __extends(InferredElementDragging, _super);

  function InferredElementDragging(containerEl) {
    var _this = _super.call(this, containerEl) || this;

    _this.shouldIgnoreMove = false;
    _this.mirrorSelector = '';
    _this.currentMirrorEl = null;

    _this.handlePointerDown = function (ev) {
      _this.emitter.trigger('pointerdown', ev);

      if (!_this.shouldIgnoreMove) {
        // fire dragstart right away. does not support delay or min-distance
        _this.emitter.trigger('dragstart', ev);
      }
    };

    _this.handlePointerMove = function (ev) {
      if (!_this.shouldIgnoreMove) {
        _this.emitter.trigger('dragmove', ev);
      }
    };

    _this.handlePointerUp = function (ev) {
      _this.emitter.trigger('pointerup', ev);

      if (!_this.shouldIgnoreMove) {
        // fire dragend right away. does not support a revert animation
        _this.emitter.trigger('dragend', ev);
      }
    };

    var pointer = _this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on('pointerdown', _this.handlePointerDown);
    pointer.emitter.on('pointermove', _this.handlePointerMove);
    pointer.emitter.on('pointerup', _this.handlePointerUp);
    return _this;
  }

  InferredElementDragging.prototype.destroy = function () {
    this.pointer.destroy();
  };

  InferredElementDragging.prototype.setIgnoreMove = function (bool) {
    this.shouldIgnoreMove = bool;
  };

  InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {
    if (bool) {
      // restore a previously hidden element.
      // use the reference in case the selector class has already been removed.
      if (this.currentMirrorEl) {
        this.currentMirrorEl.style.visibility = '';
        this.currentMirrorEl = null;
      }
    } else {
      var mirrorEl = this.mirrorSelector // TODO: somehow query FullCalendars WITHIN shadow-roots
      ? document.querySelector(this.mirrorSelector) : null;

      if (mirrorEl) {
        this.currentMirrorEl = mirrorEl;
        mirrorEl.style.visibility = 'hidden';
      }
    }
  };

  return InferredElementDragging;
}(ElementDragging);
/*
Bridges third-party drag-n-drop systems with FullCalendar.
Must be instantiated and destroyed by caller.
*/


var ThirdPartyDraggable =
/** @class */
function () {
  function ThirdPartyDraggable(containerOrSettings, settings) {
    var containerEl = document;

    if ( // wish we could just test instanceof EventTarget, but doesn't work in IE11
    containerOrSettings === document || containerOrSettings instanceof Element) {
      containerEl = containerOrSettings;
      settings = settings || {};
    } else {
      settings = containerOrSettings || {};
    }

    var dragging = this.dragging = new InferredElementDragging(containerEl);

    if (typeof settings.itemSelector === 'string') {
      dragging.pointer.selector = settings.itemSelector;
    } else if (containerEl === document) {
      dragging.pointer.selector = '[data-event]';
    }

    if (typeof settings.mirrorSelector === 'string') {
      dragging.mirrorSelector = settings.mirrorSelector;
    }

    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new
  }

  ThirdPartyDraggable.prototype.destroy = function () {
    this.dragging.destroy();
  };

  return ThirdPartyDraggable;
}();

var main_main = createPlugin({
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS,
  listenerRefiners: LISTENER_REFINERS
});
/* harmony default export */ var interaction_main = (main_main);

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/daygrid/main.css
// extracted by mini-css-extract-plugin
/* harmony default export */ var daygrid_main = ({});
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/daygrid/main.js
/*!
FullCalendar v5.11.3
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/



/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a Table subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

var TableView =
/** @class */
function (_super) {
  __extends(TableView, _super);

  function TableView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.headerElRef = createRef();
    return _this;
  }

  TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var sections = [];
    var stickyHeaderDates = getStickyHeaderDates(context.options);

    if (headerRowContent) {
      sections.push({
        type: 'header',
        key: 'header',
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: 'fc-col-header',
          rowContent: headerRowContent
        }
      });
    }

    sections.push({
      type: 'body',
      key: 'body',
      liquid: true,
      chunk: {
        content: bodyContent
      }
    });
    return vdom_createElement(ViewRoot, {
      viewSpec: context.viewSpec
    }, function (rootElRef, classNames) {
      return vdom_createElement("div", {
        ref: rootElRef,
        className: ['fc-daygrid'].concat(classNames).join(' ')
      }, vdom_createElement(SimpleScrollGrid, {
        liquid: !props.isHeightAuto && !props.forPrint,
        collapsibleWidth: props.forPrint,
        cols: []
        /* TODO: make optional? */
        ,
        sections: sections
      }));
    });
  };

  TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {
    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;

    if (!ScrollGrid) {
      throw new Error('No ScrollGrid implementation');
    }

    var _a = this,
        props = _a.props,
        context = _a.context;

    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    var sections = [];

    if (headerRowContent) {
      sections.push({
        type: 'header',
        key: 'header',
        isSticky: stickyHeaderDates,
        chunks: [{
          key: 'main',
          elRef: this.headerElRef,
          tableClassName: 'fc-col-header',
          rowContent: headerRowContent
        }]
      });
    }

    sections.push({
      type: 'body',
      key: 'body',
      liquid: true,
      chunks: [{
        key: 'main',
        content: bodyContent
      }]
    });

    if (stickyFooterScrollbar) {
      sections.push({
        type: 'footer',
        key: 'footer',
        isSticky: true,
        chunks: [{
          key: 'main',
          content: renderScrollShim
        }]
      });
    }

    return vdom_createElement(ViewRoot, {
      viewSpec: context.viewSpec
    }, function (rootElRef, classNames) {
      return vdom_createElement("div", {
        ref: rootElRef,
        className: ['fc-daygrid'].concat(classNames).join(' ')
      }, vdom_createElement(ScrollGrid, {
        liquid: !props.isHeightAuto && !props.forPrint,
        collapsibleWidth: props.forPrint,
        colGroups: [{
          cols: [{
            span: colCnt,
            minWidth: dayMinWidth
          }]
        }],
        sections: sections
      }));
    });
  };

  return TableView;
}(DateComponent);

function splitSegsByRow(segs, rowCnt) {
  var byRow = [];

  for (var i = 0; i < rowCnt; i += 1) {
    byRow[i] = [];
  }

  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
    var seg = segs_1[_i];
    byRow[seg.row].push(seg);
  }

  return byRow;
}

function splitSegsByFirstCol(segs, colCnt) {
  var byCol = [];

  for (var i = 0; i < colCnt; i += 1) {
    byCol[i] = [];
  }

  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
    var seg = segs_2[_i];
    byCol[seg.firstCol].push(seg);
  }

  return byCol;
}

function splitInteractionByRow(ui, rowCnt) {
  var byRow = [];

  if (!ui) {
    for (var i = 0; i < rowCnt; i += 1) {
      byRow[i] = null;
    }
  } else {
    for (var i = 0; i < rowCnt; i += 1) {
      byRow[i] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }

    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {
      var seg = _a[_i];
      byRow[seg.row].segs.push(seg);
    }
  }

  return byRow;
}

var TableCellTop =
/** @class */
function (_super) {
  __extends(TableCellTop, _super);

  function TableCellTop() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TableCellTop.prototype.render = function () {
    var props = this.props;
    var navLinkAttrs = buildNavLinkAttrs(this.context, props.date);
    return vdom_createElement(DayCellContent, {
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      showDayNumber: props.showDayNumber,
      extraHookProps: props.extraHookProps,
      defaultContent: renderTopInner
    }, function (innerElRef, innerContent) {
      return (innerContent || props.forceDayTop) && vdom_createElement("div", {
        className: "fc-daygrid-day-top",
        ref: innerElRef
      }, vdom_createElement("a", _assign({
        id: props.dayNumberId,
        className: "fc-daygrid-day-number"
      }, navLinkAttrs), innerContent || vdom_createElement(vdom_Fragment, null, "\xA0")));
    });
  };

  return TableCellTop;
}(BaseComponent);

function renderTopInner(props) {
  return props.dayNumberText;
}

var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: 'numeric',
  minute: '2-digit',
  omitZeroMinute: true,
  meridiem: 'narrow'
});

function hasListItemDisplay(seg) {
  var display = seg.eventRange.ui.display;
  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd // "
  ;
}

var TableBlockEvent =
/** @class */
function (_super) {
  __extends(TableBlockEvent, _super);

  function TableBlockEvent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TableBlockEvent.prototype.render = function () {
    var props = this.props;
    return vdom_createElement(StandardEvent, _assign({}, props, {
      extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],
      defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,
      defaultDisplayEventEnd: props.defaultDisplayEventEnd,
      disableResizing: !props.seg.eventRange.def.allDay
    }));
  };

  return TableBlockEvent;
}(BaseComponent);

var TableListItemEvent =
/** @class */
function (_super) {
  __extends(TableListItemEvent, _super);

  function TableListItemEvent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TableListItemEvent.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    var timeText = buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);
    return vdom_createElement(EventRoot, {
      seg: props.seg,
      timeText: timeText,
      defaultContent: main_renderInnerContent,
      isDragging: props.isDragging,
      isResizing: false,
      isDateSelecting: false,
      isSelected: props.isSelected,
      isPast: props.isPast,
      isFuture: props.isFuture,
      isToday: props.isToday
    }, function (rootElRef, classNames, innerElRef, innerContent) {
      return (// we don't use styles!
        vdom_createElement("a", _assign({
          className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),
          ref: rootElRef
        }, getSegAnchorAttrs(props.seg, context)), innerContent)
      );
    });
  };

  return TableListItemEvent;
}(BaseComponent);

function main_renderInnerContent(innerProps) {
  return vdom_createElement(vdom_Fragment, null, vdom_createElement("div", {
    className: "fc-daygrid-event-dot",
    style: {
      borderColor: innerProps.borderColor || innerProps.backgroundColor
    }
  }), innerProps.timeText && vdom_createElement("div", {
    className: "fc-event-time"
  }, innerProps.timeText), vdom_createElement("div", {
    className: "fc-event-title"
  }, innerProps.event.title || vdom_createElement(vdom_Fragment, null, "\xA0")));
}

var TableCellMoreLink =
/** @class */
function (_super) {
  __extends(TableCellMoreLink, _super);

  function TableCellMoreLink() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.compileSegs = memoize(compileSegs);
    return _this;
  }

  TableCellMoreLink.prototype.render = function () {
    var props = this.props;

    var _a = this.compileSegs(props.singlePlacements),
        allSegs = _a.allSegs,
        invisibleSegs = _a.invisibleSegs;

    return vdom_createElement(MoreLinkRoot, {
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      allDayDate: props.allDayDate,
      moreCnt: props.moreCnt,
      allSegs: allSegs,
      hiddenSegs: invisibleSegs,
      alignmentElRef: props.alignmentElRef,
      alignGridTop: props.alignGridTop,
      extraDateSpan: props.extraDateSpan,
      popoverContent: function popoverContent() {
        var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
        return vdom_createElement(vdom_Fragment, null, allSegs.map(function (seg) {
          var instanceId = seg.eventRange.instance.instanceId;
          return vdom_createElement("div", {
            className: "fc-daygrid-event-harness",
            key: instanceId,
            style: {
              visibility: isForcedInvisible[instanceId] ? 'hidden' : ''
            }
          }, hasListItemDisplay(seg) ? vdom_createElement(TableListItemEvent, _assign({
            seg: seg,
            isDragging: false,
            isSelected: instanceId === props.eventSelection,
            defaultDisplayEventEnd: false
          }, getSegMeta(seg, props.todayRange))) : vdom_createElement(TableBlockEvent, _assign({
            seg: seg,
            isDragging: false,
            isResizing: false,
            isDateSelecting: false,
            isSelected: instanceId === props.eventSelection,
            defaultDisplayEventEnd: false
          }, getSegMeta(seg, props.todayRange))));
        }));
      }
    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {
      return vdom_createElement("a", _assign({
        ref: rootElRef,
        className: ['fc-daygrid-more-link'].concat(classNames).join(' '),
        title: title,
        "aria-expanded": isExpanded,
        "aria-controls": popoverId
      }, createAriaClickAttrs(handleClick)), innerContent);
    });
  };

  return TableCellMoreLink;
}(BaseComponent);

function compileSegs(singlePlacements) {
  var allSegs = [];
  var invisibleSegs = [];

  for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {
    var placement = singlePlacements_1[_i];
    allSegs.push(placement.seg);

    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }

  return {
    allSegs: allSegs,
    invisibleSegs: invisibleSegs
  };
}

var DEFAULT_WEEK_NUM_FORMAT = createFormatter({
  week: 'narrow'
});

var TableCell =
/** @class */
function (_super) {
  __extends(TableCell, _super);

  function TableCell() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();
    _this.state = {
      dayNumberId: getUniqueDomId()
    };

    _this.handleRootEl = function (el) {
      setRef(_this.rootElRef, el);
      setRef(_this.props.elRef, el);
    };

    return _this;
  }

  TableCell.prototype.render = function () {
    var _a = this,
        context = _a.context,
        props = _a.props,
        state = _a.state,
        rootElRef = _a.rootElRef;

    var date = props.date,
        dateProfile = props.dateProfile;
    var navLinkAttrs = buildNavLinkAttrs(context, date, 'week');
    return vdom_createElement(DayCellRoot, {
      date: date,
      dateProfile: dateProfile,
      todayRange: props.todayRange,
      showDayNumber: props.showDayNumber,
      extraHookProps: props.extraHookProps,
      elRef: this.handleRootEl
    }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) {
      return vdom_createElement("td", _assign({
        ref: dayElRef,
        role: "gridcell",
        className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ')
      }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? {
        'aria-labelledby': state.dayNumberId
      } : {}), vdom_createElement("div", {
        className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner",
        ref: props.innerElRef
        /* different from hook system! RENAME */

      }, props.showWeekNumber && vdom_createElement(WeekNumberRoot, {
        date: date,
        defaultFormat: DEFAULT_WEEK_NUM_FORMAT
      }, function (weekElRef, weekClassNames, innerElRef, innerContent) {
        return vdom_createElement("a", _assign({
          ref: weekElRef,
          className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ')
        }, navLinkAttrs), innerContent);
      }), !isDisabled && vdom_createElement(TableCellTop, {
        date: date,
        dateProfile: dateProfile,
        showDayNumber: props.showDayNumber,
        dayNumberId: state.dayNumberId,
        forceDayTop: props.forceDayTop,
        todayRange: props.todayRange,
        extraHookProps: props.extraHookProps
      }), vdom_createElement("div", {
        className: "fc-daygrid-day-events",
        ref: props.fgContentElRef
      }, props.fgContent, vdom_createElement("div", {
        className: "fc-daygrid-day-bottom",
        style: {
          marginTop: props.moreMarginTop
        }
      }, vdom_createElement(TableCellMoreLink, {
        allDayDate: date,
        singlePlacements: props.singlePlacements,
        moreCnt: props.moreCnt,
        alignmentElRef: rootElRef,
        alignGridTop: !props.showDayNumber,
        extraDateSpan: props.extraDateSpan,
        dateProfile: props.dateProfile,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        todayRange: props.todayRange
      }))), vdom_createElement("div", {
        className: "fc-daygrid-day-bg"
      }, props.bgContent)));
    });
  };

  return TableCell;
}(DateComponent);

function computeFgSegPlacement(segs, // assumed already sorted
dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {
  var hierarchy = new DayGridSegHierarchy();
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;

  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === 'number') {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === 'number') {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  } // create segInputs only for segs with known heights


  var segInputs = [];
  var unknownHeightSegs = [];

  for (var i = 0; i < segs.length; i += 1) {
    var seg = segs[i];
    var instanceId = seg.eventRange.instance.instanceId;
    var eventHeight = eventInstanceHeights[instanceId];

    if (eventHeight != null) {
      segInputs.push({
        index: i,
        thickness: eventHeight,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }

  var hiddenEntries = hierarchy.addSegs(segInputs);
  var segRects = hierarchy.toRects();

  var _a = placeRects(segRects, segs, cells),
      singleColPlacements = _a.singleColPlacements,
      multiColPlacements = _a.multiColPlacements,
      leftoverMargins = _a.leftoverMargins;

  var moreCnts = [];
  var moreMarginTops = []; // add segs with unknown heights

  for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {
    var seg = unknownHeightSegs_1[_i];
    multiColPlacements[seg.firstCol].push({
      seg: seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });

    for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  } // add the hidden entries


  for (var col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }

  for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {
    var hiddenEntry = hiddenEntries_1[_b];
    var seg = segs[hiddenEntry.index];
    var hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });

    for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  } // deal with leftover margins


  for (var col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }

  return {
    singleColPlacements: singleColPlacements,
    multiColPlacements: multiColPlacements,
    moreCnts: moreCnts,
    moreMarginTops: moreMarginTops
  };
} // rects ordered by top coord, then left


function placeRects(allRects, segs, cells) {
  var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  var singleColPlacements = [];
  var multiColPlacements = [];
  var leftoverMargins = [];

  for (var col = 0; col < cells.length; col += 1) {
    var rects = rectsByEachCol[col]; // compute all static segs in singlePlacements

    var singlePlacements = [];
    var currentHeight = 0;
    var currentMarginTop = 0;

    for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {
      var rect = rects_1[_i];
      var seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    } // compute mixed static/absolute segs in multiPlacements


    var multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;

    for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {
      var rect = rects_2[_a];
      var seg = segs[rect.index];
      var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?

      var isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg

      currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg

      if (isAbsolute) {
        currentMarginTop += rect.thickness;

        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop // claim the margin

        });
        currentMarginTop = 0;
      }
    }

    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }

  return {
    singleColPlacements: singleColPlacements,
    multiColPlacements: multiColPlacements,
    leftoverMargins: leftoverMargins
  };
}

function groupRectsByEachCol(rects, colCnt) {
  var rectsByEachCol = [];

  for (var col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }

  for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {
    var rect = rects_3[_i];

    for (var col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }

  return rectsByEachCol;
}

function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }

  var eventRange = seg.eventRange;
  var origRange = eventRange.range;
  var slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return _assign(_assign({}, seg), {
    firstCol: spanStart,
    lastCol: spanEnd - 1,
    eventRange: {
      def: eventRange.def,
      ui: _assign(_assign({}, eventRange.ui), {
        durationEditable: false
      }),
      instance: eventRange.instance,
      range: slicedRange
    },
    isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),
    isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()
  });
}

var DayGridSegHierarchy =
/** @class */
function (_super) {
  __extends(DayGridSegHierarchy, _super);

  function DayGridSegHierarchy() {
    var _this = _super !== null && _super.apply(this, arguments) || this; // config


    _this.hiddenConsumes = false; // allows us to keep hidden entries in the hierarchy so they take up space

    _this.forceHidden = {};
    return _this;
  }

  DayGridSegHierarchy.prototype.addSegs = function (segInputs) {
    var _this = this;

    var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);

    var entriesByLevel = this.entriesByLevel;

    var excludeHidden = function excludeHidden(entry) {
      return !_this.forceHidden[buildEntryKey(entry)];
    }; // remove the forced-hidden segs


    for (var level = 0; level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }

    return hiddenSegs;
  };

  DayGridSegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {
    var _a = this,
        entriesByLevel = _a.entriesByLevel,
        forceHidden = _a.forceHidden;

    var touchingEntry = insertion.touchingEntry,
        touchingLevel = insertion.touchingLevel,
        touchingLateral = insertion.touchingLateral;

    if (this.hiddenConsumes && touchingEntry) {
      var touchingEntryId = buildEntryKey(touchingEntry); // if not already hidden

      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          var placeholderEntry = _assign(_assign({}, touchingEntry), {
            span: intersectSpans(touchingEntry.span, entry.span)
          });

          var placeholderEntryId = buildEntryKey(placeholderEntry);
          forceHidden[placeholderEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder

          this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }

    return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);
  };

  return DayGridSegHierarchy;
}(SegHierarchy);

var TableRow =
/** @class */
function (_super) {
  __extends(TableRow, _super);

  function TableRow() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.cellElRefs = new RefMap(); // the <td>

    _this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame

    _this.fgElRefs = new RefMap(); // the fc-daygrid-day-events

    _this.segHarnessRefs = new RefMap(); // indexed by "instanceId:firstCol"

    _this.rootElRef = createRef();
    _this.state = {
      framePositions: null,
      maxContentHeight: null,
      eventInstanceHeights: {}
    };
    return _this;
  }

  TableRow.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var options = context.options;
    var colCnt = props.cells.length;
    var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);

    var _b = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells),
        singleColPlacements = _b.singleColPlacements,
        multiColPlacements = _b.multiColPlacements,
        moreCnts = _b.moreCnts,
        moreMarginTops = _b.moreMarginTops;

    var isForcedInvisible = // TODO: messy way to compute this
    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};
    return vdom_createElement("tr", {
      ref: this.rootElRef,
      role: "row"
    }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {
      var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);

      var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);

      return vdom_createElement(TableCell, {
        key: cell.key,
        elRef: _this.cellElRefs.createRef(cell.key),
        innerElRef: _this.frameElRefs.createRef(cell.key)
        /* FF <td> problem, but okay to use for left/right. TODO: rename prop */
        ,
        dateProfile: props.dateProfile,
        date: cell.date,
        showDayNumber: props.showDayNumbers,
        showWeekNumber: props.showWeekNumbers && col === 0,
        forceDayTop: props.showWeekNumbers
        /* even displaying weeknum for row, not necessarily day */
        ,
        todayRange: props.todayRange,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        extraHookProps: cell.extraHookProps,
        extraDataAttrs: cell.extraDataAttrs,
        extraClassNames: cell.extraClassNames,
        extraDateSpan: cell.extraDateSpan,
        moreCnt: moreCnts[col],
        moreMarginTop: moreMarginTops[col],
        singlePlacements: singleColPlacements[col],
        fgContentElRef: _this.fgElRefs.createRef(cell.key),
        fgContent: // Fragment scopes the keys
        vdom_createElement(vdom_Fragment, null, vdom_createElement(vdom_Fragment, null, normalFgNodes), vdom_createElement(vdom_Fragment, null, mirrorFgNodes)),
        bgContent: // Fragment scopes the keys
        vdom_createElement(vdom_Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))
      });
    }));
  };

  TableRow.prototype.componentDidMount = function () {
    this.updateSizing(true);
  };

  TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {
    var currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  };

  TableRow.prototype.getHighlightSegs = function () {
    var props = this.props;

    if (props.eventDrag && props.eventDrag.segs.length) {
      // messy check
      return props.eventDrag.segs;
    }

    if (props.eventResize && props.eventResize.segs.length) {
      // messy check
      return props.eventResize.segs;
    }

    return props.dateSelectionSegs;
  };

  TableRow.prototype.getMirrorSegs = function () {
    var props = this.props;

    if (props.eventResize && props.eventResize.segs.length) {
      // messy check
      return props.eventResize.segs;
    }

    return [];
  };

  TableRow.prototype.renderFgSegs = function (col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    var context = this.context;
    var eventSelection = this.props.eventSelection;
    var framePositions = this.state.framePositions;
    var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1

    var isMirror = isDragging || isResizing || isDateSelecting;
    var nodes = [];

    if (framePositions) {
      for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {
        var placement = segPlacements_1[_i];
        var seg = placement.seg;
        var instanceId = seg.eventRange.instance.instanceId;
        var key = instanceId + ':' + col;
        var isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        var isAbsolute = placement.isAbsolute;
        var left = '';
        var right = '';

        if (isAbsolute) {
          if (context.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        /*
        known bug: events that are force to be list-item but span multiple days still take up space in later columns
        todo: in print view, for multi-day events, don't display title within non-start/end segs
        */


        nodes.push(vdom_createElement("div", {
          className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),
          key: key,
          ref: isMirror ? null : this.segHarnessRefs.createRef(key),
          style: {
            visibility: isVisible ? '' : 'hidden',
            marginTop: isAbsolute ? '' : placement.marginTop,
            top: isAbsolute ? placement.absoluteTop : '',
            left: left,
            right: right
          }
        }, hasListItemDisplay(seg) ? vdom_createElement(TableListItemEvent, _assign({
          seg: seg,
          isDragging: isDragging,
          isSelected: instanceId === eventSelection,
          defaultDisplayEventEnd: defaultDisplayEventEnd
        }, getSegMeta(seg, todayRange))) : vdom_createElement(TableBlockEvent, _assign({
          seg: seg,
          isDragging: isDragging,
          isResizing: isResizing,
          isDateSelecting: isDateSelecting,
          isSelected: instanceId === eventSelection,
          defaultDisplayEventEnd: defaultDisplayEventEnd
        }, getSegMeta(seg, todayRange)))));
      }
    }

    return nodes;
  };

  TableRow.prototype.renderFillSegs = function (segs, fillType) {
    var isRtl = this.context.isRtl;
    var todayRange = this.props.todayRange;
    var framePositions = this.state.framePositions;
    var nodes = [];

    if (framePositions) {
      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        var leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(vdom_createElement("div", {
          key: buildEventRangeKey(seg.eventRange),
          className: "fc-daygrid-bg-harness",
          style: leftRightCss
        }, fillType === 'bg-event' ? vdom_createElement(BgEvent, _assign({
          seg: seg
        }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }

    return vdom_createElement.apply(void 0, __spreadArray([vdom_Fragment, {}], nodes));
  };

  TableRow.prototype.updateSizing = function (isExternalSizingChange) {
    var _a = this,
        props = _a.props,
        frameElRefs = _a.frameElRefs;

    if (!props.forPrint && props.clientWidth !== null // positioning ready?
    ) {
      if (isExternalSizingChange) {
        var frameEls = props.cells.map(function (cell) {
          return frameElRefs.currentMap[cell.key];
        });

        if (frameEls.length) {
          var originEl = this.rootElRef.current;
          this.setState({
            framePositions: new PositionCache(originEl, frameEls, true, // isHorizontal
            false)
          });
        }
      }

      var oldInstanceHeights = this.state.eventInstanceHeights;
      var newInstanceHeights = this.queryEventInstanceHeights();
      var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        // HACK to prevent oscillations of events being shown/hidden from max-event-rows
        // Essentially, once you compute an element's height, never null-out.
        // TODO: always display all events, as visibility:hidden?
        eventInstanceHeights: _assign(_assign({}, oldInstanceHeights), newInstanceHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  };

  TableRow.prototype.queryEventInstanceHeights = function () {
    var segElMap = this.segHarnessRefs.currentMap;
    var eventInstanceHeights = {}; // get the max height amongst instance segs

    for (var key in segElMap) {
      var height = Math.round(segElMap[key].getBoundingClientRect().height);
      var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key

      eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);
    }

    return eventInstanceHeights;
  };

  TableRow.prototype.computeMaxContentHeight = function () {
    var firstKey = this.props.cells[0].key;
    var cellEl = this.cellElRefs.currentMap[firstKey];
    var fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  };

  TableRow.prototype.getCellEls = function () {
    var elMap = this.cellElRefs.currentMap;
    return this.props.cells.map(function (cell) {
      return elMap[cell.key];
    });
  };

  return TableRow;
}(DateComponent);

TableRow.addStateEquality({
  eventInstanceHeights: isPropsEqual
});

function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }

  var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?

  return mirrorSegs.map(function (seg) {
    return {
      seg: seg,
      isVisible: true,
      isAbsolute: true,
      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
      marginTop: 0
    };
  });
}

function buildAbsoluteTopHash(colPlacements) {
  var topsByInstanceId = {};

  for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {
    var placements = colPlacements_1[_i];

    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {
      var placement = placements_1[_a];
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }

  return topsByInstanceId;
}

var Table =
/** @class */
function (_super) {
  __extends(Table, _super);

  function Table() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.splitBusinessHourSegs = memoize(splitSegsByRow);
    _this.splitBgEventSegs = memoize(splitSegsByRow);
    _this.splitFgEventSegs = memoize(splitSegsByRow);
    _this.splitDateSelectionSegs = memoize(splitSegsByRow);
    _this.splitEventDrag = memoize(splitInteractionByRow);
    _this.splitEventResize = memoize(splitInteractionByRow);
    _this.rowRefs = new RefMap();

    _this.handleRootEl = function (rootEl) {
      _this.rootEl = rootEl;

      if (rootEl) {
        _this.context.registerInteractiveComponent(_this, {
          el: rootEl,
          isHitComboAllowed: _this.props.isHitComboAllowed
        });
      } else {
        _this.context.unregisterInteractiveComponent(_this);
      }
    };

    return _this;
  }

  Table.prototype.render = function () {
    var _this = this;

    var props = this.props;
    var dateProfile = props.dateProfile,
        dayMaxEventRows = props.dayMaxEventRows,
        dayMaxEvents = props.dayMaxEvents,
        expandRows = props.expandRows;
    var rowCnt = props.cells.length;
    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit
    // TODO: best place to normalize these options?

    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }

    var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?
    ];
    return vdom_createElement("div", {
      className: classNames.join(' '),
      ref: this.handleRootEl,
      style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      }
    }, vdom_createElement(NowTimer, {
      unit: "day"
    }, function (nowDate, todayRange) {
      return vdom_createElement(vdom_Fragment, null, vdom_createElement("table", {
        role: "presentation",
        className: "fc-scrollgrid-sync-table",
        style: {
          width: props.clientWidth,
          minWidth: props.tableMinWidth,
          height: expandRows ? props.clientHeight : ''
        }
      }, props.colGroupNode, vdom_createElement("tbody", {
        role: "presentation"
      }, props.cells.map(function (cells, row) {
        return vdom_createElement(TableRow, {
          ref: _this.rowRefs.createRef(row),
          key: cells.length ? cells[0].date.toISOString()
          /* best? or put key on cell? or use diff formatter? */
          : row // in case there are no cells (like when resource view is loading)
          ,
          showDayNumbers: rowCnt > 1,
          showWeekNumbers: props.showWeekNumbers,
          todayRange: todayRange,
          dateProfile: dateProfile,
          cells: cells,
          renderIntro: props.renderRowIntro,
          businessHourSegs: businessHourSegsByRow[row],
          eventSelection: props.eventSelection,
          bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)
          /* hack */
          ,
          fgEventSegs: fgEventSegsByRow[row],
          dateSelectionSegs: dateSelectionSegsByRow[row],
          eventDrag: eventDragByRow[row],
          eventResize: eventResizeByRow[row],
          dayMaxEvents: dayMaxEvents,
          dayMaxEventRows: dayMaxEventRows,
          clientWidth: props.clientWidth,
          clientHeight: props.clientHeight,
          forPrint: props.forPrint
        });
      }))));
    }));
  }; // Hit System
  // ----------------------------------------------------------------------------------------------------


  Table.prototype.prepareHits = function () {
    this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {
      return rowObj.getCellEls()[0];
    }), // first cell el in each row. TODO: not optimal
    false, true);
    this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row
    true, // horizontal
    false);
  };

  Table.prototype.queryHit = function (positionLeft, positionTop) {
    var _a = this,
        colPositions = _a.colPositions,
        rowPositions = _a.rowPositions;

    var col = colPositions.leftToIndex(positionLeft);
    var row = rowPositions.topToIndex(positionTop);

    if (row != null && col != null) {
      var cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: _assign({
          range: this.getCellRange(row, col),
          allDay: true
        }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }

    return null;
  };

  Table.prototype.getCellEl = function (row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal
  };

  Table.prototype.getCellRange = function (row, col) {
    var start = this.props.cells[row][col].date;
    var end = addDays(start, 1);
    return {
      start: start,
      end: end
    };
  };

  return Table;
}(DateComponent);

function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}

var DayTableSlicer =
/** @class */
function (_super) {
  __extends(DayTableSlicer, _super);

  function DayTableSlicer() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.forceDayIfListItem = true;
    return _this;
  }

  DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  };

  return DayTableSlicer;
}(Slicer);

var DayTable =
/** @class */
function (_super) {
  __extends(DayTable, _super);

  function DayTable() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.slicer = new DayTableSlicer();
    _this.tableRef = createRef();
    return _this;
  }

  DayTable.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    return vdom_createElement(Table, _assign({
      ref: this.tableRef
    }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {
      dateProfile: props.dateProfile,
      cells: props.dayTableModel.cells,
      colGroupNode: props.colGroupNode,
      tableMinWidth: props.tableMinWidth,
      renderRowIntro: props.renderRowIntro,
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      showWeekNumbers: props.showWeekNumbers,
      expandRows: props.expandRows,
      headerAlignElRef: props.headerAlignElRef,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      forPrint: props.forPrint
    }));
  };

  return DayTable;
}(DateComponent);

var DayTableView =
/** @class */
function (_super) {
  __extends(DayTableView, _super);

  function DayTableView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buildDayTableModel = memoize(buildDayTableModel);
    _this.headerRef = createRef();
    _this.tableRef = createRef();
    return _this;
  }

  DayTableView.prototype.render = function () {
    var _this = this;

    var _a = this.context,
        options = _a.options,
        dateProfileGenerator = _a.dateProfileGenerator;
    var props = this.props;
    var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    var headerContent = options.dayHeaders && vdom_createElement(DayHeader, {
      ref: this.headerRef,
      dateProfile: props.dateProfile,
      dates: dayTableModel.headerDates,
      datesRepDistinctDays: dayTableModel.rowCnt === 1
    });

    var bodyContent = function bodyContent(contentArg) {
      return vdom_createElement(DayTable, {
        ref: _this.tableRef,
        dateProfile: props.dateProfile,
        dayTableModel: dayTableModel,
        businessHours: props.businessHours,
        dateSelection: props.dateSelection,
        eventStore: props.eventStore,
        eventUiBases: props.eventUiBases,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        nextDayThreshold: options.nextDayThreshold,
        colGroupNode: contentArg.tableColGroupNode,
        tableMinWidth: contentArg.tableMinWidth,
        dayMaxEvents: options.dayMaxEvents,
        dayMaxEventRows: options.dayMaxEventRows,
        showWeekNumbers: options.weekNumbers,
        expandRows: !props.isHeightAuto,
        headerAlignElRef: _this.headerElRef,
        clientWidth: contentArg.clientWidth,
        clientHeight: contentArg.clientHeight,
        forPrint: props.forPrint
      });
    };

    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  };

  return DayTableView;
}(TableView);

function buildDayTableModel(dateProfile, dateProfileGenerator) {
  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}

var TableDateProfileGenerator =
/** @class */
function (_super) {
  __extends(TableDateProfileGenerator, _super);

  function TableDateProfileGenerator() {
    return _super !== null && _super.apply(this, arguments) || this;
  } // Computes the date range that will be rendered.


  TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
    var dateEnv = this.props.dateEnv;

    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);

    var start = renderRange.start;
    var end = renderRange.end;
    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week

    if (/^(year|month)$/.test(currentRangeUnit)) {
      start = dateEnv.startOfWeek(start); // make end-of-week if not already

      endOfWeek = dateEnv.startOfWeek(end);

      if (endOfWeek.valueOf() !== end.valueOf()) {
        end = addWeeks(endOfWeek, 1);
      }
    } // ensure 6 weeks


    if (this.props.monthMode && this.props.fixedWeekCount) {
      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
      diffWeeks(start, end));
      end = addWeeks(end, 6 - rowCnt);
    }

    return {
      start: start,
      end: end
    };
  };

  return TableDateProfileGenerator;
}(DateProfileGenerator);

var daygrid_main_main = createPlugin({
  initialView: 'dayGridMonth',
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: 'dayGrid',
      duration: {
        days: 1
      }
    },
    dayGridWeek: {
      type: 'dayGrid',
      duration: {
        weeks: 1
      }
    },
    dayGridMonth: {
      type: 'dayGrid',
      duration: {
        months: 1
      },
      monthMode: true,
      fixedWeekCount: true
    }
  }
});
/* harmony default export */ var _fullcalendar_daygrid_main = (daygrid_main_main);

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/timegrid/main.css
// extracted by mini-css-extract-plugin
/* harmony default export */ var timegrid_main = ({});
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/timegrid/main.js
/*!
FullCalendar v5.11.3
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/





var AllDaySplitter =
/** @class */
function (_super) {
  __extends(AllDaySplitter, _super);

  function AllDaySplitter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AllDaySplitter.prototype.getKeyInfo = function () {
    return {
      allDay: {},
      timed: {}
    };
  };

  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {
    if (dateSpan.allDay) {
      return ['allDay'];
    }

    return ['timed'];
  };

  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {
    if (!eventDef.allDay) {
      return ['timed'];
    }

    if (hasBgRendering(eventDef)) {
      return ['timed', 'allDay'];
    }

    return ['allDay'];
  };

  return AllDaySplitter;
}(Splitter);

var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
  hour: 'numeric',
  minute: '2-digit',
  omitZeroMinute: true,
  meridiem: 'short'
});

function TimeColsAxisCell(props) {
  var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];
  return vdom_createElement(ViewContextType.Consumer, null, function (context) {
    if (!props.isLabeled) {
      return vdom_createElement("td", {
        className: classNames.join(' '),
        "data-time": props.isoTimeStr
      });
    }

    var dateEnv = context.dateEnv,
        options = context.options,
        viewApi = context.viewApi;
    var labelFormat = // TODO: fully pre-parse
    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);
    var hookProps = {
      level: 0,
      time: props.time,
      date: dateEnv.toDate(props.date),
      view: viewApi,
      text: dateEnv.format(props.date, labelFormat)
    };
    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.slotLabelClassNames,
      content: options.slotLabelContent,
      defaultContent: timegrid_main_renderInnerContent,
      didMount: options.slotLabelDidMount,
      willUnmount: options.slotLabelWillUnmount
    }, function (rootElRef, customClassNames, innerElRef, innerContent) {
      return vdom_createElement("td", {
        ref: rootElRef,
        className: classNames.concat(customClassNames).join(' '),
        "data-time": props.isoTimeStr
      }, vdom_createElement("div", {
        className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame"
      }, vdom_createElement("div", {
        className: "fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion",
        ref: innerElRef
      }, innerContent)));
    });
  });
}

function timegrid_main_renderInnerContent(props) {
  return props.text;
}

var TimeBodyAxis =
/** @class */
function (_super) {
  __extends(TimeBodyAxis, _super);

  function TimeBodyAxis() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimeBodyAxis.prototype.render = function () {
    return this.props.slatMetas.map(function (slatMeta) {
      return vdom_createElement("tr", {
        key: slatMeta.key
      }, vdom_createElement(TimeColsAxisCell, _assign({}, slatMeta)));
    });
  };

  return TimeBodyAxis;
}(BaseComponent);

var main_DEFAULT_WEEK_NUM_FORMAT = createFormatter({
  week: 'short'
});
var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;

var TimeColsView =
/** @class */
function (_super) {
  __extends(TimeColsView, _super);

  function TimeColsView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses

    _this.headerElRef = createRef();
    _this.rootElRef = createRef();
    _this.scrollerElRef = createRef();
    _this.state = {
      slatCoords: null
    };

    _this.handleScrollTopRequest = function (scrollTop) {
      var scrollerEl = _this.scrollerElRef.current;

      if (scrollerEl) {
        // TODO: not sure how this could ever be null. weirdness with the reducer
        scrollerEl.scrollTop = scrollTop;
      }
    };
    /* Header Render Methods
    ------------------------------------------------------------------------------------------------------------------*/


    _this.renderHeadAxis = function (rowKey, frameHeight) {
      if (frameHeight === void 0) {
        frameHeight = '';
      }

      var options = _this.context.options;
      var dateProfile = _this.props.dateProfile;
      var range = dateProfile.renderRange;
      var dayCnt = diffDays(range.start, range.end);
      var navLinkAttrs = dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)
      ? buildNavLinkAttrs(_this.context, range.start, 'week') : {};

      if (options.weekNumbers && rowKey === 'day') {
        return vdom_createElement(WeekNumberRoot, {
          date: range.start,
          defaultFormat: main_DEFAULT_WEEK_NUM_FORMAT
        }, function (rootElRef, classNames, innerElRef, innerContent) {
          return vdom_createElement("th", {
            ref: rootElRef,
            "aria-hidden": true,
            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')
          }, vdom_createElement("div", {
            className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid",
            style: {
              height: frameHeight
            }
          }, vdom_createElement("a", _assign({
            ref: innerElRef,
            className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner"
          }, navLinkAttrs), innerContent)));
        });
      }

      return vdom_createElement("th", {
        "aria-hidden": true,
        className: "fc-timegrid-axis"
      }, vdom_createElement("div", {
        className: "fc-timegrid-axis-frame",
        style: {
          height: frameHeight
        }
      }));
    };
    /* Table Component Render Methods
    ------------------------------------------------------------------------------------------------------------------*/
    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,
    // but DayGrid still needs to have classNames on inner elements in order to measure.


    _this.renderTableRowAxis = function (rowHeight) {
      var _a = _this.context,
          options = _a.options,
          viewApi = _a.viewApi;
      var hookProps = {
        text: options.allDayText,
        view: viewApi
      };
      return (// TODO: make reusable hook. used in list view too
        vdom_createElement(RenderHook, {
          hookProps: hookProps,
          classNames: options.allDayClassNames,
          content: options.allDayContent,
          defaultContent: renderAllDayInner,
          didMount: options.allDayDidMount,
          willUnmount: options.allDayWillUnmount
        }, function (rootElRef, classNames, innerElRef, innerContent) {
          return vdom_createElement("td", {
            ref: rootElRef,
            "aria-hidden": true,
            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')
          }, vdom_createElement("div", {
            className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),
            style: {
              height: rowHeight
            }
          }, vdom_createElement("span", {
            className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner",
            ref: innerElRef
          }, innerContent)));
        })
      );
    };

    _this.handleSlatCoords = function (slatCoords) {
      _this.setState({
        slatCoords: slatCoords
      });
    };

    return _this;
  } // rendering
  // ----------------------------------------------------------------------------------------------------


  TimeColsView.prototype.renderSimpleLayout = function (headerRowContent, allDayContent, timeContent) {
    var _a = this,
        context = _a.context,
        props = _a.props;

    var sections = [];
    var stickyHeaderDates = getStickyHeaderDates(context.options);

    if (headerRowContent) {
      sections.push({
        type: 'header',
        key: 'header',
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: 'fc-col-header',
          rowContent: headerRowContent
        }
      });
    }

    if (allDayContent) {
      sections.push({
        type: 'body',
        key: 'all-day',
        chunk: {
          content: allDayContent
        }
      });
      sections.push({
        type: 'body',
        key: 'all-day-divider',
        outerContent: // TODO: rename to cellContent so don't need to define <tr>?
        vdom_createElement("tr", {
          role: "presentation",
          className: "fc-scrollgrid-section"
        }, vdom_createElement("td", {
          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')
        }))
      });
    }

    sections.push({
      type: 'body',
      key: 'body',
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunk: {
        scrollerElRef: this.scrollerElRef,
        content: timeContent
      }
    });
    return vdom_createElement(ViewRoot, {
      viewSpec: context.viewSpec,
      elRef: this.rootElRef
    }, function (rootElRef, classNames) {
      return vdom_createElement("div", {
        className: ['fc-timegrid'].concat(classNames).join(' '),
        ref: rootElRef
      }, vdom_createElement(SimpleScrollGrid, {
        liquid: !props.isHeightAuto && !props.forPrint,
        collapsibleWidth: props.forPrint,
        cols: [{
          width: 'shrink'
        }],
        sections: sections
      }));
    });
  };

  TimeColsView.prototype.renderHScrollLayout = function (headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
    var _this = this;

    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;

    if (!ScrollGrid) {
      throw new Error('No ScrollGrid implementation');
    }

    var _a = this,
        context = _a.context,
        props = _a.props;

    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    var sections = [];

    if (headerRowContent) {
      sections.push({
        type: 'header',
        key: 'header',
        isSticky: stickyHeaderDates,
        syncRowHeights: true,
        chunks: [{
          key: 'axis',
          rowContent: function rowContent(arg) {
            return vdom_createElement("tr", {
              role: "presentation"
            }, _this.renderHeadAxis('day', arg.rowSyncHeights[0]));
          }
        }, {
          key: 'cols',
          elRef: this.headerElRef,
          tableClassName: 'fc-col-header',
          rowContent: headerRowContent
        }]
      });
    }

    if (allDayContent) {
      sections.push({
        type: 'body',
        key: 'all-day',
        syncRowHeights: true,
        chunks: [{
          key: 'axis',
          rowContent: function rowContent(contentArg) {
            return vdom_createElement("tr", {
              role: "presentation"
            }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));
          }
        }, {
          key: 'cols',
          content: allDayContent
        }]
      });
      sections.push({
        key: 'all-day-divider',
        type: 'body',
        outerContent: // TODO: rename to cellContent so don't need to define <tr>?
        vdom_createElement("tr", {
          role: "presentation",
          className: "fc-scrollgrid-section"
        }, vdom_createElement("td", {
          colSpan: 2,
          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')
        }))
      });
    }

    var isNowIndicator = context.options.nowIndicator;
    sections.push({
      type: 'body',
      key: 'body',
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunks: [{
        key: 'axis',
        content: function content(arg) {
          return (// TODO: make this now-indicator arrow more DRY with TimeColsContent
            vdom_createElement("div", {
              className: "fc-timegrid-axis-chunk"
            }, vdom_createElement("table", {
              "aria-hidden": true,
              style: {
                height: arg.expandRows ? arg.clientHeight : ''
              }
            }, arg.tableColGroupNode, vdom_createElement("tbody", null, vdom_createElement(TimeBodyAxis, {
              slatMetas: slatMetas
            }))), vdom_createElement("div", {
              className: "fc-timegrid-now-indicator-container"
            }, vdom_createElement(NowTimer, {
              unit: isNowIndicator ? 'minute' : 'day'
              /* hacky */

            }, function (nowDate) {
              var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void

              if (typeof nowIndicatorTop === 'number') {
                return vdom_createElement(NowIndicatorRoot, {
                  isAxis: true,
                  date: nowDate
                }, function (rootElRef, classNames, innerElRef, innerContent) {
                  return vdom_createElement("div", {
                    ref: rootElRef,
                    className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),
                    style: {
                      top: nowIndicatorTop
                    }
                  }, innerContent);
                });
              }

              return null;
            })))
          );
        }
      }, {
        key: 'cols',
        scrollerElRef: this.scrollerElRef,
        content: timeContent
      }]
    });

    if (stickyFooterScrollbar) {
      sections.push({
        key: 'footer',
        type: 'footer',
        isSticky: true,
        chunks: [{
          key: 'axis',
          content: renderScrollShim
        }, {
          key: 'cols',
          content: renderScrollShim
        }]
      });
    }

    return vdom_createElement(ViewRoot, {
      viewSpec: context.viewSpec,
      elRef: this.rootElRef
    }, function (rootElRef, classNames) {
      return vdom_createElement("div", {
        className: ['fc-timegrid'].concat(classNames).join(' '),
        ref: rootElRef
      }, vdom_createElement(ScrollGrid, {
        liquid: !props.isHeightAuto && !props.forPrint,
        collapsibleWidth: false,
        colGroups: [{
          width: 'shrink',
          cols: [{
            width: 'shrink'
          }]
        }, {
          cols: [{
            span: colCnt,
            minWidth: dayMinWidth
          }]
        }],
        sections: sections
      }));
    });
  };
  /* Dimensions
  ------------------------------------------------------------------------------------------------------------------*/


  TimeColsView.prototype.getAllDayMaxEventProps = function () {
    var _a = this.context.options,
        dayMaxEvents = _a.dayMaxEvents,
        dayMaxEventRows = _a.dayMaxEventRows;

    if (dayMaxEvents === true || dayMaxEventRows === true) {
      // is auto?
      dayMaxEvents = undefined;
      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure "auto" goes to a real number
    }

    return {
      dayMaxEvents: dayMaxEvents,
      dayMaxEventRows: dayMaxEventRows
    };
  };

  return TimeColsView;
}(DateComponent);

function renderAllDayInner(hookProps) {
  return hookProps.text;
}

var TimeColsSlatsCoords =
/** @class */
function () {
  function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {
    this.positions = positions;
    this.dateProfile = dateProfile;
    this.slotDuration = slotDuration;
  }

  TimeColsSlatsCoords.prototype.safeComputeTop = function (date) {
    var dateProfile = this.dateProfile;

    if (rangeContainsMarker(dateProfile.currentRange, date)) {
      var startOfDayDate = startOfDay(date);
      var timeMs = date.valueOf() - startOfDayDate.valueOf();

      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {
        return this.computeTimeTop(createDuration(timeMs));
      }
    }

    return null;
  }; // Computes the top coordinate, relative to the bounds of the grid, of the given date.
  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.


  TimeColsSlatsCoords.prototype.computeDateTop = function (when, startOfDayDate) {
    if (!startOfDayDate) {
      startOfDayDate = startOfDay(when);
    }

    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
  }; // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
  // Eventually allow computation with arbirary slat dates.


  TimeColsSlatsCoords.prototype.computeTimeTop = function (duration) {
    var _a = this,
        positions = _a.positions,
        dateProfile = _a.dateProfile;

    var len = positions.els.length; // floating-point value of # of slots covered

    var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
    var slatIndex;
    var slatRemainder; // compute a floating-point number for how many slats should be progressed through.
    // from 0 to number of slats (inclusive)
    // constrained because slotMinTime/slotMaxTime might be customized.

    slatCoverage = Math.max(0, slatCoverage);
    slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat
    // from 0 to number slats (*exclusive*, so len-1)

    slatIndex = Math.floor(slatCoverage);
    slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
    // could be 1.0 if slatCoverage is covering *all* the slots

    slatRemainder = slatCoverage - slatIndex;
    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
  };

  return TimeColsSlatsCoords;
}();

var TimeColsSlatsBody =
/** @class */
function (_super) {
  __extends(TimeColsSlatsBody, _super);

  function TimeColsSlatsBody() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimeColsSlatsBody.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options;
    var slatElRefs = props.slatElRefs;
    return vdom_createElement("tbody", null, props.slatMetas.map(function (slatMeta, i) {
      var hookProps = {
        time: slatMeta.time,
        date: context.dateEnv.toDate(slatMeta.date),
        view: context.viewApi
      };
      var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'];
      return vdom_createElement("tr", {
        key: slatMeta.key,
        ref: slatElRefs.createRef(slatMeta.key)
      }, props.axis && vdom_createElement(TimeColsAxisCell, _assign({}, slatMeta)), vdom_createElement(RenderHook, {
        hookProps: hookProps,
        classNames: options.slotLaneClassNames,
        content: options.slotLaneContent,
        didMount: options.slotLaneDidMount,
        willUnmount: options.slotLaneWillUnmount
      }, function (rootElRef, customClassNames, innerElRef, innerContent) {
        return vdom_createElement("td", {
          ref: rootElRef,
          className: classNames.concat(customClassNames).join(' '),
          "data-time": slatMeta.isoTimeStr
        }, innerContent);
      }));
    }));
  };

  return TimeColsSlatsBody;
}(BaseComponent);
/*
for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
*/


var TimeColsSlats =
/** @class */
function (_super) {
  __extends(TimeColsSlats, _super);

  function TimeColsSlats() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();
    _this.slatElRefs = new RefMap();
    return _this;
  }

  TimeColsSlats.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    return vdom_createElement("div", {
      ref: this.rootElRef,
      className: "fc-timegrid-slots"
    }, vdom_createElement("table", {
      "aria-hidden": true,
      className: context.theme.getClass('table'),
      style: {
        minWidth: props.tableMinWidth,
        width: props.clientWidth,
        height: props.minHeight
      }
    }, props.tableColGroupNode
    /* relies on there only being a single <col> for the axis */
    , vdom_createElement(TimeColsSlatsBody, {
      slatElRefs: this.slatElRefs,
      axis: props.axis,
      slatMetas: props.slatMetas
    })));
  };

  TimeColsSlats.prototype.componentDidMount = function () {
    this.updateSizing();
  };

  TimeColsSlats.prototype.componentDidUpdate = function () {
    this.updateSizing();
  };

  TimeColsSlats.prototype.componentWillUnmount = function () {
    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  };

  TimeColsSlats.prototype.updateSizing = function () {
    var _a = this,
        context = _a.context,
        props = _a.props;

    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized
    ) {
      var rootEl = this.rootElRef.current;

      if (rootEl.offsetHeight) {
        // not hidden by css
        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
      }
    }
  };

  return TimeColsSlats;
}(BaseComponent);

function collectSlatEls(elMap, slatMetas) {
  return slatMetas.map(function (slatMeta) {
    return elMap[slatMeta.key];
  });
}

function splitSegsByCol(segs, colCnt) {
  var segsByCol = [];
  var i;

  for (i = 0; i < colCnt; i += 1) {
    segsByCol.push([]);
  }

  if (segs) {
    for (i = 0; i < segs.length; i += 1) {
      segsByCol[segs[i].col].push(segs[i]);
    }
  }

  return segsByCol;
}

function splitInteractionByCol(ui, colCnt) {
  var byRow = [];

  if (!ui) {
    for (var i = 0; i < colCnt; i += 1) {
      byRow[i] = null;
    }
  } else {
    for (var i = 0; i < colCnt; i += 1) {
      byRow[i] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }

    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {
      var seg = _a[_i];
      byRow[seg.col].segs.push(seg);
    }
  }

  return byRow;
}

var TimeColMoreLink =
/** @class */
function (_super) {
  __extends(TimeColMoreLink, _super);

  function TimeColMoreLink() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();
    return _this;
  }

  TimeColMoreLink.prototype.render = function () {
    var _this = this;

    var props = this.props;
    return vdom_createElement(MoreLinkRoot, {
      allDayDate: null,
      moreCnt: props.hiddenSegs.length,
      allSegs: props.hiddenSegs,
      hiddenSegs: props.hiddenSegs,
      alignmentElRef: this.rootElRef,
      defaultContent: main_renderMoreLinkInner,
      extraDateSpan: props.extraDateSpan,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      popoverContent: function popoverContent() {
        return renderPlainFgSegs(props.hiddenSegs, props);
      }
    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {
      return vdom_createElement("a", {
        ref: function ref(el) {
          setRef(rootElRef, el);
          setRef(_this.rootElRef, el);
        },
        className: ['fc-timegrid-more-link'].concat(classNames).join(' '),
        style: {
          top: props.top,
          bottom: props.bottom
        },
        onClick: handleClick,
        title: title,
        "aria-expanded": isExpanded,
        "aria-controls": popoverId
      }, vdom_createElement("div", {
        ref: innerElRef,
        className: "fc-timegrid-more-link-inner fc-sticky"
      }, innerContent));
    });
  };

  return TimeColMoreLink;
}(BaseComponent);

function main_renderMoreLinkInner(props) {
  return props.shortText;
} // segInputs assumed sorted


function buildPositioning(segInputs, strictOrder, maxStackCnt) {
  var hierarchy = new SegHierarchy();

  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }

  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }

  var hiddenEntries = hierarchy.addSegs(segInputs);
  var hiddenGroups = groupIntersectingEntries(hiddenEntries);
  var web = buildWeb(hierarchy);
  web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0

  var segRects = webToRects(web);
  return {
    segRects: segRects,
    hiddenGroups: hiddenGroups
  };
}

function buildWeb(hierarchy) {
  var entriesByLevel = hierarchy.entriesByLevel;
  var buildNode = cacheable(function (level, lateral) {
    return level + ':' + lateral;
  }, function (level, lateral) {
    var siblingRange = findNextLevelSegs(hierarchy, level, lateral);
    var nextLevelRes = buildNodes(siblingRange, buildNode);
    var entry = entriesByLevel[level][lateral];
    return [_assign(_assign({}, entry), {
      nextLevelNodes: nextLevelRes[0]
    }), entry.thickness + nextLevelRes[1] // the pressure builds
    ];
  });
  return buildNodes(entriesByLevel.length ? {
    level: 0,
    lateralStart: 0,
    lateralEnd: entriesByLevel[0].length
  } : null, buildNode)[0];
}

function buildNodes(siblingRange, buildNode) {
  if (!siblingRange) {
    return [[], 0];
  }

  var level = siblingRange.level,
      lateralStart = siblingRange.lateralStart,
      lateralEnd = siblingRange.lateralEnd;
  var lateral = lateralStart;
  var pairs = [];

  while (lateral < lateralEnd) {
    pairs.push(buildNode(level, lateral));
    lateral += 1;
  }

  pairs.sort(cmpDescPressures);
  return [pairs.map(extractNode), pairs[0][1] // first item's pressure
  ];
}

function cmpDescPressures(a, b) {
  return b[1] - a[1];
}

function extractNode(a) {
  return a[0];
}

function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
  var levelCoords = hierarchy.levelCoords,
      entriesByLevel = hierarchy.entriesByLevel;
  var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
  var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
  var levelCnt = levelCoords.length;
  var level = subjectLevel; // skip past levels that are too high up

  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1) {
    ;
  } // do nothing


  for (; level < levelCnt; level += 1) {
    var entries = entriesByLevel[level];
    var entry = void 0;
    var searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
    var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one

    var lateralEnd = lateralStart;

    while ( // loop through entries that horizontally intersect
    (entry = entries[lateralEnd]) && // but not past the whole seg list
    entry.span.start < subjectEntry.span.end) {
      lateralEnd += 1;
    }

    if (lateralStart < lateralEnd) {
      return {
        level: level,
        lateralStart: lateralStart,
        lateralEnd: lateralEnd
      };
    }
  }

  return null;
}

function stretchWeb(topLevelNodes, totalThickness) {
  var stretchNode = cacheable(function (node, startCoord, prevThickness) {
    return buildEntryKey(node);
  }, function (node, startCoord, prevThickness) {
    var nextLevelNodes = node.nextLevelNodes,
        thickness = node.thickness;
    var allThickness = thickness + prevThickness;
    var thicknessFraction = thickness / allThickness;
    var endCoord;
    var newChildren = [];

    if (!nextLevelNodes.length) {
      endCoord = totalThickness;
    } else {
      for (var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++) {
        var childNode = nextLevelNodes_1[_i];

        if (endCoord === undefined) {
          var res = stretchNode(childNode, startCoord, allThickness);
          endCoord = res[0];
          newChildren.push(res[1]);
        } else {
          var res = stretchNode(childNode, endCoord, 0);
          newChildren.push(res[1]);
        }
      }
    }

    var newThickness = (endCoord - startCoord) * thicknessFraction;
    return [endCoord - newThickness, _assign(_assign({}, node), {
      thickness: newThickness,
      nextLevelNodes: newChildren
    })];
  });
  return topLevelNodes.map(function (node) {
    return stretchNode(node, 0, 0)[1];
  });
} // not sorted in any particular order


function webToRects(topLevelNodes) {
  var rects = [];
  var processNode = cacheable(function (node, levelCoord, stackDepth) {
    return buildEntryKey(node);
  }, function (node, levelCoord, stackDepth) {
    var rect = _assign(_assign({}, node), {
      levelCoord: levelCoord,
      stackDepth: stackDepth,
      stackForward: 0
    });

    rects.push(rect);
    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
  });

  function processNodes(nodes, levelCoord, stackDepth) {
    var stackForward = 0;

    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
      var node = nodes_1[_i];
      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
    }

    return stackForward;
  }

  processNodes(topLevelNodes, 0, 0);
  return rects; // TODO: sort rects by levelCoord to be consistent with toRects?
} // TODO: move to general util


function cacheable(keyFunc, workFunc) {
  var cache = {};
  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var key = keyFunc.apply(void 0, args);
    return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);
  };
}

function computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {
  if (slatCoords === void 0) {
    slatCoords = null;
  }

  if (eventMinHeight === void 0) {
    eventMinHeight = 0;
  }

  var vcoords = [];

  if (slatCoords) {
    for (var i = 0; i < segs.length; i += 1) {
      var seg = segs[i];
      var spanStart = slatCoords.computeDateTop(seg.start, colDate);
      var spanEnd = Math.max(spanStart + (eventMinHeight || 0), // :(
      slatCoords.computeDateTop(seg.end, colDate));
      vcoords.push({
        start: Math.round(spanStart),
        end: Math.round(spanEnd) //

      });
    }
  }

  return vcoords;
}

function computeFgSegPlacements(segs, segVCoords, // might not have for every seg
eventOrderStrict, eventMaxStack) {
  var segInputs = [];
  var dumbSegs = []; // segs without coords

  for (var i = 0; i < segs.length; i += 1) {
    var vcoords = segVCoords[i];

    if (vcoords) {
      segInputs.push({
        index: i,
        thickness: 1,
        span: vcoords
      });
    } else {
      dumbSegs.push(segs[i]);
    }
  }

  var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack),
      segRects = _a.segRects,
      hiddenGroups = _a.hiddenGroups;

  var segPlacements = [];

  for (var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++) {
    var segRect = segRects_1[_i];
    segPlacements.push({
      seg: segs[segRect.index],
      rect: segRect
    });
  }

  for (var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++) {
    var dumbSeg = dumbSegs_1[_b];
    segPlacements.push({
      seg: dumbSeg,
      rect: null
    });
  }

  return {
    segPlacements: segPlacements,
    hiddenGroups: hiddenGroups
  };
}

var DEFAULT_TIME_FORMAT = createFormatter({
  hour: 'numeric',
  minute: '2-digit',
  meridiem: false
});

var TimeColEvent =
/** @class */
function (_super) {
  __extends(TimeColEvent, _super);

  function TimeColEvent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimeColEvent.prototype.render = function () {
    var classNames = ['fc-timegrid-event', 'fc-v-event'];

    if (this.props.isShort) {
      classNames.push('fc-timegrid-event-short');
    }

    return vdom_createElement(StandardEvent, _assign({}, this.props, {
      defaultTimeFormat: DEFAULT_TIME_FORMAT,
      extraClassNames: classNames
    }));
  };

  return TimeColEvent;
}(BaseComponent);

var TimeColMisc =
/** @class */
function (_super) {
  __extends(TimeColMisc, _super);

  function TimeColMisc() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimeColMisc.prototype.render = function () {
    var props = this.props;
    return vdom_createElement(DayCellContent, {
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      extraHookProps: props.extraHookProps
    }, function (innerElRef, innerContent) {
      return innerContent && vdom_createElement("div", {
        className: "fc-timegrid-col-misc",
        ref: innerElRef
      }, innerContent);
    });
  };

  return TimeColMisc;
}(BaseComponent);

var TimeCol =
/** @class */
function (_super) {
  __extends(TimeCol, _super);

  function TimeCol() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.sortEventSegs = memoize(sortEventSegs);
    return _this;
  } // TODO: memoize event-placement?


  TimeCol.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var isSelectMirror = context.options.selectMirror;
    var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];
    var interactionAffectedInstances = // TODO: messy way to compute this
    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};
    var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);
    return vdom_createElement(DayCellRoot, {
      elRef: props.elRef,
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      extraHookProps: props.extraHookProps
    }, function (rootElRef, classNames, dataAttrs) {
      return vdom_createElement("td", _assign({
        ref: rootElRef,
        role: "gridcell",
        className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')
      }, dataAttrs, props.extraDataAttrs), vdom_createElement("div", {
        className: "fc-timegrid-col-frame"
      }, vdom_createElement("div", {
        className: "fc-timegrid-col-bg"
      }, _this.renderFillSegs(props.businessHourSegs, 'non-business'), _this.renderFillSegs(props.bgEventSegs, 'bg-event'), _this.renderFillSegs(props.dateSelectionSegs, 'highlight')), vdom_createElement("div", {
        className: "fc-timegrid-col-events"
      }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), vdom_createElement("div", {
        className: "fc-timegrid-col-events"
      }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), vdom_createElement("div", {
        className: "fc-timegrid-now-indicator-container"
      }, _this.renderNowIndicator(props.nowIndicatorSegs)), vdom_createElement(TimeColMisc, {
        date: props.date,
        dateProfile: props.dateProfile,
        todayRange: props.todayRange,
        extraHookProps: props.extraHookProps
      })));
    });
  };

  TimeCol.prototype.renderFgSegs = function (sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {
    var props = this.props;

    if (props.forPrint) {
      return renderPlainFgSegs(sortedFgSegs, props);
    }

    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);
  };

  TimeCol.prototype.renderPositionedFgSegs = function (segs, // if not mirror, needs to be sorted
  segIsInvisible, isDragging, isResizing, isDateSelecting) {
    var _this = this;

    var _a = this.context.options,
        eventMaxStack = _a.eventMaxStack,
        eventShortHeight = _a.eventShortHeight,
        eventOrderStrict = _a.eventOrderStrict,
        eventMinHeight = _a.eventMinHeight;
    var _b = this.props,
        date = _b.date,
        slatCoords = _b.slatCoords,
        eventSelection = _b.eventSelection,
        todayRange = _b.todayRange,
        nowDate = _b.nowDate;
    var isMirror = isDragging || isResizing || isDateSelecting;
    var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);

    var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack),
        segPlacements = _c.segPlacements,
        hiddenGroups = _c.hiddenGroups;

    return vdom_createElement(vdom_Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function (segPlacement) {
      var seg = segPlacement.seg,
          rect = segPlacement.rect;
      var instanceId = seg.eventRange.instance.instanceId;
      var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
      var vStyle = computeSegVStyle(rect && rect.span);
      var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : {
        left: 0,
        right: 0
      };
      var isInset = Boolean(rect) && rect.stackForward > 0;
      var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem

      return vdom_createElement("div", {
        className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),
        key: instanceId,
        style: _assign(_assign({
          visibility: isVisible ? '' : 'hidden'
        }, vStyle), hStyle)
      }, vdom_createElement(TimeColEvent, _assign({
        seg: seg,
        isDragging: isDragging,
        isResizing: isResizing,
        isDateSelecting: isDateSelecting,
        isSelected: instanceId === eventSelection,
        isShort: isShort
      }, getSegMeta(seg, todayRange, nowDate))));
    }));
  }; // will already have eventMinHeight applied because segInputs already had it


  TimeCol.prototype.renderHiddenGroups = function (hiddenGroups, segs) {
    var _a = this.props,
        extraDateSpan = _a.extraDateSpan,
        dateProfile = _a.dateProfile,
        todayRange = _a.todayRange,
        nowDate = _a.nowDate,
        eventSelection = _a.eventSelection,
        eventDrag = _a.eventDrag,
        eventResize = _a.eventResize;
    return vdom_createElement(vdom_Fragment, null, hiddenGroups.map(function (hiddenGroup) {
      var positionCss = computeSegVStyle(hiddenGroup.span);
      var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
      return vdom_createElement(TimeColMoreLink, {
        key: buildIsoString(computeEarliestSegStart(hiddenSegs)),
        hiddenSegs: hiddenSegs,
        top: positionCss.top,
        bottom: positionCss.bottom,
        extraDateSpan: extraDateSpan,
        dateProfile: dateProfile,
        todayRange: todayRange,
        nowDate: nowDate,
        eventSelection: eventSelection,
        eventDrag: eventDrag,
        eventResize: eventResize
      });
    }));
  };

  TimeCol.prototype.renderFillSegs = function (segs, fillType) {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated

    var children = segVCoords.map(function (vcoords, i) {
      var seg = segs[i];
      return vdom_createElement("div", {
        key: buildEventRangeKey(seg.eventRange),
        className: "fc-timegrid-bg-harness",
        style: computeSegVStyle(vcoords)
      }, fillType === 'bg-event' ? vdom_createElement(BgEvent, _assign({
        seg: seg
      }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));
    });
    return vdom_createElement(vdom_Fragment, null, children);
  };

  TimeCol.prototype.renderNowIndicator = function (segs) {
    var _a = this.props,
        slatCoords = _a.slatCoords,
        date = _a.date;

    if (!slatCoords) {
      return null;
    }

    return segs.map(function (seg, i) {
      return vdom_createElement(NowIndicatorRoot, {
        isAxis: false,
        date: date,
        // key doesn't matter. will only ever be one
        key: i
      }, function (rootElRef, classNames, innerElRef, innerContent) {
        return vdom_createElement("div", {
          ref: rootElRef,
          className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '),
          style: {
            top: slatCoords.computeDateTop(seg.start, date)
          }
        }, innerContent);
      });
    });
  };

  TimeCol.prototype.computeSegHStyle = function (segHCoords) {
    var _a = this.context,
        isRtl = _a.isRtl,
        options = _a.options;
    var shouldOverlap = options.slotEventOverlap;
    var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point

    var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point

    var left; // amount of space from left edge, a fraction of the total width

    var right; // amount of space from right edge, a fraction of the total width

    if (shouldOverlap) {
      // double the width, but don't go beyond the maximum forward coordinate (1.0)
      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
    }

    if (isRtl) {
      left = 1 - farCoord;
      right = nearCoord;
    } else {
      left = nearCoord;
      right = 1 - farCoord;
    }

    var props = {
      zIndex: segHCoords.stackDepth + 1,
      left: left * 100 + '%',
      right: right * 100 + '%'
    };

    if (shouldOverlap && !segHCoords.stackForward) {
      // add padding to the edge so that forward stacked events don't cover the resizer's icon
      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
    }

    return props;
  };

  return TimeCol;
}(BaseComponent);

function renderPlainFgSegs(sortedFgSegs, _a) {
  var todayRange = _a.todayRange,
      nowDate = _a.nowDate,
      eventSelection = _a.eventSelection,
      eventDrag = _a.eventDrag,
      eventResize = _a.eventResize;
  var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
  return vdom_createElement(vdom_Fragment, null, sortedFgSegs.map(function (seg) {
    var instanceId = seg.eventRange.instance.instanceId;
    return vdom_createElement("div", {
      key: instanceId,
      style: {
        visibility: hiddenInstances[instanceId] ? 'hidden' : ''
      }
    }, vdom_createElement(TimeColEvent, _assign({
      seg: seg,
      isDragging: false,
      isResizing: false,
      isDateSelecting: false,
      isSelected: instanceId === eventSelection,
      isShort: false
    }, getSegMeta(seg, todayRange, nowDate))));
  }));
}

function computeSegVStyle(segVCoords) {
  if (!segVCoords) {
    return {
      top: '',
      bottom: ''
    };
  }

  return {
    top: segVCoords.start,
    bottom: -segVCoords.end
  };
}

function compileSegsFromEntries(segEntries, allSegs) {
  return segEntries.map(function (segEntry) {
    return allSegs[segEntry.index];
  });
}

var TimeColsContent =
/** @class */
function (_super) {
  __extends(TimeColsContent, _super);

  function TimeColsContent() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.splitFgEventSegs = memoize(splitSegsByCol);
    _this.splitBgEventSegs = memoize(splitSegsByCol);
    _this.splitBusinessHourSegs = memoize(splitSegsByCol);
    _this.splitNowIndicatorSegs = memoize(splitSegsByCol);
    _this.splitDateSelectionSegs = memoize(splitSegsByCol);
    _this.splitEventDrag = memoize(splitInteractionByCol);
    _this.splitEventResize = memoize(splitInteractionByCol);
    _this.rootElRef = createRef();
    _this.cellElRefs = new RefMap();
    return _this;
  }

  TimeColsContent.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void

    var colCnt = props.cells.length;
    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
    var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
    var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
    var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
    return vdom_createElement("div", {
      className: "fc-timegrid-cols",
      ref: this.rootElRef
    }, vdom_createElement("table", {
      role: "presentation",
      style: {
        minWidth: props.tableMinWidth,
        width: props.clientWidth
      }
    }, props.tableColGroupNode, vdom_createElement("tbody", {
      role: "presentation"
    }, vdom_createElement("tr", {
      role: "row"
    }, props.axis && vdom_createElement("td", {
      "aria-hidden": true,
      className: "fc-timegrid-col fc-timegrid-axis"
    }, vdom_createElement("div", {
      className: "fc-timegrid-col-frame"
    }, vdom_createElement("div", {
      className: "fc-timegrid-now-indicator-container"
    }, typeof nowIndicatorTop === 'number' && vdom_createElement(NowIndicatorRoot, {
      isAxis: true,
      date: props.nowDate
    }, function (rootElRef, classNames, innerElRef, innerContent) {
      return vdom_createElement("div", {
        ref: rootElRef,
        className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),
        style: {
          top: nowIndicatorTop
        }
      }, innerContent);
    })))), props.cells.map(function (cell, i) {
      return vdom_createElement(TimeCol, {
        key: cell.key,
        elRef: _this.cellElRefs.createRef(cell.key),
        dateProfile: props.dateProfile,
        date: cell.date,
        nowDate: props.nowDate,
        todayRange: props.todayRange,
        extraHookProps: cell.extraHookProps,
        extraDataAttrs: cell.extraDataAttrs,
        extraClassNames: cell.extraClassNames,
        extraDateSpan: cell.extraDateSpan,
        fgEventSegs: fgEventSegsByRow[i],
        bgEventSegs: bgEventSegsByRow[i],
        businessHourSegs: businessHourSegsByRow[i],
        nowIndicatorSegs: nowIndicatorSegsByRow[i],
        dateSelectionSegs: dateSelectionSegsByRow[i],
        eventDrag: eventDragByRow[i],
        eventResize: eventResizeByRow[i],
        slatCoords: props.slatCoords,
        eventSelection: props.eventSelection,
        forPrint: props.forPrint
      });
    })))));
  };

  TimeColsContent.prototype.componentDidMount = function () {
    this.updateCoords();
  };

  TimeColsContent.prototype.componentDidUpdate = function () {
    this.updateCoords();
  };

  TimeColsContent.prototype.updateCoords = function () {
    var props = this.props;

    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized
    ) {
      props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal
      false));
    }
  };

  return TimeColsContent;
}(BaseComponent);

function collectCellEls(elMap, cells) {
  return cells.map(function (cell) {
    return elMap[cell.key];
  });
}
/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/


var TimeCols =
/** @class */
function (_super) {
  __extends(TimeCols, _super);

  function TimeCols() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.processSlotOptions = memoize(processSlotOptions);
    _this.state = {
      slatCoords: null
    };

    _this.handleRootEl = function (el) {
      if (el) {
        _this.context.registerInteractiveComponent(_this, {
          el: el,
          isHitComboAllowed: _this.props.isHitComboAllowed
        });
      } else {
        _this.context.unregisterInteractiveComponent(_this);
      }
    };

    _this.handleScrollRequest = function (request) {
      var onScrollTopRequest = _this.props.onScrollTopRequest;
      var slatCoords = _this.state.slatCoords;

      if (onScrollTopRequest && slatCoords) {
        if (request.time) {
          var top_1 = slatCoords.computeTimeTop(request.time);
          top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further

          if (top_1) {
            top_1 += 1; // to overcome top border that slots beyond the first have. looks better
          }

          onScrollTopRequest(top_1);
        }

        return true;
      }

      return false;
    };

    _this.handleColCoords = function (colCoords) {
      _this.colCoords = colCoords;
    };

    _this.handleSlatCoords = function (slatCoords) {
      _this.setState({
        slatCoords: slatCoords
      });

      if (_this.props.onSlatCoords) {
        _this.props.onSlatCoords(slatCoords);
      }
    };

    return _this;
  }

  TimeCols.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state;

    return vdom_createElement("div", {
      className: "fc-timegrid-body",
      ref: this.handleRootEl,
      style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      }
    }, vdom_createElement(TimeColsSlats, {
      axis: props.axis,
      dateProfile: props.dateProfile,
      slatMetas: props.slatMetas,
      clientWidth: props.clientWidth,
      minHeight: props.expandRows ? props.clientHeight : '',
      tableMinWidth: props.tableMinWidth,
      tableColGroupNode: props.axis ? props.tableColGroupNode : null
      /* axis depends on the colgroup's shrinking */
      ,
      onCoords: this.handleSlatCoords
    }), vdom_createElement(TimeColsContent, {
      cells: props.cells,
      axis: props.axis,
      dateProfile: props.dateProfile,
      businessHourSegs: props.businessHourSegs,
      bgEventSegs: props.bgEventSegs,
      fgEventSegs: props.fgEventSegs,
      dateSelectionSegs: props.dateSelectionSegs,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      todayRange: props.todayRange,
      nowDate: props.nowDate,
      nowIndicatorSegs: props.nowIndicatorSegs,
      clientWidth: props.clientWidth,
      tableMinWidth: props.tableMinWidth,
      tableColGroupNode: props.tableColGroupNode,
      slatCoords: state.slatCoords,
      onColCoords: this.handleColCoords,
      forPrint: props.forPrint
    }));
  };

  TimeCols.prototype.componentDidMount = function () {
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  };

  TimeCols.prototype.componentDidUpdate = function (prevProps) {
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  };

  TimeCols.prototype.componentWillUnmount = function () {
    this.scrollResponder.detach();
  };

  TimeCols.prototype.queryHit = function (positionLeft, positionTop) {
    var _a = this.context,
        dateEnv = _a.dateEnv,
        options = _a.options;
    var colCoords = this.colCoords;
    var dateProfile = this.props.dateProfile;
    var slatCoords = this.state.slatCoords;

    var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration),
        snapDuration = _b.snapDuration,
        snapsPerSlot = _b.snapsPerSlot;

    var colIndex = colCoords.leftToIndex(positionLeft);
    var slatIndex = slatCoords.positions.topToIndex(positionTop);

    if (colIndex != null && slatIndex != null) {
      var cell = this.props.cells[colIndex];
      var slatTop = slatCoords.positions.tops[slatIndex];
      var slatHeight = slatCoords.positions.getHeight(slatIndex);
      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1

      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat

      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
      var dayDate = this.props.cells[colIndex].date;
      var time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
      var start = dateEnv.add(dayDate, time);
      var end = dateEnv.add(start, snapDuration);
      return {
        dateProfile: dateProfile,
        dateSpan: _assign({
          range: {
            start: start,
            end: end
          },
          allDay: false
        }, cell.extraDateSpan),
        dayEl: colCoords.els[colIndex],
        rect: {
          left: colCoords.lefts[colIndex],
          right: colCoords.rights[colIndex],
          top: slatTop,
          bottom: slatTop + slatHeight
        },
        layer: 0
      };
    }

    return null;
  };

  return TimeCols;
}(DateComponent);

function processSlotOptions(slotDuration, snapDurationOverride) {
  var snapDuration = snapDurationOverride || slotDuration;
  var snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);

  if (snapsPerSlot === null) {
    snapDuration = slotDuration;
    snapsPerSlot = 1; // TODO: say warning?
  }

  return {
    snapDuration: snapDuration,
    snapsPerSlot: snapsPerSlot
  };
}

var DayTimeColsSlicer =
/** @class */
function (_super) {
  __extends(DayTimeColsSlicer, _super);

  function DayTimeColsSlicer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DayTimeColsSlicer.prototype.sliceRange = function (range, dayRanges) {
    var segs = [];

    for (var col = 0; col < dayRanges.length; col += 1) {
      var segRange = intersectRanges(range, dayRanges[col]);

      if (segRange) {
        segs.push({
          start: segRange.start,
          end: segRange.end,
          isStart: segRange.start.valueOf() === range.start.valueOf(),
          isEnd: segRange.end.valueOf() === range.end.valueOf(),
          col: col
        });
      }
    }

    return segs;
  };

  return DayTimeColsSlicer;
}(Slicer);

var DayTimeCols =
/** @class */
function (_super) {
  __extends(DayTimeCols, _super);

  function DayTimeCols() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buildDayRanges = memoize(buildDayRanges);
    _this.slicer = new DayTimeColsSlicer();
    _this.timeColsRef = createRef();
    return _this;
  }

  DayTimeCols.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var dateProfile = props.dateProfile,
        dayTableModel = props.dayTableModel;
    var isNowIndicator = context.options.nowIndicator;
    var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv); // give it the first row of cells
    // TODO: would move this further down hierarchy, but sliceNowDate needs it

    return vdom_createElement(NowTimer, {
      unit: isNowIndicator ? 'minute' : 'day'
    }, function (nowDate, todayRange) {
      return vdom_createElement(TimeCols, _assign({
        ref: _this.timeColsRef
      }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {
        forPrint: props.forPrint,
        axis: props.axis,
        dateProfile: dateProfile,
        slatMetas: props.slatMetas,
        slotDuration: props.slotDuration,
        cells: dayTableModel.cells[0],
        tableColGroupNode: props.tableColGroupNode,
        tableMinWidth: props.tableMinWidth,
        clientWidth: props.clientWidth,
        clientHeight: props.clientHeight,
        expandRows: props.expandRows,
        nowDate: nowDate,
        nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),
        todayRange: todayRange,
        onScrollTopRequest: props.onScrollTopRequest,
        onSlatCoords: props.onSlatCoords
      }));
    });
  };

  return DayTimeCols;
}(DateComponent);

function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
  var ranges = [];

  for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {
    var date = _a[_i];
    ranges.push({
      start: dateEnv.add(date, dateProfile.slotMinTime),
      end: dateEnv.add(date, dateProfile.slotMaxTime)
    });
  }

  return ranges;
} // potential nice values for the slot-duration and interval-duration
// from largest to smallest


var STOCK_SUB_DURATIONS = [{
  hours: 1
}, {
  minutes: 30
}, {
  minutes: 15
}, {
  seconds: 30
}, {
  seconds: 15
}];

function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
  var dayStart = new Date(0);
  var slatTime = slotMinTime;
  var slatIterator = createDuration(0);
  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
  var metas = [];

  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
    var date = dateEnv.add(dayStart, slatTime);
    var isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
    metas.push({
      date: date,
      time: slatTime,
      key: date.toISOString(),
      isoTimeStr: formatIsoTimeString(date),
      isLabeled: isLabeled
    });
    slatTime = addDurations(slatTime, slotDuration);
    slatIterator = addDurations(slatIterator, slotDuration);
  }

  return metas;
} // Computes an automatic value for slotLabelInterval


function computeLabelInterval(slotDuration) {
  var i;
  var labelInterval;
  var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label

  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {
    labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);
    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);

    if (slotsPerLabel !== null && slotsPerLabel > 1) {
      return labelInterval;
    }
  }

  return slotDuration; // fall back
}

var DayTimeColsView =
/** @class */
function (_super) {
  __extends(DayTimeColsView, _super);

  function DayTimeColsView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buildTimeColsModel = memoize(buildTimeColsModel);
    _this.buildSlatMetas = memoize(buildSlatMetas);
    return _this;
  }

  DayTimeColsView.prototype.render = function () {
    var _this = this;

    var _a = this.context,
        options = _a.options,
        dateEnv = _a.dateEnv,
        dateProfileGenerator = _a.dateProfileGenerator;
    var props = this.props;
    var dateProfile = props.dateProfile;
    var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
    var splitProps = this.allDaySplitter.splitProps(props);
    var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
    var dayMinWidth = options.dayMinWidth;
    var hasAttachedAxis = !dayMinWidth;
    var hasDetachedAxis = dayMinWidth;
    var headerContent = options.dayHeaders && vdom_createElement(DayHeader, {
      dates: dayTableModel.headerDates,
      dateProfile: dateProfile,
      datesRepDistinctDays: true,
      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null
    });

    var allDayContent = options.allDaySlot !== false && function (contentArg) {
      return vdom_createElement(DayTable, _assign({}, splitProps.allDay, {
        dateProfile: dateProfile,
        dayTableModel: dayTableModel,
        nextDayThreshold: options.nextDayThreshold,
        tableMinWidth: contentArg.tableMinWidth,
        colGroupNode: contentArg.tableColGroupNode,
        renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,
        showWeekNumbers: false,
        expandRows: false,
        headerAlignElRef: _this.headerElRef,
        clientWidth: contentArg.clientWidth,
        clientHeight: contentArg.clientHeight,
        forPrint: props.forPrint
      }, _this.getAllDayMaxEventProps()));
    };

    var timeGridContent = function timeGridContent(contentArg) {
      return vdom_createElement(DayTimeCols, _assign({}, splitProps.timed, {
        dayTableModel: dayTableModel,
        dateProfile: dateProfile,
        axis: hasAttachedAxis,
        slotDuration: options.slotDuration,
        slatMetas: slatMetas,
        forPrint: props.forPrint,
        tableColGroupNode: contentArg.tableColGroupNode,
        tableMinWidth: contentArg.tableMinWidth,
        clientWidth: contentArg.clientWidth,
        clientHeight: contentArg.clientHeight,
        onSlatCoords: _this.handleSlatCoords,
        expandRows: contentArg.expandRows,
        onScrollTopRequest: _this.handleScrollTopRequest
      }));
    };

    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
  };

  return DayTimeColsView;
}(TimeColsView);

function buildTimeColsModel(dateProfile, dateProfileGenerator) {
  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, false);
}

var main_OPTION_REFINERS = {
  allDaySlot: Boolean
};
var timegrid_main_main = createPlugin({
  initialView: 'timeGridWeek',
  optionRefiners: main_OPTION_REFINERS,
  views: {
    timeGrid: {
      component: DayTimeColsView,
      usesMinMaxTime: true,
      allDaySlot: true,
      slotDuration: '00:30:00',
      slotEventOverlap: true // a bad name. confused with overlap/constraint system

    },
    timeGridDay: {
      type: 'timeGrid',
      duration: {
        days: 1
      }
    },
    timeGridWeek: {
      type: 'timeGrid',
      duration: {
        weeks: 1
      }
    }
  }
});
/* harmony default export */ var _fullcalendar_timegrid_main = (timegrid_main_main);

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/list/main.css
// extracted by mini-css-extract-plugin
/* harmony default export */ var list_main = ({});
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/list/main.js
/*!
FullCalendar v5.11.3
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/




var ListViewHeaderRow =
/** @class */
function (_super) {
  __extends(ListViewHeaderRow, _super);

  function ListViewHeaderRow() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      textId: getUniqueDomId()
    };
    return _this;
  }

  ListViewHeaderRow.prototype.render = function () {
    var _a = this.context,
        theme = _a.theme,
        dateEnv = _a.dateEnv,
        options = _a.options,
        viewApi = _a.viewApi;
    var _b = this.props,
        cellId = _b.cellId,
        dayDate = _b.dayDate,
        todayRange = _b.todayRange;
    var textId = this.state.textId;
    var dayMeta = getDateMeta(dayDate, todayRange); // will ever be falsy?

    var text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : ''; // will ever be falsy? also, BAD NAME "alt"

    var sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';

    var hookProps = _assign({
      date: dateEnv.toDate(dayDate),
      view: viewApi,
      textId: textId,
      text: text,
      sideText: sideText,
      navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),
      sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, 'day', false)
    }, dayMeta);

    var classNames = ['fc-list-day'].concat(getDayClassNames(dayMeta, theme)); // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)

    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.dayHeaderClassNames,
      content: options.dayHeaderContent,
      defaultContent: list_main_renderInnerContent,
      didMount: options.dayHeaderDidMount,
      willUnmount: options.dayHeaderWillUnmount
    }, function (rootElRef, customClassNames, innerElRef, innerContent) {
      return vdom_createElement("tr", {
        ref: rootElRef,
        className: classNames.concat(customClassNames).join(' '),
        "data-date": formatDayString(dayDate)
      }, vdom_createElement("th", {
        scope: "colgroup",
        colSpan: 3,
        id: cellId,
        "aria-labelledby": textId
      }, vdom_createElement("div", {
        className: 'fc-list-day-cushion ' + theme.getClass('tableCellShaded'),
        ref: innerElRef
      }, innerContent)));
    });
  };

  return ListViewHeaderRow;
}(BaseComponent);

function list_main_renderInnerContent(props) {
  return vdom_createElement(vdom_Fragment, null, props.text && vdom_createElement("a", _assign({
    id: props.textId,
    className: "fc-list-day-text"
  }, props.navLinkAttrs), props.text), props.sideText &&
  /* not keyboard tabbable */
  vdom_createElement("a", _assign({
    "aria-hidden": true,
    className: "fc-list-day-side-text"
  }, props.sideNavLinkAttrs), props.sideText));
}

var main_DEFAULT_TIME_FORMAT = createFormatter({
  hour: 'numeric',
  minute: '2-digit',
  meridiem: 'short'
});

var ListViewEventRow =
/** @class */
function (_super) {
  __extends(ListViewEventRow, _super);

  function ListViewEventRow() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ListViewEventRow.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var seg = props.seg,
        timeHeaderId = props.timeHeaderId,
        eventHeaderId = props.eventHeaderId,
        dateHeaderId = props.dateHeaderId;
    var timeFormat = context.options.eventTimeFormat || main_DEFAULT_TIME_FORMAT;
    return vdom_createElement(EventRoot, {
      seg: seg,
      timeText: "" // BAD. because of all-day content
      ,
      disableDragging: true,
      disableResizing: true,
      defaultContent: function defaultContent() {
        return renderEventInnerContent(seg, context);
      }
      /* weird */
      ,
      isPast: props.isPast,
      isFuture: props.isFuture,
      isToday: props.isToday,
      isSelected: props.isSelected,
      isDragging: props.isDragging,
      isResizing: props.isResizing,
      isDateSelecting: props.isDateSelecting
    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {
      return vdom_createElement("tr", {
        className: ['fc-list-event', hookProps.event.url ? 'fc-event-forced-url' : ''].concat(classNames).join(' '),
        ref: rootElRef
      }, buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId), vdom_createElement("td", {
        "aria-hidden": true,
        className: "fc-list-event-graphic"
      }, vdom_createElement("span", {
        className: "fc-list-event-dot",
        style: {
          borderColor: hookProps.borderColor || hookProps.backgroundColor
        }
      })), vdom_createElement("td", {
        ref: innerElRef,
        headers: eventHeaderId + " " + dateHeaderId,
        className: "fc-list-event-title"
      }, innerContent));
    });
  };

  return ListViewEventRow;
}(BaseComponent);

function renderEventInnerContent(seg, context) {
  var interactiveAttrs = getSegAnchorAttrs(seg, context);
  return vdom_createElement("a", _assign({}, interactiveAttrs), seg.eventRange.def.title);
}

function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
  var options = context.options;

  if (options.displayEventTime !== false) {
    var eventDef = seg.eventRange.def;
    var eventInstance = seg.eventRange.instance;
    var doAllDay = false;
    var timeText = void 0;

    if (eventDef.allDay) {
      doAllDay = true;
    } else if (isMultiDayRange(seg.eventRange.range)) {
      // TODO: use (!isStart || !isEnd) instead?
      if (seg.isStart) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
      } else if (seg.isEnd) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
      } else {
        doAllDay = true;
      }
    } else {
      timeText = buildSegTimeText(seg, timeFormat, context);
    }

    if (doAllDay) {
      var hookProps = {
        text: context.options.allDayText,
        view: context.viewApi
      };
      return vdom_createElement(RenderHook, {
        hookProps: hookProps,
        classNames: options.allDayClassNames,
        content: options.allDayContent,
        defaultContent: main_renderAllDayInner,
        didMount: options.allDayDidMount,
        willUnmount: options.allDayWillUnmount
      }, function (rootElRef, classNames, innerElRef, innerContent) {
        return vdom_createElement("td", {
          ref: rootElRef,
          headers: timeHeaderId + " " + dateHeaderId,
          className: ['fc-list-event-time'].concat(classNames).join(' ')
        }, innerContent);
      });
    }

    return vdom_createElement("td", {
      className: "fc-list-event-time"
    }, timeText);
  }

  return null;
}

function main_renderAllDayInner(hookProps) {
  return hookProps.text;
}
/*
Responsible for the scroller, and forwarding event-related actions into the "grid".
*/


var ListView =
/** @class */
function (_super) {
  __extends(ListView, _super);

  function ListView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.computeDateVars = memoize(computeDateVars);
    _this.eventStoreToSegs = memoize(_this._eventStoreToSegs);
    _this.state = {
      timeHeaderId: getUniqueDomId(),
      eventHeaderId: getUniqueDomId(),
      dateHeaderIdRoot: getUniqueDomId()
    };

    _this.setRootEl = function (rootEl) {
      if (rootEl) {
        _this.context.registerInteractiveComponent(_this, {
          el: rootEl
        });
      } else {
        _this.context.unregisterInteractiveComponent(_this);
      }
    };

    return _this;
  }

  ListView.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var extraClassNames = ['fc-list', context.theme.getClass('table'), context.options.stickyHeaderDates !== false ? 'fc-list-sticky' : ''];

    var _b = this.computeDateVars(props.dateProfile),
        dayDates = _b.dayDates,
        dayRanges = _b.dayRanges;

    var eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
    return vdom_createElement(ViewRoot, {
      viewSpec: context.viewSpec,
      elRef: this.setRootEl
    }, function (rootElRef, classNames) {
      return vdom_createElement("div", {
        ref: rootElRef,
        className: extraClassNames.concat(classNames).join(' ')
      }, vdom_createElement(Scroller, {
        liquid: !props.isHeightAuto,
        overflowX: props.isHeightAuto ? 'visible' : 'hidden',
        overflowY: props.isHeightAuto ? 'visible' : 'auto'
      }, eventSegs.length > 0 ? _this.renderSegList(eventSegs, dayDates) : _this.renderEmptyMessage()));
    });
  };

  ListView.prototype.renderEmptyMessage = function () {
    var _a = this.context,
        options = _a.options,
        viewApi = _a.viewApi;
    var hookProps = {
      text: options.noEventsText,
      view: viewApi
    };
    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.noEventsClassNames,
      content: options.noEventsContent,
      defaultContent: renderNoEventsInner,
      didMount: options.noEventsDidMount,
      willUnmount: options.noEventsWillUnmount
    }, function (rootElRef, classNames, innerElRef, innerContent) {
      return vdom_createElement("div", {
        className: ['fc-list-empty'].concat(classNames).join(' '),
        ref: rootElRef
      }, vdom_createElement("div", {
        className: "fc-list-empty-cushion",
        ref: innerElRef
      }, innerContent));
    });
  };

  ListView.prototype.renderSegList = function (allSegs, dayDates) {
    var _a = this.context,
        theme = _a.theme,
        options = _a.options;
    var _b = this.state,
        timeHeaderId = _b.timeHeaderId,
        eventHeaderId = _b.eventHeaderId,
        dateHeaderIdRoot = _b.dateHeaderIdRoot;
    var segsByDay = groupSegsByDay(allSegs); // sparse array

    return vdom_createElement(NowTimer, {
      unit: "day"
    }, function (nowDate, todayRange) {
      var innerNodes = [];

      for (var dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {
        var daySegs = segsByDay[dayIndex];

        if (daySegs) {
          // sparse array, so might be undefined
          var dayStr = formatDayString(dayDates[dayIndex]);
          var dateHeaderId = dateHeaderIdRoot + '-' + dayStr; // append a day header

          innerNodes.push(vdom_createElement(ListViewHeaderRow, {
            key: dayStr,
            cellId: dateHeaderId,
            dayDate: dayDates[dayIndex],
            todayRange: todayRange
          }));
          daySegs = sortEventSegs(daySegs, options.eventOrder);

          for (var _i = 0, daySegs_1 = daySegs; _i < daySegs_1.length; _i++) {
            var seg = daySegs_1[_i];
            innerNodes.push(vdom_createElement(ListViewEventRow, _assign({
              key: dayStr + ':' + seg.eventRange.instance.instanceId
              /* are multiple segs for an instanceId */
              ,
              seg: seg,
              isDragging: false,
              isResizing: false,
              isDateSelecting: false,
              isSelected: false,
              timeHeaderId: timeHeaderId,
              eventHeaderId: eventHeaderId,
              dateHeaderId: dateHeaderId
            }, getSegMeta(seg, todayRange, nowDate))));
          }
        }
      }

      return vdom_createElement("table", {
        className: 'fc-list-table ' + theme.getClass('table')
      }, vdom_createElement("thead", null, vdom_createElement("tr", null, vdom_createElement("th", {
        scope: "col",
        id: timeHeaderId
      }, options.timeHint), vdom_createElement("th", {
        scope: "col",
        "aria-hidden": true
      }), vdom_createElement("th", {
        scope: "col",
        id: eventHeaderId
      }, options.eventHint))), vdom_createElement("tbody", null, innerNodes));
    });
  };

  ListView.prototype._eventStoreToSegs = function (eventStore, eventUiBases, dayRanges) {
    return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
  };

  ListView.prototype.eventRangesToSegs = function (eventRanges, dayRanges) {
    var segs = [];

    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
      var eventRange = eventRanges_1[_i];
      segs.push.apply(segs, this.eventRangeToSegs(eventRange, dayRanges));
    }

    return segs;
  };

  ListView.prototype.eventRangeToSegs = function (eventRange, dayRanges) {
    var dateEnv = this.context.dateEnv;
    var nextDayThreshold = this.context.options.nextDayThreshold;
    var range = eventRange.range;
    var allDay = eventRange.def.allDay;
    var dayIndex;
    var segRange;
    var seg;
    var segs = [];

    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {
      segRange = intersectRanges(range, dayRanges[dayIndex]);

      if (segRange) {
        seg = {
          component: this,
          eventRange: eventRange,
          start: segRange.start,
          end: segRange.end,
          isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),
          isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),
          dayIndex: dayIndex
        };
        segs.push(seg); // detect when range won't go fully into the next day,
        // and mutate the latest seg to the be the end.

        if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
          seg.end = range.end;
          seg.isEnd = true;
          break;
        }
      }
    }

    return segs;
  };

  return ListView;
}(DateComponent);

function renderNoEventsInner(hookProps) {
  return hookProps.text;
}

function computeDateVars(dateProfile) {
  var dayStart = startOfDay(dateProfile.renderRange.start);
  var viewEnd = dateProfile.renderRange.end;
  var dayDates = [];
  var dayRanges = [];

  while (dayStart < viewEnd) {
    dayDates.push(dayStart);
    dayRanges.push({
      start: dayStart,
      end: addDays(dayStart, 1)
    });
    dayStart = addDays(dayStart, 1);
  }

  return {
    dayDates: dayDates,
    dayRanges: dayRanges
  };
} // Returns a sparse array of arrays, segs grouped by their dayIndex


function groupSegsByDay(segs) {
  var segsByDay = []; // sparse array

  var i;
  var seg;

  for (i = 0; i < segs.length; i += 1) {
    seg = segs[i];
    (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
  }

  return segsByDay;
}

var list_main_OPTION_REFINERS = {
  listDayFormat: createFalsableFormatter,
  listDaySideFormat: createFalsableFormatter,
  noEventsClassNames: identity,
  noEventsContent: identity,
  noEventsDidMount: identity,
  noEventsWillUnmount: identity // noEventsText is defined in base options

};

function createFalsableFormatter(input) {
  return input === false ? null : createFormatter(input);
}

var list_main_main = createPlugin({
  optionRefiners: list_main_OPTION_REFINERS,
  views: {
    list: {
      component: ListView,
      buttonTextKey: 'list',
      listDayFormat: {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      } // like "January 1, 2016"

    },
    listDay: {
      type: 'list',
      duration: {
        days: 1
      },
      listDayFormat: {
        weekday: 'long'
      } // day-of-week is all we need. full date is probably in headerToolbar

    },
    listWeek: {
      type: 'list',
      duration: {
        weeks: 1
      },
      listDayFormat: {
        weekday: 'long'
      },
      listDaySideFormat: {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      }
    },
    listMonth: {
      type: 'list',
      duration: {
        month: 1
      },
      listDaySideFormat: {
        weekday: 'long'
      } // day-of-week is nice-to-have

    },
    listYear: {
      type: 'list',
      duration: {
        year: 1
      },
      listDaySideFormat: {
        weekday: 'long'
      } // day-of-week is nice-to-have

    }
  }
});
/* harmony default export */ var _fullcalendar_list_main = (list_main_main);

// EXTERNAL MODULE: ./node_modules/@fullcalendar/core/locales/da.js
var locales_da = __webpack_require__(5561);
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/premium-common/main.js
/*!
FullCalendar Scheduler v5.11.3
Docs & License: https://fullcalendar.io/scheduler
(c) 2022 Adam Shaw
*/

var RELEASE_DATE = '2022-08-23'; // for Scheduler

var UPGRADE_WINDOW = 365 + 7; // days. 1 week leeway, for tz shift reasons too

var INVALID_LICENSE_URL = 'http://fullcalendar.io/docs/schedulerLicenseKey#invalid';
var OUTDATED_LICENSE_URL = 'http://fullcalendar.io/docs/schedulerLicenseKey#outdated';
var PRESET_LICENSE_KEYS = ['GPL-My-Project-Is-Open-Source', 'CC-Attribution-NonCommercial-NoDerivatives'];
var CSS = {
  position: 'absolute',
  zIndex: 99999,
  bottom: '1px',
  left: '1px',
  background: '#eee',
  borderColor: '#ddd',
  borderStyle: 'solid',
  borderWidth: '1px 1px 0 0',
  padding: '2px 4px',
  fontSize: '12px',
  borderTopRightRadius: '3px'
};

function buildLicenseWarning(context) {
  var key = context.options.schedulerLicenseKey;
  var currentUrl = typeof window !== 'undefined' ? window.location.href : '';

  if (!isImmuneUrl(currentUrl)) {
    var status_1 = processLicenseKey(key);

    if (status_1 !== 'valid') {
      return vdom_createElement("div", {
        className: "fc-license-message",
        style: CSS
      }, status_1 === 'outdated' ? vdom_createElement(vdom_Fragment, null, 'Your license key is too old to work with this version. ', vdom_createElement("a", {
        href: OUTDATED_LICENSE_URL
      }, "More Info")) : vdom_createElement(vdom_Fragment, null, 'Your license key is invalid. ', vdom_createElement("a", {
        href: INVALID_LICENSE_URL
      }, "More Info")));
    }
  }

  return null;
}
/*
This decryption is not meant to be bulletproof. Just a way to remind about an upgrade.
*/


function processLicenseKey(key) {
  if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {
    return 'valid';
  }

  var parts = (key || '').match(/^(\d+)-fcs-(\d+)$/);

  if (parts && parts[1].length === 10) {
    var purchaseDate = new Date(parseInt(parts[2], 10) * 1000);
    var releaseDate = new Date(config.mockSchedulerReleaseDate || RELEASE_DATE);

    if (isValidDate(releaseDate)) {
      // token won't be replaced in dev mode
      var minPurchaseDate = addDays(releaseDate, -UPGRADE_WINDOW);

      if (minPurchaseDate < purchaseDate) {
        return 'valid';
      }

      return 'outdated';
    }
  }

  return 'invalid';
}

function isImmuneUrl(url) {
  return /\w+:\/\/fullcalendar\.io\/|\/examples\/[\w-]+\.html$/.test(url);
}

var premium_common_main_OPTION_REFINERS = {
  schedulerLicenseKey: String
};
var premium_common_main_main = createPlugin({
  optionRefiners: premium_common_main_OPTION_REFINERS,
  viewContainerAppends: [buildLicenseWarning]
});
/* harmony default export */ var premium_common_main = (premium_common_main_main);
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/resource-common/main.js
/*!
FullCalendar Scheduler v5.11.3
Docs & License: https://fullcalendar.io/scheduler
(c) 2022 Adam Shaw
*/




function massageEventDragMutation(eventMutation, hit0, hit1) {
  var resource0 = hit0.dateSpan.resourceId;
  var resource1 = hit1.dateSpan.resourceId;

  if (resource0 && resource1 && resource0 !== resource1) {
    eventMutation.resourceMutation = {
      matchResourceId: resource0,
      setResourceId: resource1
    };
  }
}
/*
TODO: all this would be much easier if we were using a hash!
*/


function applyEventDefMutation(eventDef, mutation, context) {
  var resourceMutation = mutation.resourceMutation;

  if (resourceMutation && computeResourceEditable(eventDef, context)) {
    var index = eventDef.resourceIds.indexOf(resourceMutation.matchResourceId);

    if (index !== -1) {
      var resourceIds = eventDef.resourceIds.slice(); // copy

      resourceIds.splice(index, 1); // remove

      if (resourceIds.indexOf(resourceMutation.setResourceId) === -1) {
        // not already in there
        resourceIds.push(resourceMutation.setResourceId); // add
      }

      eventDef.resourceIds = resourceIds;
    }
  }
}
/*
HACK
TODO: use EventUi system instead of this
*/


function computeResourceEditable(eventDef, context) {
  var resourceEditable = eventDef.resourceEditable;

  if (resourceEditable == null) {
    var source = eventDef.sourceId && context.getCurrentData().eventSources[eventDef.sourceId];

    if (source) {
      resourceEditable = source.extendedProps.resourceEditable; // used the Source::extendedProps hack
    }

    if (resourceEditable == null) {
      resourceEditable = context.options.eventResourceEditable;

      if (resourceEditable == null) {
        resourceEditable = context.options.editable; // TODO: use defaults system instead
      }
    }
  }

  return resourceEditable;
}

function transformEventDrop(mutation, context) {
  var resourceMutation = mutation.resourceMutation;

  if (resourceMutation) {
    var calendarApi = context.calendarApi;
    return {
      oldResource: calendarApi.getResourceById(resourceMutation.matchResourceId),
      newResource: calendarApi.getResourceById(resourceMutation.setResourceId)
    };
  }

  return {
    oldResource: null,
    newResource: null
  };
}

var ResourceDataAdder =
/** @class */
function () {
  function ResourceDataAdder() {
    this.filterResources = memoize(filterResources);
  }

  ResourceDataAdder.prototype.transform = function (viewProps, calendarProps) {
    if (calendarProps.viewSpec.optionDefaults.needsResourceData) {
      return {
        resourceStore: this.filterResources(calendarProps.resourceStore, calendarProps.options.filterResourcesWithEvents, calendarProps.eventStore, calendarProps.dateProfile.activeRange),
        resourceEntityExpansions: calendarProps.resourceEntityExpansions
      };
    }

    return null;
  };

  return ResourceDataAdder;
}();

function filterResources(resourceStore, doFilterResourcesWithEvents, eventStore, activeRange) {
  if (doFilterResourcesWithEvents) {
    var instancesInRange = filterEventInstancesInRange(eventStore.instances, activeRange);
    var hasEvents_1 = computeHasEvents(instancesInRange, eventStore.defs);

    _assign(hasEvents_1, computeAncestorHasEvents(hasEvents_1, resourceStore));

    return filterHash(resourceStore, function (resource, resourceId) {
      return hasEvents_1[resourceId];
    });
  }

  return resourceStore;
}

function filterEventInstancesInRange(eventInstances, activeRange) {
  return filterHash(eventInstances, function (eventInstance) {
    return rangesIntersect(eventInstance.range, activeRange);
  });
}

function computeHasEvents(eventInstances, eventDefs) {
  var hasEvents = {};

  for (var instanceId in eventInstances) {
    var instance = eventInstances[instanceId];

    for (var _i = 0, _a = eventDefs[instance.defId].resourceIds; _i < _a.length; _i++) {
      var resourceId = _a[_i];
      hasEvents[resourceId] = true;
    }
  }

  return hasEvents;
}
/*
mark resources as having events if any of their ancestors have them
NOTE: resourceStore might not have all the resources that hasEvents{} has keyed
*/


function computeAncestorHasEvents(hasEvents, resourceStore) {
  var res = {};

  for (var resourceId in hasEvents) {
    var resource = void 0;

    while (resource = resourceStore[resourceId]) {
      resourceId = resource.parentId; // now functioning as the parentId

      if (resourceId) {
        res[resourceId] = true;
      } else {
        break;
      }
    }
  }

  return res;
}
/*
for making sure events that have editable resources are always draggable in resource views
*/


function transformIsDraggable(val, eventDef, eventUi, context) {
  if (!val) {
    var state = context.getCurrentData();
    var viewSpec = state.viewSpecs[state.currentViewType];

    if (viewSpec.optionDefaults.needsResourceData) {
      if (computeResourceEditable(eventDef, context)) {
        return true;
      }
    }
  }

  return val;
} // for when non-resource view should be given EventUi info (for event coloring/constraints based off of resource data)


var ResourceEventConfigAdder =
/** @class */
function () {
  function ResourceEventConfigAdder() {
    this.buildResourceEventUis = memoize(buildResourceEventUis, isPropsEqual);
    this.injectResourceEventUis = memoize(injectResourceEventUis);
  }

  ResourceEventConfigAdder.prototype.transform = function (viewProps, calendarProps) {
    if (!calendarProps.viewSpec.optionDefaults.needsResourceData) {
      return {
        eventUiBases: this.injectResourceEventUis(viewProps.eventUiBases, viewProps.eventStore.defs, this.buildResourceEventUis(calendarProps.resourceStore))
      };
    }

    return null;
  };

  return ResourceEventConfigAdder;
}();

function buildResourceEventUis(resourceStore) {
  return mapHash(resourceStore, function (resource) {
    return resource.ui;
  });
}

function injectResourceEventUis(eventUiBases, eventDefs, resourceEventUis) {
  return mapHash(eventUiBases, function (eventUi, defId) {
    if (defId) {
      // not the '' key
      return injectResourceEventUi(eventUi, eventDefs[defId], resourceEventUis);
    }

    return eventUi;
  });
}

function injectResourceEventUi(origEventUi, eventDef, resourceEventUis) {
  var parts = []; // first resource takes precedence, which fights with the ordering of combineEventUis, thus the unshifts

  for (var _i = 0, _a = eventDef.resourceIds; _i < _a.length; _i++) {
    var resourceId = _a[_i];

    if (resourceEventUis[resourceId]) {
      parts.unshift(resourceEventUis[resourceId]);
    }
  }

  parts.unshift(origEventUi);
  return combineEventUis(parts);
}

var defs = []; // TODO: use plugin system

function registerResourceSourceDef(def) {
  defs.push(def);
}

function getResourceSourceDef(id) {
  return defs[id];
}

function getResourceSourceDefs() {
  return defs;
} // TODO: make this a plugin-able parser
// TODO: success/failure


var RESOURCE_SOURCE_REFINERS = {
  id: String,
  // for array. TODO: move to resource-array
  resources: identity,
  // for json feed. TODO: move to resource-json-feed
  url: String,
  method: String,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  extraParams: identity
};

function parseResourceSource(input) {
  var inputObj;

  if (typeof input === 'string') {
    inputObj = {
      url: input
    };
  } else if (typeof input === 'function' || Array.isArray(input)) {
    inputObj = {
      resources: input
    };
  } else if (typeof input === 'object' && input) {
    // non-null object
    inputObj = input;
  }

  if (inputObj) {
    var _a = refineProps(inputObj, RESOURCE_SOURCE_REFINERS),
        refined = _a.refined,
        extra = _a.extra;

    warnUnknownProps(extra);
    var metaRes = buildResourceSourceMeta(refined);

    if (metaRes) {
      return {
        _raw: input,
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        publicId: refined.id || '',
        isFetching: false,
        latestFetchId: '',
        fetchRange: null
      };
    }
  }

  return null;
}

function buildResourceSourceMeta(refined) {
  var defs = getResourceSourceDefs();

  for (var i = defs.length - 1; i >= 0; i -= 1) {
    // later-added plugins take precedence
    var def = defs[i];
    var meta = def.parseMeta(refined);

    if (meta) {
      return {
        meta: meta,
        sourceDefId: i
      };
    }
  }

  return null;
}

function warnUnknownProps(props) {
  for (var propName in props) {
    console.warn("Unknown resource prop '" + propName + "'");
  }
}

function reduceResourceSource(source, action, context) {
  var options = context.options,
      dateProfile = context.dateProfile;

  if (!source || !action) {
    return createSource(options.initialResources || options.resources, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);
  }

  switch (action.type) {
    case 'RESET_RESOURCE_SOURCE':
      return createSource(action.resourceSourceInput, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);

    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

    case 'NEXT':
    case 'CHANGE_DATE':
    case 'CHANGE_VIEW_TYPE':
      return handleRangeChange(source, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);

    case 'RECEIVE_RESOURCES':
    case 'RECEIVE_RESOURCE_ERROR':
      return main_receiveResponse(source, action.fetchId, action.fetchRange);

    case 'REFETCH_RESOURCES':
      return main_fetchSource(source, dateProfile.activeRange, context);

    default:
      return source;
  }
}

function createSource(input, activeRange, refetchResourcesOnNavigate, context) {
  if (input) {
    var source = parseResourceSource(input);
    source = main_fetchSource(source, refetchResourcesOnNavigate ? activeRange : null, context);
    return source;
  }

  return null;
}

function handleRangeChange(source, activeRange, refetchResourcesOnNavigate, context) {
  if (refetchResourcesOnNavigate && !doesSourceIgnoreRange(source) && (!source.fetchRange || !rangesEqual(source.fetchRange, activeRange))) {
    return main_fetchSource(source, activeRange, context);
  }

  return source;
}

function doesSourceIgnoreRange(source) {
  return Boolean(getResourceSourceDef(source.sourceDefId).ignoreRange);
}

function main_fetchSource(source, fetchRange, context) {
  var sourceDef = getResourceSourceDef(source.sourceDefId);
  var fetchId = guid();
  sourceDef.fetch({
    resourceSource: source,
    range: fetchRange,
    context: context
  }, function (res) {
    context.dispatch({
      type: 'RECEIVE_RESOURCES',
      fetchId: fetchId,
      fetchRange: fetchRange,
      rawResources: res.rawResources
    });
  }, function (error) {
    context.dispatch({
      type: 'RECEIVE_RESOURCE_ERROR',
      fetchId: fetchId,
      fetchRange: fetchRange,
      error: error
    });
  });
  return _assign(_assign({}, source), {
    isFetching: true,
    latestFetchId: fetchId
  });
}

function main_receiveResponse(source, fetchId, fetchRange) {
  if (fetchId === source.latestFetchId) {
    return _assign(_assign({}, source), {
      isFetching: false,
      fetchRange: fetchRange
    });
  }

  return source;
}

var PRIVATE_ID_PREFIX = '_fc:';
var RESOURCE_REFINERS = {
  id: String,
  parentId: String,
  children: identity,
  title: String,
  businessHours: identity,
  extendedProps: identity,
  // event-ui
  eventEditable: Boolean,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventConstraint: identity,
  eventOverlap: Boolean,
  eventAllow: identity,
  eventClassNames: parseClassNames,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String
};
/*
needs a full store so that it can populate children too
*/

function parseResource(raw, parentId, store, context) {
  if (parentId === void 0) {
    parentId = '';
  }

  var _a = refineProps(raw, RESOURCE_REFINERS),
      refined = _a.refined,
      extra = _a.extra;

  var resource = {
    id: refined.id || PRIVATE_ID_PREFIX + guid(),
    parentId: refined.parentId || parentId,
    title: refined.title || '',
    businessHours: refined.businessHours ? parseBusinessHours(refined.businessHours, context) : null,
    ui: createEventUi({
      editable: refined.eventEditable,
      startEditable: refined.eventStartEditable,
      durationEditable: refined.eventDurationEditable,
      constraint: refined.eventConstraint,
      overlap: refined.eventOverlap,
      allow: refined.eventAllow,
      classNames: refined.eventClassNames,
      backgroundColor: refined.eventBackgroundColor,
      borderColor: refined.eventBorderColor,
      textColor: refined.eventTextColor,
      color: refined.eventColor
    }, context),
    extendedProps: _assign(_assign({}, extra), refined.extendedProps)
  }; // help out ResourceApi from having user modify props

  Object.freeze(resource.ui.classNames);
  Object.freeze(resource.extendedProps);
  if (store[resource.id]) ;else {
    store[resource.id] = resource;

    if (refined.children) {
      for (var _i = 0, _b = refined.children; _i < _b.length; _i++) {
        var childInput = _b[_i];
        parseResource(childInput, resource.id, store, context);
      }
    }
  }
  return resource;
}
/*
TODO: use this in more places
*/


function getPublicId(id) {
  if (id.indexOf(PRIVATE_ID_PREFIX) === 0) {
    return '';
  }

  return id;
}

function reduceResourceStore(store, action, source, context) {
  if (!store || !action) {
    return {};
  }

  switch (action.type) {
    case 'RECEIVE_RESOURCES':
      return receiveRawResources(store, action.rawResources, action.fetchId, source, context);

    case 'ADD_RESOURCE':
      return addResource(store, action.resourceHash);

    case 'REMOVE_RESOURCE':
      return removeResource(store, action.resourceId);

    case 'SET_RESOURCE_PROP':
      return setResourceProp(store, action.resourceId, action.propName, action.propValue);

    case 'SET_RESOURCE_EXTENDED_PROP':
      return setResourceExtendedProp(store, action.resourceId, action.propName, action.propValue);

    default:
      return store;
  }
}

function receiveRawResources(existingStore, inputs, fetchId, source, context) {
  if (source.latestFetchId === fetchId) {
    var nextStore = {};

    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
      var input = inputs_1[_i];
      parseResource(input, '', nextStore, context);
    }

    return nextStore;
  }

  return existingStore;
}

function addResource(existingStore, additions) {
  // TODO: warn about duplicate IDs
  return _assign(_assign({}, existingStore), additions);
}

function removeResource(existingStore, resourceId) {
  var newStore = _assign({}, existingStore);

  delete newStore[resourceId]; // promote children

  for (var childResourceId in newStore) {
    // a child, *maybe* but probably not
    if (newStore[childResourceId].parentId === resourceId) {
      newStore[childResourceId] = _assign(_assign({}, newStore[childResourceId]), {
        parentId: ''
      });
    }
  }

  return newStore;
}

function setResourceProp(existingStore, resourceId, name, value) {
  var _a, _b;

  var existingResource = existingStore[resourceId]; // TODO: sanitization

  if (existingResource) {
    return _assign(_assign({}, existingStore), (_a = {}, _a[resourceId] = _assign(_assign({}, existingResource), (_b = {}, _b[name] = value, _b)), _a));
  }

  return existingStore;
}

function setResourceExtendedProp(existingStore, resourceId, name, value) {
  var _a, _b;

  var existingResource = existingStore[resourceId];

  if (existingResource) {
    return _assign(_assign({}, existingStore), (_a = {}, _a[resourceId] = _assign(_assign({}, existingResource), {
      extendedProps: _assign(_assign({}, existingResource.extendedProps), (_b = {}, _b[name] = value, _b))
    }), _a));
  }

  return existingStore;
}

function reduceResourceEntityExpansions(expansions, action) {
  var _a;

  if (!expansions || !action) {
    return {};
  }

  switch (action.type) {
    case 'SET_RESOURCE_ENTITY_EXPANDED':
      return _assign(_assign({}, expansions), (_a = {}, _a[action.id] = action.isExpanded, _a));

    default:
      return expansions;
  }
}

function reduceResources(state, action, context) {
  var resourceSource = reduceResourceSource(state && state.resourceSource, action, context);
  var resourceStore = reduceResourceStore(state && state.resourceStore, action, resourceSource, context);
  var resourceEntityExpansions = reduceResourceEntityExpansions(state && state.resourceEntityExpansions, action);
  return {
    resourceSource: resourceSource,
    resourceStore: resourceStore,
    resourceEntityExpansions: resourceEntityExpansions
  };
}

var main_EVENT_REFINERS = {
  resourceId: String,
  resourceIds: identity,
  resourceEditable: Boolean
};

function generateEventDefResourceMembers(refined) {
  return {
    resourceIds: ensureStringArray(refined.resourceIds).concat(refined.resourceId ? [refined.resourceId] : []),
    resourceEditable: refined.resourceEditable
  };
}

function ensureStringArray(items) {
  return (items || []).map(function (item) {
    return String(item);
  });
}

function transformDateSelectionJoin(hit0, hit1) {
  var resourceId0 = hit0.dateSpan.resourceId;
  var resourceId1 = hit1.dateSpan.resourceId;

  if (resourceId0 && resourceId1) {
    return {
      resourceId: resourceId0
    };
  }

  return null;
}

var ResourceApi =
/** @class */
function () {
  function ResourceApi(_context, _resource) {
    this._context = _context;
    this._resource = _resource;
  }

  ResourceApi.prototype.setProp = function (name, value) {
    var oldResource = this._resource;

    this._context.dispatch({
      type: 'SET_RESOURCE_PROP',
      resourceId: oldResource.id,
      propName: name,
      propValue: value
    });

    this.sync(oldResource);
  };

  ResourceApi.prototype.setExtendedProp = function (name, value) {
    var oldResource = this._resource;

    this._context.dispatch({
      type: 'SET_RESOURCE_EXTENDED_PROP',
      resourceId: oldResource.id,
      propName: name,
      propValue: value
    });

    this.sync(oldResource);
  };

  ResourceApi.prototype.sync = function (oldResource) {
    var context = this._context;
    var resourceId = oldResource.id; // TODO: what if dispatch didn't complete synchronously?

    this._resource = context.getCurrentData().resourceStore[resourceId];
    context.emitter.trigger('resourceChange', {
      oldResource: new ResourceApi(context, oldResource),
      resource: this,
      revert: function revert() {
        var _a;

        context.dispatch({
          type: 'ADD_RESOURCE',
          resourceHash: (_a = {}, _a[resourceId] = oldResource, _a)
        });
      }
    });
  };

  ResourceApi.prototype.remove = function () {
    var context = this._context;
    var internalResource = this._resource;
    var resourceId = internalResource.id;
    context.dispatch({
      type: 'REMOVE_RESOURCE',
      resourceId: resourceId
    });
    context.emitter.trigger('resourceRemove', {
      resource: this,
      revert: function revert() {
        var _a;

        context.dispatch({
          type: 'ADD_RESOURCE',
          resourceHash: (_a = {}, _a[resourceId] = internalResource, _a)
        });
      }
    });
  };

  ResourceApi.prototype.getParent = function () {
    var context = this._context;
    var parentId = this._resource.parentId;

    if (parentId) {
      return new ResourceApi(context, context.getCurrentData().resourceSource[parentId]);
    }

    return null;
  };

  ResourceApi.prototype.getChildren = function () {
    var thisResourceId = this._resource.id;
    var context = this._context;
    var resourceStore = context.getCurrentData().resourceStore;
    var childApis = [];

    for (var resourceId in resourceStore) {
      if (resourceStore[resourceId].parentId === thisResourceId) {
        childApis.push(new ResourceApi(context, resourceStore[resourceId]));
      }
    }

    return childApis;
  };
  /*
  this is really inefficient!
  TODO: make EventApi::resourceIds a hash or keep an index in the Calendar's state
  */


  ResourceApi.prototype.getEvents = function () {
    var thisResourceId = this._resource.id;
    var context = this._context;
    var _a = context.getCurrentData().eventStore,
        defs = _a.defs,
        instances = _a.instances;
    var eventApis = [];

    for (var instanceId in instances) {
      var instance = instances[instanceId];
      var def = defs[instance.defId];

      if (def.resourceIds.indexOf(thisResourceId) !== -1) {
        // inefficient!!!
        eventApis.push(new EventApi(context, def, instance));
      }
    }

    return eventApis;
  };

  Object.defineProperty(ResourceApi.prototype, "id", {
    get: function get() {
      return getPublicId(this._resource.id);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "title", {
    get: function get() {
      return this._resource.title;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "eventConstraint", {
    get: function get() {
      return this._resource.ui.constraints[0] || null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "eventOverlap", {
    get: function get() {
      return this._resource.ui.overlap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "eventAllow", {
    get: function get() {
      return this._resource.ui.allows[0] || null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "eventBackgroundColor", {
    get: function get() {
      return this._resource.ui.backgroundColor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "eventBorderColor", {
    get: function get() {
      return this._resource.ui.borderColor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "eventTextColor", {
    get: function get() {
      return this._resource.ui.textColor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "eventClassNames", {
    // NOTE: user can't modify these because Object.freeze was called in event-def parsing
    get: function get() {
      return this._resource.ui.classNames;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ResourceApi.prototype, "extendedProps", {
    get: function get() {
      return this._resource.extendedProps;
    },
    enumerable: false,
    configurable: true
  });

  ResourceApi.prototype.toPlainObject = function (settings) {
    if (settings === void 0) {
      settings = {};
    }

    var internal = this._resource;
    var ui = internal.ui;
    var publicId = this.id;
    var res = {};

    if (publicId) {
      res.id = publicId;
    }

    if (internal.title) {
      res.title = internal.title;
    }

    if (settings.collapseEventColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.eventColor = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.eventBackgroundColor = ui.backgroundColor;
      }

      if (ui.borderColor) {
        res.eventBorderColor = ui.borderColor;
      }
    }

    if (ui.textColor) {
      res.eventTextColor = ui.textColor;
    }

    if (ui.classNames.length) {
      res.eventClassNames = ui.classNames;
    }

    if (Object.keys(internal.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        _assign(res, internal.extendedProps);
      } else {
        res.extendedProps = internal.extendedProps;
      }
    }

    return res;
  };

  ResourceApi.prototype.toJSON = function () {
    return this.toPlainObject();
  };

  return ResourceApi;
}();

function buildResourceApis(resourceStore, context) {
  var resourceApis = [];

  for (var resourceId in resourceStore) {
    resourceApis.push(new ResourceApi(context, resourceStore[resourceId]));
  }

  return resourceApis;
}

CalendarApi.prototype.addResource = function (input, scrollTo) {
  var _a;

  var _this = this;

  if (scrollTo === void 0) {
    scrollTo = true;
  }

  var currentState = this.getCurrentData();
  var resourceHash;
  var resource;

  if (input instanceof ResourceApi) {
    resource = input._resource;
    resourceHash = (_a = {}, _a[resource.id] = resource, _a);
  } else {
    resourceHash = {};
    resource = parseResource(input, '', resourceHash, currentState);
  }

  this.dispatch({
    type: 'ADD_RESOURCE',
    resourceHash: resourceHash
  });

  if (scrollTo) {
    // TODO: wait til dispatch completes somehow
    this.trigger('_scrollRequest', {
      resourceId: resource.id
    });
  }

  var resourceApi = new ResourceApi(currentState, resource);
  currentState.emitter.trigger('resourceAdd', {
    resource: resourceApi,
    revert: function revert() {
      _this.dispatch({
        type: 'REMOVE_RESOURCE',
        resourceId: resource.id
      });
    }
  });
  return resourceApi;
};

CalendarApi.prototype.getResourceById = function (id) {
  id = String(id);
  var currentState = this.getCurrentData(); // eslint-disable-line react/no-this-in-sfc

  if (currentState.resourceStore) {
    // guard against calendar with no resource functionality
    var rawResource = currentState.resourceStore[id];

    if (rawResource) {
      return new ResourceApi(currentState, rawResource);
    }
  }

  return null;
};

CalendarApi.prototype.getResources = function () {
  var currentState = this.getCurrentData();
  var resourceStore = currentState.resourceStore;
  var resourceApis = [];

  if (resourceStore) {
    // guard against calendar with no resource functionality
    for (var resourceId in resourceStore) {
      resourceApis.push(new ResourceApi(currentState, resourceStore[resourceId]));
    }
  }

  return resourceApis;
};

CalendarApi.prototype.getTopLevelResources = function () {
  var currentState = this.getCurrentData();
  var resourceStore = currentState.resourceStore;
  var resourceApis = [];

  if (resourceStore) {
    // guard against calendar with no resource functionality
    for (var resourceId in resourceStore) {
      if (!resourceStore[resourceId].parentId) {
        resourceApis.push(new ResourceApi(currentState, resourceStore[resourceId]));
      }
    }
  }

  return resourceApis;
};

CalendarApi.prototype.refetchResources = function () {
  this.dispatch({
    type: 'REFETCH_RESOURCES'
  });
};

function transformDatePoint(dateSpan, context) {
  return dateSpan.resourceId ? {
    resource: context.calendarApi.getResourceById(dateSpan.resourceId)
  } : {};
}

function transformDateSpan(dateSpan, context) {
  return dateSpan.resourceId ? {
    resource: context.calendarApi.getResourceById(dateSpan.resourceId)
  } : {};
}
/*
splits things BASED OFF OF which resources they are associated with.
creates a '' entry which is when something has NO resource.
*/


var ResourceSplitter =
/** @class */
function (_super) {
  __extends(ResourceSplitter, _super);

  function ResourceSplitter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ResourceSplitter.prototype.getKeyInfo = function (props) {
    return _assign({
      '': {}
    }, props.resourceStore);
  };

  ResourceSplitter.prototype.getKeysForDateSpan = function (dateSpan) {
    return [dateSpan.resourceId || ''];
  };

  ResourceSplitter.prototype.getKeysForEventDef = function (eventDef) {
    var resourceIds = eventDef.resourceIds;

    if (!resourceIds.length) {
      return [''];
    }

    return resourceIds;
  };

  return ResourceSplitter;
}(Splitter);

function isPropsValidWithResources(combinedProps, context) {
  var splitter = new ResourceSplitter();
  var sets = splitter.splitProps(_assign(_assign({}, combinedProps), {
    resourceStore: context.getCurrentData().resourceStore
  }));

  for (var resourceId in sets) {
    var props = sets[resourceId]; // merge in event data from the non-resource segment

    if (resourceId && sets['']) {
      // current segment is not the non-resource one, and there IS a non-resource one
      props = _assign(_assign({}, props), {
        eventStore: mergeEventStores(sets[''].eventStore, props.eventStore),
        eventUiBases: _assign(_assign({}, sets[''].eventUiBases), props.eventUiBases)
      });
    }

    if (!isPropsValid(props, context, {
      resourceId: resourceId
    }, filterConfig.bind(null, resourceId))) {
      return false;
    }
  }

  return true;
}

function filterConfig(resourceId, config) {
  return _assign(_assign({}, config), {
    constraints: filterConstraints(resourceId, config.constraints)
  });
}

function filterConstraints(resourceId, constraints) {
  return constraints.map(function (constraint) {
    var defs = constraint.defs;

    if (defs) {
      // we are dealing with an EventStore
      // if any of the events define constraints to resources that are NOT this resource,
      // then this resource is unconditionally prohibited, which is what a `false` value does.
      for (var defId in defs) {
        var resourceIds = defs[defId].resourceIds;

        if (resourceIds.length && resourceIds.indexOf(resourceId) === -1) {
          // TODO: use a hash?!!! (for other reasons too)
          return false;
        }
      }
    }

    return constraint;
  });
}

function transformExternalDef(dateSpan) {
  return dateSpan.resourceId ? {
    resourceId: dateSpan.resourceId
  } : {};
}

EventApi.prototype.getResources = function () {
  var calendarApi = this._context.calendarApi;
  return this._def.resourceIds.map(function (resourceId) {
    return calendarApi.getResourceById(resourceId);
  });
};

EventApi.prototype.setResources = function (resources) {
  var resourceIds = []; // massage resources -> resourceIds

  for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
    var resource = resources_1[_i];
    var resourceId = null;

    if (typeof resource === 'string') {
      resourceId = resource;
    } else if (typeof resource === 'number') {
      resourceId = String(resource);
    } else if (resource instanceof ResourceApi) {
      resourceId = resource.id; // guaranteed to always have an ID. hmmm
    } else {
      console.warn('unknown resource type: ' + resource);
    }

    if (resourceId) {
      resourceIds.push(resourceId);
    }
  }

  this.mutate({
    standardProps: {
      resourceIds: resourceIds
    }
  });
};

var optionChangeHandlers = {
  resources: handleResources
};

function handleResources(newSourceInput, context) {
  var oldSourceInput = context.getCurrentData().resourceSource._raw;

  if (oldSourceInput !== newSourceInput) {
    context.dispatch({
      type: 'RESET_RESOURCE_SOURCE',
      resourceSourceInput: newSourceInput
    });
  }
}

var DEFAULT_RESOURCE_ORDER = parseFieldSpecs('id,title');

function handleResourceStore(resourceStore, calendarData) {
  var emitter = calendarData.emitter;

  if (emitter.hasHandlers('resourcesSet')) {
    emitter.trigger('resourcesSet', buildResourceApis(resourceStore, calendarData));
  }
}

var resource_common_main_OPTION_REFINERS = {
  initialResources: identity,
  resources: identity,
  eventResourceEditable: Boolean,
  refetchResourcesOnNavigate: Boolean,
  resourceOrder: parseFieldSpecs,
  filterResourcesWithEvents: Boolean,
  resourceGroupField: String,
  resourceAreaWidth: identity,
  resourceAreaColumns: identity,
  resourcesInitiallyExpanded: Boolean,
  datesAboveResources: Boolean,
  needsResourceData: Boolean,
  resourceAreaHeaderClassNames: identity,
  resourceAreaHeaderContent: identity,
  resourceAreaHeaderDidMount: identity,
  resourceAreaHeaderWillUnmount: identity,
  resourceGroupLabelClassNames: identity,
  resourceGroupLabelContent: identity,
  resourceGroupLabelDidMount: identity,
  resourceGroupLabelWillUnmount: identity,
  resourceLabelClassNames: identity,
  resourceLabelContent: identity,
  resourceLabelDidMount: identity,
  resourceLabelWillUnmount: identity,
  resourceLaneClassNames: identity,
  resourceLaneContent: identity,
  resourceLaneDidMount: identity,
  resourceLaneWillUnmount: identity,
  resourceGroupLaneClassNames: identity,
  resourceGroupLaneContent: identity,
  resourceGroupLaneDidMount: identity,
  resourceGroupLaneWillUnmount: identity
};
var main_LISTENER_REFINERS = {
  resourcesSet: identity,
  resourceAdd: identity,
  resourceChange: identity,
  resourceRemove: identity
};
registerResourceSourceDef({
  ignoreRange: true,
  parseMeta: function parseMeta(refined) {
    if (Array.isArray(refined.resources)) {
      return refined.resources;
    }

    return null;
  },
  fetch: function fetch(arg, successCallback) {
    successCallback({
      rawResources: arg.resourceSource.meta
    });
  }
});
registerResourceSourceDef({
  parseMeta: function parseMeta(refined) {
    if (typeof refined.resources === 'function') {
      return refined.resources;
    }

    return null;
  },
  fetch: function fetch(arg, success, failure) {
    var dateEnv = arg.context.dateEnv;
    var func = arg.resourceSource.meta;
    var publicArg = arg.range ? {
      start: dateEnv.toDate(arg.range.start),
      end: dateEnv.toDate(arg.range.end),
      startStr: dateEnv.formatIso(arg.range.start),
      endStr: dateEnv.formatIso(arg.range.end),
      timeZone: dateEnv.timeZone
    } : {}; // TODO: make more dry with EventSourceFunc
    // TODO: accept a response?

    unpromisify(func.bind(null, publicArg), function (rawResources) {
      success({
        rawResources: rawResources
      }); // needs an object response
    }, failure);
  }
});
registerResourceSourceDef({
  parseMeta: function parseMeta(refined) {
    if (refined.url) {
      return {
        url: refined.url,
        method: (refined.method || 'GET').toUpperCase(),
        extraParams: refined.extraParams
      };
    }

    return null;
  },
  fetch: function fetch(arg, successCallback, failureCallback) {
    var meta = arg.resourceSource.meta;
    var requestParams = main_buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams, function (rawResources, xhr) {
      successCallback({
        rawResources: rawResources,
        xhr: xhr
      });
    }, function (message, xhr) {
      failureCallback({
        message: message,
        xhr: xhr
      });
    });
  }
}); // TODO: somehow consolidate with event json feed

function main_buildRequestParams(meta, range, context) {
  var dateEnv = context.dateEnv,
      options = context.options;
  var startParam;
  var endParam;
  var timeZoneParam;
  var customRequestParams;
  var params = {};

  if (range) {
    startParam = meta.startParam;

    if (startParam == null) {
      startParam = options.startParam;
    }

    endParam = meta.endParam;

    if (endParam == null) {
      endParam = options.endParam;
    }

    timeZoneParam = meta.timeZoneParam;

    if (timeZoneParam == null) {
      timeZoneParam = options.timeZoneParam;
    }

    params[startParam] = dateEnv.formatIso(range.start);
    params[endParam] = dateEnv.formatIso(range.end);

    if (dateEnv.timeZone !== 'local') {
      params[timeZoneParam] = dateEnv.timeZone;
    }
  } // retrieve any outbound GET/POST data from the options


  if (typeof meta.extraParams === 'function') {
    // supplied as a function that returns a key/value object
    customRequestParams = meta.extraParams();
  } else {
    // probably supplied as a straight key/value object
    customRequestParams = meta.extraParams || {};
  }

  _assign(params, customRequestParams);

  return params;
} // TODO: not used for Spreadsheet. START USING. difficult because of col-specific rendering props


function ResourceLabelRoot(props) {
  return vdom_createElement(ViewContextType.Consumer, null, function (context) {
    var options = context.options;
    var hookProps = {
      resource: new ResourceApi(context, props.resource),
      date: props.date ? context.dateEnv.toDate(props.date) : null,
      view: context.viewApi
    };
    var dataAttrs = {
      'data-resource-id': props.resource.id,
      'data-date': props.date ? formatDayString(props.date) : undefined
    };
    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.resourceLabelClassNames,
      content: options.resourceLabelContent,
      defaultContent: resource_common_main_renderInnerContent,
      didMount: options.resourceLabelDidMount,
      willUnmount: options.resourceLabelWillUnmount
    }, function (rootElRef, classNames, innerElRef, innerContent) {
      return props.children(rootElRef, classNames, // TODO: pass in 'fc-resource' ?
      dataAttrs, innerElRef, innerContent);
    });
  });
}

function resource_common_main_renderInnerContent(props) {
  return props.resource.title || props.resource.id;
}

var ResourceCell =
/** @class */
function (_super) {
  __extends(ResourceCell, _super);

  function ResourceCell() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ResourceCell.prototype.render = function () {
    var props = this.props;
    return vdom_createElement(ResourceLabelRoot, {
      resource: props.resource,
      date: props.date
    }, function (elRef, customClassNames, dataAttrs, innerElRef, innerContent) {
      return vdom_createElement("th", _assign({
        ref: elRef,
        role: "columnheader",
        className: ['fc-col-header-cell', 'fc-resource'].concat(customClassNames).join(' '),
        colSpan: props.colSpan
      }, dataAttrs), vdom_createElement("div", {
        className: "fc-scrollgrid-sync-inner"
      }, vdom_createElement("span", {
        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),
        ref: innerElRef
      }, innerContent)));
    });
  };

  return ResourceCell;
}(BaseComponent);

var ResourceDayHeader =
/** @class */
function (_super) {
  __extends(ResourceDayHeader, _super);

  function ResourceDayHeader() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buildDateFormat = memoize(buildDateFormat);
    return _this;
  }

  ResourceDayHeader.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var dateFormat = this.buildDateFormat(context.options.dayHeaderFormat, props.datesRepDistinctDays, props.dates.length);
    return vdom_createElement(NowTimer, {
      unit: "day"
    }, function (nowDate, todayRange) {
      if (props.dates.length === 1) {
        return _this.renderResourceRow(props.resources, props.dates[0]);
      }

      if (context.options.datesAboveResources) {
        return _this.renderDayAndResourceRows(props.dates, dateFormat, todayRange, props.resources);
      }

      return _this.renderResourceAndDayRows(props.resources, props.dates, dateFormat, todayRange);
    });
  };

  ResourceDayHeader.prototype.renderResourceRow = function (resources, date) {
    var resourceCells = resources.map(function (resource) {
      return vdom_createElement(ResourceCell, {
        key: resource.id,
        resource: resource,
        colSpan: 1,
        date: date
      });
    });
    return this.buildTr(resourceCells, 'resources');
  };

  ResourceDayHeader.prototype.renderDayAndResourceRows = function (dates, dateFormat, todayRange, resources) {
    var dateCells = [];
    var resourceCells = [];

    for (var _i = 0, dates_1 = dates; _i < dates_1.length; _i++) {
      var date = dates_1[_i];
      dateCells.push(this.renderDateCell(date, dateFormat, todayRange, resources.length, null, true));

      for (var _a = 0, resources_1 = resources; _a < resources_1.length; _a++) {
        var resource = resources_1[_a];
        resourceCells.push(vdom_createElement(ResourceCell, {
          key: resource.id + ':' + date.toISOString(),
          resource: resource,
          colSpan: 1,
          date: date
        }));
      }
    }

    return vdom_createElement(vdom_Fragment, null, this.buildTr(dateCells, 'day'), this.buildTr(resourceCells, 'resources'));
  };

  ResourceDayHeader.prototype.renderResourceAndDayRows = function (resources, dates, dateFormat, todayRange) {
    var resourceCells = [];
    var dateCells = [];

    for (var _i = 0, resources_2 = resources; _i < resources_2.length; _i++) {
      var resource = resources_2[_i];
      resourceCells.push(vdom_createElement(ResourceCell, {
        key: resource.id,
        resource: resource,
        colSpan: dates.length,
        isSticky: true
      }));

      for (var _a = 0, dates_2 = dates; _a < dates_2.length; _a++) {
        var date = dates_2[_a];
        dateCells.push(this.renderDateCell(date, dateFormat, todayRange, 1, resource));
      }
    }

    return vdom_createElement(vdom_Fragment, null, this.buildTr(resourceCells, 'resources'), this.buildTr(dateCells, 'day'));
  }; // a cell with date text. might have a resource associated with it


  ResourceDayHeader.prototype.renderDateCell = function (date, dateFormat, todayRange, colSpan, resource, isSticky) {
    var props = this.props;
    var keyPostfix = resource ? ":" + resource.id : '';
    var extraHookProps = resource ? {
      resource: new ResourceApi(this.context, resource)
    } : {};
    var extraDataAttrs = resource ? {
      'data-resource-id': resource.id
    } : {};
    return props.datesRepDistinctDays ? vdom_createElement(TableDateCell, {
      key: date.toISOString() + keyPostfix,
      date: date,
      dateProfile: props.dateProfile,
      todayRange: todayRange,
      colCnt: props.dates.length * props.resources.length,
      dayHeaderFormat: dateFormat,
      colSpan: colSpan,
      isSticky: isSticky,
      extraHookProps: extraHookProps,
      extraDataAttrs: extraDataAttrs
    }) : vdom_createElement(TableDowCell // we can't leverage the pure-componentness becausae the extra* props are new every time :(
    , {
      key: date.getUTCDay() + keyPostfix,
      dow: date.getUTCDay(),
      dayHeaderFormat: dateFormat,
      colSpan: colSpan,
      isSticky: isSticky,
      extraHookProps: extraHookProps,
      extraDataAttrs: extraDataAttrs
    });
  };

  ResourceDayHeader.prototype.buildTr = function (cells, key) {
    var renderIntro = this.props.renderIntro;

    if (!cells.length) {
      cells = [vdom_createElement("td", {
        key: 0
      }, "\xA0")];
    }

    return vdom_createElement("tr", {
      key: key,
      role: "row"
    }, renderIntro && renderIntro(key), cells);
  };

  return ResourceDayHeader;
}(BaseComponent);

function buildDateFormat(dayHeaderFormat, datesRepDistinctDays, dayCnt) {
  return dayHeaderFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt);
}

var ResourceIndex =
/** @class */
function () {
  function ResourceIndex(resources) {
    var indicesById = {};
    var ids = [];

    for (var i = 0; i < resources.length; i += 1) {
      var id = resources[i].id;
      ids.push(id);
      indicesById[id] = i;
    }

    this.ids = ids;
    this.indicesById = indicesById;
    this.length = resources.length;
  }

  return ResourceIndex;
}();

var AbstractResourceDayTableModel =
/** @class */
function () {
  function AbstractResourceDayTableModel(dayTableModel, resources, context) {
    this.dayTableModel = dayTableModel;
    this.resources = resources;
    this.context = context;
    this.resourceIndex = new ResourceIndex(resources);
    this.rowCnt = dayTableModel.rowCnt;
    this.colCnt = dayTableModel.colCnt * resources.length;
    this.cells = this.buildCells();
  }

  AbstractResourceDayTableModel.prototype.buildCells = function () {
    var _a = this,
        rowCnt = _a.rowCnt,
        dayTableModel = _a.dayTableModel,
        resources = _a.resources;

    var rows = [];

    for (var row = 0; row < rowCnt; row += 1) {
      var rowCells = [];

      for (var dateCol = 0; dateCol < dayTableModel.colCnt; dateCol += 1) {
        for (var resourceCol = 0; resourceCol < resources.length; resourceCol += 1) {
          var resource = resources[resourceCol];
          var extraHookProps = {
            resource: new ResourceApi(this.context, resource)
          };
          var extraDataAttrs = {
            'data-resource-id': resource.id
          };
          var extraClassNames = ['fc-resource'];
          var extraDateSpan = {
            resourceId: resource.id
          };
          var date = dayTableModel.cells[row][dateCol].date;
          rowCells[this.computeCol(dateCol, resourceCol)] = {
            key: resource.id + ':' + date.toISOString(),
            date: date,
            extraHookProps: extraHookProps,
            extraDataAttrs: extraDataAttrs,
            extraClassNames: extraClassNames,
            extraDateSpan: extraDateSpan
          };
        }
      }

      rows.push(rowCells);
    }

    return rows;
  };

  return AbstractResourceDayTableModel;
}();
/*
resources over dates
*/


var ResourceDayTableModel =
/** @class */
function (_super) {
  __extends(ResourceDayTableModel, _super);

  function ResourceDayTableModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ResourceDayTableModel.prototype.computeCol = function (dateI, resourceI) {
    return resourceI * this.dayTableModel.colCnt + dateI;
  };
  /*
  all date ranges are intact
  */


  ResourceDayTableModel.prototype.computeColRanges = function (dateStartI, dateEndI, resourceI) {
    return [{
      firstCol: this.computeCol(dateStartI, resourceI),
      lastCol: this.computeCol(dateEndI, resourceI),
      isStart: true,
      isEnd: true
    }];
  };

  return ResourceDayTableModel;
}(AbstractResourceDayTableModel);
/*
dates over resources
*/


var DayResourceTableModel =
/** @class */
function (_super) {
  __extends(DayResourceTableModel, _super);

  function DayResourceTableModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DayResourceTableModel.prototype.computeCol = function (dateI, resourceI) {
    return dateI * this.resources.length + resourceI;
  };
  /*
  every single day is broken up
  */


  DayResourceTableModel.prototype.computeColRanges = function (dateStartI, dateEndI, resourceI) {
    var segs = [];

    for (var i = dateStartI; i <= dateEndI; i += 1) {
      var col = this.computeCol(i, resourceI);
      segs.push({
        firstCol: col,
        lastCol: col,
        isStart: i === dateStartI,
        isEnd: i === dateEndI
      });
    }

    return segs;
  };

  return DayResourceTableModel;
}(AbstractResourceDayTableModel);

var NO_SEGS = []; // for memoizing

var VResourceJoiner =
/** @class */
function () {
  function VResourceJoiner() {
    this.joinDateSelection = memoize(this.joinSegs);
    this.joinBusinessHours = memoize(this.joinSegs);
    this.joinFgEvents = memoize(this.joinSegs);
    this.joinBgEvents = memoize(this.joinSegs);
    this.joinEventDrags = memoize(this.joinInteractions);
    this.joinEventResizes = memoize(this.joinInteractions);
  }
  /*
  propSets also has a '' key for things with no resource
  */


  VResourceJoiner.prototype.joinProps = function (propSets, resourceDayTable) {
    var dateSelectionSets = [];
    var businessHoursSets = [];
    var fgEventSets = [];
    var bgEventSets = [];
    var eventDrags = [];
    var eventResizes = [];
    var eventSelection = '';
    var keys = resourceDayTable.resourceIndex.ids.concat(['']); // add in the all-resource key

    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      var props = propSets[key];
      dateSelectionSets.push(props.dateSelectionSegs);
      businessHoursSets.push(key ? props.businessHourSegs : NO_SEGS); // don't include redundant all-resource businesshours

      fgEventSets.push(key ? props.fgEventSegs : NO_SEGS); // don't include fg all-resource segs

      bgEventSets.push(props.bgEventSegs);
      eventDrags.push(props.eventDrag);
      eventResizes.push(props.eventResize);
      eventSelection = eventSelection || props.eventSelection;
    }

    return {
      dateSelectionSegs: this.joinDateSelection.apply(this, __spreadArray([resourceDayTable], dateSelectionSets)),
      businessHourSegs: this.joinBusinessHours.apply(this, __spreadArray([resourceDayTable], businessHoursSets)),
      fgEventSegs: this.joinFgEvents.apply(this, __spreadArray([resourceDayTable], fgEventSets)),
      bgEventSegs: this.joinBgEvents.apply(this, __spreadArray([resourceDayTable], bgEventSets)),
      eventDrag: this.joinEventDrags.apply(this, __spreadArray([resourceDayTable], eventDrags)),
      eventResize: this.joinEventResizes.apply(this, __spreadArray([resourceDayTable], eventResizes)),
      eventSelection: eventSelection
    };
  };

  VResourceJoiner.prototype.joinSegs = function (resourceDayTable) {
    var segGroups = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      segGroups[_i - 1] = arguments[_i];
    }

    var resourceCnt = resourceDayTable.resources.length;
    var transformedSegs = [];

    for (var i = 0; i < resourceCnt; i += 1) {
      for (var _a = 0, _b = segGroups[i]; _a < _b.length; _a++) {
        var seg = _b[_a];
        transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));
      }

      for (var _c = 0, _d = segGroups[resourceCnt]; _c < _d.length; _c++) {
        // one beyond. the all-resource
        var seg = _d[_c];
        transformedSegs.push.apply( // one beyond. the all-resource
        transformedSegs, this.transformSeg(seg, resourceDayTable, i));
      }
    }

    return transformedSegs;
  };
  /*
  for expanding non-resource segs to all resources.
  only for public use.
  no memoizing.
  */


  VResourceJoiner.prototype.expandSegs = function (resourceDayTable, segs) {
    var resourceCnt = resourceDayTable.resources.length;
    var transformedSegs = [];

    for (var i = 0; i < resourceCnt; i += 1) {
      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));
      }
    }

    return transformedSegs;
  };

  VResourceJoiner.prototype.joinInteractions = function (resourceDayTable) {
    var interactions = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      interactions[_i - 1] = arguments[_i];
    }

    var resourceCnt = resourceDayTable.resources.length;
    var affectedInstances = {};
    var transformedSegs = [];
    var anyInteractions = false;
    var isEvent = false;

    for (var i = 0; i < resourceCnt; i += 1) {
      var interaction = interactions[i];

      if (interaction) {
        anyInteractions = true;

        for (var _a = 0, _b = interaction.segs; _a < _b.length; _a++) {
          var seg = _b[_a];
          transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));
        }

        _assign(affectedInstances, interaction.affectedInstances);

        isEvent = isEvent || interaction.isEvent;
      }

      if (interactions[resourceCnt]) {
        // one beyond. the all-resource
        for (var _c = 0, _d = interactions[resourceCnt].segs; _c < _d.length; _c++) {
          var seg = _d[_c];
          transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));
        }
      }
    }

    if (anyInteractions) {
      return {
        affectedInstances: affectedInstances,
        segs: transformedSegs,
        isEvent: isEvent
      };
    }

    return null;
  };

  return VResourceJoiner;
}();
/*
TODO: just use ResourceHash somehow? could then use the generic ResourceSplitter
*/


var VResourceSplitter =
/** @class */
function (_super) {
  __extends(VResourceSplitter, _super);

  function VResourceSplitter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  VResourceSplitter.prototype.getKeyInfo = function (props) {
    var resourceDayTableModel = props.resourceDayTableModel;
    var hash = mapHash(resourceDayTableModel.resourceIndex.indicesById, function (i) {
      return resourceDayTableModel.resources[i];
    }); // :(

    hash[''] = {};
    return hash;
  };

  VResourceSplitter.prototype.getKeysForDateSpan = function (dateSpan) {
    return [dateSpan.resourceId || ''];
  };

  VResourceSplitter.prototype.getKeysForEventDef = function (eventDef) {
    var resourceIds = eventDef.resourceIds;

    if (!resourceIds.length) {
      return [''];
    }

    return resourceIds;
  };

  return VResourceSplitter;
}(Splitter);
/*
doesn't accept grouping
*/


function flattenResources(resourceStore, orderSpecs) {
  return buildRowNodes(resourceStore, [], orderSpecs, false, {}, true).map(function (node) {
    return node.resource;
  });
}

function buildRowNodes(resourceStore, groupSpecs, orderSpecs, isVGrouping, expansions, expansionDefault) {
  var complexNodes = buildHierarchy(resourceStore, isVGrouping ? -1 : 1, groupSpecs, orderSpecs);
  var flatNodes = [];
  flattenNodes(complexNodes, flatNodes, isVGrouping, [], 0, expansions, expansionDefault);
  return flatNodes;
}

function flattenNodes(complexNodes, res, isVGrouping, rowSpans, depth, expansions, expansionDefault) {
  for (var i = 0; i < complexNodes.length; i += 1) {
    var complexNode = complexNodes[i];
    var group = complexNode.group;

    if (group) {
      if (isVGrouping) {
        var firstRowIndex = res.length;
        var rowSpanIndex = rowSpans.length;
        flattenNodes(complexNode.children, res, isVGrouping, rowSpans.concat(0), depth, expansions, expansionDefault);

        if (firstRowIndex < res.length) {
          var firstRow = res[firstRowIndex];
          var firstRowSpans = firstRow.rowSpans = firstRow.rowSpans.slice();
          firstRowSpans[rowSpanIndex] = res.length - firstRowIndex;
        }
      } else {
        var id = group.spec.field + ':' + group.value;
        var isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;
        res.push({
          id: id,
          group: group,
          isExpanded: isExpanded
        });

        if (isExpanded) {
          flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);
        }
      }
    } else if (complexNode.resource) {
      var id = complexNode.resource.id;
      var isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;
      res.push({
        id: id,
        rowSpans: rowSpans,
        depth: depth,
        isExpanded: isExpanded,
        hasChildren: Boolean(complexNode.children.length),
        resource: complexNode.resource,
        resourceFields: complexNode.resourceFields
      });

      if (isExpanded) {
        flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);
      }
    }
  }
}

function buildHierarchy(resourceStore, maxDepth, groupSpecs, orderSpecs) {
  var resourceNodes = buildResourceNodes(resourceStore, orderSpecs);
  var builtNodes = [];

  for (var resourceId in resourceNodes) {
    var resourceNode = resourceNodes[resourceId];

    if (!resourceNode.resource.parentId) {
      insertResourceNode(resourceNode, builtNodes, groupSpecs, 0, maxDepth, orderSpecs);
    }
  }

  return builtNodes;
}

function buildResourceNodes(resourceStore, orderSpecs) {
  var nodeHash = {};

  for (var resourceId in resourceStore) {
    var resource = resourceStore[resourceId];
    nodeHash[resourceId] = {
      resource: resource,
      resourceFields: buildResourceFields(resource),
      children: []
    };
  }

  for (var resourceId in resourceStore) {
    var resource = resourceStore[resourceId];

    if (resource.parentId) {
      var parentNode = nodeHash[resource.parentId];

      if (parentNode) {
        insertResourceNodeInSiblings(nodeHash[resourceId], parentNode.children, orderSpecs);
      }
    }
  }

  return nodeHash;
}

function insertResourceNode(resourceNode, nodes, groupSpecs, depth, maxDepth, orderSpecs) {
  if (groupSpecs.length && (maxDepth === -1 || depth <= maxDepth)) {
    var groupNode = ensureGroupNodes(resourceNode, nodes, groupSpecs[0]);
    insertResourceNode(resourceNode, groupNode.children, groupSpecs.slice(1), depth + 1, maxDepth, orderSpecs);
  } else {
    insertResourceNodeInSiblings(resourceNode, nodes, orderSpecs);
  }
}

function ensureGroupNodes(resourceNode, nodes, groupSpec) {
  var groupValue = resourceNode.resourceFields[groupSpec.field];
  var groupNode;
  var newGroupIndex; // find an existing group that matches, or determine the position for a new group

  if (groupSpec.order) {
    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex += 1) {
      var node = nodes[newGroupIndex];

      if (node.group) {
        var cmp = flexibleCompare(groupValue, node.group.value) * groupSpec.order;

        if (cmp === 0) {
          groupNode = node;
          break;
        } else if (cmp < 0) {
          break;
        }
      }
    }
  } else {
    // the groups are unordered
    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex += 1) {
      var node = nodes[newGroupIndex];

      if (node.group && groupValue === node.group.value) {
        groupNode = node;
        break;
      }
    }
  }

  if (!groupNode) {
    groupNode = {
      group: {
        value: groupValue,
        spec: groupSpec
      },
      children: []
    };
    nodes.splice(newGroupIndex, 0, groupNode);
  }

  return groupNode;
}

function insertResourceNodeInSiblings(resourceNode, siblings, orderSpecs) {
  var i;

  for (i = 0; i < siblings.length; i += 1) {
    var cmp = compareByFieldSpecs(siblings[i].resourceFields, resourceNode.resourceFields, orderSpecs); // TODO: pass in ResourceApi?

    if (cmp > 0) {
      // went 1 past. insert at i
      break;
    }
  }

  siblings.splice(i, 0, resourceNode);
}

function buildResourceFields(resource) {
  var obj = _assign(_assign(_assign({}, resource.extendedProps), resource.ui), resource);

  delete obj.ui;
  delete obj.extendedProps;
  return obj;
}

function isGroupsEqual(group0, group1) {
  return group0.spec === group1.spec && group0.value === group1.value;
}

var resource_common_main_main = createPlugin({
  deps: [premium_common_main],
  reducers: [reduceResources],
  isLoadingFuncs: [function (state) {
    return state.resourceSource && state.resourceSource.isFetching;
  }],
  eventRefiners: main_EVENT_REFINERS,
  eventDefMemberAdders: [generateEventDefResourceMembers],
  isDraggableTransformers: [transformIsDraggable],
  eventDragMutationMassagers: [massageEventDragMutation],
  eventDefMutationAppliers: [applyEventDefMutation],
  dateSelectionTransformers: [transformDateSelectionJoin],
  datePointTransforms: [transformDatePoint],
  dateSpanTransforms: [transformDateSpan],
  viewPropsTransformers: [ResourceDataAdder, ResourceEventConfigAdder],
  isPropsValid: isPropsValidWithResources,
  externalDefTransforms: [transformExternalDef],
  eventDropTransformers: [transformEventDrop],
  optionChangeHandlers: optionChangeHandlers,
  optionRefiners: resource_common_main_OPTION_REFINERS,
  listenerRefiners: main_LISTENER_REFINERS,
  propSetHandlers: {
    resourceStore: handleResourceStore
  }
});
/* harmony default export */ var resource_common_main = (resource_common_main_main);

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/resource-daygrid/main.js
/*!
FullCalendar Scheduler v5.11.3
Docs & License: https://fullcalendar.io/scheduler
(c) 2022 Adam Shaw
*/






var ResourceDayTableJoiner =
/** @class */
function (_super) {
  __extends(ResourceDayTableJoiner, _super);

  function ResourceDayTableJoiner() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ResourceDayTableJoiner.prototype.transformSeg = function (seg, resourceDayTableModel, resourceI) {
    var colRanges = resourceDayTableModel.computeColRanges(seg.firstCol, seg.lastCol, resourceI);
    return colRanges.map(function (colRange) {
      return _assign(_assign(_assign({}, seg), colRange), {
        isStart: seg.isStart && colRange.isStart,
        isEnd: seg.isEnd && colRange.isEnd
      });
    });
  };

  return ResourceDayTableJoiner;
}(VResourceJoiner);

var ResourceDayTable =
/** @class */
function (_super) {
  __extends(ResourceDayTable, _super);

  function ResourceDayTable() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.splitter = new VResourceSplitter();
    _this.slicers = {};
    _this.joiner = new ResourceDayTableJoiner();
    _this.tableRef = createRef();

    _this.isHitComboAllowed = function (hit0, hit1) {
      var allowAcrossResources = _this.props.resourceDayTableModel.dayTableModel.colCnt === 1;
      return allowAcrossResources || hit0.dateSpan.resourceId === hit1.dateSpan.resourceId;
    };

    return _this;
  }

  ResourceDayTable.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var resourceDayTableModel = props.resourceDayTableModel,
        nextDayThreshold = props.nextDayThreshold,
        dateProfile = props.dateProfile;
    var splitProps = this.splitter.splitProps(props);
    this.slicers = mapHash(splitProps, function (split, resourceId) {
      return _this.slicers[resourceId] || new DayTableSlicer();
    });
    var slicedProps = mapHash(this.slicers, function (slicer, resourceId) {
      return slicer.sliceProps(splitProps[resourceId], dateProfile, nextDayThreshold, context, resourceDayTableModel.dayTableModel);
    });
    return vdom_createElement(Table, _assign({
      forPrint: props.forPrint,
      ref: this.tableRef
    }, this.joiner.joinProps(slicedProps, resourceDayTableModel), {
      cells: resourceDayTableModel.cells,
      dateProfile: dateProfile,
      colGroupNode: props.colGroupNode,
      tableMinWidth: props.tableMinWidth,
      renderRowIntro: props.renderRowIntro,
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      showWeekNumbers: props.showWeekNumbers,
      expandRows: props.expandRows,
      headerAlignElRef: props.headerAlignElRef,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      isHitComboAllowed: this.isHitComboAllowed
    }));
  };

  return ResourceDayTable;
}(DateComponent);

var ResourceDayTableView =
/** @class */
function (_super) {
  __extends(ResourceDayTableView, _super);

  function ResourceDayTableView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.flattenResources = memoize(flattenResources);
    _this.buildResourceDayTableModel = memoize(buildResourceDayTableModel);
    _this.headerRef = createRef();
    _this.tableRef = createRef();
    return _this;
  }

  ResourceDayTableView.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options;
    var resourceOrderSpecs = options.resourceOrder || DEFAULT_RESOURCE_ORDER;
    var resources = this.flattenResources(props.resourceStore, resourceOrderSpecs);
    var resourceDayTableModel = this.buildResourceDayTableModel(props.dateProfile, context.dateProfileGenerator, resources, options.datesAboveResources, context);
    var headerContent = options.dayHeaders && vdom_createElement(ResourceDayHeader, {
      ref: this.headerRef,
      resources: resources,
      dateProfile: props.dateProfile,
      dates: resourceDayTableModel.dayTableModel.headerDates,
      datesRepDistinctDays: true
    });

    var bodyContent = function bodyContent(contentArg) {
      return vdom_createElement(ResourceDayTable, {
        ref: _this.tableRef,
        dateProfile: props.dateProfile,
        resourceDayTableModel: resourceDayTableModel,
        businessHours: props.businessHours,
        eventStore: props.eventStore,
        eventUiBases: props.eventUiBases,
        dateSelection: props.dateSelection,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        nextDayThreshold: options.nextDayThreshold,
        tableMinWidth: contentArg.tableMinWidth,
        colGroupNode: contentArg.tableColGroupNode,
        dayMaxEvents: options.dayMaxEvents,
        dayMaxEventRows: options.dayMaxEventRows,
        showWeekNumbers: options.weekNumbers,
        expandRows: !props.isHeightAuto,
        headerAlignElRef: _this.headerElRef,
        clientWidth: contentArg.clientWidth,
        clientHeight: contentArg.clientHeight,
        forPrint: props.forPrint
      });
    };

    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, resourceDayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  };

  return ResourceDayTableView;
}(TableView);

function buildResourceDayTableModel(dateProfile, dateProfileGenerator, resources, datesAboveResources, context) {
  var dayTable = buildDayTableModel(dateProfile, dateProfileGenerator);
  return datesAboveResources ? new DayResourceTableModel(dayTable, resources, context) : new ResourceDayTableModel(dayTable, resources, context);
}

var resource_daygrid_main_main = createPlugin({
  deps: [premium_common_main, resource_common_main, _fullcalendar_daygrid_main],
  initialView: 'resourceDayGridDay',
  views: {
    resourceDayGrid: {
      type: 'dayGrid',
      component: ResourceDayTableView,
      needsResourceData: true
    },
    resourceDayGridDay: {
      type: 'resourceDayGrid',
      duration: {
        days: 1
      }
    },
    resourceDayGridWeek: {
      type: 'resourceDayGrid',
      duration: {
        weeks: 1
      }
    },
    resourceDayGridMonth: {
      type: 'resourceDayGrid',
      duration: {
        months: 1
      },
      // TODO: wish we didn't have to C&P from dayGrid's file
      monthMode: true,
      fixedWeekCount: true
    }
  }
});
/* harmony default export */ var resource_daygrid_main = ((/* unused pure expression or super */ null && (resource_daygrid_main_main)));

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/resource-timegrid/main.js
/*!
FullCalendar Scheduler v5.11.3
Docs & License: https://fullcalendar.io/scheduler
(c) 2022 Adam Shaw
*/







var ResourceDayTimeColsJoiner =
/** @class */
function (_super) {
  __extends(ResourceDayTimeColsJoiner, _super);

  function ResourceDayTimeColsJoiner() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ResourceDayTimeColsJoiner.prototype.transformSeg = function (seg, resourceDayTable, resourceI) {
    return [_assign(_assign({}, seg), {
      col: resourceDayTable.computeCol(seg.col, resourceI)
    })];
  };

  return ResourceDayTimeColsJoiner;
}(VResourceJoiner);

var ResourceDayTimeCols =
/** @class */
function (_super) {
  __extends(ResourceDayTimeCols, _super);

  function ResourceDayTimeCols() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buildDayRanges = memoize(buildDayRanges);
    _this.splitter = new VResourceSplitter();
    _this.slicers = {};
    _this.joiner = new ResourceDayTimeColsJoiner();
    _this.timeColsRef = createRef();

    _this.isHitComboAllowed = function (hit0, hit1) {
      var allowAcrossResources = _this.dayRanges.length === 1;
      return allowAcrossResources || hit0.dateSpan.resourceId === hit1.dateSpan.resourceId;
    };

    return _this;
  }

  ResourceDayTimeCols.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var dateEnv = context.dateEnv,
        options = context.options;
    var dateProfile = props.dateProfile,
        resourceDayTableModel = props.resourceDayTableModel;
    var dayRanges = this.dayRanges = this.buildDayRanges(resourceDayTableModel.dayTableModel, dateProfile, dateEnv);
    var splitProps = this.splitter.splitProps(props);
    this.slicers = mapHash(splitProps, function (split, resourceId) {
      return _this.slicers[resourceId] || new DayTimeColsSlicer();
    });
    var slicedProps = mapHash(this.slicers, function (slicer, resourceId) {
      return slicer.sliceProps(splitProps[resourceId], dateProfile, null, context, dayRanges);
    });
    return (// TODO: would move this further down hierarchy, but sliceNowDate needs it
      vdom_createElement(NowTimer, {
        unit: options.nowIndicator ? 'minute' : 'day'
      }, function (nowDate, todayRange) {
        return vdom_createElement(TimeCols, _assign({
          ref: _this.timeColsRef
        }, _this.joiner.joinProps(slicedProps, resourceDayTableModel), {
          dateProfile: dateProfile,
          axis: props.axis,
          slotDuration: props.slotDuration,
          slatMetas: props.slatMetas,
          cells: resourceDayTableModel.cells[0],
          tableColGroupNode: props.tableColGroupNode,
          tableMinWidth: props.tableMinWidth,
          clientWidth: props.clientWidth,
          clientHeight: props.clientHeight,
          expandRows: props.expandRows,
          nowDate: nowDate,
          nowIndicatorSegs: options.nowIndicator && _this.buildNowIndicatorSegs(nowDate),
          todayRange: todayRange,
          onScrollTopRequest: props.onScrollTopRequest,
          forPrint: props.forPrint,
          onSlatCoords: props.onSlatCoords,
          isHitComboAllowed: _this.isHitComboAllowed
        }));
      })
    );
  };

  ResourceDayTimeCols.prototype.buildNowIndicatorSegs = function (date) {
    var nonResourceSegs = this.slicers[''].sliceNowDate(date, this.context, this.dayRanges);
    return this.joiner.expandSegs(this.props.resourceDayTableModel, nonResourceSegs);
  };

  return ResourceDayTimeCols;
}(DateComponent);

var ResourceDayTimeColsView =
/** @class */
function (_super) {
  __extends(ResourceDayTimeColsView, _super);

  function ResourceDayTimeColsView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.flattenResources = memoize(flattenResources);
    _this.buildResourceTimeColsModel = memoize(buildResourceTimeColsModel);
    _this.buildSlatMetas = memoize(buildSlatMetas);
    return _this;
  }

  ResourceDayTimeColsView.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options,
        dateEnv = context.dateEnv;
    var dateProfile = props.dateProfile;
    var splitProps = this.allDaySplitter.splitProps(props);
    var resourceOrderSpecs = options.resourceOrder || DEFAULT_RESOURCE_ORDER;
    var resources = this.flattenResources(props.resourceStore, resourceOrderSpecs);
    var resourceDayTableModel = this.buildResourceTimeColsModel(dateProfile, context.dateProfileGenerator, resources, options.datesAboveResources, context);
    var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
    var dayMinWidth = options.dayMinWidth;
    var hasAttachedAxis = !dayMinWidth;
    var hasDetachedAxis = dayMinWidth;
    var headerContent = options.dayHeaders && vdom_createElement(ResourceDayHeader, {
      resources: resources,
      dates: resourceDayTableModel.dayTableModel.headerDates,
      dateProfile: dateProfile,
      datesRepDistinctDays: true,
      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null
    });

    var allDayContent = options.allDaySlot !== false && function (contentArg) {
      return vdom_createElement(ResourceDayTable, _assign({}, splitProps.allDay, {
        dateProfile: dateProfile,
        resourceDayTableModel: resourceDayTableModel,
        nextDayThreshold: options.nextDayThreshold,
        tableMinWidth: contentArg.tableMinWidth,
        colGroupNode: contentArg.tableColGroupNode,
        renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,
        showWeekNumbers: false,
        expandRows: false,
        headerAlignElRef: _this.headerElRef,
        clientWidth: contentArg.clientWidth,
        clientHeight: contentArg.clientHeight,
        forPrint: props.forPrint
      }, _this.getAllDayMaxEventProps()));
    };

    var timeGridContent = function timeGridContent(contentArg) {
      return vdom_createElement(ResourceDayTimeCols, _assign({}, splitProps.timed, {
        dateProfile: dateProfile,
        axis: hasAttachedAxis,
        slotDuration: options.slotDuration,
        slatMetas: slatMetas,
        resourceDayTableModel: resourceDayTableModel,
        tableColGroupNode: contentArg.tableColGroupNode,
        tableMinWidth: contentArg.tableMinWidth,
        clientWidth: contentArg.clientWidth,
        clientHeight: contentArg.clientHeight,
        onSlatCoords: _this.handleSlatCoords,
        expandRows: contentArg.expandRows,
        forPrint: props.forPrint,
        onScrollTopRequest: _this.handleScrollTopRequest
      }));
    };

    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, resourceDayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
  };

  return ResourceDayTimeColsView;
}(TimeColsView);

function buildResourceTimeColsModel(dateProfile, dateProfileGenerator, resources, datesAboveResources, context) {
  var dayTable = buildTimeColsModel(dateProfile, dateProfileGenerator);
  return datesAboveResources ? new DayResourceTableModel(dayTable, resources, context) : new ResourceDayTableModel(dayTable, resources, context);
}

var resource_timegrid_main_main = createPlugin({
  deps: [premium_common_main, resource_common_main, _fullcalendar_timegrid_main],
  initialView: 'resourceTimeGridDay',
  views: {
    resourceTimeGrid: {
      type: 'timeGrid',
      component: ResourceDayTimeColsView,
      needsResourceData: true
    },
    resourceTimeGridDay: {
      type: 'resourceTimeGrid',
      duration: {
        days: 1
      }
    },
    resourceTimeGridWeek: {
      type: 'resourceTimeGrid',
      duration: {
        weeks: 1
      }
    }
  }
});
/* harmony default export */ var resource_timegrid_main = (resource_timegrid_main_main);

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/resource-timeline/main.css
// extracted by mini-css-extract-plugin
/* harmony default export */ var resource_timeline_main = ({});
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/timeline/main.css
// extracted by mini-css-extract-plugin
/* harmony default export */ var timeline_main = ({});
;// CONCATENATED MODULE: ./node_modules/@fullcalendar/scrollgrid/main.js
/*!
FullCalendar Scheduler v5.11.3
Docs & License: https://fullcalendar.io/scheduler
(c) 2022 Adam Shaw
*/



var WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');
/*
ALSO, with the ability to disable touch
*/

var ScrollListener =
/** @class */
function () {
  function ScrollListener(el) {
    var _this = this;

    this.el = el;
    this.emitter = new Emitter();
    this.isScrolling = false;
    this.isTouching = false; // user currently has finger down?

    this.isRecentlyWheeled = false;
    this.isRecentlyScrolled = false;
    this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));
    this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this)); // Handlers
    // ----------------------------------------------------------------------------------------------

    this.handleScroll = function () {
      _this.startScroll();

      _this.emitter.trigger('scroll', _this.isRecentlyWheeled, _this.isTouching);

      _this.isRecentlyScrolled = true;

      _this.scrollWaiter.request(500);
    }; // will fire *before* the scroll event is fired (might not cause a scroll)


    this.handleWheel = function () {
      _this.isRecentlyWheeled = true;

      _this.wheelWaiter.request(500);
    }; // will fire *before* the scroll event is fired (might not cause a scroll)


    this.handleTouchStart = function () {
      _this.isTouching = true;
    };

    this.handleTouchEnd = function () {
      _this.isTouching = false; // if the user ended their touch, and the scroll area wasn't moving,
      // we consider this to be the end of the scroll.

      if (!_this.isRecentlyScrolled) {
        _this.endScroll(); // won't fire if already ended

      }
    };

    el.addEventListener('scroll', this.handleScroll);
    el.addEventListener('touchstart', this.handleTouchStart, {
      passive: true
    });
    el.addEventListener('touchend', this.handleTouchEnd);

    for (var _i = 0, WHEEL_EVENT_NAMES_1 = WHEEL_EVENT_NAMES; _i < WHEEL_EVENT_NAMES_1.length; _i++) {
      var eventName = WHEEL_EVENT_NAMES_1[_i];
      el.addEventListener(eventName, this.handleWheel);
    }
  }

  ScrollListener.prototype.destroy = function () {
    var el = this.el;
    el.removeEventListener('scroll', this.handleScroll);
    el.removeEventListener('touchstart', this.handleTouchStart, {
      passive: true
    });
    el.removeEventListener('touchend', this.handleTouchEnd);

    for (var _i = 0, WHEEL_EVENT_NAMES_2 = WHEEL_EVENT_NAMES; _i < WHEEL_EVENT_NAMES_2.length; _i++) {
      var eventName = WHEEL_EVENT_NAMES_2[_i];
      el.removeEventListener(eventName, this.handleWheel);
    }
  }; // Start / Stop
  // ----------------------------------------------------------------------------------------------


  ScrollListener.prototype.startScroll = function () {
    if (!this.isScrolling) {
      this.isScrolling = true;
      this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);
    }
  };

  ScrollListener.prototype.endScroll = function () {
    if (this.isScrolling) {
      this.emitter.trigger('scrollEnd');
      this.isScrolling = false;
      this.isRecentlyScrolled = true;
      this.isRecentlyWheeled = false;
      this.scrollWaiter.clear();
      this.wheelWaiter.clear();
    }
  };

  ScrollListener.prototype._handleScrollWaited = function () {
    this.isRecentlyScrolled = false; // only end the scroll if not currently touching.
    // if touching, the scrolling will end later, on touchend.

    if (!this.isTouching) {
      this.endScroll(); // won't fire if already ended
    }
  };

  ScrollListener.prototype._handleWheelWaited = function () {
    this.isRecentlyWheeled = false;
  };

  return ScrollListener;
}(); // TODO: assume the el has no borders?


function getScrollCanvasOrigin(scrollEl) {
  var rect = scrollEl.getBoundingClientRect();
  var edges = computeEdges(scrollEl); // TODO: pass in isRtl?

  return {
    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),
    top: rect.top + edges.borderTop - scrollEl.scrollTop
  };
}

function getScrollFromLeftEdge(el) {
  var scrollLeft = el.scrollLeft;
  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?

  if (computedStyles.direction === 'rtl') {
    switch (getRtlScrollSystem()) {
      case 'negative':
        scrollLeft *= -1;
      // convert to 'reverse'. fall through...

      case 'reverse':
        // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge
        scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;
    }
  }

  return scrollLeft;
}

function setScrollFromLeftEdge(el, scrollLeft) {
  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?

  if (computedStyles.direction === 'rtl') {
    switch (getRtlScrollSystem()) {
      case 'reverse':
        scrollLeft = el.scrollWidth - scrollLeft;
        break;

      case 'negative':
        scrollLeft = -(el.scrollWidth - scrollLeft);
        break;
    }
  }

  el.scrollLeft = scrollLeft;
} // Horizontal Scroll System Detection
// ----------------------------------------------------------------------------------------------


var _rtlScrollSystem;

function getRtlScrollSystem() {
  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());
}

function detectRtlScrollSystem() {
  var el = document.createElement('div');
  el.style.position = 'absolute';
  el.style.top = '-1000px';
  el.style.width = '1px';
  el.style.height = '1px';
  el.style.overflow = 'scroll';
  el.style.direction = 'rtl';
  el.style.fontSize = '100px';
  el.innerHTML = 'A';
  document.body.appendChild(el);
  var system;

  if (el.scrollLeft > 0) {
    system = 'positive'; // scroll is a positive number from the left edge
  } else {
    el.scrollLeft = 1;

    if (el.scrollLeft > 0) {
      system = 'reverse'; // scroll is a positive number from the right edge
    } else {
      system = 'negative'; // scroll is a negative number from the right edge
    }
  }

  removeElement(el);
  return system;
}

var IS_MS_EDGE = typeof navigator !== 'undefined' && /Edge/.test(navigator.userAgent); // TODO: what about Chromeum-based Edge?

var STICKY_SELECTOR = '.fc-sticky';
/*
useful beyond the native position:sticky for these reasons:
- support in IE11
- nice centering support

REQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.
This is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.

TODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container
*/

var StickyScrolling =
/** @class */
function () {
  function StickyScrolling(scrollEl, isRtl) {
    var _this = this;

    this.scrollEl = scrollEl;
    this.isRtl = isRtl;
    this.usingRelative = null;

    this.updateSize = function () {
      var scrollEl = _this.scrollEl;
      var els = findElements(scrollEl, STICKY_SELECTOR);

      var elGeoms = _this.queryElGeoms(els);

      var viewportWidth = scrollEl.clientWidth;
      var viewportHeight = scrollEl.clientHeight;

      if (_this.usingRelative) {
        var elDestinations = _this.computeElDestinations(elGeoms, viewportWidth); // read before prepPositioning


        assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight);
      } else {
        assignStickyPositions(els, elGeoms, viewportWidth);
      }
    };

    this.usingRelative = !getStickySupported() || // IE11
    // https://stackoverflow.com/questions/56835658/in-microsoft-edge-sticky-positioning-doesnt-work-when-combined-with-dir-rtl
    IS_MS_EDGE && isRtl;

    if (this.usingRelative) {
      this.listener = new ScrollListener(scrollEl);
      this.listener.emitter.on('scrollEnd', this.updateSize);
    }
  }

  StickyScrolling.prototype.destroy = function () {
    if (this.listener) {
      this.listener.destroy();
    }
  };

  StickyScrolling.prototype.queryElGeoms = function (els) {
    var _a = this,
        scrollEl = _a.scrollEl,
        isRtl = _a.isRtl;

    var canvasOrigin = getScrollCanvasOrigin(scrollEl);
    var elGeoms = [];

    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
      var el = els_1[_i];
      var parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!
      -canvasOrigin.left, -canvasOrigin.top);
      var elRect = el.getBoundingClientRect();
      var computedStyles = window.getComputedStyle(el);
      var textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent

      var naturalBound = null;

      if (textAlign === 'start') {
        textAlign = isRtl ? 'right' : 'left';
      } else if (textAlign === 'end') {
        textAlign = isRtl ? 'left' : 'right';
      }

      if (computedStyles.position !== 'sticky') {
        naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'
        -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));
      }

      elGeoms.push({
        parentBound: parentBound,
        naturalBound: naturalBound,
        elWidth: elRect.width,
        elHeight: elRect.height,
        textAlign: textAlign
      });
    }

    return elGeoms;
  }; // only for IE


  StickyScrolling.prototype.computeElDestinations = function (elGeoms, viewportWidth) {
    var scrollEl = this.scrollEl;
    var viewportTop = scrollEl.scrollTop;
    var viewportLeft = getScrollFromLeftEdge(scrollEl);
    var viewportRight = viewportLeft + viewportWidth;
    return elGeoms.map(function (elGeom) {
      var elWidth = elGeom.elWidth,
          elHeight = elGeom.elHeight,
          parentBound = elGeom.parentBound,
          naturalBound = elGeom.naturalBound;
      var destLeft; // relative to canvas topleft

      var destTop; // "

      switch (elGeom.textAlign) {
        case 'left':
          destLeft = viewportLeft;
          break;

        case 'right':
          destLeft = viewportRight - elWidth;
          break;

        case 'center':
          destLeft = (viewportLeft + viewportRight) / 2 - elWidth / 2; /// noooo, use half-width insteadddddddd

          break;
      }

      destLeft = Math.min(destLeft, parentBound.right - elWidth);
      destLeft = Math.max(destLeft, parentBound.left);
      destTop = viewportTop;
      destTop = Math.min(destTop, parentBound.bottom - elHeight);
      destTop = Math.max(destTop, naturalBound.top); // better to use natural top for upper bound

      return {
        left: destLeft,
        top: destTop
      };
    });
  };

  return StickyScrolling;
}();

function assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight) {
  els.forEach(function (el, i) {
    var _a = elGeoms[i],
        naturalBound = _a.naturalBound,
        parentBound = _a.parentBound;
    var parentWidth = parentBound.right - parentBound.left;
    var parentHeight = parentBound.bottom - parentBound.bottom;
    var left;
    var top;

    if (parentWidth > viewportWidth || parentHeight > viewportHeight) {
      left = elDestinations[i].left - naturalBound.left;
      top = elDestinations[i].top - naturalBound.top;
    } else {
      // if parent container can be completely in view, we don't need stickiness
      left = '';
      top = '';
    }

    applyStyle(el, {
      position: 'relative',
      left: left,
      right: -left,
      top: top
    });
  });
}

function assignStickyPositions(els, elGeoms, viewportWidth) {
  els.forEach(function (el, i) {
    var _a = elGeoms[i],
        textAlign = _a.textAlign,
        elWidth = _a.elWidth,
        parentBound = _a.parentBound;
    var parentWidth = parentBound.right - parentBound.left;
    var left;

    if (textAlign === 'center' && parentWidth > viewportWidth) {
      left = (viewportWidth - elWidth) / 2;
    } else {
      // if parent container can be completely in view, we don't need stickiness
      left = '';
    }

    applyStyle(el, {
      left: left,
      right: left,
      top: 0
    });
  });
}

var _isStickySupported;

function getStickySupported() {
  if (_isStickySupported == null) {
    _isStickySupported = computeStickySupported();
  }

  return _isStickySupported;
}

function computeStickySupported() {
  var el = document.createElement('div');
  el.style.position = 'sticky';
  document.body.appendChild(el);
  var val = window.getComputedStyle(el).position;
  removeElement(el);
  return val === 'sticky';
}

var ClippedScroller =
/** @class */
function (_super) {
  __extends(ClippedScroller, _super);

  function ClippedScroller() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.elRef = createRef();
    _this.state = {
      xScrollbarWidth: 0,
      yScrollbarWidth: 0
    };

    _this.handleScroller = function (scroller) {
      _this.scroller = scroller;
      setRef(_this.props.scrollerRef, scroller);
    };

    _this.handleSizing = function () {
      var props = _this.props;

      if (props.overflowY === 'scroll-hidden') {
        _this.setState({
          yScrollbarWidth: _this.scroller.getYScrollbarWidth()
        });
      }

      if (props.overflowX === 'scroll-hidden') {
        _this.setState({
          xScrollbarWidth: _this.scroller.getXScrollbarWidth()
        });
      }
    };

    return _this;
  }

  ClippedScroller.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();
    var overcomeLeft = 0;
    var overcomeRight = 0;
    var overcomeBottom = 0;

    if (props.overflowX === 'scroll-hidden') {
      overcomeBottom = state.xScrollbarWidth;
    }

    if (props.overflowY === 'scroll-hidden') {
      if (state.yScrollbarWidth != null) {
        if (isScrollbarOnLeft) {
          overcomeLeft = state.yScrollbarWidth;
        } else {
          overcomeRight = state.yScrollbarWidth;
        }
      }
    }

    return vdom_createElement("div", {
      ref: this.elRef,
      className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '')
    }, vdom_createElement(Scroller, {
      ref: this.handleScroller,
      elRef: this.props.scrollerElRef,
      overflowX: props.overflowX === 'scroll-hidden' ? 'scroll' : props.overflowX,
      overflowY: props.overflowY === 'scroll-hidden' ? 'scroll' : props.overflowY,
      overcomeLeft: overcomeLeft,
      overcomeRight: overcomeRight,
      overcomeBottom: overcomeBottom,
      maxHeight: typeof props.maxHeight === 'number' ? props.maxHeight + (props.overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0) : '',
      liquid: props.liquid,
      liquidIsAbsolute: true
    }, props.children));
  };

  ClippedScroller.prototype.componentDidMount = function () {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  };

  ClippedScroller.prototype.componentDidUpdate = function (prevProps) {
    if (!isPropsEqual(prevProps, this.props)) {
      // an external change?
      this.handleSizing();
    }
  };

  ClippedScroller.prototype.componentWillUnmount = function () {
    this.context.removeResizeHandler(this.handleSizing);
  };

  ClippedScroller.prototype.needsXScrolling = function () {
    return this.scroller.needsXScrolling();
  };

  ClippedScroller.prototype.needsYScrolling = function () {
    return this.scroller.needsYScrolling();
  };

  return ClippedScroller;
}(BaseComponent);

var ScrollSyncer =
/** @class */
function () {
  function ScrollSyncer(isVertical, scrollEls) {
    var _this = this;

    this.isVertical = isVertical;
    this.scrollEls = scrollEls;
    this.isPaused = false;
    this.scrollListeners = scrollEls.map(function (el) {
      return _this.bindScroller(el);
    });
  }

  ScrollSyncer.prototype.destroy = function () {
    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {
      var scrollListener = _a[_i];
      scrollListener.destroy();
    }
  };

  ScrollSyncer.prototype.bindScroller = function (el) {
    var _this = this;

    var _a = this,
        scrollEls = _a.scrollEls,
        isVertical = _a.isVertical;

    var scrollListener = new ScrollListener(el);

    var onScroll = function onScroll(isWheel, isTouch) {
      if (!_this.isPaused) {
        if (!_this.masterEl || _this.masterEl !== el && (isWheel || isTouch)) {
          _this.assignMaster(el);
        }

        if (_this.masterEl === el) {
          // dealing with current
          for (var _i = 0, scrollEls_1 = scrollEls; _i < scrollEls_1.length; _i++) {
            var otherEl = scrollEls_1[_i];

            if (otherEl !== el) {
              if (isVertical) {
                otherEl.scrollTop = el.scrollTop;
              } else {
                otherEl.scrollLeft = el.scrollLeft;
              }
            }
          }
        }
      }
    };

    var onScrollEnd = function onScrollEnd() {
      if (_this.masterEl === el) {
        _this.masterEl = null;
      }
    };

    scrollListener.emitter.on('scroll', onScroll);
    scrollListener.emitter.on('scrollEnd', onScrollEnd);
    return scrollListener;
  };

  ScrollSyncer.prototype.assignMaster = function (el) {
    this.masterEl = el;

    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {
      var scrollListener = _a[_i];

      if (scrollListener.el !== el) {
        scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master
      }
    }
  };
  /*
  will normalize the scrollLeft value
  */


  ScrollSyncer.prototype.forceScrollLeft = function (scrollLeft) {
    this.isPaused = true;

    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {
      var listener = _a[_i];
      setScrollFromLeftEdge(listener.el, scrollLeft);
    }

    this.isPaused = false;
  };

  ScrollSyncer.prototype.forceScrollTop = function (top) {
    this.isPaused = true;

    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {
      var listener = _a[_i];
      listener.el.scrollTop = top;
    }

    this.isPaused = false;
  };

  return ScrollSyncer;
}();
/*
TODO: make <ScrollGridSection> subcomponent
NOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)
*/


var ScrollGrid =
/** @class */
function (_super) {
  __extends(ScrollGrid, _super);

  function ScrollGrid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);
    _this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers

    _this.clippedScrollerRefs = new RefMap(); // doesn't hold non-scrolling els used just for padding

    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));
    _this.chunkElRefs = new RefMap(_this._handleChunkEl.bind(_this));
    _this.stickyScrollings = [];
    _this.scrollSyncersBySection = {};
    _this.scrollSyncersByColumn = {}; // for row-height-syncing

    _this.rowUnstableMap = new Map(); // no need to groom. always self-cancels

    _this.rowInnerMaxHeightMap = new Map();
    _this.anyRowHeightsChanged = false;
    _this.recentSizingCnt = 0;
    _this.state = {
      shrinkWidths: [],
      forceYScrollbars: false,
      forceXScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {},
      sectionRowMaxHeights: []
    };

    _this.handleSizing = function (isForcedResize, sectionRowMaxHeightsChanged) {
      if (!_this.allowSizing()) {
        return;
      }

      if (!sectionRowMaxHeightsChanged) {
        // something else changed, probably external
        _this.anyRowHeightsChanged = true;
      }

      var otherState = {}; // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything

      if (isForcedResize || !sectionRowMaxHeightsChanged && !_this.rowUnstableMap.size) {
        otherState.sectionRowMaxHeights = _this.computeSectionRowMaxHeights();
      }

      _this.setState(_assign(_assign({
        shrinkWidths: _this.computeShrinkWidths()
      }, _this.computeScrollerDims()), otherState), function () {
        if (!_this.rowUnstableMap.size) {
          _this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM

        }
      });
    };

    _this.handleRowHeightChange = function (rowEl, isStable) {
      var _a = _this,
          rowUnstableMap = _a.rowUnstableMap,
          rowInnerMaxHeightMap = _a.rowInnerMaxHeightMap;

      if (!isStable) {
        rowUnstableMap.set(rowEl, true);
      } else {
        rowUnstableMap.delete(rowEl);
        var innerMaxHeight = getRowInnerMaxHeight(rowEl);

        if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {
          rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);
          _this.anyRowHeightsChanged = true;
        }

        if (!rowUnstableMap.size && _this.anyRowHeightsChanged) {
          _this.anyRowHeightsChanged = false;

          _this.setState({
            sectionRowMaxHeights: _this.computeSectionRowMaxHeights()
          });
        }
      }
    };

    return _this;
  }

  ScrollGrid.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var shrinkWidths = state.shrinkWidths;
    var colGroupStats = this.compileColGroupStats(props.colGroups.map(function (colGroup) {
      return [colGroup];
    }));
    var microColGroupNodes = this.renderMicroColGroups(colGroupStats.map(function (stat, i) {
      return [stat.cols, shrinkWidths[i]];
    }));
    var classNames = getScrollGridClassNames(props.liquid, context);

    var _b = this.getDims();

    _b[0];
    _b[1]; // TODO: make DRY

    var sectionConfigs = props.sections;
    var configCnt = sectionConfigs.length;
    var configI = 0;
    var currentConfig;
    var headSectionNodes = [];
    var bodySectionNodes = [];
    var footSectionNodes = [];

    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {
      headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));
      configI += 1;
    }

    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {
      bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));
      configI += 1;
    }

    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {
      footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));
      configI += 1;
    }

    var isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid

    var roleAttrs = {
      role: 'rowgroup'
    };
    return vdom_createElement('table', {
      ref: props.elRef,
      role: 'grid',
      className: classNames.join(' ')
    }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && vdom_createElement.apply(void 0, __spreadArray(['thead', roleAttrs], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && vdom_createElement.apply(void 0, __spreadArray(['tbody', roleAttrs], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && vdom_createElement.apply(void 0, __spreadArray(['tfoot', roleAttrs], footSectionNodes)), isBuggy && vdom_createElement.apply(void 0, __spreadArray(__spreadArray(__spreadArray(['tbody', roleAttrs], headSectionNodes), bodySectionNodes), footSectionNodes)));
  };

  ScrollGrid.prototype.renderSection = function (sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {
    var _this = this;

    if ('outerContent' in sectionConfig) {
      return vdom_createElement(vdom_Fragment, {
        key: sectionConfig.key
      }, sectionConfig.outerContent);
    }

    return vdom_createElement("tr", {
      key: sectionConfig.key,
      role: "presentation",
      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')
    }, sectionConfig.chunks.map(function (chunkConfig, i) {
      return _this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader);
    }));
  };

  ScrollGrid.prototype.renderChunk = function (sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {
    if ('outerContent' in chunkConfig) {
      return vdom_createElement(vdom_Fragment, {
        key: chunkConfig.key
      }, chunkConfig.outerContent);
    }

    var state = this.state;
    var scrollerClientWidths = state.scrollerClientWidths,
        scrollerClientHeights = state.scrollerClientHeights;

    var _a = this.getDims(),
        sectionCnt = _a[0],
        chunksPerSection = _a[1];

    var index = sectionIndex * chunksPerSection + chunkIndex;
    var sideScrollIndex = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;
    var isVScrollSide = chunkIndex === sideScrollIndex;
    var isLastSection = sectionIndex === sectionCnt - 1;
    var forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`

    var forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`

    var allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?

    var allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?

    var chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?

    var expandRows = sectionConfig.expandRows && chunkVGrow;
    var tableMinWidth = colGroupStat && colGroupStat.totalColMinWidth || '';
    var content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: tableMinWidth,
      clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,
      clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,
      expandRows: expandRows,
      syncRowHeights: Boolean(sectionConfig.syncRowHeights),
      rowSyncHeights: rowHeights,
      reportRowHeightChange: this.handleRowHeightChange
    }, isHeader);
    var overflowX = forceXScrollbars ? isLastSection ? 'scroll' : 'scroll-hidden' : !allowXScrolling ? 'hidden' : isLastSection ? 'auto' : 'scroll-hidden';
    var overflowY = forceYScrollbars ? isVScrollSide ? 'scroll' : 'scroll-hidden' : !allowYScrolling ? 'hidden' : isVScrollSide ? 'auto' : 'scroll-hidden'; // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,
    // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.

    content = vdom_createElement(ClippedScroller, {
      ref: this.clippedScrollerRefs.createRef(index),
      scrollerElRef: this.scrollerElRefs.createRef(index),
      overflowX: overflowX,
      overflowY: overflowY,
      liquid: chunkVGrow,
      maxHeight: sectionConfig.maxHeight
    }, content);
    return vdom_createElement(isHeader ? 'th' : 'td', {
      key: chunkConfig.key,
      ref: this.chunkElRefs.createRef(index),
      role: 'presentation'
    }, content);
  };

  ScrollGrid.prototype.componentDidMount = function () {
    this.getStickyScrolling = memoizeArraylike(initStickyScrolling, null, destroyStickyScrolling);
    this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);
    this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);
    this.updateScrollSyncers();
    this.handleSizing(false);
    this.context.addResizeHandler(this.handleSizing);
  };

  ScrollGrid.prototype.componentDidUpdate = function (prevProps, prevState) {
    this.updateScrollSyncers(); // TODO: need better solution when state contains non-sizing things

    this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);
  };

  ScrollGrid.prototype.componentWillUnmount = function () {
    this.context.removeResizeHandler(this.handleSizing);
    this.destroyStickyScrolling();
    this.destroyScrollSyncers();
  };

  ScrollGrid.prototype.allowSizing = function () {
    var now = new Date();

    if (!this.lastSizingDate || now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {
      this.lastSizingDate = now;
      this.recentSizingCnt = 0;
      return true;
    }

    return (this.recentSizingCnt += 1) <= 10;
  };

  ScrollGrid.prototype.computeShrinkWidths = function () {
    var _this = this;

    var colGroupStats = this.compileColGroupStats(this.props.colGroups.map(function (colGroup) {
      return [colGroup];
    }));

    var _a = this.getDims(),
        sectionCnt = _a[0],
        chunksPerSection = _a[1];

    var cnt = sectionCnt * chunksPerSection;
    var shrinkWidths = [];
    colGroupStats.forEach(function (colGroupStat, i) {
      if (colGroupStat.hasShrinkCol) {
        var chunkEls = _this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col


        shrinkWidths[i] = computeShrinkWidth(chunkEls);
      }
    });
    return shrinkWidths;
  }; // has the side effect of grooming rowInnerMaxHeightMap
  // TODO: somehow short-circuit if there are no new height changes


  ScrollGrid.prototype.computeSectionRowMaxHeights = function () {
    var newHeightMap = new Map();

    var _a = this.getDims(),
        sectionCnt = _a[0],
        chunksPerSection = _a[1];

    var sectionRowMaxHeights = [];

    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      var sectionConfig = this.props.sections[sectionI];
      var assignableHeights = []; // chunk, row

      if (sectionConfig && sectionConfig.syncRowHeights) {
        var rowHeightsByChunk = [];

        for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
          var index = sectionI * chunksPerSection + chunkI;
          var rowHeights = [];
          var chunkEl = this.chunkElRefs.currentMap[index];

          if (chunkEl) {
            rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map(function (rowEl) {
              var max = getRowInnerMaxHeight(rowEl);
              newHeightMap.set(rowEl, max);
              return max;
            });
          } else {
            rowHeights = [];
          }

          rowHeightsByChunk.push(rowHeights);
        }

        var rowCnt = rowHeightsByChunk[0].length;
        var isEqualRowCnt = true;

        for (var chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {
          var isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null

          if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) {
            // skip outer content
            isEqualRowCnt = false;
            break;
          }
        }

        if (!isEqualRowCnt) {
          var chunkHeightSums = [];

          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
            chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);
          }

          var maxTotalSum = Math.max.apply(Math, chunkHeightSums);

          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
            var rowInChunkCnt = rowHeightsByChunk[chunkI].length;
            var rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border
            // height of non-first row. we do this to avoid rounding, because it's unreliable within a table

            var rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt); // whatever is leftover goes to the first row

            var rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);
            var rowInChunkHeights = [];
            var row = 0;

            if (row < rowInChunkCnt) {
              rowInChunkHeights.push(rowInChunkHeightFirst);
              row += 1;
            }

            while (row < rowInChunkCnt) {
              rowInChunkHeights.push(rowInChunkHeightOthers);
              row += 1;
            }

            assignableHeights.push(rowInChunkHeights);
          }
        } else {
          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
            assignableHeights.push([]);
          }

          for (var row = 0; row < rowCnt; row += 1) {
            var rowHeightsAcrossChunks = [];

            for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
              var h = rowHeightsByChunk[chunkI][row];

              if (h != null) {
                // protect against outerContent
                rowHeightsAcrossChunks.push(h);
              }
            }

            var maxHeight = Math.max.apply(Math, rowHeightsAcrossChunks);

            for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
              assignableHeights[chunkI].push(maxHeight);
            }
          }
        }
      }

      sectionRowMaxHeights.push(assignableHeights);
    }

    this.rowInnerMaxHeightMap = newHeightMap;
    return sectionRowMaxHeights;
  };

  ScrollGrid.prototype.computeScrollerDims = function () {
    var scrollbarWidth = getScrollbarWidths();

    var _a = this.getDims(),
        sectionCnt = _a[0],
        chunksPerSection = _a[1];

    var sideScrollI = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;
    var lastSectionI = sectionCnt - 1;
    var currentScrollers = this.clippedScrollerRefs.currentMap;
    var scrollerEls = this.scrollerElRefs.currentMap;
    var forceYScrollbars = false;
    var forceXScrollbars = false;
    var scrollerClientWidths = {};
    var scrollerClientHeights = {};

    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      // along edge
      var index = sectionI * chunksPerSection + sideScrollI;
      var scroller = currentScrollers[index];

      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }

    for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
      // along last row
      var index = lastSectionI * chunksPerSection + chunkI;
      var scroller = currentScrollers[index];

      if (scroller && scroller.needsXScrolling()) {
        forceXScrollbars = true;
        break;
      }
    }

    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
        var index = sectionI * chunksPerSection + chunkI;
        var scrollerEl = scrollerEls[index];

        if (scrollerEl) {
          // TODO: weird way to get this. need harness b/c doesn't include table borders
          var harnessEl = scrollerEl.parentNode;
          scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - (chunkI === sideScrollI && forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future
          : 0));
          scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - (sectionI === lastSectionI && forceXScrollbars ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future
          : 0));
        }
      }
    }

    return {
      forceYScrollbars: forceYScrollbars,
      forceXScrollbars: forceXScrollbars,
      scrollerClientWidths: scrollerClientWidths,
      scrollerClientHeights: scrollerClientHeights
    };
  };

  ScrollGrid.prototype.updateStickyScrolling = function () {
    var isRtl = this.context.isRtl;
    var argsByKey = this.scrollerElRefs.getAll().map(function (scrollEl) {
      return [scrollEl, isRtl];
    });
    var stickyScrollings = this.getStickyScrolling(argsByKey);
    stickyScrollings.forEach(function (stickyScrolling) {
      return stickyScrolling.updateSize();
    });
    this.stickyScrollings = stickyScrollings;
  };

  ScrollGrid.prototype.destroyStickyScrolling = function () {
    this.stickyScrollings.forEach(destroyStickyScrolling);
  };

  ScrollGrid.prototype.updateScrollSyncers = function () {
    var _a = this.getDims(),
        sectionCnt = _a[0],
        chunksPerSection = _a[1];

    var cnt = sectionCnt * chunksPerSection;
    var scrollElsBySection = {};
    var scrollElsByColumn = {};
    var scrollElMap = this.scrollerElRefs.currentMap;

    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      var startIndex = sectionI * chunksPerSection;
      var endIndex = startIndex + chunksPerSection;
      scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered
    }

    for (var col = 0; col < chunksPerSection; col += 1) {
      scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered
    }

    this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);
    this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);
  };

  ScrollGrid.prototype.destroyScrollSyncers = function () {
    mapHash(this.scrollSyncersBySection, destroyScrollSyncer);
    mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);
  };

  ScrollGrid.prototype.getChunkConfigByIndex = function (index) {
    var chunksPerSection = this.getDims()[1];
    var sectionI = Math.floor(index / chunksPerSection);
    var chunkI = index % chunksPerSection;
    var sectionConfig = this.props.sections[sectionI];
    return sectionConfig && sectionConfig.chunks[chunkI];
  };

  ScrollGrid.prototype.forceScrollLeft = function (col, scrollLeft) {
    var scrollSyncer = this.scrollSyncersByColumn[col];

    if (scrollSyncer) {
      scrollSyncer.forceScrollLeft(scrollLeft);
    }
  };

  ScrollGrid.prototype.forceScrollTop = function (sectionI, scrollTop) {
    var scrollSyncer = this.scrollSyncersBySection[sectionI];

    if (scrollSyncer) {
      scrollSyncer.forceScrollTop(scrollTop);
    }
  };

  ScrollGrid.prototype._handleChunkEl = function (chunkEl, key) {
    var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));

    if (chunkConfig) {
      // null if section disappeared. bad, b/c won't null-set the elRef
      setRef(chunkConfig.elRef, chunkEl);
    }
  };

  ScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {
    var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));

    if (chunkConfig) {
      // null if section disappeared. bad, b/c won't null-set the elRef
      setRef(chunkConfig.scrollerElRef, scrollerEl);
    }
  };

  ScrollGrid.prototype.getDims = function () {
    var sectionCnt = this.props.sections.length;
    var chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;
    return [sectionCnt, chunksPerSection];
  };

  return ScrollGrid;
}(BaseComponent);

ScrollGrid.addStateEquality({
  shrinkWidths: isArraysEqual,
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});

function sumNumbers(numbers) {
  var sum = 0;

  for (var _i = 0, numbers_1 = numbers; _i < numbers_1.length; _i++) {
    var n = numbers_1[_i];
    sum += n;
  }

  return sum;
}

function getRowInnerMaxHeight(rowEl) {
  var innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);

  if (innerHeights.length) {
    return Math.max.apply(Math, innerHeights);
  }

  return 0;
}

function getElHeight(el) {
  return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent
}

function renderMacroColGroup(colGroupStats, shrinkWidths) {
  var children = colGroupStats.map(function (colGroupStat, i) {
    var width = colGroupStat.width;

    if (width === 'shrink') {
      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(
    }

    return (// eslint-disable-next-line react/jsx-key
      vdom_createElement("col", {
        style: {
          width: width
        }
      })
    );
  });
  return vdom_createElement.apply(void 0, __spreadArray(['colgroup', {}], children));
}

function compileColGroupStat(colGroupConfig) {
  var totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes "shrink"

  var totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');
  var hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);
  var allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);
  return {
    hasShrinkCol: hasShrinkCol,
    totalColWidth: totalColWidth,
    totalColMinWidth: totalColMinWidth,
    allowXScrolling: allowXScrolling,
    cols: colGroupConfig.cols,
    width: colGroupConfig.width
  };
}

function sumColProp(cols, propName) {
  var total = 0;

  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {
    var col = cols_1[_i];
    var val = col[propName];

    if (typeof val === 'number') {
      total += val * (col.span || 1);
    }
  }

  return total;
}

var COL_GROUP_STAT_EQUALITY = {
  cols: isColPropsEqual
};

function isColGroupStatsEqual(stat0, stat1) {
  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);
} // for memoizers...


function initScrollSyncer(isVertical) {
  var scrollEls = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    scrollEls[_i - 1] = arguments[_i];
  }

  return new ScrollSyncer(isVertical, scrollEls);
}

function destroyScrollSyncer(scrollSyncer) {
  scrollSyncer.destroy();
}

function initStickyScrolling(scrollEl, isRtl) {
  return new StickyScrolling(scrollEl, isRtl);
}

function destroyStickyScrolling(stickyScrolling) {
  stickyScrolling.destroy();
}

var scrollgrid_main_main = createPlugin({
  deps: [premium_common_main],
  scrollGridImpl: ScrollGrid
});
config.SCROLLGRID_RESIZE_INTERVAL = 500;
/* harmony default export */ var scrollgrid_main = ((/* unused pure expression or super */ null && (scrollgrid_main_main)));

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/timeline/main.js
/*!
FullCalendar Scheduler v5.11.3
Docs & License: https://fullcalendar.io/scheduler
(c) 2022 Adam Shaw
*/





var MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours

var MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour

var MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration

config.MAX_TIMELINE_SLOTS = 1000; // potential nice values for slot-duration and interval-duration

var main_STOCK_SUB_DURATIONS = [{
  years: 1
}, {
  months: 1
}, {
  days: 1
}, {
  hours: 1
}, {
  minutes: 30
}, {
  minutes: 15
}, {
  minutes: 10
}, {
  minutes: 5
}, {
  minutes: 1
}, {
  seconds: 30
}, {
  seconds: 15
}, {
  seconds: 10
}, {
  seconds: 5
}, {
  seconds: 1
}, {
  milliseconds: 500
}, {
  milliseconds: 100
}, {
  milliseconds: 10
}, {
  milliseconds: 1
}];

function buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {
  var tDateProfile = {
    labelInterval: allOptions.slotLabelInterval,
    slotDuration: allOptions.slotDuration
  };
  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration

  ensureLabelInterval(tDateProfile, dateProfile, dateEnv);
  ensureSlotDuration(tDateProfile, dateProfile, dateEnv);
  var input = allOptions.slotLabelFormat;
  var rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);
  tDateProfile.headerFormats = rawFormats.map(function (rawFormat) {
    return createFormatter(rawFormat);
  });
  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);
  var largeUnit = null;

  if (!tDateProfile.isTimeScale) {
    var slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;

    if (/year|month|week/.test(slotUnit)) {
      largeUnit = slotUnit;
    }
  }

  tDateProfile.largeUnit = largeUnit;
  tDateProfile.emphasizeWeeks = asCleanDays(tDateProfile.slotDuration) === 1 && currentRangeAs('weeks', dateProfile, dateEnv) >= 2 && !allOptions.businessHours;
  /*
  console.log('label interval =', timelineView.labelInterval.humanize())
  console.log('slot duration =', timelineView.slotDuration.humanize())
  console.log('header formats =', timelineView.headerFormats)
  console.log('isTimeScale', timelineView.isTimeScale)
  console.log('largeUnit', timelineView.largeUnit)
  */

  var rawSnapDuration = allOptions.snapDuration;
  var snapDuration;
  var snapsPerSlot;

  if (rawSnapDuration) {
    snapDuration = createDuration(rawSnapDuration);
    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration); // ^ TODO: warning if not whole?
  }

  if (snapsPerSlot == null) {
    snapDuration = tDateProfile.slotDuration;
    snapsPerSlot = 1;
  }

  tDateProfile.snapDuration = snapDuration;
  tDateProfile.snapsPerSlot = snapsPerSlot; // more...

  var timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime); // TODO: why not use normalizeRange!?

  var normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);
  var normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv); // apply slotMinTime/slotMaxTime
  // TODO: View should be responsible.

  if (tDateProfile.isTimeScale) {
    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);
    normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);
  }

  tDateProfile.timeWindowMs = timeWindowMs;
  tDateProfile.normalizedRange = {
    start: normalizedStart,
    end: normalizedEnd
  };
  var slotDates = [];
  var date = normalizedStart;

  while (date < normalizedEnd) {
    if (main_isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {
      slotDates.push(date);
    }

    date = dateEnv.add(date, tDateProfile.slotDuration);
  }

  tDateProfile.slotDates = slotDates; // more...

  var snapIndex = -1;
  var snapDiff = 0; // index of the diff :(

  var snapDiffToIndex = [];
  var snapIndexToDiff = [];
  date = normalizedStart;

  while (date < normalizedEnd) {
    if (main_isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {
      snapIndex += 1;
      snapDiffToIndex.push(snapIndex);
      snapIndexToDiff.push(snapDiff);
    } else {
      snapDiffToIndex.push(snapIndex + 0.5);
    }

    date = dateEnv.add(date, tDateProfile.snapDuration);
    snapDiff += 1;
  }

  tDateProfile.snapDiffToIndex = snapDiffToIndex;
  tDateProfile.snapIndexToDiff = snapIndexToDiff;
  tDateProfile.snapCnt = snapIndex + 1; // is always one behind

  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot; // more...

  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);
  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);
  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);
  return tDateProfile;
}
/*
snaps to appropriate unit
*/


function normalizeDate(date, tDateProfile, dateEnv) {
  var normalDate = date;

  if (!tDateProfile.isTimeScale) {
    normalDate = startOfDay(normalDate);

    if (tDateProfile.largeUnit) {
      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);
    }
  }

  return normalDate;
}
/*
snaps to appropriate unit
*/


function normalizeRange(range, tDateProfile, dateEnv) {
  if (!tDateProfile.isTimeScale) {
    range = computeVisibleDayRange(range);

    if (tDateProfile.largeUnit) {
      var dayRange = range; // preserve original result

      range = {
        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),
        end: dateEnv.startOf(range.end, tDateProfile.largeUnit)
      }; // if date is partially through the interval, or is in the same interval as the start,
      // make the exclusive end be the *next* interval

      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {
        range = {
          start: range.start,
          end: dateEnv.add(range.end, tDateProfile.slotDuration)
        };
      }
    }
  }

  return range;
}

function main_isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {
  if (dateProfileGenerator.isHiddenDay(date)) {
    return false;
  }

  if (tDateProfile.isTimeScale) {
    // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values
    var day = startOfDay(date);
    var timeMs = date.valueOf() - day.valueOf();
    var ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime

    ms = (ms % 86400000 + 86400000) % 86400000; // make negative values wrap to 24hr clock

    return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?
  }

  return true;
}

function validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {
  var currentRange = dateProfile.currentRange; // make sure labelInterval doesn't exceed the max number of cells

  if (tDateProfile.labelInterval) {
    var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);

    if (labelCnt > config.MAX_TIMELINE_SLOTS) {
      console.warn('slotLabelInterval results in too many cells');
      tDateProfile.labelInterval = null;
    }
  } // make sure slotDuration doesn't exceed the maximum number of cells


  if (tDateProfile.slotDuration) {
    var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);

    if (slotCnt > config.MAX_TIMELINE_SLOTS) {
      console.warn('slotDuration results in too many cells');
      tDateProfile.slotDuration = null;
    }
  } // make sure labelInterval is a multiple of slotDuration


  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {
    var slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);

    if (slotsPerLabel === null || slotsPerLabel < 1) {
      console.warn('slotLabelInterval must be a multiple of slotDuration');
      tDateProfile.slotDuration = null;
    }
  }
}

function ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {
  var currentRange = dateProfile.currentRange;
  var labelInterval = tDateProfile.labelInterval;

  if (!labelInterval) {
    // compute based off the slot duration
    // find the largest label interval with an acceptable slots-per-label
    var input = void 0;

    if (tDateProfile.slotDuration) {
      for (var _i = 0, STOCK_SUB_DURATIONS_1 = main_STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_1.length; _i++) {
        input = STOCK_SUB_DURATIONS_1[_i];
        var tryLabelInterval = createDuration(input);
        var slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);

        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {
          labelInterval = tryLabelInterval;
          break;
        }
      } // use the slot duration as a last resort


      if (!labelInterval) {
        labelInterval = tDateProfile.slotDuration;
      } // compute based off the view's duration
      // find the largest label interval that yields the minimum number of labels

    } else {
      for (var _a = 0, STOCK_SUB_DURATIONS_2 = main_STOCK_SUB_DURATIONS; _a < STOCK_SUB_DURATIONS_2.length; _a++) {
        input = STOCK_SUB_DURATIONS_2[_a];
        labelInterval = createDuration(input);
        var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);

        if (labelCnt >= MIN_AUTO_LABELS) {
          break;
        }
      }
    }

    tDateProfile.labelInterval = labelInterval;
  }

  return labelInterval;
}

function ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {
  var currentRange = dateProfile.currentRange;
  var slotDuration = tDateProfile.slotDuration;

  if (!slotDuration) {
    var labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary
    // compute based off the label interval
    // find the largest slot duration that is different from labelInterval, but still acceptable

    for (var _i = 0, STOCK_SUB_DURATIONS_3 = main_STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_3.length; _i++) {
      var input = STOCK_SUB_DURATIONS_3[_i];
      var trySlotDuration = createDuration(input);
      var slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);

      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {
        slotDuration = trySlotDuration;
        break;
      }
    } // only allow the value if it won't exceed the view's # of slots limit


    if (slotDuration) {
      var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);

      if (slotCnt > MAX_AUTO_CELLS) {
        slotDuration = null;
      }
    } // use the label interval as a last resort


    if (!slotDuration) {
      slotDuration = labelInterval;
    }

    tDateProfile.slotDuration = slotDuration;
  }

  return slotDuration;
}

function computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {
  var format1;
  var format2;
  var labelInterval = tDateProfile.labelInterval;
  var unit = greatestDurationDenominator(labelInterval).unit;
  var weekNumbersVisible = allOptions.weekNumbers;
  var format0 = format1 = format2 = null; // NOTE: weekNumber computation function wont work

  if (unit === 'week' && !weekNumbersVisible) {
    unit = 'day';
  }

  switch (unit) {
    case 'year':
      format0 = {
        year: 'numeric'
      }; // '2015'

      break;

    case 'month':
      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {
        format0 = {
          year: 'numeric'
        }; // '2015'
      }

      format1 = {
        month: 'short'
      }; // 'Jan'

      break;

    case 'week':
      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {
        format0 = {
          year: 'numeric'
        }; // '2015'
      }

      format1 = {
        week: 'narrow'
      }; // 'Wk4'

      break;

    case 'day':
      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {
        format0 = {
          year: 'numeric',
          month: 'long'
        }; // 'January 2014'
      } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {
        format0 = {
          month: 'long'
        }; // 'January'
      }

      if (weekNumbersVisible) {
        format1 = {
          week: 'short'
        }; // 'Wk 4'
      }

      format2 = {
        weekday: 'narrow',
        day: 'numeric'
      }; // 'Su 9'

      break;

    case 'hour':
      if (weekNumbersVisible) {
        format0 = {
          week: 'short'
        }; // 'Wk 4'
      }

      if (currentRangeAs('days', dateProfile, dateEnv) > 1) {
        format1 = {
          weekday: 'short',
          day: 'numeric',
          month: 'numeric',
          omitCommas: true
        }; // Sat 4/7
      }

      format2 = {
        hour: 'numeric',
        minute: '2-digit',
        omitZeroMinute: true,
        meridiem: 'short'
      };
      break;

    case 'minute':
      // sufficiently large number of different minute cells?
      if (asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {
        format0 = {
          hour: 'numeric',
          meridiem: 'short'
        };

        format1 = function format1(params) {
          return ':' + padStart(params.date.minute, 2) // ':30'
          ;
        };
      } else {
        format0 = {
          hour: 'numeric',
          minute: 'numeric',
          meridiem: 'short'
        };
      }

      break;

    case 'second':
      // sufficiently large number of different second cells?
      if (asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {
        format0 = {
          hour: 'numeric',
          minute: '2-digit',
          meridiem: 'lowercase'
        }; // '8:30 PM'

        format1 = function format1(params) {
          return ':' + padStart(params.date.second, 2) // ':30'
          ;
        };
      } else {
        format0 = {
          hour: 'numeric',
          minute: '2-digit',
          second: '2-digit',
          meridiem: 'lowercase'
        }; // '8:30:45 PM'
      }

      break;

    case 'millisecond':
      format0 = {
        hour: 'numeric',
        minute: '2-digit',
        second: '2-digit',
        meridiem: 'lowercase'
      }; // '8:30:45 PM'

      format1 = function format1(params) {
        return '.' + padStart(params.millisecond, 3);
      };

      break;
  }

  return [].concat(format0 || [], format1 || [], format2 || []);
} // Compute the number of the give units in the "current" range.
// Won't go more precise than days.
// Will return `0` if there's not a clean whole interval.


function currentRangeAs(unit, dateProfile, dateEnv) {
  var range = dateProfile.currentRange;
  var res = null;

  if (unit === 'years') {
    res = dateEnv.diffWholeYears(range.start, range.end);
  } else if (unit === 'months') {
    res = dateEnv.diffWholeMonths(range.start, range.end);
  } else if (unit === 'weeks') {
    res = dateEnv.diffWholeMonths(range.start, range.end);
  } else if (unit === 'days') {
    res = diffWholeDays(range.start, range.end);
  }

  return res || 0;
}

function buildIsWeekStarts(tDateProfile, dateEnv) {
  var slotDates = tDateProfile.slotDates,
      emphasizeWeeks = tDateProfile.emphasizeWeeks;
  var prevWeekNumber = null;
  var isWeekStarts = [];

  for (var _i = 0, slotDates_1 = slotDates; _i < slotDates_1.length; _i++) {
    var slotDate = slotDates_1[_i];
    var weekNumber = dateEnv.computeWeekNumber(slotDate);
    var isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;
    prevWeekNumber = weekNumber;
    isWeekStarts.push(isWeekStart);
  }

  return isWeekStarts;
}

function buildCellRows(tDateProfile, dateEnv) {
  var slotDates = tDateProfile.slotDates;
  var formats = tDateProfile.headerFormats;
  var cellRows = formats.map(function () {
    return [];
  }); // indexed by row,col

  var slotAsDays = asCleanDays(tDateProfile.slotDuration);
  var guessedSlotUnit = slotAsDays === 7 ? 'week' : slotAsDays === 1 ? 'day' : null; // specifically for navclicks

  var rowUnitsFromFormats = formats.map(function (format) {
    return format.getLargestUnit ? format.getLargestUnit() : null;
  }); // builds cellRows and slotCells

  for (var i = 0; i < slotDates.length; i += 1) {
    var date = slotDates[i];
    var isWeekStart = tDateProfile.isWeekStarts[i];

    for (var row = 0; row < formats.length; row += 1) {
      var format = formats[row];
      var rowCells = cellRows[row];
      var leadingCell = rowCells[rowCells.length - 1];
      var isLastRow = row === formats.length - 1;
      var isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last

      var newCell = null;
      var rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);

      if (isSuperRow) {
        var text = dateEnv.format(date, format);

        if (!leadingCell || leadingCell.text !== text) {
          newCell = buildCellObject(date, text, rowUnit);
        } else {
          leadingCell.colspan += 1;
        }
      } else if (!leadingCell || isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {
        var text = dateEnv.format(date, format);
        newCell = buildCellObject(date, text, rowUnit);
      } else {
        leadingCell.colspan += 1;
      }

      if (newCell) {
        newCell.weekStart = isWeekStart;
        rowCells.push(newCell);
      }
    }
  }

  return cellRows;
}

function buildCellObject(date, text, rowUnit) {
  return {
    date: date,
    text: text,
    rowUnit: rowUnit,
    colspan: 1,
    isWeekStart: false
  };
}

var TimelineHeaderThInner =
/** @class */
function (_super) {
  __extends(TimelineHeaderThInner, _super);

  function TimelineHeaderThInner() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimelineHeaderThInner.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    return vdom_createElement(ContentHook, {
      hookProps: props.hookProps,
      content: context.options.slotLabelContent,
      defaultContent: timeline_main_renderInnerContent
    }, function (innerElRef, innerContent) {
      return vdom_createElement("a", _assign({
        ref: innerElRef,
        className: 'fc-timeline-slot-cushion fc-scrollgrid-sync-inner' + (props.isSticky ? ' fc-sticky' : '')
      }, props.navLinkAttrs), innerContent);
    });
  };

  return TimelineHeaderThInner;
}(BaseComponent);

function timeline_main_renderInnerContent(props) {
  return props.text;
}

function refineHookProps(input) {
  return {
    level: input.level,
    date: input.dateEnv.toDate(input.dateMarker),
    view: input.viewApi,
    text: input.text
  };
}

var TimelineHeaderTh =
/** @class */
function (_super) {
  __extends(TimelineHeaderTh, _super);

  function TimelineHeaderTh() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refineHookProps = memoizeObjArg(refineHookProps);
    _this.normalizeClassNames = buildClassNameNormalizer();
    _this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);
    return _this;
  }

  TimelineHeaderTh.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var dateEnv = context.dateEnv,
        options = context.options;
    var cell = props.cell,
        dateProfile = props.dateProfile,
        tDateProfile = props.tDateProfile; // the cell.rowUnit is f'd
    // giving 'month' for a 3-day view
    // workaround: to infer day, do NOT time

    var dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);
    var classNames = ['fc-timeline-slot', 'fc-timeline-slot-label'].concat(cell.rowUnit === 'time' // TODO: so slot classnames for week/month/bigger. see note above about rowUnit
    ? getSlotClassNames(dateMeta, context.theme) : getDayClassNames(dateMeta, context.theme));

    if (cell.isWeekStart) {
      classNames.push('fc-timeline-slot-em');
    }

    var hookProps = this.refineHookProps({
      level: props.rowLevel,
      dateMarker: cell.date,
      text: cell.text,
      dateEnv: context.dateEnv,
      viewApi: context.viewApi
    });
    var customClassNames = this.normalizeClassNames(options.slotLabelClassNames, hookProps);
    return vdom_createElement(MountHook, {
      hookProps: hookProps,
      didMount: options.slotLabelDidMount,
      willUnmount: options.slotLabelWillUnmount
    }, function (rootElRef) {
      return vdom_createElement("th", {
        ref: rootElRef,
        className: classNames.concat(customClassNames).join(' '),
        "data-date": dateEnv.formatIso(cell.date, {
          omitTime: !tDateProfile.isTimeScale,
          omitTimeZoneOffset: true
        }),
        colSpan: cell.colspan
      }, vdom_createElement("div", {
        className: "fc-timeline-slot-frame",
        style: {
          height: props.rowInnerHeight
        }
      }, vdom_createElement(TimelineHeaderThInner, {
        hookProps: hookProps,
        isSticky: props.isSticky,
        navLinkAttrs: _this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit)
      })));
    });
  };

  return TimelineHeaderTh;
}(BaseComponent);

function buildCellNavLinkAttrs(context, cellDate, rowUnit) {
  return rowUnit && rowUnit !== 'time' ? buildNavLinkAttrs(context, cellDate, rowUnit) : {};
}

var TimelineHeaderRows =
/** @class */
function (_super) {
  __extends(TimelineHeaderRows, _super);

  function TimelineHeaderRows() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimelineHeaderRows.prototype.render = function () {
    var _a = this.props,
        dateProfile = _a.dateProfile,
        tDateProfile = _a.tDateProfile,
        rowInnerHeights = _a.rowInnerHeights,
        todayRange = _a.todayRange,
        nowDate = _a.nowDate;
    var cellRows = tDateProfile.cellRows;
    return vdom_createElement(vdom_Fragment, null, cellRows.map(function (rowCells, rowLevel) {
      var isLast = rowLevel === cellRows.length - 1;
      var isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?

      var classNames = ['fc-timeline-header-row', isChrono ? 'fc-timeline-header-row-chrono' : ''];
      return (// eslint-disable-next-line react/no-array-index-key
        vdom_createElement("tr", {
          key: rowLevel,
          className: classNames.join(' ')
        }, rowCells.map(function (cell) {
          return vdom_createElement(TimelineHeaderTh, {
            key: cell.date.toISOString(),
            cell: cell,
            rowLevel: rowLevel,
            dateProfile: dateProfile,
            tDateProfile: tDateProfile,
            todayRange: todayRange,
            nowDate: nowDate,
            rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel],
            isSticky: !isLast
          });
        }))
      );
    }));
  };

  return TimelineHeaderRows;
}(BaseComponent);

var TimelineCoords =
/** @class */
function () {
  function TimelineCoords(slatRootEl, // okay to expose?
  slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {
    this.slatRootEl = slatRootEl;
    this.dateProfile = dateProfile;
    this.tDateProfile = tDateProfile;
    this.dateEnv = dateEnv;
    this.isRtl = isRtl;
    this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true, // isHorizontal
    false); // for the inner divs within the slats
    // used for event rendering and scrollTime, to disregard slat border

    this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true, // isHorizontal
    false);
  }

  TimelineCoords.prototype.isDateInRange = function (date) {
    return rangeContainsMarker(this.dateProfile.currentRange, date);
  }; // results range from negative width of area to 0


  TimelineCoords.prototype.dateToCoord = function (date) {
    var tDateProfile = this.tDateProfile;
    var snapCoverage = this.computeDateSnapCoverage(date);
    var slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;
    var slotIndex = Math.floor(slotCoverage);
    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);
    var partial = slotCoverage - slotIndex;

    var _a = this,
        innerCoordCache = _a.innerCoordCache,
        outerCoordCache = _a.outerCoordCache;

    if (this.isRtl) {
      return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial);
    }

    return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;
  };

  TimelineCoords.prototype.rangeToCoords = function (range) {
    return {
      start: this.dateToCoord(range.start),
      end: this.dateToCoord(range.end)
    };
  };

  TimelineCoords.prototype.durationToCoord = function (duration) {
    var _a = this,
        dateProfile = _a.dateProfile,
        tDateProfile = _a.tDateProfile,
        dateEnv = _a.dateEnv,
        isRtl = _a.isRtl;

    var coord = 0;

    if (dateProfile) {
      var date = dateEnv.add(dateProfile.activeRange.start, duration);

      if (!tDateProfile.isTimeScale) {
        date = startOfDay(date);
      }

      coord = this.dateToCoord(date); // hack to overcome the left borders of non-first slat

      if (!isRtl && coord) {
        coord += 1;
      }
    }

    return coord;
  };

  TimelineCoords.prototype.coordFromLeft = function (coord) {
    if (this.isRtl) {
      return this.outerCoordCache.originClientRect.width - coord;
    }

    return coord;
  }; // returned value is between 0 and the number of snaps


  TimelineCoords.prototype.computeDateSnapCoverage = function (date) {
    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);
  };

  return TimelineCoords;
}(); // returned value is between 0 and the number of snaps


function computeDateSnapCoverage(date, tDateProfile, dateEnv) {
  var snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);

  if (snapDiff < 0) {
    return 0;
  }

  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {
    return tDateProfile.snapCnt;
  }

  var snapDiffInt = Math.floor(snapDiff);
  var snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];

  if (isInt(snapCoverage)) {
    // not an in-between value
    snapCoverage += snapDiff - snapDiffInt; // add the remainder
  } else {
    // a fractional value, meaning the date is not visible
    // always round up in this case. works for start AND end dates in a range.
    snapCoverage = Math.ceil(snapCoverage);
  }

  return snapCoverage;
}

function coordToCss(hcoord, isRtl) {
  if (hcoord === null) {
    return {
      left: '',
      right: ''
    };
  }

  if (isRtl) {
    return {
      right: hcoord,
      left: ''
    };
  }

  return {
    left: hcoord,
    right: ''
  };
}

function coordsToCss(hcoords, isRtl) {
  if (!hcoords) {
    return {
      left: '',
      right: ''
    };
  }

  if (isRtl) {
    return {
      right: hcoords.start,
      left: -hcoords.end
    };
  }

  return {
    left: hcoords.start,
    right: -hcoords.end
  };
}

var TimelineHeader =
/** @class */
function (_super) {
  __extends(TimelineHeader, _super);

  function TimelineHeader() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();
    return _this;
  }

  TimelineHeader.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context; // TODO: very repetitive
    // TODO: make part of tDateProfile?


    var timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit; // WORKAROUND: make ignore slatCoords when out of sync with dateProfile

    var slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;
    return vdom_createElement(NowTimer, {
      unit: timerUnit
    }, function (nowDate, todayRange) {
      return vdom_createElement("div", {
        className: "fc-timeline-header",
        ref: _this.rootElRef
      }, vdom_createElement("table", {
        "aria-hidden": true,
        className: "fc-scrollgrid-sync-table",
        style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth
        }
      }, props.tableColGroupNode, vdom_createElement("tbody", null, vdom_createElement(TimelineHeaderRows, {
        dateProfile: props.dateProfile,
        tDateProfile: props.tDateProfile,
        nowDate: nowDate,
        todayRange: todayRange,
        rowInnerHeights: props.rowInnerHeights
      }))), context.options.nowIndicator && // need to have a container regardless of whether the current view has a visible now indicator
      // because apparently removal of the element resets the scroll for some reasons (issue #5351).
      // this issue doesn't happen for the timeline body however (
      vdom_createElement("div", {
        className: "fc-timeline-now-indicator-container"
      }, slatCoords && slatCoords.isDateInRange(nowDate) && vdom_createElement(NowIndicatorRoot, {
        isAxis: true,
        date: nowDate
      }, function (rootElRef, classNames, innerElRef, innerContent) {
        return vdom_createElement("div", {
          ref: rootElRef,
          className: ['fc-timeline-now-indicator-arrow'].concat(classNames).join(' '),
          style: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl)
        }, innerContent);
      })));
    });
  };

  TimelineHeader.prototype.componentDidMount = function () {
    this.updateSize();
  };

  TimelineHeader.prototype.componentDidUpdate = function () {
    this.updateSize();
  };

  TimelineHeader.prototype.updateSize = function () {
    if (this.props.onMaxCushionWidth) {
      this.props.onMaxCushionWidth(this.computeMaxCushionWidth());
    }
  };

  TimelineHeader.prototype.computeMaxCushionWidth = function () {
    return Math.max.apply(Math, findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map(function (el) {
      return el.getBoundingClientRect().width;
    }));
  };

  return TimelineHeader;
}(BaseComponent);

var TimelineSlatCell =
/** @class */
function (_super) {
  __extends(TimelineSlatCell, _super);

  function TimelineSlatCell() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimelineSlatCell.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var dateEnv = context.dateEnv,
        options = context.options,
        theme = context.theme;
    var date = props.date,
        tDateProfile = props.tDateProfile,
        isEm = props.isEm;
    var dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);
    var classNames = ['fc-timeline-slot', 'fc-timeline-slot-lane'];
    var dataAttrs = {
      'data-date': dateEnv.formatIso(date, {
        omitTimeZoneOffset: true,
        omitTime: !tDateProfile.isTimeScale
      })
    };

    var hookProps = _assign(_assign({
      date: dateEnv.toDate(props.date)
    }, dateMeta), {
      view: context.viewApi
    });

    if (isEm) {
      classNames.push('fc-timeline-slot-em');
    }

    if (tDateProfile.isTimeScale) {
      classNames.push(isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ? 'fc-timeline-slot-major' : 'fc-timeline-slot-minor');
    }

    classNames.push.apply(classNames, props.isDay ? getDayClassNames(dateMeta, theme) : getSlotClassNames(dateMeta, theme));
    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: options.slotLaneClassNames,
      content: options.slotLaneContent,
      didMount: options.slotLaneDidMount,
      willUnmount: options.slotLaneWillUnmount,
      elRef: props.elRef
    }, function (rootElRef, customClassNames, innerElRef, innerContent) {
      return vdom_createElement("td", _assign({
        ref: rootElRef,
        className: classNames.concat(customClassNames).join(' ')
      }, dataAttrs), vdom_createElement("div", {
        ref: innerElRef
      }, innerContent));
    });
  };

  return TimelineSlatCell;
}(BaseComponent);

var TimelineSlatsBody =
/** @class */
function (_super) {
  __extends(TimelineSlatsBody, _super);

  function TimelineSlatsBody() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimelineSlatsBody.prototype.render = function () {
    var props = this.props;
    var tDateProfile = props.tDateProfile,
        cellElRefs = props.cellElRefs;
    var slotDates = tDateProfile.slotDates,
        isWeekStarts = tDateProfile.isWeekStarts;
    var isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;
    return vdom_createElement("tbody", null, vdom_createElement("tr", null, slotDates.map(function (slotDate, i) {
      var key = slotDate.toISOString();
      return vdom_createElement(TimelineSlatCell, {
        key: key,
        elRef: cellElRefs.createRef(key),
        date: slotDate,
        dateProfile: props.dateProfile,
        tDateProfile: tDateProfile,
        nowDate: props.nowDate,
        todayRange: props.todayRange,
        isEm: isWeekStarts[i],
        isDay: isDay
      });
    })));
  };

  return TimelineSlatsBody;
}(BaseComponent);

var TimelineSlats =
/** @class */
function (_super) {
  __extends(TimelineSlats, _super);

  function TimelineSlats() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();
    _this.cellElRefs = new RefMap();

    _this.handleScrollRequest = function (request) {
      var onScrollLeftRequest = _this.props.onScrollLeftRequest;
      var coords = _this.coords;

      if (onScrollLeftRequest && coords) {
        if (request.time) {
          var scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));
          onScrollLeftRequest(scrollLeft);
        }

        return true;
      }

      return null; // best?
    };

    return _this;
  }

  TimelineSlats.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    return vdom_createElement("div", {
      className: "fc-timeline-slots",
      ref: this.rootElRef
    }, vdom_createElement("table", {
      "aria-hidden": true,
      className: context.theme.getClass('table'),
      style: {
        minWidth: props.tableMinWidth,
        width: props.clientWidth
      }
    }, props.tableColGroupNode, vdom_createElement(TimelineSlatsBody, {
      cellElRefs: this.cellElRefs,
      dateProfile: props.dateProfile,
      tDateProfile: props.tDateProfile,
      nowDate: props.nowDate,
      todayRange: props.todayRange
    })));
  };

  TimelineSlats.prototype.componentDidMount = function () {
    this.updateSizing();
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  };

  TimelineSlats.prototype.componentDidUpdate = function (prevProps) {
    this.updateSizing();
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  };

  TimelineSlats.prototype.componentWillUnmount = function () {
    this.scrollResponder.detach();

    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  };

  TimelineSlats.prototype.updateSizing = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    if (props.clientWidth !== null && // is sizing stable?
    this.scrollResponder // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder
    ) {
      var rootEl = this.rootElRef.current;

      if (rootEl.offsetWidth) {
        // not hidden by css
        this.coords = new TimelineCoords(this.rootElRef.current, main_collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);

        if (props.onCoords) {
          props.onCoords(this.coords);
        }

        this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state
      }
    }
  };

  TimelineSlats.prototype.positionToHit = function (leftPosition) {
    var outerCoordCache = this.coords.outerCoordCache;
    var _a = this.context,
        dateEnv = _a.dateEnv,
        isRtl = _a.isRtl;
    var tDateProfile = this.props.tDateProfile;
    var slatIndex = outerCoordCache.leftToIndex(leftPosition);

    if (slatIndex != null) {
      // somewhat similar to what TimeGrid does. consolidate?
      var slatWidth = outerCoordCache.getWidth(slatIndex);
      var partial = isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;
      var localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);
      var start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));
      var end = dateEnv.add(start, tDateProfile.snapDuration);
      return {
        dateSpan: {
          range: {
            start: start,
            end: end
          },
          allDay: !this.props.tDateProfile.isTimeScale
        },
        dayEl: this.cellElRefs.currentMap[slatIndex],
        left: outerCoordCache.lefts[slatIndex],
        right: outerCoordCache.rights[slatIndex]
      };
    }

    return null;
  };

  return TimelineSlats;
}(BaseComponent);

function main_collectCellEls(elMap, slotDates) {
  return slotDates.map(function (slotDate) {
    var key = slotDate.toISOString();
    return elMap[key];
  });
}

function computeSegHCoords(segs, minWidth, timelineCoords) {
  var hcoords = [];

  if (timelineCoords) {
    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
      var seg = segs_1[_i];
      var res = timelineCoords.rangeToCoords(seg);
      var start = Math.round(res.start); // for barely-overlapping collisions

      var end = Math.round(res.end); //

      if (end - start < minWidth) {
        end = start + minWidth;
      }

      hcoords.push({
        start: start,
        end: end
      });
    }
  }

  return hcoords;
}

function main_computeFgSegPlacements(segs, segHCoords, // might not have for every seg
eventInstanceHeights, // might not have for every seg
moreLinkHeights, // might not have for every more-link
strictOrder, maxStackCnt) {
  var segInputs = [];
  var crudePlacements = []; // when we don't know dims

  for (var i = 0; i < segs.length; i += 1) {
    var seg = segs[i];
    var instanceId = seg.eventRange.instance.instanceId;
    var height = eventInstanceHeights[instanceId];
    var hcoords = segHCoords[i];

    if (height && hcoords) {
      segInputs.push({
        index: i,
        span: hcoords,
        thickness: height
      });
    } else {
      crudePlacements.push({
        seg: seg,
        hcoords: hcoords,
        top: null
      });
    }
  }

  var hierarchy = new SegHierarchy();

  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }

  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }

  var hiddenEntries = hierarchy.addSegs(segInputs);
  var hiddenPlacements = hiddenEntries.map(function (entry) {
    return {
      seg: segs[entry.index],
      hcoords: entry.span,
      top: null
    };
  });
  var hiddenGroups = groupIntersectingEntries(hiddenEntries);
  var moreLinkInputs = [];
  var moreLinkCrudePlacements = [];

  var extractSeg = function extractSeg(entry) {
    return segs[entry.index];
  };

  for (var i = 0; i < hiddenGroups.length; i += 1) {
    var hiddenGroup = hiddenGroups[i];
    var sortedSegs = hiddenGroup.entries.map(extractSeg);
    var height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(

    if (height != null) {
      // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.
      moreLinkInputs.push({
        index: segs.length + i,
        thickness: height,
        span: hiddenGroup.span
      });
    } else {
      moreLinkCrudePlacements.push({
        seg: sortedSegs,
        hcoords: hiddenGroup.span,
        top: null
      });
    }
  } // add more-links into the hierarchy, but don't limit


  hierarchy.maxStackCnt = -1;
  hierarchy.addSegs(moreLinkInputs);
  var visibleRects = hierarchy.toRects();
  var visiblePlacements = [];
  var maxHeight = 0;

  for (var _i = 0, visibleRects_1 = visibleRects; _i < visibleRects_1.length; _i++) {
    var rect = visibleRects_1[_i];
    var segIndex = rect.index;
    visiblePlacements.push({
      seg: segIndex < segs.length ? segs[segIndex] // a real seg
      : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),
      hcoords: rect.span,
      top: rect.levelCoord
    });
    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);
  }

  return [visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements), maxHeight];
}

var TimelineLaneBg =
/** @class */
function (_super) {
  __extends(TimelineLaneBg, _super);

  function TimelineLaneBg() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimelineLaneBg.prototype.render = function () {
    var props = this.props;
    var highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);
    return props.timelineCoords && vdom_createElement("div", {
      className: "fc-timeline-bg"
    }, this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'), this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'), this.renderSegs(highlightSeg, props.timelineCoords, 'highlight'));
  };

  TimelineLaneBg.prototype.renderSegs = function (segs, timelineCoords, fillType) {
    var _a = this.props,
        todayRange = _a.todayRange,
        nowDate = _a.nowDate;
    var isRtl = this.context.isRtl;
    var segHCoords = computeSegHCoords(segs, 0, timelineCoords);
    var children = segs.map(function (seg, i) {
      var hcoords = segHCoords[i];
      var hStyle = coordsToCss(hcoords, isRtl);
      return vdom_createElement("div", {
        key: buildEventRangeKey(seg.eventRange),
        className: "fc-timeline-bg-harness",
        style: hStyle
      }, fillType === 'bg-event' ? vdom_createElement(BgEvent, _assign({
        seg: seg
      }, getSegMeta(seg, todayRange, nowDate))) : renderFill(fillType));
    });
    return vdom_createElement(vdom_Fragment, null, children);
  };

  return TimelineLaneBg;
}(BaseComponent);

var TimelineLaneSlicer =
/** @class */
function (_super) {
  __extends(TimelineLaneSlicer, _super);

  function TimelineLaneSlicer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimelineLaneSlicer.prototype.sliceRange = function (origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {
    var normalRange = normalizeRange(origRange, tDateProfile, dateEnv);
    var segs = []; // protect against when the span is entirely in an invalid date region

    if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv) < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {
      // intersect the footprint's range with the grid's range
      var slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);

      if (slicedRange) {
        segs.push({
          start: slicedRange.start,
          end: slicedRange.end,
          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && main_isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),
          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && main_isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator)
        });
      }
    }

    return segs;
  };

  return TimelineLaneSlicer;
}(Slicer);

var timeline_main_DEFAULT_TIME_FORMAT = createFormatter({
  hour: 'numeric',
  minute: '2-digit',
  omitZeroMinute: true,
  meridiem: 'narrow'
});

var TimelineEvent =
/** @class */
function (_super) {
  __extends(TimelineEvent, _super);

  function TimelineEvent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimelineEvent.prototype.render = function () {
    var props = this.props;
    return vdom_createElement(StandardEvent, _assign({}, props, {
      extraClassNames: ['fc-timeline-event', 'fc-h-event'],
      defaultTimeFormat: timeline_main_DEFAULT_TIME_FORMAT,
      defaultDisplayEventTime: !props.isTimeScale
    }));
  };

  return TimelineEvent;
}(BaseComponent);

var TimelineLaneMoreLink =
/** @class */
function (_super) {
  __extends(TimelineLaneMoreLink, _super);

  function TimelineLaneMoreLink() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();
    return _this;
  }

  TimelineLaneMoreLink.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var hiddenSegs = props.hiddenSegs,
        elRef = props.elRef,
        placement = props.placement,
        resourceId = props.resourceId;
    var top = placement.top,
        hcoords = placement.hcoords;
    var isVisible = hcoords && top !== null;
    var hStyle = coordsToCss(hcoords, context.isRtl);
    var extraDateSpan = resourceId ? {
      resourceId: resourceId
    } : {};
    return vdom_createElement(MoreLinkRoot, {
      allDayDate: null,
      moreCnt: hiddenSegs.length,
      allSegs: hiddenSegs,
      hiddenSegs: hiddenSegs,
      alignmentElRef: this.rootElRef,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      extraDateSpan: extraDateSpan,
      popoverContent: function popoverContent() {
        return vdom_createElement(vdom_Fragment, null, hiddenSegs.map(function (seg) {
          var instanceId = seg.eventRange.instance.instanceId;
          return vdom_createElement("div", {
            key: instanceId,
            style: {
              visibility: props.isForcedInvisible[instanceId] ? 'hidden' : ''
            }
          }, vdom_createElement(TimelineEvent, _assign({
            isTimeScale: props.isTimeScale,
            seg: seg,
            isDragging: false,
            isResizing: false,
            isDateSelecting: false,
            isSelected: instanceId === props.eventSelection
          }, getSegMeta(seg, props.todayRange, props.nowDate))));
        }));
      }
    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {
      return vdom_createElement("a", {
        ref: function ref(el) {
          setRef(rootElRef, el); // for MoreLinkRoot

          setRef(elRef, el); // for props props

          setRef(_this.rootElRef, el); // for this component
        },
        className: ['fc-timeline-more-link'].concat(classNames).join(' '),
        style: _assign({
          visibility: isVisible ? '' : 'hidden',
          top: top || 0
        }, hStyle),
        onClick: handleClick,
        title: title,
        "aria-expanded": isExpanded,
        "aria-controls": popoverId
      }, vdom_createElement("div", {
        ref: innerElRef,
        className: "fc-timeline-more-link-inner fc-sticky"
      }, innerContent));
    });
  };

  return TimelineLaneMoreLink;
}(BaseComponent);

var TimelineLane =
/** @class */
function (_super) {
  __extends(TimelineLane, _super);

  function TimelineLane() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.slicer = new TimelineLaneSlicer();
    _this.sortEventSegs = memoize(sortEventSegs);
    _this.harnessElRefs = new RefMap();
    _this.moreElRefs = new RefMap();
    _this.innerElRef = createRef(); // TODO: memoize event positioning

    _this.state = {
      eventInstanceHeights: {},
      moreLinkHeights: {}
    };
    return _this;
  }

  TimelineLane.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var options = context.options;
    var dateProfile = props.dateProfile,
        tDateProfile = props.tDateProfile;
    var slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't have to pass in the rest of the args...
    dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);
    var mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) || (slicedProps.eventResize ? slicedProps.eventResize.segs : null) || [];
    var fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);
    var fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);

    var _b = main_computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack),
        fgPlacements = _b[0],
        fgHeight = _b[1];

    var isForcedInvisible = // TODO: more convenient
    (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) || (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) || {};
    return vdom_createElement(vdom_Fragment, null, vdom_createElement(TimelineLaneBg, {
      businessHourSegs: slicedProps.businessHourSegs,
      bgEventSegs: slicedProps.bgEventSegs,
      timelineCoords: props.timelineCoords,
      eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : []
      /* bad new empty array? */
      ,
      dateSelectionSegs: slicedProps.dateSelectionSegs,
      nowDate: props.nowDate,
      todayRange: props.todayRange
    }), vdom_createElement("div", {
      className: "fc-timeline-events fc-scrollgrid-sync-inner",
      ref: this.innerElRef,
      style: {
        height: fgHeight
      }
    }, this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false), this.renderFgSegs(main_buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false)));
  };

  TimelineLane.prototype.componentDidMount = function () {
    this.updateSize();
  };

  TimelineLane.prototype.componentDidUpdate = function (prevProps, prevState) {
    if (prevProps.eventStore !== this.props.eventStore || // external thing changed?
    prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?
    prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality
    ) {
      this.updateSize();
    }
  };

  TimelineLane.prototype.updateSize = function () {
    var props = this.props;
    var timelineCoords = props.timelineCoords;
    var innerEl = this.innerElRef.current;

    if (props.onHeightChange) {
      props.onHeightChange(innerEl, false);
    }

    if (timelineCoords) {
      this.setState({
        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, function (harnessEl) {
          return Math.round(harnessEl.getBoundingClientRect().height);
        }),
        moreLinkHeights: mapHash(this.moreElRefs.currentMap, function (moreEl) {
          return Math.round(moreEl.getBoundingClientRect().height);
        })
      }, function () {
        if (props.onHeightChange) {
          props.onHeightChange(innerEl, true);
        }
      });
    } // hack


    if (props.syncParentMinHeight) {
      innerEl.parentElement.style.minHeight = innerEl.style.height;
    }
  };

  TimelineLane.prototype.renderFgSegs = function (segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    var _a = this,
        harnessElRefs = _a.harnessElRefs,
        moreElRefs = _a.moreElRefs,
        props = _a.props,
        context = _a.context;

    var isMirror = isDragging || isResizing || isDateSelecting;
    return vdom_createElement(vdom_Fragment, null, segPlacements.map(function (segPlacement) {
      var seg = segPlacement.seg,
          hcoords = segPlacement.hcoords,
          top = segPlacement.top;

      if (Array.isArray(seg)) {
        // a more-link
        var isoStr = buildIsoString(computeEarliestSegStart(seg));
        return vdom_createElement(TimelineLaneMoreLink, {
          key: 'm:' + isoStr
          /* "m" for "more" */
          ,
          elRef: moreElRefs.createRef(isoStr),
          hiddenSegs: seg,
          placement: segPlacement,
          dateProfile: props.dateProfile,
          nowDate: props.nowDate,
          todayRange: props.todayRange,
          isTimeScale: props.tDateProfile.isTimeScale,
          eventSelection: props.eventSelection,
          resourceId: props.resourceId,
          isForcedInvisible: isForcedInvisible
        });
      }

      var instanceId = seg.eventRange.instance.instanceId;
      var isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);
      var hStyle = coordsToCss(hcoords, context.isRtl);
      return vdom_createElement("div", {
        key: 'e:' + instanceId
        /* "e" for "event" */
        ,
        ref: isMirror ? null : harnessElRefs.createRef(instanceId),
        className: "fc-timeline-event-harness",
        style: _assign({
          visibility: isVisible ? '' : 'hidden',
          top: top || 0
        }, hStyle)
      }, vdom_createElement(TimelineEvent, _assign({
        isTimeScale: props.tDateProfile.isTimeScale,
        seg: seg,
        isDragging: isDragging,
        isResizing: isResizing,
        isDateSelecting: isDateSelecting,
        isSelected: instanceId === props.eventSelection
        /* TODO: bad for mirror? */

      }, getSegMeta(seg, props.todayRange, props.nowDate))));
    }));
  };

  return TimelineLane;
}(BaseComponent);

TimelineLane.addStateEquality({
  eventInstanceHeights: isPropsEqual,
  moreLinkHeights: isPropsEqual
});

function main_buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {
  if (!mirrorSegs.length || !timelineCoords) {
    return [];
  }

  var topsByInstanceId = main_buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?

  return mirrorSegs.map(function (seg) {
    return {
      seg: seg,
      hcoords: timelineCoords.rangeToCoords(seg),
      top: topsByInstanceId[seg.eventRange.instance.instanceId]
    };
  });
}

function main_buildAbsoluteTopHash(placements) {
  var topsByInstanceId = {};

  for (var _i = 0, placements_1 = placements; _i < placements_1.length; _i++) {
    var placement = placements_1[_i];
    var seg = placement.seg;

    if (!Array.isArray(seg)) {
      // doesn't represent a more-link
      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;
    }
  }

  return topsByInstanceId;
}

var TimelineGrid =
/** @class */
function (_super) {
  __extends(TimelineGrid, _super);

  function TimelineGrid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.slatsRef = createRef();
    _this.state = {
      coords: null
    };

    _this.handeEl = function (el) {
      if (el) {
        _this.context.registerInteractiveComponent(_this, {
          el: el
        });
      } else {
        _this.context.unregisterInteractiveComponent(_this);
      }
    };

    _this.handleCoords = function (coords) {
      _this.setState({
        coords: coords
      });

      if (_this.props.onSlatCoords) {
        _this.props.onSlatCoords(coords);
      }
    };

    return _this;
  }

  TimelineGrid.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var options = context.options;
    var dateProfile = props.dateProfile,
        tDateProfile = props.tDateProfile;
    var timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    return vdom_createElement("div", {
      className: "fc-timeline-body",
      ref: this.handeEl,
      style: {
        minWidth: props.tableMinWidth,
        height: props.clientHeight,
        width: props.clientWidth
      }
    }, vdom_createElement(NowTimer, {
      unit: timerUnit
    }, function (nowDate, todayRange) {
      return vdom_createElement(vdom_Fragment, null, vdom_createElement(TimelineSlats, {
        ref: _this.slatsRef,
        dateProfile: dateProfile,
        tDateProfile: tDateProfile,
        nowDate: nowDate,
        todayRange: todayRange,
        clientWidth: props.clientWidth,
        tableColGroupNode: props.tableColGroupNode,
        tableMinWidth: props.tableMinWidth,
        onCoords: _this.handleCoords,
        onScrollLeftRequest: props.onScrollLeftRequest
      }), vdom_createElement(TimelineLane, {
        dateProfile: dateProfile,
        tDateProfile: props.tDateProfile,
        nowDate: nowDate,
        todayRange: todayRange,
        nextDayThreshold: options.nextDayThreshold,
        businessHours: props.businessHours,
        eventStore: props.eventStore,
        eventUiBases: props.eventUiBases,
        dateSelection: props.dateSelection,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        timelineCoords: state.coords,
        syncParentMinHeight: true
      }), options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate) && vdom_createElement("div", {
        className: "fc-timeline-now-indicator-container"
      }, vdom_createElement(NowIndicatorRoot, {
        isAxis: false,
        date: nowDate
      }, function (rootElRef, classNames, innerElRef, innerContent) {
        return vdom_createElement("div", {
          ref: rootElRef,
          className: ['fc-timeline-now-indicator-line'].concat(classNames).join(' '),
          style: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl)
        }, innerContent);
      })));
    }));
  }; // Hit System
  // ------------------------------------------------------------------------------------------


  TimelineGrid.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
    var slats = this.slatsRef.current;
    var slatHit = slats.positionToHit(positionLeft);

    if (slatHit) {
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: slatHit.dateSpan,
        rect: {
          left: slatHit.left,
          right: slatHit.right,
          top: 0,
          bottom: elHeight
        },
        dayEl: slatHit.dayEl,
        layer: 0
      };
    }

    return null;
  };

  return TimelineGrid;
}(DateComponent);

var TimelineView =
/** @class */
function (_super) {
  __extends(TimelineView, _super);

  function TimelineView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);
    _this.scrollGridRef = createRef();
    _this.state = {
      slatCoords: null,
      slotCushionMaxWidth: null
    };

    _this.handleSlatCoords = function (slatCoords) {
      _this.setState({
        slatCoords: slatCoords
      });
    };

    _this.handleScrollLeftRequest = function (scrollLeft) {
      var scrollGrid = _this.scrollGridRef.current;
      scrollGrid.forceScrollLeft(0, scrollLeft);
    };

    _this.handleMaxCushionWidth = function (slotCushionMaxWidth) {
      _this.setState({
        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth) // for less rerendering TODO: DRY

      });
    };

    return _this;
  }

  TimelineView.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var options = context.options;
    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);
    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);
    var tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);
    var extraClassNames = ['fc-timeline', options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : ''];
    var slotMinWidth = options.slotMinWidth;
    var slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));
    var sections = [{
      type: 'header',
      key: 'header',
      isSticky: stickyHeaderDates,
      chunks: [{
        key: 'timeline',
        content: function content(contentArg) {
          return vdom_createElement(TimelineHeader, {
            dateProfile: props.dateProfile,
            clientWidth: contentArg.clientWidth,
            clientHeight: contentArg.clientHeight,
            tableMinWidth: contentArg.tableMinWidth,
            tableColGroupNode: contentArg.tableColGroupNode,
            tDateProfile: tDateProfile,
            slatCoords: state.slatCoords,
            onMaxCushionWidth: slotMinWidth ? null : _this.handleMaxCushionWidth
          });
        }
      }]
    }, {
      type: 'body',
      key: 'body',
      liquid: true,
      chunks: [{
        key: 'timeline',
        content: function content(contentArg) {
          return vdom_createElement(TimelineGrid, _assign({}, props, {
            clientWidth: contentArg.clientWidth,
            clientHeight: contentArg.clientHeight,
            tableMinWidth: contentArg.tableMinWidth,
            tableColGroupNode: contentArg.tableColGroupNode,
            tDateProfile: tDateProfile,
            onSlatCoords: _this.handleSlatCoords,
            onScrollLeftRequest: _this.handleScrollLeftRequest
          }));
        }
      }]
    }];

    if (stickyFooterScrollbar) {
      sections.push({
        type: 'footer',
        key: 'footer',
        isSticky: true,
        chunks: [{
          key: 'timeline',
          content: renderScrollShim
        }]
      });
    }

    return vdom_createElement(ViewRoot, {
      viewSpec: context.viewSpec
    }, function (rootElRef, classNames) {
      return vdom_createElement("div", {
        ref: rootElRef,
        className: extraClassNames.concat(classNames).join(' ')
      }, vdom_createElement(ScrollGrid, {
        ref: _this.scrollGridRef,
        liquid: !props.isHeightAuto && !props.forPrint,
        collapsibleWidth: false,
        colGroups: [{
          cols: slatCols
        }],
        sections: sections
      }));
    });
  };

  TimelineView.prototype.computeFallbackSlotMinWidth = function (tDateProfile) {
    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);
  };

  return TimelineView;
}(DateComponent);

function buildSlatCols(tDateProfile, slotMinWidth) {
  return [{
    span: tDateProfile.slotCnt,
    minWidth: slotMinWidth || 1 // needs to be a non-zero number to trigger horizontal scrollbars!??????

  }];
}

var timeline_main_main = createPlugin({
  deps: [premium_common_main],
  initialView: 'timelineDay',
  views: {
    timeline: {
      component: TimelineView,
      usesMinMaxTime: true,
      eventResizableFromStart: true // how is this consumed for TimelineView tho?

    },
    timelineDay: {
      type: 'timeline',
      duration: {
        days: 1
      }
    },
    timelineWeek: {
      type: 'timeline',
      duration: {
        weeks: 1
      }
    },
    timelineMonth: {
      type: 'timeline',
      duration: {
        months: 1
      }
    },
    timelineYear: {
      type: 'timeline',
      duration: {
        years: 1
      }
    }
  }
});
/* harmony default export */ var _fullcalendar_timeline_main = (timeline_main_main);

;// CONCATENATED MODULE: ./node_modules/@fullcalendar/resource-timeline/main.js
/*!
FullCalendar Scheduler v5.11.3
Docs & License: https://fullcalendar.io/scheduler
(c) 2022 Adam Shaw
*/







/*
Renders the DOM responsible for the subrow expander area,
as well as the space before it (used to align expanders of similar depths)
*/

function ExpanderIcon(_a) {
  var depth = _a.depth,
      hasChildren = _a.hasChildren,
      isExpanded = _a.isExpanded,
      onExpanderClick = _a.onExpanderClick;
  var nodes = [];

  for (var i = 0; i < depth; i += 1) {
    nodes.push(vdom_createElement("span", {
      className: "fc-icon"
    }));
  }

  var iconClassNames = ['fc-icon'];

  if (hasChildren) {
    if (isExpanded) {
      iconClassNames.push('fc-icon-minus-square');
    } else {
      iconClassNames.push('fc-icon-plus-square');
    }
  }

  nodes.push(vdom_createElement("span", {
    className: 'fc-datagrid-expander' + (hasChildren ? '' : ' fc-datagrid-expander-placeholder'),
    onClick: onExpanderClick
  }, vdom_createElement("span", {
    className: iconClassNames.join(' ')
  })));
  return vdom_createElement.apply(void 0, __spreadArray([vdom_Fragment, {}], nodes));
}

function refineHookProps$1(raw) {
  return {
    resource: new ResourceApi(raw.context, raw.resource),
    fieldValue: raw.fieldValue,
    view: raw.context.viewApi
  };
}

var SpreadsheetIndividualCellInner =
/** @class */
function (_super) {
  __extends(SpreadsheetIndividualCellInner, _super);

  function SpreadsheetIndividualCellInner() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SpreadsheetIndividualCellInner.prototype.render = function () {
    var props = this.props;
    return vdom_createElement(ContentHook, {
      hookProps: props.hookProps,
      content: props.colSpec.cellContent,
      defaultContent: renderResourceInner
    }, function (innerElRef, innerContent) {
      return vdom_createElement("span", {
        className: "fc-datagrid-cell-main",
        ref: innerElRef
      }, innerContent);
    });
  };

  return SpreadsheetIndividualCellInner;
}(BaseComponent);

function renderResourceInner(hookProps) {
  return hookProps.fieldValue || vdom_createElement(vdom_Fragment, null, "\xA0");
} // worth making a PureComponent? (because of innerHeight)


var SpreadsheetIndividualCell =
/** @class */
function (_super) {
  __extends(SpreadsheetIndividualCell, _super);

  function SpreadsheetIndividualCell() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refineHookProps = memoizeObjArg(refineHookProps$1);
    _this.normalizeClassNames = buildClassNameNormalizer();

    _this.onExpanderClick = function (ev) {
      var props = _this.props;

      if (props.hasChildren) {
        _this.context.dispatch({
          type: 'SET_RESOURCE_ENTITY_EXPANDED',
          id: props.resource.id,
          isExpanded: !props.isExpanded
        });
      }
    };

    return _this;
  }

  SpreadsheetIndividualCell.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var colSpec = props.colSpec;
    var hookProps = this.refineHookProps({
      resource: props.resource,
      fieldValue: props.fieldValue,
      context: context
    });
    var customClassNames = this.normalizeClassNames(colSpec.cellClassNames, hookProps);
    return vdom_createElement(MountHook, {
      hookProps: hookProps,
      didMount: colSpec.cellDidMount,
      willUnmount: colSpec.cellWillUnmount
    }, function (rootElRef) {
      return vdom_createElement("td", {
        ref: rootElRef,
        role: "gridcell",
        "data-resource-id": props.resource.id,
        className: ['fc-datagrid-cell', 'fc-resource'].concat(customClassNames).join(' ')
      }, vdom_createElement("div", {
        className: "fc-datagrid-cell-frame",
        style: {
          height: props.innerHeight
        }
      }, vdom_createElement("div", {
        className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner"
      }, colSpec.isMain && vdom_createElement(ExpanderIcon, {
        depth: props.depth,
        hasChildren: props.hasChildren,
        isExpanded: props.isExpanded,
        onExpanderClick: _this.onExpanderClick
      }), vdom_createElement(SpreadsheetIndividualCellInner, {
        hookProps: hookProps,
        colSpec: colSpec
      }))));
    });
  };

  return SpreadsheetIndividualCell;
}(BaseComponent); // for VERTICAL cell grouping, in spreadsheet area


var SpreadsheetGroupCell =
/** @class */
function (_super) {
  __extends(SpreadsheetGroupCell, _super);

  function SpreadsheetGroupCell() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SpreadsheetGroupCell.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var colSpec = props.colSpec;
    var hookProps = {
      groupValue: props.fieldValue,
      view: context.viewApi
    }; // a grouped cell. no data that is specific to this specific resource
    // `colSpec` is for the group. a GroupSpec :(

    return vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: colSpec.cellClassNames,
      content: colSpec.cellContent,
      defaultContent: renderGroupInner,
      didMount: colSpec.cellDidMount,
      willUnmount: colSpec.cellWillUnmount
    }, function (rootElRef, classNames, innerElRef, innerContent) {
      return (// TODO: make data-attr with group value?
        vdom_createElement("td", {
          ref: rootElRef,
          role: "gridcell",
          rowSpan: props.rowSpan,
          className: ['fc-datagrid-cell', 'fc-resource-group'].concat(classNames).join(' ')
        }, vdom_createElement("div", {
          className: "fc-datagrid-cell-frame fc-datagrid-cell-frame-liquid"
        }, vdom_createElement("div", {
          className: "fc-datagrid-cell-cushion fc-sticky",
          ref: innerElRef
        }, innerContent)))
      );
    });
  };

  return SpreadsheetGroupCell;
}(BaseComponent);

function renderGroupInner(hookProps) {
  return hookProps.groupValue || vdom_createElement(vdom_Fragment, null, "\xA0");
}

var SpreadsheetRow =
/** @class */
function (_super) {
  __extends(SpreadsheetRow, _super);

  function SpreadsheetRow() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SpreadsheetRow.prototype.render = function () {
    var props = this.props;
    var resource = props.resource,
        rowSpans = props.rowSpans,
        depth = props.depth;
    var resourceFields = buildResourceFields(resource); // slightly inefficient. already done up the call stack

    return vdom_createElement("tr", {
      role: "row"
    }, props.colSpecs.map(function (colSpec, i) {
      var rowSpan = rowSpans[i];

      if (rowSpan === 0) {
        // not responsible for group-based rows. VRowGroup is
        return null;
      }

      if (rowSpan == null) {
        rowSpan = 1;
      }

      var fieldValue = colSpec.field ? resourceFields[colSpec.field] : resource.title || getPublicId(resource.id);

      if (rowSpan > 1) {
        return vdom_createElement(SpreadsheetGroupCell, {
          key: i,
          colSpec: colSpec,
          fieldValue: fieldValue,
          rowSpan: rowSpan
        });
      }

      return vdom_createElement(SpreadsheetIndividualCell, {
        key: i,
        colSpec: colSpec,
        resource: resource,
        fieldValue: fieldValue,
        depth: depth,
        hasChildren: props.hasChildren,
        isExpanded: props.isExpanded,
        innerHeight: props.innerHeight
      });
    }));
  };

  return SpreadsheetRow;
}(BaseComponent);

SpreadsheetRow.addPropsEquality({
  rowSpans: isArraysEqual
}); // for HORIZONTAL cell grouping, in spreadsheet area

var SpreadsheetGroupRow =
/** @class */
function (_super) {
  __extends(SpreadsheetGroupRow, _super);

  function SpreadsheetGroupRow() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.innerInnerRef = createRef();

    _this.onExpanderClick = function () {
      var props = _this.props;

      _this.context.dispatch({
        type: 'SET_RESOURCE_ENTITY_EXPANDED',
        id: props.id,
        isExpanded: !props.isExpanded
      });
    };

    return _this;
  }

  SpreadsheetGroupRow.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var hookProps = {
      groupValue: props.group.value,
      view: context.viewApi
    };
    var spec = props.group.spec;
    return vdom_createElement("tr", {
      role: "row"
    }, vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: spec.labelClassNames,
      content: spec.labelContent,
      defaultContent: renderCellInner,
      didMount: spec.labelDidMount,
      willUnmount: spec.labelWillUnmount
    }, function (rootElRef, classNames, innerElRef, innerContent) {
      return vdom_createElement("th", {
        ref: rootElRef,
        // ARIA TODO: not really a columnheader
        // extremely tedious to make this aria-compliant,
        // to assign multiple headers to each cell
        // https://www.w3.org/WAI/tutorials/tables/multi-level/
        role: "columnheader",
        scope: "colgroup",
        colSpan: props.spreadsheetColCnt,
        className: ['fc-datagrid-cell', 'fc-resource-group', context.theme.getClass('tableCellShaded')].concat(classNames).join(' ')
      }, vdom_createElement("div", {
        className: "fc-datagrid-cell-frame",
        style: {
          height: props.innerHeight
        }
      }, vdom_createElement("div", {
        className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner",
        ref: _this.innerInnerRef
      }, vdom_createElement(ExpanderIcon, {
        depth: 0,
        hasChildren: true,
        isExpanded: props.isExpanded,
        onExpanderClick: _this.onExpanderClick
      }), vdom_createElement("span", {
        className: "fc-datagrid-cell-main",
        ref: innerElRef
      }, innerContent))));
    }));
  };

  return SpreadsheetGroupRow;
}(BaseComponent);

SpreadsheetGroupRow.addPropsEquality({
  group: isGroupsEqual
});

function renderCellInner(hookProps) {
  return hookProps.groupValue || vdom_createElement(vdom_Fragment, null, "\xA0");
}

var SPREADSHEET_COL_MIN_WIDTH = 20;

var SpreadsheetHeader =
/** @class */
function (_super) {
  __extends(SpreadsheetHeader, _super);

  function SpreadsheetHeader() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.resizerElRefs = new RefMap(_this._handleColResizerEl.bind(_this));
    _this.colDraggings = {};
    return _this;
  }

  SpreadsheetHeader.prototype.render = function () {
    var _this = this;

    var _a = this.props,
        colSpecs = _a.colSpecs,
        superHeaderRendering = _a.superHeaderRendering,
        rowInnerHeights = _a.rowInnerHeights;
    var hookProps = {
      view: this.context.viewApi
    };
    var rowNodes = [];
    rowInnerHeights = rowInnerHeights.slice(); // copy, because we're gonna pop

    if (superHeaderRendering) {
      var rowInnerHeight_1 = rowInnerHeights.shift();
      rowNodes.push(vdom_createElement("tr", {
        key: "row-super",
        role: "row"
      }, vdom_createElement(RenderHook, {
        hookProps: hookProps,
        classNames: superHeaderRendering.headerClassNames,
        content: superHeaderRendering.headerContent,
        didMount: superHeaderRendering.headerDidMount,
        willUnmount: superHeaderRendering.headerWillUnmount
      }, function (rootElRef, classNames, innerElRef, innerContent) {
        return vdom_createElement("th", {
          ref: rootElRef,
          role: "columnheader",
          scope: "colgroup",
          colSpan: colSpecs.length,
          className: ['fc-datagrid-cell', 'fc-datagrid-cell-super'].concat(classNames).join(' ')
        }, vdom_createElement("div", {
          className: "fc-datagrid-cell-frame",
          style: {
            height: rowInnerHeight_1
          }
        }, vdom_createElement("div", {
          className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner",
          ref: innerElRef
        }, innerContent)));
      })));
    }

    var rowInnerHeight = rowInnerHeights.shift();
    rowNodes.push(vdom_createElement("tr", {
      key: "row",
      role: "row"
    }, colSpecs.map(function (colSpec, i) {
      var isLastCol = i === colSpecs.length - 1; // need empty inner div for abs positioning for resizer

      return vdom_createElement(RenderHook, {
        key: i,
        hookProps: hookProps,
        classNames: colSpec.headerClassNames,
        content: colSpec.headerContent,
        didMount: colSpec.headerDidMount,
        willUnmount: colSpec.headerWillUnmount
      }, function (rootElRef, classNames, innerElRef, innerContent) {
        return vdom_createElement("th", {
          ref: rootElRef,
          role: "columnheader",
          className: ['fc-datagrid-cell'].concat(classNames).join(' ')
        }, vdom_createElement("div", {
          className: "fc-datagrid-cell-frame",
          style: {
            height: rowInnerHeight
          }
        }, vdom_createElement("div", {
          className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner"
        }, colSpec.isMain && vdom_createElement("span", {
          className: "fc-datagrid-expander fc-datagrid-expander-placeholder"
        }, vdom_createElement("span", {
          className: "fc-icon"
        })), vdom_createElement("span", {
          className: "fc-datagrid-cell-main",
          ref: innerElRef
        }, innerContent)), !isLastCol && vdom_createElement("div", {
          className: "fc-datagrid-cell-resizer",
          ref: _this.resizerElRefs.createRef(i)
        })));
      });
    })));
    return vdom_createElement(vdom_Fragment, null, rowNodes);
  };

  SpreadsheetHeader.prototype._handleColResizerEl = function (resizerEl, index) {
    var colDraggings = this.colDraggings;

    if (!resizerEl) {
      var dragging = colDraggings[index];

      if (dragging) {
        dragging.destroy();
        delete colDraggings[index];
      }
    } else {
      var dragging = this.initColResizing(resizerEl, parseInt(index, 10));

      if (dragging) {
        colDraggings[index] = dragging;
      }
    }
  };

  SpreadsheetHeader.prototype.initColResizing = function (resizerEl, index) {
    var _a = this.context,
        pluginHooks = _a.pluginHooks,
        isRtl = _a.isRtl;
    var onColWidthChange = this.props.onColWidthChange;
    var ElementDraggingImpl = pluginHooks.elementDraggingImpl;

    if (ElementDraggingImpl) {
      var dragging = new ElementDraggingImpl(resizerEl);
      var startWidth_1; // of just the single column

      var currentWidths_1; // of all columns

      dragging.emitter.on('dragstart', function () {
        var allCells = findElements(elementClosest(resizerEl, 'tr'), 'th');
        currentWidths_1 = allCells.map(function (cellEl) {
          return cellEl.getBoundingClientRect().width;
        });
        startWidth_1 = currentWidths_1[index];
      });
      dragging.emitter.on('dragmove', function (pev) {
        currentWidths_1[index] = Math.max(startWidth_1 + pev.deltaX * (isRtl ? -1 : 1), SPREADSHEET_COL_MIN_WIDTH);

        if (onColWidthChange) {
          onColWidthChange(currentWidths_1.slice()); // send a copy since currentWidths continues to be mutated
        }
      });
      dragging.setAutoScrollEnabled(false); // because gets weird with auto-scrolling time area

      return dragging;
    }

    return null;
  };

  return SpreadsheetHeader;
}(BaseComponent);

var ResourceTimelineLaneMisc =
/** @class */
function (_super) {
  __extends(ResourceTimelineLaneMisc, _super);

  function ResourceTimelineLaneMisc() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ResourceTimelineLaneMisc.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var hookProps = {
      resource: new ResourceApi(context, props.resource)
    }; // just easier to make directly

    return vdom_createElement(ContentHook, {
      hookProps: hookProps,
      content: context.options.resourceLaneContent
    }, function (innerElRef, innerContent) {
      return innerContent && // TODO: test how this would interfere with height
      vdom_createElement("div", {
        className: "fc-timeline-lane-misc",
        ref: innerElRef
      }, innerContent);
    });
  };

  return ResourceTimelineLaneMisc;
}(BaseComponent);

var ResourceTimelineLane =
/** @class */
function (_super) {
  __extends(ResourceTimelineLane, _super);

  function ResourceTimelineLane() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refineHookProps = memoizeObjArg(main_refineHookProps);
    _this.normalizeClassNames = buildClassNameNormalizer();

    _this.handleHeightChange = function (innerEl, isStable) {
      if (_this.props.onHeightChange) {
        _this.props.onHeightChange( // would want to use own <tr> ref, but not guaranteed to be ready when this fires
        elementClosest(innerEl, 'tr'), isStable);
      }
    };

    return _this;
  }

  ResourceTimelineLane.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        context = _a.context;

    var options = context.options;
    var hookProps = this.refineHookProps({
      resource: props.resource,
      context: context
    });
    var customClassNames = this.normalizeClassNames(options.resourceLaneClassNames, hookProps);
    return vdom_createElement("tr", {
      ref: props.elRef
    }, vdom_createElement(MountHook, {
      hookProps: hookProps,
      didMount: options.resourceLaneDidMount,
      willUnmount: options.resourceLaneWillUnmount
    }, function (rootElRef) {
      return vdom_createElement("td", {
        ref: rootElRef,
        className: ['fc-timeline-lane', 'fc-resource'].concat(customClassNames).join(' '),
        "data-resource-id": props.resource.id
      }, vdom_createElement("div", {
        className: "fc-timeline-lane-frame",
        style: {
          height: props.innerHeight
        }
      }, vdom_createElement(ResourceTimelineLaneMisc, {
        resource: props.resource
      }), vdom_createElement(TimelineLane, {
        dateProfile: props.dateProfile,
        tDateProfile: props.tDateProfile,
        nowDate: props.nowDate,
        todayRange: props.todayRange,
        nextDayThreshold: props.nextDayThreshold,
        businessHours: props.businessHours,
        eventStore: props.eventStore,
        eventUiBases: props.eventUiBases,
        dateSelection: props.dateSelection,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        timelineCoords: props.timelineCoords,
        onHeightChange: _this.handleHeightChange,
        resourceId: props.resource.id
      })));
    })); // important NOT to do liquid-height. dont want to shrink height smaller than content
  };

  return ResourceTimelineLane;
}(BaseComponent);

function main_refineHookProps(raw) {
  return {
    resource: new ResourceApi(raw.context, raw.resource)
  };
}
/*
parallels the SpreadsheetGroupRow
*/


var DividerRow =
/** @class */
function (_super) {
  __extends(DividerRow, _super);

  function DividerRow() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DividerRow.prototype.render = function () {
    var _this = this;

    var props = this.props;
    var renderingHooks = this.props.renderingHooks;
    var hookProps = {
      groupValue: props.groupValue,
      view: this.context.viewApi
    };
    return vdom_createElement("tr", {
      ref: props.elRef
    }, vdom_createElement(RenderHook, {
      hookProps: hookProps,
      classNames: renderingHooks.laneClassNames,
      content: renderingHooks.laneContent,
      didMount: renderingHooks.laneDidMount,
      willUnmount: renderingHooks.laneWillUnmount
    }, function (rootElRef, classNames, innerElRef, innerContent) {
      return vdom_createElement("td", {
        ref: rootElRef,
        className: ['fc-timeline-lane', 'fc-resource-group', _this.context.theme.getClass('tableCellShaded')].concat(classNames).join(' ')
      }, vdom_createElement("div", {
        style: {
          height: props.innerHeight
        },
        ref: innerElRef
      }, innerContent));
    }));
  };

  return DividerRow;
}(BaseComponent);

var ResourceTimelineLanesBody =
/** @class */
function (_super) {
  __extends(ResourceTimelineLanesBody, _super);

  function ResourceTimelineLanesBody() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ResourceTimelineLanesBody.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    var rowElRefs = props.rowElRefs,
        innerHeights = props.innerHeights;
    return vdom_createElement("tbody", null, props.rowNodes.map(function (node, index) {
      if (node.group) {
        return vdom_createElement(DividerRow, {
          key: node.id,
          elRef: rowElRefs.createRef(node.id),
          groupValue: node.group.value,
          renderingHooks: node.group.spec,
          innerHeight: innerHeights[index] || ''
        });
      }

      if (node.resource) {
        var resource = node.resource;
        return vdom_createElement(ResourceTimelineLane, _assign({
          key: node.id,
          elRef: rowElRefs.createRef(node.id)
        }, props.splitProps[resource.id], {
          resource: resource,
          dateProfile: props.dateProfile,
          tDateProfile: props.tDateProfile,
          nowDate: props.nowDate,
          todayRange: props.todayRange,
          nextDayThreshold: context.options.nextDayThreshold,
          businessHours: resource.businessHours || props.fallbackBusinessHours,
          innerHeight: innerHeights[index] || '',
          timelineCoords: props.slatCoords,
          onHeightChange: props.onRowHeightChange
        }));
      }

      return null;
    }));
  };

  return ResourceTimelineLanesBody;
}(BaseComponent);

var ResourceTimelineLanes =
/** @class */
function (_super) {
  __extends(ResourceTimelineLanes, _super);

  function ResourceTimelineLanes() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.rootElRef = createRef();
    _this.rowElRefs = new RefMap();
    return _this;
  }

  ResourceTimelineLanes.prototype.render = function () {
    var _a = this,
        props = _a.props,
        context = _a.context;

    return vdom_createElement("table", {
      ref: this.rootElRef,
      "aria-hidden": true,
      className: 'fc-scrollgrid-sync-table ' + context.theme.getClass('table'),
      style: {
        minWidth: props.tableMinWidth,
        width: props.clientWidth,
        height: props.minHeight
      }
    }, vdom_createElement(ResourceTimelineLanesBody, {
      rowElRefs: this.rowElRefs,
      rowNodes: props.rowNodes,
      dateProfile: props.dateProfile,
      tDateProfile: props.tDateProfile,
      nowDate: props.nowDate,
      todayRange: props.todayRange,
      splitProps: props.splitProps,
      fallbackBusinessHours: props.fallbackBusinessHours,
      slatCoords: props.slatCoords,
      innerHeights: props.innerHeights,
      onRowHeightChange: props.onRowHeightChange
    }));
  };

  ResourceTimelineLanes.prototype.componentDidMount = function () {
    this.updateCoords();
  };

  ResourceTimelineLanes.prototype.componentDidUpdate = function () {
    this.updateCoords();
  };

  ResourceTimelineLanes.prototype.componentWillUnmount = function () {
    if (this.props.onRowCoords) {
      this.props.onRowCoords(null);
    }
  };

  ResourceTimelineLanes.prototype.updateCoords = function () {
    var props = this.props;

    if (props.onRowCoords && props.clientWidth !== null) {
      // a populated clientWidth means sizing has stabilized
      this.props.onRowCoords(new PositionCache(this.rootElRef.current, collectRowEls(this.rowElRefs.currentMap, props.rowNodes), false, true));
    }
  };

  return ResourceTimelineLanes;
}(BaseComponent);

function collectRowEls(elMap, rowNodes) {
  return rowNodes.map(function (rowNode) {
    return elMap[rowNode.id];
  });
}

var ResourceTimelineGrid =
/** @class */
function (_super) {
  __extends(ResourceTimelineGrid, _super);

  function ResourceTimelineGrid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.computeHasResourceBusinessHours = memoize(computeHasResourceBusinessHours);
    _this.resourceSplitter = new ResourceSplitter(); // doesn't let it do businessHours tho

    _this.bgSlicer = new TimelineLaneSlicer();
    _this.slatsRef = createRef(); // needed for Hit creation :(

    _this.state = {
      slatCoords: null
    };

    _this.handleEl = function (el) {
      if (el) {
        _this.context.registerInteractiveComponent(_this, {
          el: el
        });
      } else {
        _this.context.unregisterInteractiveComponent(_this);
      }
    };

    _this.handleSlatCoords = function (slatCoords) {
      _this.setState({
        slatCoords: slatCoords
      });

      if (_this.props.onSlatCoords) {
        _this.props.onSlatCoords(slatCoords);
      }
    };

    _this.handleRowCoords = function (rowCoords) {
      _this.rowCoords = rowCoords;

      if (_this.props.onRowCoords) {
        _this.props.onRowCoords(rowCoords);
      }
    };

    return _this;
  }

  ResourceTimelineGrid.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var dateProfile = props.dateProfile,
        tDateProfile = props.tDateProfile;
    var timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    var hasResourceBusinessHours = this.computeHasResourceBusinessHours(props.rowNodes);
    var splitProps = this.resourceSplitter.splitProps(props);
    var bgLaneProps = splitProps[''];
    var bgSlicedProps = this.bgSlicer.sliceProps(bgLaneProps, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't need to pass in the rest of these args...
    dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv); // WORKAROUND: make ignore slatCoords when out of sync with dateProfile

    var slatCoords = state.slatCoords && state.slatCoords.dateProfile === props.dateProfile ? state.slatCoords : null;
    return vdom_createElement("div", {
      ref: this.handleEl,
      className: ['fc-timeline-body', props.expandRows ? 'fc-timeline-body-expandrows' : ''].join(' '),
      style: {
        minWidth: props.tableMinWidth
      }
    }, vdom_createElement(NowTimer, {
      unit: timerUnit
    }, function (nowDate, todayRange) {
      return vdom_createElement(vdom_Fragment, null, vdom_createElement(TimelineSlats, {
        ref: _this.slatsRef,
        dateProfile: dateProfile,
        tDateProfile: tDateProfile,
        nowDate: nowDate,
        todayRange: todayRange,
        clientWidth: props.clientWidth,
        tableColGroupNode: props.tableColGroupNode,
        tableMinWidth: props.tableMinWidth,
        onCoords: _this.handleSlatCoords,
        onScrollLeftRequest: props.onScrollLeftRequest
      }), vdom_createElement(TimelineLaneBg, {
        businessHourSegs: hasResourceBusinessHours ? null : bgSlicedProps.businessHourSegs,
        bgEventSegs: bgSlicedProps.bgEventSegs,
        timelineCoords: slatCoords,
        // empty array will result in unnecessary rerenders?
        eventResizeSegs: bgSlicedProps.eventResize ? bgSlicedProps.eventResize.segs : [],
        dateSelectionSegs: bgSlicedProps.dateSelectionSegs,
        nowDate: nowDate,
        todayRange: todayRange
      }), vdom_createElement(ResourceTimelineLanes, {
        rowNodes: props.rowNodes,
        dateProfile: dateProfile,
        tDateProfile: props.tDateProfile,
        nowDate: nowDate,
        todayRange: todayRange,
        splitProps: splitProps,
        fallbackBusinessHours: hasResourceBusinessHours ? props.businessHours : null,
        clientWidth: props.clientWidth,
        minHeight: props.expandRows ? props.clientHeight : '',
        tableMinWidth: props.tableMinWidth,
        innerHeights: props.rowInnerHeights,
        slatCoords: slatCoords,
        onRowCoords: _this.handleRowCoords,
        onRowHeightChange: props.onRowHeightChange
      }), context.options.nowIndicator && slatCoords && slatCoords.isDateInRange(nowDate) && vdom_createElement("div", {
        className: "fc-timeline-now-indicator-container"
      }, vdom_createElement(NowIndicatorRoot, {
        isAxis: false,
        date: nowDate
      }, function (rootElRef, classNames, innerElRef, innerContent) {
        return vdom_createElement("div", {
          ref: rootElRef,
          className: ['fc-timeline-now-indicator-line'].concat(classNames).join(' '),
          style: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl)
        }, innerContent);
      })));
    }));
  }; // Hit System
  // ------------------------------------------------------------------------------------------


  ResourceTimelineGrid.prototype.queryHit = function (positionLeft, positionTop) {
    var rowCoords = this.rowCoords;
    var rowIndex = rowCoords.topToIndex(positionTop);

    if (rowIndex != null) {
      var resource = this.props.rowNodes[rowIndex].resource;

      if (resource) {
        // not a group
        var slatHit = this.slatsRef.current.positionToHit(positionLeft);

        if (slatHit) {
          return {
            dateProfile: this.props.dateProfile,
            dateSpan: {
              range: slatHit.dateSpan.range,
              allDay: slatHit.dateSpan.allDay,
              resourceId: resource.id
            },
            rect: {
              left: slatHit.left,
              right: slatHit.right,
              top: rowCoords.tops[rowIndex],
              bottom: rowCoords.bottoms[rowIndex]
            },
            dayEl: slatHit.dayEl,
            layer: 0
          };
        }
      }
    }

    return null;
  };

  return ResourceTimelineGrid;
}(DateComponent);

function computeHasResourceBusinessHours(rowNodes) {
  for (var _i = 0, rowNodes_1 = rowNodes; _i < rowNodes_1.length; _i++) {
    var node = rowNodes_1[_i];
    var resource = node.resource;

    if (resource && resource.businessHours) {
      return true;
    }
  }

  return false;
}

var MIN_RESOURCE_AREA_WIDTH = 30; // definitely bigger than scrollbars
// RENAME?

var ResourceTimelineViewLayout =
/** @class */
function (_super) {
  __extends(ResourceTimelineViewLayout, _super);

  function ResourceTimelineViewLayout() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.scrollGridRef = createRef();
    _this.timeBodyScrollerElRef = createRef();
    _this.spreadsheetHeaderChunkElRef = createRef();
    _this.rootElRef = createRef();
    _this.ensureScrollGridResizeId = 0;
    _this.state = {
      resourceAreaWidthOverride: null
    };
    /*
    ghetto debounce. don't race with ScrollGrid's resizing delay. solves #6140
    */

    _this.ensureScrollGridResize = function () {
      if (_this.ensureScrollGridResizeId) {
        clearTimeout(_this.ensureScrollGridResizeId);
      }

      _this.ensureScrollGridResizeId = setTimeout(function () {
        _this.scrollGridRef.current.handleSizing(false);
      }, config.SCROLLGRID_RESIZE_INTERVAL + 1);
    };

    return _this;
  }

  ResourceTimelineViewLayout.prototype.render = function () {
    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var options = context.options;
    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);
    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);
    var sections = [{
      type: 'header',
      key: 'header',
      syncRowHeights: true,
      isSticky: stickyHeaderDates,
      chunks: [{
        key: 'datagrid',
        elRef: this.spreadsheetHeaderChunkElRef,
        // TODO: allow the content to specify this. have general-purpose 'content' with obj with keys
        tableClassName: 'fc-datagrid-header',
        rowContent: props.spreadsheetHeaderRows
      }, {
        key: 'divider',
        outerContent: vdom_createElement("td", {
          role: "presentation",
          className: 'fc-resource-timeline-divider ' + context.theme.getClass('tableCellShaded')
        })
      }, {
        key: 'timeline',
        content: props.timeHeaderContent
      }]
    }, {
      type: 'body',
      key: 'body',
      syncRowHeights: true,
      liquid: true,
      expandRows: Boolean(options.expandRows),
      chunks: [{
        key: 'datagrid',
        tableClassName: 'fc-datagrid-body',
        rowContent: props.spreadsheetBodyRows
      }, {
        key: 'divider',
        outerContent: vdom_createElement("td", {
          role: "presentation",
          className: 'fc-resource-timeline-divider ' + context.theme.getClass('tableCellShaded')
        })
      }, {
        key: 'timeline',
        scrollerElRef: this.timeBodyScrollerElRef,
        content: props.timeBodyContent
      }]
    }];

    if (stickyFooterScrollbar) {
      sections.push({
        type: 'footer',
        key: 'footer',
        isSticky: true,
        chunks: [{
          key: 'datagrid',
          content: renderScrollShim
        }, {
          key: 'divider',
          outerContent: vdom_createElement("td", {
            role: "presentation",
            className: 'fc-resource-timeline-divider ' + context.theme.getClass('tableCellShaded')
          })
        }, {
          key: 'timeline',
          content: renderScrollShim
        }]
      });
    }

    var resourceAreaWidth = state.resourceAreaWidthOverride != null ? state.resourceAreaWidthOverride : options.resourceAreaWidth;
    return vdom_createElement(ScrollGrid, {
      ref: this.scrollGridRef,
      elRef: this.rootElRef,
      liquid: !props.isHeightAuto && !props.forPrint,
      collapsibleWidth: false,
      colGroups: [{
        cols: props.spreadsheetCols,
        width: resourceAreaWidth
      }, {
        cols: []
      }, {
        cols: props.timeCols
      }],
      sections: sections
    });
  };

  ResourceTimelineViewLayout.prototype.forceTimeScroll = function (left) {
    var scrollGrid = this.scrollGridRef.current;
    scrollGrid.forceScrollLeft(2, left); // 2 = the time area
  };

  ResourceTimelineViewLayout.prototype.forceResourceScroll = function (top) {
    var scrollGrid = this.scrollGridRef.current;
    scrollGrid.forceScrollTop(1, top); // 1 = the body
  };

  ResourceTimelineViewLayout.prototype.getResourceScroll = function () {
    var timeBodyScrollerEl = this.timeBodyScrollerElRef.current;
    return timeBodyScrollerEl.scrollTop;
  }; // Resource Area Resizing
  // ------------------------------------------------------------------------------------------
  // NOTE: a callback Ref for the resizer was firing multiple times with same elements (Preact)
  // that's why we use spreadsheetResizerElRef instead


  ResourceTimelineViewLayout.prototype.componentDidMount = function () {
    this.initSpreadsheetResizing();
  };

  ResourceTimelineViewLayout.prototype.componentWillUnmount = function () {
    this.destroySpreadsheetResizing();
  };

  ResourceTimelineViewLayout.prototype.initSpreadsheetResizing = function () {
    var _this = this;

    var _a = this.context,
        isRtl = _a.isRtl,
        pluginHooks = _a.pluginHooks;
    var ElementDraggingImpl = pluginHooks.elementDraggingImpl;
    var spreadsheetHeadEl = this.spreadsheetHeaderChunkElRef.current;

    if (ElementDraggingImpl) {
      var rootEl_1 = this.rootElRef.current;
      var dragging = this.spreadsheetResizerDragging = new ElementDraggingImpl(rootEl_1, '.fc-resource-timeline-divider');
      var dragStartWidth_1;
      var viewWidth_1;
      dragging.emitter.on('dragstart', function () {
        dragStartWidth_1 = spreadsheetHeadEl.getBoundingClientRect().width;
        viewWidth_1 = rootEl_1.getBoundingClientRect().width;
      });
      dragging.emitter.on('dragmove', function (pev) {
        var newWidth = dragStartWidth_1 + pev.deltaX * (isRtl ? -1 : 1);
        newWidth = Math.max(newWidth, MIN_RESOURCE_AREA_WIDTH);
        newWidth = Math.min(newWidth, viewWidth_1 - MIN_RESOURCE_AREA_WIDTH); // scrollgrid will ignore resize requests if there are too many :|

        _this.setState({
          resourceAreaWidthOverride: newWidth
        }, _this.ensureScrollGridResize);
      });
      dragging.setAutoScrollEnabled(false); // because gets weird with auto-scrolling time area
    }
  };

  ResourceTimelineViewLayout.prototype.destroySpreadsheetResizing = function () {
    if (this.spreadsheetResizerDragging) {
      this.spreadsheetResizerDragging.destroy();
    }
  };

  return ResourceTimelineViewLayout;
}(BaseComponent);

var ResourceTimelineView =
/** @class */
function (_super) {
  __extends(ResourceTimelineView, _super);

  function ResourceTimelineView(props, context) {
    var _this = _super.call(this, props, context) || this;

    _this.processColOptions = memoize(processColOptions);
    _this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);
    _this.hasNesting = memoize(hasNesting);
    _this.buildRowNodes = memoize(buildRowNodes);
    _this.layoutRef = createRef();
    _this.rowNodes = [];
    _this.renderedRowNodes = [];
    _this.buildRowIndex = memoize(buildRowIndex);

    _this.handleSlatCoords = function (slatCoords) {
      _this.setState({
        slatCoords: slatCoords
      });
    };

    _this.handleRowCoords = function (rowCoords) {
      _this.rowCoords = rowCoords;

      _this.scrollResponder.update(false); // TODO: could eliminate this if rowCoords lived in state

    };

    _this.handleMaxCushionWidth = function (slotCushionMaxWidth) {
      _this.setState({
        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth) // for less rerendering TODO: DRY

      });
    }; // Scrolling
    // ------------------------------------------------------------------------------------------------------------------
    // this is useful for scrolling prev/next dates while resource is scrolled down


    _this.handleScrollLeftRequest = function (scrollLeft) {
      var layout = _this.layoutRef.current;
      layout.forceTimeScroll(scrollLeft);
    };

    _this.handleScrollRequest = function (request) {
      var rowCoords = _this.rowCoords;
      var layout = _this.layoutRef.current;
      var rowId = request.rowId || request.resourceId;

      if (rowCoords) {
        if (rowId) {
          var rowIdToIndex = _this.buildRowIndex(_this.renderedRowNodes);

          var index = rowIdToIndex[rowId];

          if (index != null) {
            var scrollTop = request.fromBottom != null ? rowCoords.bottoms[index] - request.fromBottom : // pixels from bottom edge
            rowCoords.tops[index] // just use top edge
            ;
            layout.forceResourceScroll(scrollTop);
          }
        }

        return true;
      }

      return null;
    }; // Resource INDIVIDUAL-Column Area Resizing
    // ------------------------------------------------------------------------------------------


    _this.handleColWidthChange = function (colWidths) {
      _this.setState({
        spreadsheetColWidths: colWidths
      });
    };

    _this.state = {
      resourceAreaWidth: context.options.resourceAreaWidth,
      spreadsheetColWidths: []
    };
    return _this;
  }

  ResourceTimelineView.prototype.render = function () {
    var _this = this;

    var _a = this,
        props = _a.props,
        state = _a.state,
        context = _a.context;

    var options = context.options,
        viewSpec = context.viewSpec;

    var _b = this.processColOptions(context.options),
        superHeaderRendering = _b.superHeaderRendering,
        groupSpecs = _b.groupSpecs,
        orderSpecs = _b.orderSpecs,
        isVGrouping = _b.isVGrouping,
        colSpecs = _b.colSpecs;

    var tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);
    var rowNodes = this.rowNodes = this.buildRowNodes(props.resourceStore, groupSpecs, orderSpecs, isVGrouping, props.resourceEntityExpansions, options.resourcesInitiallyExpanded);
    var extraClassNames = ['fc-resource-timeline', this.hasNesting(rowNodes) ? '' : 'fc-resource-timeline-flat', 'fc-timeline', options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : 'fc-timeline-overlap-enabled'];
    var slotMinWidth = options.slotMinWidth;
    var slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));
    return vdom_createElement(ViewRoot, {
      viewSpec: viewSpec
    }, function (rootElRef, classNames) {
      return vdom_createElement("div", {
        ref: rootElRef,
        className: extraClassNames.concat(classNames).join(' ')
      }, vdom_createElement(ResourceTimelineViewLayout, {
        ref: _this.layoutRef,
        forPrint: props.forPrint,
        isHeightAuto: props.isHeightAuto,
        spreadsheetCols: buildSpreadsheetCols(colSpecs, state.spreadsheetColWidths, ''),
        spreadsheetHeaderRows: function spreadsheetHeaderRows(contentArg) {
          return vdom_createElement(SpreadsheetHeader // TODO: rename to SpreadsheetHeaderRows
          , {
            superHeaderRendering: superHeaderRendering,
            colSpecs: colSpecs,
            onColWidthChange: _this.handleColWidthChange,
            rowInnerHeights: contentArg.rowSyncHeights
          });
        },
        spreadsheetBodyRows: function spreadsheetBodyRows(contentArg) {
          return vdom_createElement(vdom_Fragment, null, _this.renderSpreadsheetRows(rowNodes, colSpecs, contentArg.rowSyncHeights));
        },
        timeCols: slatCols,
        timeHeaderContent: function timeHeaderContent(contentArg) {
          return vdom_createElement(TimelineHeader, {
            clientWidth: contentArg.clientWidth,
            clientHeight: contentArg.clientHeight,
            tableMinWidth: contentArg.tableMinWidth,
            tableColGroupNode: contentArg.tableColGroupNode,
            dateProfile: props.dateProfile,
            tDateProfile: tDateProfile,
            slatCoords: state.slatCoords,
            rowInnerHeights: contentArg.rowSyncHeights,
            onMaxCushionWidth: slotMinWidth ? null : _this.handleMaxCushionWidth
          });
        },
        timeBodyContent: function timeBodyContent(contentArg) {
          return vdom_createElement(ResourceTimelineGrid, {
            dateProfile: props.dateProfile,
            clientWidth: contentArg.clientWidth,
            clientHeight: contentArg.clientHeight,
            tableMinWidth: contentArg.tableMinWidth,
            tableColGroupNode: contentArg.tableColGroupNode,
            expandRows: contentArg.expandRows,
            tDateProfile: tDateProfile,
            rowNodes: rowNodes,
            businessHours: props.businessHours,
            dateSelection: props.dateSelection,
            eventStore: props.eventStore,
            eventUiBases: props.eventUiBases,
            eventSelection: props.eventSelection,
            eventDrag: props.eventDrag,
            eventResize: props.eventResize,
            resourceStore: props.resourceStore,
            nextDayThreshold: context.options.nextDayThreshold,
            rowInnerHeights: contentArg.rowSyncHeights,
            onSlatCoords: _this.handleSlatCoords,
            onRowCoords: _this.handleRowCoords,
            onScrollLeftRequest: _this.handleScrollLeftRequest,
            onRowHeightChange: contentArg.reportRowHeightChange
          });
        }
      }));
    });
  };

  ResourceTimelineView.prototype.renderSpreadsheetRows = function (nodes, colSpecs, rowSyncHeights) {
    return nodes.map(function (node, index) {
      if (node.group) {
        return vdom_createElement(SpreadsheetGroupRow, {
          key: node.id,
          id: node.id,
          spreadsheetColCnt: colSpecs.length,
          isExpanded: node.isExpanded,
          group: node.group,
          innerHeight: rowSyncHeights[index] || ''
        });
      }

      if (node.resource) {
        return vdom_createElement(SpreadsheetRow, {
          key: node.id,
          colSpecs: colSpecs,
          rowSpans: node.rowSpans,
          depth: node.depth,
          isExpanded: node.isExpanded,
          hasChildren: node.hasChildren,
          resource: node.resource,
          innerHeight: rowSyncHeights[index] || ''
        });
      }

      return null;
    });
  };

  ResourceTimelineView.prototype.componentDidMount = function () {
    this.renderedRowNodes = this.rowNodes;
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  };

  ResourceTimelineView.prototype.getSnapshotBeforeUpdate = function () {
    if (!this.props.forPrint) {
      // because print-view is always zero?
      return {
        resourceScroll: this.queryResourceScroll()
      };
    }

    return {};
  };

  ResourceTimelineView.prototype.componentDidUpdate = function (prevProps, prevState, snapshot) {
    this.renderedRowNodes = this.rowNodes;
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);

    if (snapshot.resourceScroll) {
      this.handleScrollRequest(snapshot.resourceScroll); // TODO: this gets triggered too often
    }
  };

  ResourceTimelineView.prototype.componentWillUnmount = function () {
    this.scrollResponder.detach();
  };

  ResourceTimelineView.prototype.computeFallbackSlotMinWidth = function (tDateProfile) {
    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);
  };

  ResourceTimelineView.prototype.queryResourceScroll = function () {
    var _a = this,
        rowCoords = _a.rowCoords,
        renderedRowNodes = _a.renderedRowNodes;

    if (rowCoords) {
      var layout = this.layoutRef.current;
      var trBottoms = rowCoords.bottoms;
      var scrollTop = layout.getResourceScroll();
      var scroll_1 = {};

      for (var i = 0; i < trBottoms.length; i += 1) {
        var rowNode = renderedRowNodes[i];
        var elBottom = trBottoms[i] - scrollTop; // from the top of the scroller

        if (elBottom > 0) {
          scroll_1.rowId = rowNode.id;
          scroll_1.fromBottom = elBottom;
          break;
        }
      }

      return scroll_1;
    }

    return null;
  };

  return ResourceTimelineView;
}(BaseComponent);

ResourceTimelineView.addStateEquality({
  spreadsheetColWidths: isArraysEqual
});

function buildRowIndex(rowNodes) {
  var rowIdToIndex = {};

  for (var i = 0; i < rowNodes.length; i += 1) {
    rowIdToIndex[rowNodes[i].id] = i;
  }

  return rowIdToIndex;
}

function buildSpreadsheetCols(colSpecs, forcedWidths, fallbackWidth) {
  if (fallbackWidth === void 0) {
    fallbackWidth = '';
  }

  return colSpecs.map(function (colSpec, i) {
    return {
      className: colSpec.isMain ? 'fc-main-col' : '',
      width: forcedWidths[i] || colSpec.width || fallbackWidth
    };
  });
}

function hasNesting(nodes) {
  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var node = nodes_1[_i];

    if (node.group) {
      return true;
    }

    if (node.resource) {
      if (node.hasChildren) {
        return true;
      }
    }
  }

  return false;
}

function processColOptions(options) {
  var allColSpecs = options.resourceAreaColumns || [];
  var superHeaderRendering = null;

  if (!allColSpecs.length) {
    allColSpecs.push({
      headerClassNames: options.resourceAreaHeaderClassNames,
      headerContent: options.resourceAreaHeaderContent || 'Resources',
      headerDidMount: options.resourceAreaHeaderDidMount,
      headerWillUnmount: options.resourceAreaHeaderWillUnmount
    });
  } else if (options.resourceAreaHeaderContent) {
    // weird way to determine if content
    superHeaderRendering = {
      headerClassNames: options.resourceAreaHeaderClassNames,
      headerContent: options.resourceAreaHeaderContent,
      headerDidMount: options.resourceAreaHeaderDidMount,
      headerWillUnmount: options.resourceAreaHeaderWillUnmount
    };
  }

  var plainColSpecs = [];
  var groupColSpecs = []; // part of the colSpecs, but filtered out in order to put first

  var groupSpecs = [];
  var isVGrouping = false;

  for (var _i = 0, allColSpecs_1 = allColSpecs; _i < allColSpecs_1.length; _i++) {
    var colSpec = allColSpecs_1[_i];

    if (colSpec.group) {
      groupColSpecs.push(_assign(_assign({}, colSpec), {
        cellClassNames: colSpec.cellClassNames || options.resourceGroupLabelClassNames,
        cellContent: colSpec.cellContent || options.resourceGroupLabelContent,
        cellDidMount: colSpec.cellDidMount || options.resourceGroupLabelDidMount,
        cellWillUnmount: colSpec.cellWillUnmount || options.resourceGroupLaneWillUnmount
      }));
    } else {
      plainColSpecs.push(colSpec);
    }
  } // BAD: mutates a user-supplied option


  var mainColSpec = plainColSpecs[0];
  mainColSpec.isMain = true;
  mainColSpec.cellClassNames = mainColSpec.cellClassNames || options.resourceLabelClassNames;
  mainColSpec.cellContent = mainColSpec.cellContent || options.resourceLabelContent;
  mainColSpec.cellDidMount = mainColSpec.cellDidMount || options.resourceLabelDidMount;
  mainColSpec.cellWillUnmount = mainColSpec.cellWillUnmount || options.resourceLabelWillUnmount;

  if (groupColSpecs.length) {
    groupSpecs = groupColSpecs;
    isVGrouping = true;
  } else {
    var hGroupField = options.resourceGroupField;

    if (hGroupField) {
      groupSpecs.push({
        field: hGroupField,
        labelClassNames: options.resourceGroupLabelClassNames,
        labelContent: options.resourceGroupLabelContent,
        labelDidMount: options.resourceGroupLabelDidMount,
        labelWillUnmount: options.resourceGroupLabelWillUnmount,
        laneClassNames: options.resourceGroupLaneClassNames,
        laneContent: options.resourceGroupLaneContent,
        laneDidMount: options.resourceGroupLaneDidMount,
        laneWillUnmount: options.resourceGroupLaneWillUnmount
      });
    }
  }

  var allOrderSpecs = options.resourceOrder || DEFAULT_RESOURCE_ORDER;
  var plainOrderSpecs = [];

  for (var _a = 0, allOrderSpecs_1 = allOrderSpecs; _a < allOrderSpecs_1.length; _a++) {
    var orderSpec = allOrderSpecs_1[_a];
    var isGroup = false;

    for (var _b = 0, groupSpecs_1 = groupSpecs; _b < groupSpecs_1.length; _b++) {
      var groupSpec = groupSpecs_1[_b];

      if (groupSpec.field === orderSpec.field) {
        groupSpec.order = orderSpec.order; // -1, 0, 1

        isGroup = true;
        break;
      }
    }

    if (!isGroup) {
      plainOrderSpecs.push(orderSpec);
    }
  }

  return {
    superHeaderRendering: superHeaderRendering,
    isVGrouping: isVGrouping,
    groupSpecs: groupSpecs,
    colSpecs: groupColSpecs.concat(plainColSpecs),
    orderSpecs: plainOrderSpecs
  };
}

var resource_timeline_main_main = createPlugin({
  deps: [premium_common_main, resource_common_main, _fullcalendar_timeline_main],
  initialView: 'resourceTimelineDay',
  views: {
    resourceTimeline: {
      type: 'timeline',
      component: ResourceTimelineView,
      needsResourceData: true,
      resourceAreaWidth: '30%',
      resourcesInitiallyExpanded: true,
      eventResizableFromStart: true // TODO: not DRY with this same setting in the main timeline config

    },
    resourceTimelineDay: {
      type: 'resourceTimeline',
      duration: {
        days: 1
      }
    },
    resourceTimelineWeek: {
      type: 'resourceTimeline',
      duration: {
        weeks: 1
      }
    },
    resourceTimelineMonth: {
      type: 'resourceTimeline',
      duration: {
        months: 1
      }
    },
    resourceTimelineYear: {
      type: 'resourceTimeline',
      duration: {
        years: 1
      }
    }
  }
});
/* harmony default export */ var _fullcalendar_resource_timeline_main = (resource_timeline_main_main);

;// CONCATENATED MODULE: ./src/util/calendar-utils.js
/**
 * Round to nearest 15 minutes.
 *
 * @param {object} date - Date object
 * @returns {object} - Date object representing the current datetime, rounded up to the next half an hour.
 */function roundToNearest15(){var date=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Date();var minutes=15;var ms=1000*60*minutes;return new Date(Math.ceil(date.getTime()/ms)*ms);}/**
 * Round business hours to nearest half hour.
 *
 * @param {string} businessStartHour The hour the resource is available from
 * @param {object} currentCalendarDate Datetime object of the current Fullcalendar instance
 * @param {boolean} returnMilliseconds Return value in ms
 * @returns {string} : formatted date to represent the start of when the resource is available from, either direct
 *   resourcedata or the current time rounded up to the next half an hour, depending on which is largest.
 */function businessHoursOrNearestFifteenMinutes(businessStartHour,currentCalendarDate,returnMilliseconds){var calendarDate=currentCalendarDate.setHours(0,0,0,0);var adjustedBusinessHour=businessStartHour;var today=new Date();today=today.setHours(0,0,0,0);var currentClosestHalfAnHourFormatted="".concat(roundToNearest15(new Date()).getHours().toString().length===1?"0".concat(roundToNearest15(new Date()).getHours()):roundToNearest15(new Date()).getHours(),":").concat(roundToNearest15(new Date()).getMinutes().toString().length===1?"0".concat(roundToNearest15(new Date()).getMinutes()):roundToNearest15(new Date()).getMinutes());if(currentClosestHalfAnHourFormatted>adjustedBusinessHour&&calendarDate===today){adjustedBusinessHour=currentClosestHalfAnHourFormatted;}if(returnMilliseconds){var timeParts=adjustedBusinessHour.split(":");adjustedBusinessHour=timeParts[0]*(60000*60)+timeParts[1]*60000;}return adjustedBusinessHour;}/**
 * Handle busy intervals.
 *
 * @param {object} value Busy interval.
 * @returns {object} Busy interval formatted for fullcalendar.
 */function handleBusyIntervals(value){return{resourceId:value.resource,start:value.startTime,end:value.endTime};}/**
 * Handle resources.
 *
 * @param {object} value Resource.
 * @param {object} currentCalendarDate The current calendar date.
 * @returns {object} Resource formatted for fullcalendar.
 */function calendar_utils_handleResources(value,currentCalendarDate){var _value$resourceDispla,_value$locationDispla,_value$acceptConflict;if(value.location===""){return{};}// TODO: Add business hours.
var businessHoursArray=[];// eslint-disable-line no-param-reassign
// reformatting openHours to fullcalendar-readable format
value.openHours.forEach(function(v){var startTime=dayjs_min_default()(v.open).format("HH:mm");var endTime=dayjs_min_default()(v.close).format("HH:mm");var businessHours={daysOfWeek:[v.weekday===7?0:v.weekday],// Sunday is internally defined as day 0, hence day 7 is converted to day 0 here.
startTime:businessHoursOrNearestFifteenMinutes(startTime,currentCalendarDate,false),endTime:endTime};businessHoursArray.push(businessHours);});var resource={resourceId:value.id,id:value.resourceMail,title:(_value$resourceDispla=value.resourceDisplayName)!==null&&_value$resourceDispla!==void 0?_value$resourceDispla:value.resourceName,capacity:value.capacity,building:(_value$locationDispla=value.locationDisplayName)!==null&&_value$locationDispla!==void 0?_value$locationDispla:value.location,description:value.resourcedescription,image:"http://placekitten.com/1920/1080",monitorEquipment:value.monitorEquipment,videoConferenceEquipment:value.videoConferenceEquipment,wheelchairAccessible:value.wheelchairAccessible,catering:value.catering,acceptConflict:(_value$acceptConflict=value.acceptConflict)!==null&&_value$acceptConflict!==void 0?_value$acceptConflict:false};if(businessHoursArray.length>0){resource.businessHours=businessHoursArray;}else{resource.businessHours={startTime:businessHoursOrNearestFifteenMinutes("00:00",currentCalendarDate,false),endTime:"24:00"};}return resource;}/**
 * GetScrollTime gets the time to horizontally scroll the calendar to on load
 *
 * @param {boolean} getUnmodifiedTimeScroll Whether to return the unmodified timescroll value.
 * @param {boolean} returnDefault Whether to return the default value for timepicker, if no value is selected.
 * @returns {string} A formatted string, containing the time to scroll to, format "xx:00"
 */function getScrollTime(){var getUnmodifiedTimeScroll=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var returnDefault=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// Checks if the user has manually chosen a preferred time previously. If so, return it.
var localTimeScroll=localStorage.getItem("setTimeScroll");if(localTimeScroll&&localTimeScroll!=="auto"){if(getUnmodifiedTimeScroll){return"".concat(localTimeScroll,":00");}localTimeScroll-=1;return"".concat(localTimeScroll,":00");}// If no manually chosen preferred time is chosen, return auto for time select.
if(returnDefault){return"auto";}// Calculates the time the calendar should scroll to horizontally when the calendar loads (now - 2 hours)
var dateTimeNow=new Date();dateTimeNow.setHours(dateTimeNow.getHours()-2);return"".concat(dateTimeNow.getHours(),":00");}
;// CONCATENATED MODULE: ./src/components/calendar-cell-info-button.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var calendar_cell_info_button = ({});
;// CONCATENATED MODULE: ./src/components/calendar-cell-info-button.js
/**
 * Calendar cell information button component.
 *
 * @param {object} props Props.
 * @param {string} props.resource Resource object.
 * @param {Function} props.onClickEvent Resource click event
 * @returns {JSX.Element} Calendar cell information button component.
 */function CalendarCellInfoButton(_ref){var resource=_ref.resource,onClickEvent=_ref.onClickEvent;return/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"calendar-cell-info",children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{className:"calendar-cell-info-button",type:"button",onClick:function onClick(){onClickEvent(resource);},children:resource.title})});}/* harmony default export */ var components_calendar_cell_info_button = (CalendarCellInfoButton);
;// CONCATENATED MODULE: ./src/components/calendar-selection-box.js
/**
 * Calendar selection box component.
 *
 * @param {object} props Props.
 * @param {object} props.calendarSelection Object containing selection info returned by fullcalendar
 * @param {string} props.calendarSelectionResourceTitle Title of selected resource.
 * @param {number} props.calendarSelectionResourceId Id of selected resource
 * @param {string} props.actionText Text for action button.
 * @returns {object} Calendar selection box
 */function CalendarSelectionBox(_ref){var calendarSelection=_ref.calendarSelection,calendarSelectionResourceTitle=_ref.calendarSelectionResourceTitle,calendarSelectionResourceId=_ref.calendarSelectionResourceId,actionText=_ref.actionText;/**
   * @param {string} startStr String containing the start-dateTime of the selection.
   * @returns {string} Date formatted as string.
   */function getFormattedDate(startStr){return dayjs_min_default()(startStr).format("dddd [d.] D. MMMM YYYY");}/**
   * @param {string} startStr String containing the start-dateTime of the selection
   * @param {string} endStr String containing the end-dateTime of the selection
   * @returns {string} Time formatted as string.
   */function getFormattedTime(startStr,endStr){var formattedTimeStart=dayjs_min_default()(startStr).format("HH:mm");var formattedTimeEnd=dayjs_min_default()(endStr).format("HH:mm");return"kl. ".concat(formattedTimeStart," til ").concat(formattedTimeEnd);}return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{id:"calendar-selection-dot",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{id:"calendar-selection-line",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{id:"calendar-selection-container",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"calendar-selection-close",type:"button",children:"x"}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{id:"calendar-selection-choice",children:"Dit valg"}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{id:"calendar-selection-choice-title",children:/*#__PURE__*/(0,jsx_runtime.jsx)("b",{children:calendarSelectionResourceTitle})}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("b",{children:getFormattedDate(calendarSelection.start)})}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("b",{children:getFormattedTime(calendarSelection.start,calendarSelection.end)})}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"calendar-selection-choice-confirm","data-resource-id":calendarSelectionResourceId,type:"button",children:actionText})]})})});}CalendarSelectionBox.defaultProps={actionText:"Fortsæt med dette valg"};/* harmony default export */ var calendar_selection_box = (CalendarSelectionBox);
;// CONCATENATED MODULE: ./src/util/dom-manipulation-utils.js
/** Remove empty aria-labelledby from empty selector. */function removeEmptyAriaLabelled(){var selections=document.querySelectorAll(".fc > .fc-view-harness");selections.forEach(function(selection){if(!selection.getAttribute("aria-labelledby")){selection.removeAttribute("aria-labelledby");}});}/** Remove tab index on fullcalendar scroller index. */function tabindexCalendar(){// Set table scroller to not be tab indexed.
var scrollers=document.querySelectorAll(".fc-scroller");scrollers.forEach(function(selection){selection.setAttribute("tabindex","-1");});}/** Make filters accessible. */function setAriaLabelFilters(){var filters=document.querySelectorAll(".filters-wrapper .filter");filters.forEach(function(filter){var id=filter.getAttribute("id");var inputs=document.querySelectorAll("#".concat(id," input"));inputs.forEach(function(input){input.setAttribute("aria-label",id);input.setAttribute("aria-controls",id);});});}
;// CONCATENATED MODULE: ./src/assets/initialstate.svg
var _rect, _circle, _rect2, _rect3, _circle2, _rect4, _path, _rect5, _circle3, _rect6, _rect7, _circle4, _rect8;

var initialstate_excluded = ["title", "titleId"];

function initialstate_extends() { initialstate_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return initialstate_extends.apply(this, arguments); }

function initialstate_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = initialstate_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function initialstate_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgInitialstate(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = initialstate_objectWithoutProperties(_ref, initialstate_excluded);

  return /*#__PURE__*/react.createElement("svg", initialstate_extends({
    width: 572,
    height: 239,
    viewBox: "0 0 572 239",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, _rect || (_rect = /*#__PURE__*/react.createElement("rect", {
    x: 295,
    y: 83,
    width: 129,
    height: 30,
    rx: 4,
    fill: "white",
    stroke: "#212529",
    strokeWidth: 2
  })), _circle || (_circle = /*#__PURE__*/react.createElement("circle", {
    cx: 410.938,
    cy: 98.0617,
    r: 4.06173,
    fill: "#ADB5BD"
  })), _rect2 || (_rect2 = /*#__PURE__*/react.createElement("rect", {
    x: 305,
    y: 95,
    width: 76.5926,
    height: 6.38272,
    rx: 3.19136,
    fill: "#ADB5BD"
  })), _rect3 || (_rect3 = /*#__PURE__*/react.createElement("rect", {
    x: 442,
    y: 83,
    width: 129,
    height: 30,
    rx: 4,
    fill: "white",
    stroke: "#212529",
    strokeWidth: 2
  })), _circle2 || (_circle2 = /*#__PURE__*/react.createElement("circle", {
    cx: 557.938,
    cy: 98.0617,
    r: 4.06173,
    fill: "#ADB5BD"
  })), _rect4 || (_rect4 = /*#__PURE__*/react.createElement("rect", {
    x: 452,
    y: 95,
    width: 76.5926,
    height: 6.38272,
    rx: 3.19136,
    fill: "#ADB5BD"
  })), _path || (_path = /*#__PURE__*/react.createElement("path", {
    d: "M151.932 228.722L151.941 228.713L151.949 228.705L218.833 161.821C203.559 144.827 194.56 122.362 194.56 97.6562C194.56 44.5392 237.613 1.5 290.716 1.5C343.828 1.5 386.463 44.5615 386.463 97.6562C386.463 150.755 343.419 193.812 290.716 193.812C266.015 193.812 243.531 184.422 226.507 169.111L159.622 235.996L159.508 236.11L159.372 236.198C158.77 236.584 158.19 236.896 157.655 237.117C157.149 237.326 156.573 237.5 156.013 237.5C155.505 237.5 154.858 237.356 154.273 237.142C153.704 236.934 153.007 236.593 152.448 236.062C149.946 234.051 149.943 230.775 151.932 228.722ZM290.716 183.531C338.081 183.531 376.591 145.007 376.591 97.6562C376.591 50.3056 338.067 11.7812 290.716 11.7812C243.366 11.7812 204.841 50.3056 204.841 97.6562C204.841 145.012 242.947 183.531 290.716 183.531Z",
    fill: "#6C757D",
    stroke: "#343A40",
    strokeWidth: 3
  })), _rect5 || (_rect5 = /*#__PURE__*/react.createElement("rect", {
    x: 148,
    y: 83,
    width: 129,
    height: 30,
    rx: 4,
    fill: "white",
    stroke: "#212529",
    strokeWidth: 2
  })), _circle3 || (_circle3 = /*#__PURE__*/react.createElement("circle", {
    cx: 263.938,
    cy: 98.0617,
    r: 4.06173,
    fill: "#212529"
  })), _rect6 || (_rect6 = /*#__PURE__*/react.createElement("rect", {
    x: 158,
    y: 95,
    width: 76.5926,
    height: 6.38272,
    rx: 3.19136,
    fill: "#0D6EFD"
  })), _rect7 || (_rect7 = /*#__PURE__*/react.createElement("rect", {
    x: 1,
    y: 83,
    width: 129,
    height: 30,
    rx: 4,
    fill: "white",
    stroke: "#212529",
    strokeWidth: 2
  })), _circle4 || (_circle4 = /*#__PURE__*/react.createElement("circle", {
    cx: 116.938,
    cy: 98.0617,
    r: 4.06173,
    fill: "#ADB5BD"
  })), _rect8 || (_rect8 = /*#__PURE__*/react.createElement("rect", {
    x: 11,
    y: 95,
    width: 76.5926,
    height: 6.38272,
    rx: 3.19136,
    fill: "#ADB5BD"
  })));
}

var ForwardRef = /*#__PURE__*/react.forwardRef(SvgInitialstate);
/* harmony default export */ var initialstate = (__webpack_require__.p + "static/media/initialstate.d68f6c44ab89d6e00ad781198e70273e.svg");

;// CONCATENATED MODULE: ./src/assets/emptystate.svg
var emptystate_rect, _ellipse, _ellipse2, emptystate_rect2, emptystate_rect3, emptystate_rect4, emptystate_rect5, emptystate_rect6, emptystate_rect7, emptystate_rect8, emptystate_path, _rect9, _ellipse3, _ellipse4, _rect10, _rect11, _rect12, _rect13, _rect14, _rect15, _rect16, _path2, _path3, _rect17, emptystate_circle, emptystate_circle2, _rect18, _rect19, _rect20, _rect21, _rect22, _rect23, _rect24, _path4;

var emptystate_excluded = ["title", "titleId"];

function emptystate_extends() { emptystate_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return emptystate_extends.apply(this, arguments); }

function emptystate_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = emptystate_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function emptystate_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgEmptystate(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = emptystate_objectWithoutProperties(_ref, emptystate_excluded);

  return /*#__PURE__*/react.createElement("svg", emptystate_extends({
    width: 300,
    height: 239,
    viewBox: "0 0 300 239",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, emptystate_rect || (emptystate_rect = /*#__PURE__*/react.createElement("rect", {
    x: 157.963,
    y: 138,
    width: 141,
    height: 38,
    rx: 4,
    fill: "white",
    stroke: "#212529",
    strokeWidth: 2
  })), _ellipse || (_ellipse = /*#__PURE__*/react.createElement("ellipse", {
    cx: 291.577,
    cy: 145.889,
    rx: 3.08951,
    ry: 3.11111,
    fill: "#ADB5BD"
  })), _ellipse2 || (_ellipse2 = /*#__PURE__*/react.createElement("ellipse", {
    cx: 282.75,
    cy: 145.889,
    rx: 3.08951,
    ry: 3.11111,
    fill: "#ADB5BD"
  })), emptystate_rect2 || (emptystate_rect2 = /*#__PURE__*/react.createElement("rect", {
    x: 193.596,
    y: 143.222,
    width: 58.2593,
    height: 4.88889,
    rx: 2.44444,
    fill: "#ADB5BD"
  })), emptystate_rect3 || (emptystate_rect3 = /*#__PURE__*/react.createElement("rect", {
    x: 193.596,
    y: 150.778,
    width: 38.3981,
    height: 4.88889,
    rx: 2.44444,
    fill: "#ADB5BD"
  })), emptystate_rect4 || (emptystate_rect4 = /*#__PURE__*/react.createElement("rect", {
    x: 193.596,
    y: 161.444,
    width: 29.1296,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), emptystate_rect5 || (emptystate_rect5 = /*#__PURE__*/react.createElement("rect", {
    x: 225.373,
    y: 161.444,
    width: 29.1296,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), emptystate_rect6 || (emptystate_rect6 = /*#__PURE__*/react.createElement("rect", {
    x: 257.151,
    y: 161.444,
    width: 29.1296,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), emptystate_rect7 || (emptystate_rect7 = /*#__PURE__*/react.createElement("rect", {
    x: 193.596,
    y: 166.778,
    width: 88.713,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), emptystate_rect8 || (emptystate_rect8 = /*#__PURE__*/react.createElement("rect", {
    x: 162.7,
    y: 144.111,
    width: 25.5988,
    height: 21.3333,
    rx: 7,
    fill: "#ADB5BD"
  })), emptystate_path || (emptystate_path = /*#__PURE__*/react.createElement("path", {
    d: "M162.7 146.389C162.7 144.627 164.1 143.167 165.9 143.167H185.099C186.849 143.167 188.299 144.627 188.299 146.389V162.5C188.299 164.312 186.849 165.722 185.099 165.722H165.9C164.1 165.722 162.7 164.312 162.7 162.5V146.389ZM178.85 151.776C178.65 151.424 178.25 151.222 177.9 151.222C177.5 151.222 177.1 151.424 176.9 151.776L172.55 158.22L171.2 156.509C171 156.257 170.65 156.056 170.3 156.056C169.9 156.056 169.55 156.257 169.35 156.509L166.15 160.536C165.85 160.939 165.8 161.443 166 161.845C166.2 162.248 166.6 162.5 167.1 162.5H171.9H173.5H183.899C184.299 162.5 184.749 162.299 184.949 161.896C185.149 161.493 185.099 160.99 184.849 160.637L178.85 151.776ZM168.3 151.222C169.6 151.222 170.7 150.165 170.7 148.806C170.7 147.496 169.6 146.389 168.3 146.389C166.95 146.389 165.9 147.496 165.9 148.806C165.9 150.165 166.95 151.222 168.3 151.222Z",
    fill: "#E9ECEF"
  })), _rect9 || (_rect9 = /*#__PURE__*/react.createElement("rect", {
    x: 27.9629,
    y: 14,
    width: 141,
    height: 38,
    rx: 4,
    fill: "white",
    stroke: "#212529",
    strokeWidth: 2
  })), _ellipse3 || (_ellipse3 = /*#__PURE__*/react.createElement("ellipse", {
    cx: 161.577,
    cy: 21.8889,
    rx: 3.08951,
    ry: 3.11111,
    fill: "#ADB5BD"
  })), _ellipse4 || (_ellipse4 = /*#__PURE__*/react.createElement("ellipse", {
    cx: 152.75,
    cy: 21.8889,
    rx: 3.08951,
    ry: 3.11111,
    fill: "#ADB5BD"
  })), _rect10 || (_rect10 = /*#__PURE__*/react.createElement("rect", {
    x: 63.5957,
    y: 19.2222,
    width: 58.2593,
    height: 4.88889,
    rx: 2.44444,
    fill: "#ADB5BD"
  })), _rect11 || (_rect11 = /*#__PURE__*/react.createElement("rect", {
    x: 63.5957,
    y: 26.7778,
    width: 38.3981,
    height: 4.88889,
    rx: 2.44444,
    fill: "#ADB5BD"
  })), _rect12 || (_rect12 = /*#__PURE__*/react.createElement("rect", {
    x: 63.5957,
    y: 37.4445,
    width: 29.1296,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), _rect13 || (_rect13 = /*#__PURE__*/react.createElement("rect", {
    x: 95.3733,
    y: 37.4445,
    width: 29.1296,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), _rect14 || (_rect14 = /*#__PURE__*/react.createElement("rect", {
    x: 127.151,
    y: 37.4445,
    width: 29.1296,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), _rect15 || (_rect15 = /*#__PURE__*/react.createElement("rect", {
    x: 63.5957,
    y: 42.7778,
    width: 88.713,
    height: 3.11111,
    rx: 1.55556,
    fill: "#CED4DA"
  })), _rect16 || (_rect16 = /*#__PURE__*/react.createElement("rect", {
    x: 32.7004,
    y: 20.1111,
    width: 25.5988,
    height: 21.3333,
    rx: 7,
    fill: "#ADB5BD"
  })), _path2 || (_path2 = /*#__PURE__*/react.createElement("path", {
    d: "M32.7004 22.3888C32.7004 20.6267 34.1004 19.1666 35.9003 19.1666H55.0994C56.8493 19.1666 58.2992 20.6267 58.2992 22.3888V38.5C58.2992 40.3125 56.8493 41.7222 55.0994 41.7222H35.9003C34.1004 41.7222 32.7004 40.3125 32.7004 38.5V22.3888ZM48.8497 27.776C48.6497 27.4236 48.2497 27.2222 47.8997 27.2222C47.4997 27.2222 47.0997 27.4236 46.8998 27.776L42.55 34.2204L41.2 32.5086C41 32.2569 40.6501 32.0555 40.3001 32.0555C39.9001 32.0555 39.5501 32.2569 39.3501 32.5086L36.1503 36.5364C35.8503 36.9392 35.8003 37.4427 36.0003 37.8454C36.2003 38.2482 36.6003 38.5 37.1002 38.5H41.9H43.4999H53.8994C54.2994 38.5 54.7494 38.2986 54.9494 37.8958C55.1494 37.493 55.0994 36.9895 54.8494 36.6371L48.8497 27.776ZM38.3002 27.2222C39.6001 27.2222 40.7001 26.1649 40.7001 24.8055C40.7001 23.4965 39.6001 22.3888 38.3002 22.3888C36.9502 22.3888 35.9003 23.4965 35.9003 24.8055C35.9003 26.1649 36.9502 27.2222 38.3002 27.2222Z",
    fill: "#E9ECEF"
  })), _path3 || (_path3 = /*#__PURE__*/react.createElement("path", {
    d: "M2.93236 228.722L2.94063 228.713L2.94905 228.705L69.8333 161.821C54.5587 144.827 45.5601 122.362 45.5601 97.6562C45.5601 44.5392 88.6133 1.5 141.716 1.5C194.828 1.5 237.463 44.5615 237.463 97.6562C237.463 150.755 194.419 193.812 141.716 193.812C117.015 193.812 94.5313 184.422 77.5066 169.111L10.6223 235.996L10.5079 236.11L10.3717 236.198C9.77022 236.584 9.18964 236.896 8.65544 237.117C8.14888 237.326 7.57274 237.5 7.01323 237.5C6.50536 237.5 5.85782 237.356 5.27307 237.142C4.7039 236.934 4.00711 236.593 3.44817 236.062C0.945587 234.051 0.94342 230.775 2.93236 228.722ZM141.716 183.531C189.081 183.531 227.591 145.007 227.591 97.6562C227.591 50.3056 189.067 11.7812 141.716 11.7812C94.3657 11.7812 55.8414 50.3056 55.8414 97.6562C55.8414 145.012 93.9472 183.531 141.716 183.531Z",
    fill: "#6C757D",
    stroke: "#343A40",
    strokeWidth: 3
  })), _rect17 || (_rect17 = /*#__PURE__*/react.createElement("rect", {
    x: 84.9629,
    y: 70,
    width: 186,
    height: 50.2222,
    rx: 4,
    fill: "white",
    stroke: "#212529",
    strokeWidth: 2
  })), emptystate_circle || (emptystate_circle = /*#__PURE__*/react.createElement("circle", {
    cx: 260.938,
    cy: 80.6049,
    r: 4.06173,
    fill: "#ADB5BD"
  })), emptystate_circle2 || (emptystate_circle2 = /*#__PURE__*/react.createElement("circle", {
    cx: 249.333,
    cy: 80.6049,
    r: 4.06173,
    fill: "#ADB5BD"
  })), _rect18 || (_rect18 = /*#__PURE__*/react.createElement("rect", {
    x: 132.123,
    y: 77.1235,
    width: 76.5926,
    height: 6.38272,
    rx: 3.19136,
    fill: "#ADB5BD"
  })), _rect19 || (_rect19 = /*#__PURE__*/react.createElement("rect", {
    x: 132.123,
    y: 86.9877,
    width: 50.4815,
    height: 6.38272,
    rx: 3.19136,
    fill: "#ADB5BD"
  })), _rect20 || (_rect20 = /*#__PURE__*/react.createElement("rect", {
    x: 132.123,
    y: 100.914,
    width: 38.2963,
    height: 4.06173,
    rx: 2.03086,
    fill: "#CED4DA"
  })), _rect21 || (_rect21 = /*#__PURE__*/react.createElement("rect", {
    x: 173.901,
    y: 100.914,
    width: 38.2963,
    height: 4.06173,
    rx: 2.03086,
    fill: "#CED4DA"
  })), _rect22 || (_rect22 = /*#__PURE__*/react.createElement("rect", {
    x: 215.679,
    y: 100.914,
    width: 38.2963,
    height: 4.06173,
    rx: 2.03086,
    fill: "#CED4DA"
  })), _rect23 || (_rect23 = /*#__PURE__*/react.createElement("rect", {
    x: 132.123,
    y: 107.876,
    width: 116.63,
    height: 4.06173,
    rx: 2.03086,
    fill: "#CED4DA"
  })), _rect24 || (_rect24 = /*#__PURE__*/react.createElement("rect", {
    x: 91.5061,
    y: 76.5432,
    width: 33.6543,
    height: 27.8519,
    rx: 7,
    fill: "#FDF3F3"
  })), _path4 || (_path4 = /*#__PURE__*/react.createElement("path", {
    d: "M106.477 85L108.431 88.5909L110.439 85H113.79L110.45 90.7738L113.943 96.8095H110.581L108.453 93.0113L106.325 96.8095H102.963L106.456 90.7738L103.116 85H106.477Z",
    fill: "#DA615C"
  })));
}

var emptystate_ForwardRef = /*#__PURE__*/react.forwardRef(SvgEmptystate);
/* harmony default export */ var emptystate = (__webpack_require__.p + "static/media/emptystate.89a16119f881edf92cb9dc401f5d3c71.svg");

;// CONCATENATED MODULE: ./src/components/no-result-overlay.js
/**
 * @param {object} props Props
 * @param {string} props.state Defining the state of the overlay
 * @returns {JSX.Element} Overlay visualizing a zero-hit result
 */function NoResultOverlay(_ref){var state=_ref.state;return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"no-result-overlay",children:[state==="initial"&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"no-initial-image",children:/*#__PURE__*/(0,jsx_runtime.jsx)(ForwardRef,{})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"no-result-text",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Du har endnu ikke startet en s\xF8gning."}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Brug filtrene ovenfor for at v\xE6lge hvad du vil s\xF8ge p\xE5."})]})]}),state==="noresult"&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"no-result-image",children:/*#__PURE__*/(0,jsx_runtime.jsx)(emptystate_ForwardRef,{})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"no-result-text",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Din s\xF8gning giver desv\xE6rre ikke nogen resultater."}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Pr\xF8v at \xE6ndre p\xE5 filtrene i toppen."})]})]})]});}/* harmony default export */ var no_result_overlay = (NoResultOverlay);
;// CONCATENATED MODULE: ./src/util/api.js
var Api=/*#__PURE__*/function(){function Api(){_classCallCheck(this,Api);}_createClass(Api,null,[{key:"fetchAllResources",value:function(){var _fetchAllResources=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(apiEndpoint){return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/resources-all")).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}));case 1:case"end":return _context.stop();}}},_callee);}));function fetchAllResources(_x){return _fetchAllResources.apply(this,arguments);}return fetchAllResources;}()},{key:"fetchLocations",value:function(){var _fetchLocations=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(apiEndpoint){return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:return _context2.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/locations")).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}).then(function(data){return data["hydra:member"];}));case 1:case"end":return _context2.stop();}}},_callee2);}));function fetchLocations(_x2){return _fetchLocations.apply(this,arguments);}return fetchLocations;}()},{key:"fetchResources",value:function(){var _fetchResources=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(apiEndpoint,urlSearchParams){return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:return _context3.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/resources?").concat(urlSearchParams)).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}).then(function(data){return data["hydra:member"];}));case 1:case"end":return _context3.stop();}}},_callee3);}));function fetchResources(_x3,_x4){return _fetchResources.apply(this,arguments);}return fetchResources;}()},{key:"fetchEvents",value:function(){var _fetchEvents=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(apiEndpoint,resources,date){var dateEnd,urlSearchParams;return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:dateEnd=dayjs_min_default()(date).endOf("day");// Setup query parameters.
urlSearchParams=new URLSearchParams({resources:resources.map(function(resource){return resource.resourceMail;}),dateStart:date.toISOString(),dateEnd:dateEnd.toISOString(),page:1});// Events on resource.
return _context4.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/busy_intervals?").concat(urlSearchParams)).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}).then(function(data){return data["hydra:member"];}));case 3:case"end":return _context4.stop();}}},_callee4);}));function fetchEvents(_x5,_x6,_x7){return _fetchEvents.apply(this,arguments);}return fetchEvents;}()},{key:"fetchResource",value:function(){var _fetchResource=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(apiEndpoint,resourceEmail){return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:return _context5.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/resources/").concat(resourceEmail)).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}));case 1:case"end":return _context5.stop();}}},_callee5);}));function fetchResource(_x8,_x9){return _fetchResource.apply(this,arguments);}return fetchResource;}()},{key:"fetchUserBookings",value:function(){var _fetchUserBookings=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(apiEndpoint,search,sort,page,pageSize){var params;return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:params=new URLSearchParams({page:page,pageSize:pageSize});params.append("title",search);params.append(Object.keys(sort)[0],Object.values(sort)[0]);return _context6.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/user-bookings?").concat(params)).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}));case 4:case"end":return _context6.stop();}}},_callee6);}));function fetchUserBookings(_x10,_x11,_x12,_x13,_x14){return _fetchUserBookings.apply(this,arguments);}return fetchUserBookings;}()},{key:"deleteBooking",value:function(){var _deleteBooking=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(apiEndpoint,bookingId){return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:return _context7.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/user-booking/").concat(bookingId),{method:"DELETE"}).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}}));case 1:case"end":return _context7.stop();}}},_callee7);}));function deleteBooking(_x15,_x16){return _deleteBooking.apply(this,arguments);}return deleteBooking;}()},{key:"patchBooking",value:function(){var _patchBooking=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(apiEndpoint,bookingId,newData){return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:return _context8.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/user-booking/").concat(bookingId),{method:"PATCH",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify(newData)}).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}));case 1:case"end":return _context8.stop();}}},_callee8);}));function patchBooking(_x17,_x18,_x19){return _patchBooking.apply(this,arguments);}return patchBooking;}()},{key:"fetchUserInformation",value:function(){var _fetchUserInformation=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(apiEndpoint){return _regeneratorRuntime().wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:return _context9.abrupt("return",fetch("".concat(apiEndpoint,"itkdev_booking/user-information")).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();}));case 1:case"end":return _context9.stop();}}},_callee9);}));function fetchUserInformation(_x20){return _fetchUserInformation.apply(this,arguments);}return fetchUserInformation;}()},{key:"fetchBookingStatus",value:function fetchBookingStatus(apiEndpoint,pendingBookings){return fetch("".concat(apiEndpoint,"itkdev_booking/pending-bookings"),{headers:{Accept:"application/json","Content-Type":"application/json"},method:"POST",body:JSON.stringify({ids:pendingBookings})}).then(function(response){if(!response.ok){throw new Error("This is an HTTP error: The status is ".concat(response.status));}return response.json();});}}]);return Api;}();
;// CONCATENATED MODULE: ./node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (false) { var isImportRule; }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (false) {}
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (false) {}
  };

  return StyleSheet;
}();


;// CONCATENATED MODULE: ./node_modules/stylis/src/Utility.js
/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs;
/**
 * @param {number}
 * @return {string}
 */

var Utility_from = String.fromCharCode;
/**
 * @param {object}
 * @return {object}
 */

var Utility_assign = Object.assign;
/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */

function hash(value, length) {
  return (((length << 2 ^ Utility_charat(value, 0)) << 2 ^ Utility_charat(value, 1)) << 2 ^ Utility_charat(value, 2)) << 2 ^ Utility_charat(value, 3);
}
/**
 * @param {string} value
 * @return {string}
 */

function trim(value) {
  return value.trim();
}
/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */

function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */

function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */

function indexof(value, search) {
  return value.indexOf(search);
}
/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */

function Utility_charat(value, index) {
  return value.charCodeAt(index) | 0;
}
/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */

function Utility_substr(value, begin, end) {
  return value.slice(begin, end);
}
/**
 * @param {string} value
 * @return {number}
 */

function Utility_strlen(value) {
  return value.length;
}
/**
 * @param {any[]} value
 * @return {number}
 */

function Utility_sizeof(value) {
  return value.length;
}
/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */

function Utility_append(value, array) {
  return array.push(value), value;
}
/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */

function Utility_combine(array, callback) {
  return array.map(callback).join('');
}
;// CONCATENATED MODULE: ./node_modules/stylis/src/Tokenizer.js

var line = 1;
var column = 1;
var Tokenizer_length = 0;
var position = 0;
var character = 0;
var characters = '';
/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */

function node(value, root, parent, type, props, children, length) {
  return {
    value: value,
    root: root,
    parent: parent,
    type: type,
    props: props,
    children: children,
    line: line,
    column: column,
    length: length,
    return: ''
  };
}
/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */

function copy(root, props) {
  return Utility_assign(node('', null, null, '', null, null, 0), root, {
    length: -root.length
  }, props);
}
/**
 * @return {number}
 */

function Tokenizer_char() {
  return character;
}
/**
 * @return {number}
 */

function prev() {
  character = position > 0 ? Utility_charat(characters, --position) : 0;
  if (column--, character === 10) column = 1, line--;
  return character;
}
/**
 * @return {number}
 */

function next() {
  character = position < Tokenizer_length ? Utility_charat(characters, position++) : 0;
  if (column++, character === 10) column = 1, line++;
  return character;
}
/**
 * @return {number}
 */

function peek() {
  return Utility_charat(characters, position);
}
/**
 * @return {number}
 */

function caret() {
  return position;
}
/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */

function slice(begin, end) {
  return Utility_substr(characters, begin, end);
}
/**
 * @param {number} type
 * @return {number}
 */

function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token

    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126: // ; { } breakpoint token

    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token

    case 58:
      return 3;
    // " ' ( [ opening delimit token

    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token

    case 41:
    case 93:
      return 1;
  }

  return 0;
}
/**
 * @param {string} value
 * @return {any[]}
 */

function alloc(value) {
  return line = column = 1, Tokenizer_length = Utility_strlen(characters = value), position = 0, [];
}
/**
 * @param {any} value
 * @return {any}
 */

function dealloc(value) {
  return characters = '', value;
}
/**
 * @param {number} type
 * @return {string}
 */

function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
/**
 * @param {string} value
 * @return {string[]}
 */

function Tokenizer_tokenize(value) {
  return dealloc(tokenizer(alloc(value)));
}
/**
 * @param {number} type
 * @return {string}
 */

function whitespace(type) {
  while (character = peek()) {
    if (character < 33) next();else break;
  }

  return token(type) > 2 || token(character) > 3 ? '' : ' ';
}
/**
 * @param {string[]} children
 * @return {string[]}
 */

function tokenizer(children) {
  while (next()) {
    switch (token(character)) {
      case 0:
        append(identifier(position - 1), children);
        break;

      case 2:
        append(delimit(character), children);
        break;

      default:
        append(from(character), children);
    }
  }

  return children;
}
/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */

function escaping(index, count) {
  while (--count && next()) {
    // not 0-9 A-F a-f
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
  }

  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
/**
 * @param {number} type
 * @return {number}
 */

function delimiter(type) {
  while (next()) {
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '

      case 34:
      case 39:
        if (type !== 34 && type !== 39) delimiter(character);
        break;
      // (

      case 40:
        if (type === 41) delimiter(type);
        break;
      // \

      case 92:
        next();
        break;
    }
  }

  return position;
}
/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */

function commenter(type, index) {
  while (next()) {
    // //
    if (type + character === 47 + 10) break; // /*
    else if (type + character === 42 + 42 && peek() === 47) break;
  }

  return '/*' + slice(index, position - 1) + '*' + Utility_from(type === 47 ? type : next());
}
/**
 * @param {number} index
 * @return {string}
 */

function identifier(index) {
  while (!token(peek())) {
    next();
  }

  return slice(index, position);
}
;// CONCATENATED MODULE: ./node_modules/stylis/src/Enum.js
var MS = '-ms-';
var MOZ = '-moz-';
var WEBKIT = '-webkit-';
var COMMENT = 'comm';
var Enum_RULESET = 'rule';
var DECLARATION = 'decl';
var PAGE = '@page';
var MEDIA = '@media';
var IMPORT = '@import';
var CHARSET = '@charset';
var VIEWPORT = '@viewport';
var SUPPORTS = '@supports';
var DOCUMENT = '@document';
var NAMESPACE = '@namespace';
var KEYFRAMES = '@keyframes';
var FONT_FACE = '@font-face';
var COUNTER_STYLE = '@counter-style';
var FONT_FEATURE_VALUES = '@font-feature-values';
;// CONCATENATED MODULE: ./node_modules/stylis/src/Serializer.js


/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */

function serialize(children, callback) {
  var output = '';
  var length = Utility_sizeof(children);

  for (var i = 0; i < length; i++) {
    output += callback(children[i], i, children, callback) || '';
  }

  return output;
}
/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */

function stringify(element, index, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;

    case COMMENT:
      return '';

    case KEYFRAMES:
      return element.return = element.value + '{' + serialize(element.children, callback) + '}';

    case Enum_RULESET:
      element.value = element.props.join(',');
  }

  return Utility_strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
}
;// CONCATENATED MODULE: ./node_modules/stylis/src/Prefixer.js


/**
 * @param {string} value
 * @param {number} length
 * @return {string}
 */

function prefix(value, length) {
  switch (hash(value, length)) {
    // color-adjust
    case 5103:
      return WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order

    case 6165:
      return WEBKIT + value + MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if (Utility_strlen(value) - 1 - length > 6) switch (Utility_charat(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if (Utility_charat(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (Utility_charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if (Utility_charat(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch (Utility_charat(value, Utility_strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ':', ':' + WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (Utility_charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch (Utility_charat(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return WEBKIT + value + MS + value + value;
  }

  return value;
}
;// CONCATENATED MODULE: ./node_modules/stylis/src/Middleware.js





/**
 * @param {function[]} collection
 * @return {function}
 */

function middleware(collection) {
  var length = Utility_sizeof(collection);
  return function (element, index, children, callback) {
    var output = '';

    for (var i = 0; i < length; i++) {
      output += collection[i](element, index, children, callback) || '';
    }

    return output;
  };
}
/**
 * @param {function} callback
 * @return {function}
 */

function rulesheet(callback) {
  return function (element) {
    if (!element.root) if (element = element.return) callback(element);
  };
}
/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */

function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element.return) switch (element.type) {
    case DECLARATION:
      element.return = prefix(element.value, element.length);
      break;

    case KEYFRAMES:
      return serialize([copy(element, {
        value: replace(element.value, '@', '@' + WEBKIT)
      })], callback);

    case Enum_RULESET:
      if (element.length) return Utility_combine(element.props, function (value) {
        switch (match(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return serialize([copy(element, {
              props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return serialize([copy(element, {
              props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
            }), copy(element, {
              props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
            }), copy(element, {
              props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
}
/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 */

function namespace(element) {
  switch (element.type) {
    case RULESET:
      element.props = element.props.map(function (value) {
        return combine(tokenize(value), function (value, index, children) {
          switch (charat(value, 0)) {
            // \f
            case 12:
              return substr(value, 1, strlen(value));
            // \0 ( + > ~

            case 0:
            case 40:
            case 43:
            case 62:
            case 126:
              return value;
            // :

            case 58:
              if (children[++index] === 'global') children[index] = '', children[++index] = '\f' + substr(children[index], index = 1, -1);
            // \s

            case 32:
              return index === 1 ? '' : value;

            default:
              switch (index) {
                case 0:
                  element = value;
                  return sizeof(children) > 1 ? '' : value;

                case index = sizeof(children) - 1:
                case 2:
                  return index === 2 ? value + element + element : value + element;

                default:
                  return value;
              }

          }
        });
      });
  }
}
;// CONCATENATED MODULE: ./node_modules/stylis/src/Parser.js



/**
 * @param {string} value
 * @return {object[]}
 */

function compile(value) {
  return dealloc(Parser_parse('', null, null, null, [''], value = alloc(value), 0, [0], value));
}
/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */

function Parser_parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character = 0;
  var type = '';
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters = type;

  while (scanning) {
    switch (previous = character, character = next()) {
      // (
      case 40:
        if (previous != 108 && characters.charCodeAt(length - 1) == 58) {
          if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1) ampersand = -1;
          break;
        }

      // " ' [

      case 34:
      case 39:
      case 91:
        characters += delimit(character);
        break;
      // \t \n \r \s

      case 9:
      case 10:
      case 13:
      case 32:
        characters += whitespace(previous);
        break;
      // \

      case 92:
        characters += escaping(caret() - 1, 7);
        continue;
      // /

      case 47:
        switch (peek()) {
          case 42:
          case 47:
            Utility_append(comment(commenter(next(), caret()), root, parent), declarations);
            break;

          default:
            characters += '/';
        }

        break;
      // {

      case 123 * variable:
        points[index++] = Utility_strlen(characters) * ampersand;
      // } ; \0

      case 125 * variable:
      case 59:
      case 0:
        switch (character) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;

          case 59 + offset:
            if (property > 0 && Utility_strlen(characters) - length) Utility_append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
            break;
          // @ ;

          case 59:
            characters += ';';
          // { rule/at-rule

          default:
            Utility_append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
            if (character === 123) if (offset === 0) Parser_parse(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule) {
              // d m s
              case 100:
              case 109:
              case 115:
                Parser_parse(value, reference, reference, rule && Utility_append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
                break;

              default:
                Parser_parse(characters, reference, reference, reference, [''], children, 0, points, children);
            }
        }

        index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
        break;
      // :

      case 58:
        length = 1 + Utility_strlen(characters), property = previous;

      default:
        if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev() == 125) continue;

        switch (characters += Utility_from(character), character * variable) {
          // &
          case 38:
            ampersand = offset > 0 ? 1 : (characters += '\f', -1);
            break;
          // ,

          case 44:
            points[index++] = (Utility_strlen(characters) - 1) * ampersand, ampersand = 1;
            break;
          // @

          case 64:
            // -
            if (peek() === 45) characters += delimit(next());
            atrule = peek(), offset = length = Utility_strlen(type = characters += identifier(caret())), character++;
            break;
          // -

          case 45:
            if (previous === 45 && Utility_strlen(characters) == 2) variable = 0;
        }

    }
  }

  return rulesets;
}
/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */

function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [''];
  var size = Utility_sizeof(rule);

  for (var i = 0, j = 0, k = 0; i < index; ++i) {
    for (var x = 0, y = Utility_substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) {
      if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
    }
  }

  return node(value, root, parent, offset === 0 ? Enum_RULESET : type, props, children, length);
}
/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */

function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, Utility_from(Tokenizer_char()), Utility_substr(value, 2, -2), 0);
}
/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */

function declaration(value, root, parent, length) {
  return node(value, root, parent, DECLARATION, Utility_substr(value, 0, length), Utility_substr(value, length + 1, -1), length);
}
;// CONCATENATED MODULE: ./node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js





var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    next();
  }

  return slice(begin, position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += Utility_from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();

var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};

var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};

var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses) {
      var isNested = element.parent === children[0]; // in nested rules comments become children of the "auto-inserted" rule
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? children[0].children : // global rule at the root level
      children;

      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];

        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version


        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }

          break;
        }
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

var defaultStylisPlugins = [prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if (false) {}

  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }

      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (false) {}

  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (false) {}

  {
    var currentSheet;
    var finalizingPlugins = [stringify,  false ? 0 : rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (false) {}

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

/* harmony default export */ var emotion_cache_browser_esm = (createCache);
;// CONCATENATED MODULE: ./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = "object" !== 'undefined';

function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}

var registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};

var emotion_utils_browser_esm_insertStyles = function insertStyles(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
      current = current.next;
    } while (current !== undefined);
  }
};


;// CONCATENATED MODULE: ./node_modules/@emotion/hash/dist/emotion-hash.esm.js
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

/* harmony default export */ var emotion_hash_esm = (murmur2);
;// CONCATENATED MODULE: ./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
/* harmony default export */ var emotion_unitless_esm = (unitlessKeys);
;// CONCATENATED MODULE: ./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function emotion_memoize_esm_memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ var emotion_memoize_esm = (emotion_memoize_esm_memoize);
;// CONCATENATED MODULE: ./node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js



var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */emotion_memoize_esm(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (emotion_unitless_esm[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (false) { var hyphenatedCache, hyphenPattern, msPattern, oldProcessStyleValue, contentValues, contentValuePattern; }

var noComponentSelectorMessage = (/* unused pure expression or super */ null && ('Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.'));

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (false) {}

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          if (false) {}

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (false) {}

        break;
      }

    case 'string':
      if (false) { var replaced, matched; }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {}

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if (false) {}

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;

if (false) {} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;

var emotion_serialize_browser_esm_serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (false) {}

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      if (false) {}

      styles += strings[i];
    }
  }

  var sourceMap;

  if (false) {} // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = emotion_hash_esm(styles) + identifierName;

  if (false) {}

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};


;// CONCATENATED MODULE: ./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js



var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect = react_namespaceObject['useInsertion' + 'Effect'] ? react_namespaceObject['useInsertion' + 'Effect'] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var emotion_use_insertion_effect_with_fallbacks_browser_esm_useInsertionEffectWithLayoutFallback = useInsertionEffect || react.useLayoutEffect;

;// CONCATENATED MODULE: ./node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js








var emotion_element_6a883da9_browser_esm_hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* #__PURE__ */(0,react.createContext)( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */emotion_cache_browser_esm({
  key: 'css'
}) : null);

if (false) {}

var CacheProvider = EmotionCacheContext.Provider;

var __unsafe_useEmotionCache = function useEmotionCache() {
  return useContext(EmotionCacheContext);
};

var emotion_element_6a883da9_browser_esm_withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {
    // the cache will never be null in the browser
    var cache = (0,react.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

var emotion_element_6a883da9_browser_esm_ThemeContext = /* #__PURE__ */(0,react.createContext)({});

if (false) {}

var useTheme = function useTheme() {
  return useContext(emotion_element_6a883da9_browser_esm_ThemeContext);
};

var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(outerTheme);

    if (false) {}

    return mergedTheme;
  }

  if (false) {}

  return _extends({}, outerTheme, theme);
};

var createCacheWithTheme = /* #__PURE__ */(/* unused pure expression or super */ null && (weakMemoize(function (outerTheme) {
  return weakMemoize(function (theme) {
    return getTheme(outerTheme, theme);
  });
})));

var ThemeProvider = function ThemeProvider(props) {
  var theme = useContext(emotion_element_6a883da9_browser_esm_ThemeContext);

  if (props.theme !== theme) {
    theme = createCacheWithTheme(theme)(props.theme);
  }

  return /*#__PURE__*/createElement(emotion_element_6a883da9_browser_esm_ThemeContext.Provider, {
    value: theme
  }, props.children);
};

function withTheme(Component) {
  var componentName = Component.displayName || Component.name || 'Component';

  var render = function render(props, ref) {
    var theme = useContext(emotion_element_6a883da9_browser_esm_ThemeContext);
    return /*#__PURE__*/createElement(Component, _extends({
      theme: theme,
      ref: ref
    }, props));
  }; // $FlowFixMe


  var WithTheme = /*#__PURE__*/forwardRef(render);
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return hoistNonReactStatics(WithTheme, Component);
}

var getLastPart = function getLastPart(functionName) {
  // The match may be something like 'Object.createEmotionProps' or
  // 'Loader.prototype.render'
  var parts = functionName.split('.');
  return parts[parts.length - 1];
};

var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine(line) {
  // V8
  var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
  if (match) return getLastPart(match[1]); // Safari / Firefox

  match = /^([A-Za-z0-9$.]+)@/.exec(line);
  if (match) return getLastPart(match[1]);
  return undefined;
};

var internalReactFunctionNames = /* #__PURE__ */new Set(['renderWithHooks', 'processChild', 'finishClassComponent', 'renderToString']); // These identifiers come from error stacks, so they have to be valid JS
// identifiers, thus we only need to replace what is a valid character for JS,
// but not for CSS.

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};

var getLabelFromStackTrace = function getLabelFromStackTrace(stackTrace) {
  if (!stackTrace) return undefined;
  var lines = stackTrace.split('\n');

  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]); // The first line of V8 stack traces is just "Error"

    if (!functionName) continue; // If we reach one of these, we have gone too far and should quit

    if (internalReactFunctionNames.has(functionName)) break; // The component name is the first function in the stack that starts with an
    // uppercase letter

    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }

  return undefined;
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';

var createEmotionProps = function createEmotionProps(type, props) {
  if (false) {}

  var newProps = {};

  for (var key in props) {
    if (emotion_element_6a883da9_browser_esm_hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when
  // the label hasn't already been computed

  if (false) { var label; }

  return newProps;
};

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
    return emotion_utils_browser_esm_insertStyles(cache, serialized, isStringTag);
  });
  return null;
};

var Emotion = /* #__PURE__ */emotion_element_6a883da9_browser_esm_withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = emotion_serialize_browser_esm_serializeStyles(registeredStyles, undefined, (0,react.useContext)(emotion_element_6a883da9_browser_esm_ThemeContext));

  if (false) { var labelFromStack; }

  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (emotion_element_6a883da9_browser_esm_hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ( true || 0)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  return /*#__PURE__*/(0,react.createElement)(react.Fragment, null, /*#__PURE__*/(0,react.createElement)(Insertion, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/(0,react.createElement)(WrappedComponent, newProps));
});

if (false) {}


// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(2110);
;// CONCATENATED MODULE: ./node_modules/@emotion/react/dist/emotion-react.browser.esm.js











var pkg = {
  name: "@emotion/react",
  version: "11.10.4",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": "./macro.js"
  },
  types: "types/index.d.ts",
  files: ["src", "dist", "jsx-runtime", "jsx-dev-runtime", "_isolated-hnrs", "types/*.d.ts", "macro.js", "macro.d.ts", "macro.js.flow"],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.10.0",
    "@emotion/cache": "^11.10.0",
    "@emotion/serialize": "^1.1.0",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
    "@emotion/utils": "^1.2.0",
    "@emotion/weak-memoize": "^0.3.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    "@babel/core": "^7.0.0",
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@babel/core": {
      optional: true
    },
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@babel/core": "^7.18.5",
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.10.0",
    "@emotion/css-prettifier": "1.1.0",
    "@emotion/server": "11.10.0",
    "@emotion/styled": "11.10.4",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: ["./index.js", "./jsx-runtime.js", "./jsx-dev-runtime.js", "./_isolated-hnrs.js"],
    umdName: "emotionReact",
    exports: {
      envConditions: ["browser", "worker"],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": "./macro.js"
      }
    }
  }
};

var jsx = function jsx(type, props) {
  var args = arguments;

  if (props == null || !emotion_element_6a883da9_browser_esm_hasOwnProperty.call(props, 'css')) {
    // $FlowFixMe
    return react.createElement.apply(undefined, args);
  }

  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion;
  createElementArgArray[1] = createEmotionProps(type, props);

  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  } // $FlowFixMe


  return react.createElement.apply(null, createElementArgArray);
};

var warnedAboutCssPropForGlobal = false; // maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag

var Global = /* #__PURE__ */(/* unused pure expression or super */ null && (withEmotionCache(function (props, cache) {
  if (false) {}

  var styles = props.styles;
  var serialized = serializeStyles([styles], undefined, useContext(ThemeContext)); // but it is based on a constant that will never change at runtime
  // it's effectively like having two implementations and switching them out
  // so it's not actually breaking anything

  var sheetRef = useRef();
  useInsertionEffectWithLayoutFallback(function () {
    var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

    var sheet = new cache.sheet.constructor({
      key: key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false; // $FlowFixMe

    var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");

    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }

    if (node !== null) {
      rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

      node.setAttribute('data-emotion', key);
      sheet.hydrate([node]);
    }

    sheetRef.current = [sheet, rehydrating];
    return function () {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function () {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0],
        rehydrating = sheetRefCurrent[1];

    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }

    if (serialized.next !== undefined) {
      // insert keyframes
      insertStyles(cache, serialized.next, true);
    }

    if (sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }

    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
})));

if (false) {}

function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return emotion_serialize_browser_esm_serializeStyles(args);
}

var keyframes = function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';

  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (typeof arg) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            if (false) {}

            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css(registeredStyles);
}

var emotion_react_browser_esm_Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serializedArr = _ref.serializedArr;
  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
    for (var i = 0; i < serializedArr.length; i++) {
      var res = emotion_utils_browser_esm_insertStyles(cache, serializedArr[i], false);
    }
  });
  return null;
};

var ClassNames = /* #__PURE__ */emotion_element_6a883da9_browser_esm_withEmotionCache(function (props, cache) {
  var hasRendered = false;
  var serializedArr = [];

  var css = function css() {
    if (hasRendered && "production" !== 'production') {}

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var serialized = emotion_serialize_browser_esm_serializeStyles(args, cache.registered);
    serializedArr.push(serialized); // registration has to happen here as the result of this might get consumed by `cx`

    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };

  var cx = function cx() {
    if (hasRendered && "production" !== 'production') {}

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return merge(cache.registered, css, classnames(args));
  };

  var content = {
    css: css,
    cx: cx,
    theme: (0,react.useContext)(emotion_element_6a883da9_browser_esm_ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /*#__PURE__*/(0,react.createElement)(react.Fragment, null, /*#__PURE__*/(0,react.createElement)(emotion_react_browser_esm_Insertion, {
    cache: cache,
    serializedArr: serializedArr
  }), ele);
});

if (false) {}

if (false) { var globalKey, globalContext, isJest, emotion_react_browser_esm_isBrowser; }


;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ./node_modules/react-select/dist/index-a7690a33.esm.js













function index_a7690a33_esm_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function index_a7690a33_esm_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function index_a7690a33_esm_objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      index_a7690a33_esm_ownKeys(Object(source), true).forEach(function (key) {
        index_a7690a33_esm_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      index_a7690a33_esm_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var _excluded$3 = ["className", "clearValue", "cx", "getStyles", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"]; // ==============================
// NO OP
// ==============================

var noop = function noop() {}; // Class Name Prefixer
// ==============================

/**
 String representation of component state for styling with class names.

 Expects an array of strings OR a string/object pair:
 - className(['comp', 'comp-arg', 'comp-arg-2'])
   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
 - className('comp', { some: true, state: false })
   @returns 'react-select__comp react-select__comp--some'
*/


function applyPrefixToName(prefix, name) {
  if (!name) {
    return prefix;
  } else if (name[0] === '-') {
    return prefix + name;
  } else {
    return prefix + '__' + name;
  }
}

function classNames(prefix, state, className) {
  var arr = [className];

  if (state && prefix) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix, key)));
      }
    }
  }

  return arr.filter(function (i) {
    return i;
  }).map(function (i) {
    return String(i).trim();
  }).join(' ');
} // ==============================
// Clean Value
// ==============================


var cleanValue = function cleanValue(value) {
  if (isArray(value)) return value.filter(Boolean);
  if (_typeof(value) === 'object' && value !== null) return [value];
  return [];
}; // ==============================
// Clean Common Props
// ==============================


var cleanCommonProps = function cleanCommonProps(props) {
  //className
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;

  var innerProps = _objectWithoutProperties(props, _excluded$3);

  return index_a7690a33_esm_objectSpread2({}, innerProps);
}; // ==============================
// Handle Input Change
// ==============================


function handleInputChange(inputValue, actionMeta, onInputChange) {
  if (onInputChange) {
    var _newValue = onInputChange(inputValue, actionMeta);

    if (typeof _newValue === 'string') return _newValue;
  }

  return inputValue;
} // ==============================
// Scroll Helpers
// ==============================


function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
} // Normalized Scroll Top
// ------------------------------


function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }

  return el.clientHeight;
} // Normalized scrollTo & scrollTop
// ------------------------------


function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }

  return el.scrollTop;
}

function scrollTo(el, top) {
  // with a scroll distance, we perform scroll on the element
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }

  el.scrollTop = top;
} // Get Scroll Parent
// ------------------------------


function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === 'absolute';
  var overflowRx = /(auto|scroll)/;
  if (style.position === 'fixed') return document.documentElement;

  for (var parent = element; parent = parent.parentElement;) {
    style = getComputedStyle(parent);

    if (excludeStaticParent && style.position === 'static') {
      continue;
    }

    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }

  return document.documentElement;
} // Animated Scroll To
// ------------------------------

/**
  @param t: time (elapsed)
  @param b: initial value
  @param c: amount of change
  @param d: duration
*/


function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}

function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;

  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);

    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }

  animateScroll();
} // Scroll Into View
// ------------------------------


function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;

  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
} // ==============================
// Get bounding client object
// ==============================
// cannot get keys using array notation with DOMRect


function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
} // Touch Capability Detector
// ==============================


function isTouchCapable() {
  try {
    document.createEvent('TouchEvent');
    return true;
  } catch (e) {
    return false;
  }
} // ==============================
// Mobile Device Detector
// ==============================


function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e) {
    return false;
  }
} // ==============================
// Passive Event Detector
// ==============================
// https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36


var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }

}; // check for SSR

var w = typeof window !== 'undefined' ? window : {};

if (w.addEventListener && w.removeEventListener) {
  w.addEventListener('p', noop, options);
  w.removeEventListener('p', noop, false);
}

var supportsPassiveEvents = passiveOptionAccessed;

function notNullish(item) {
  return item != null;
}

function isArray(arg) {
  return Array.isArray(arg);
}

function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}

function singleValueAsValue(singleValue) {
  return singleValue;
}

function multiValueAsValue(multiValue) {
  return multiValue;
}

var removeProps = function removeProps(propsObj) {
  for (var _len = arguments.length, properties = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    properties[_key - 1] = arguments[_key];
  }

  var propsMap = Object.entries(propsObj).filter(function (_ref) {
    var _ref2 = slicedToArray_slicedToArray(_ref, 1),
        key = _ref2[0];

    return !properties.includes(key);
  });
  return propsMap.reduce(function (newProps, _ref3) {
    var _ref4 = slicedToArray_slicedToArray(_ref3, 2),
        key = _ref4[0],
        val = _ref4[1];

    newProps[key] = val;
    return newProps;
  }, {});
};

function getMenuPlacement(_ref) {
  var maxHeight = _ref.maxHeight,
      menuEl = _ref.menuEl,
      minHeight = _ref.minHeight,
      placement = _ref.placement,
      shouldScroll = _ref.shouldScroll,
      isFixedPosition = _ref.isFixedPosition,
      theme = _ref.theme;
  var spacing = theme.spacing;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: 'bottom',
    maxHeight: maxHeight
  }; // something went wrong, return default state

  if (!menuEl || !menuEl.offsetParent) return defaultState; // we can't trust `scrollParent.scrollHeight` --> it may increase when
  // the menu is rendered

  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
      scrollHeight = _scrollParent$getBoun.height;

  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
      menuBottom = _menuEl$getBoundingCl.bottom,
      menuHeight = _menuEl$getBoundingCl.height,
      menuTop = _menuEl$getBoundingCl.top;

  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
      containerTop = _menuEl$offsetParent$.top;

  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;

  switch (placement) {
    case 'auto':
    case 'bottom':
      // 1: the menu will fit, do nothing
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled


      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }

        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained


      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        } // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.


        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: 'bottom',
          maxHeight: constrainedHeight
        };
      } // 4. Forked beviour when there isn't enough space below
      // AUTO: flip the menu, render above


      if (placement === 'auto' || isFixedPosition) {
        // may need to be constrained after flipping
        var _constrainedHeight = maxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;

        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - spacing.controlHeight, maxHeight);
        }

        return {
          placement: 'top',
          maxHeight: _constrainedHeight
        };
      } // BOTTOM: allow browser to increase scrollable area and immediately set scroll


      if (placement === 'bottom') {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }

        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      }

      break;

    case 'top':
      // 1: the menu will fit, do nothing
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled


      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }

        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained


      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = maxHeight; // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.

        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }

        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }

        return {
          placement: 'top',
          maxHeight: _constrainedHeight2
        };
      } // 4. not enough space, the browser WILL NOT increase scrollable area when
      // absolutely positioned element rendered above the viewport (only below).
      // Flip the menu, render below


      return {
        placement: 'bottom',
        maxHeight: maxHeight
      };

    default:
      throw new Error("Invalid placement provided \"".concat(placement, "\"."));
  }

  return defaultState;
} // Menu Component
// ------------------------------


function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: 'top',
    top: 'bottom'
  };
  return placement ? placementToCSSProp[placement] : 'bottom';
}

var coercePlacement = function coercePlacement(p) {
  return p === 'auto' ? 'bottom' : p;
};

var menuCSS = function menuCSS(_ref2) {
  var _ref3;

  var placement = _ref2.placement,
      _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      spacing = _ref2$theme.spacing,
      colors = _ref2$theme.colors;
  return _ref3 = {
    label: 'menu'
  }, _defineProperty(_ref3, alignToControl(placement), '100%'), _defineProperty(_ref3, "backgroundColor", colors.neutral0), _defineProperty(_ref3, "borderRadius", borderRadius), _defineProperty(_ref3, "boxShadow", '0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)'), _defineProperty(_ref3, "marginBottom", spacing.menuGutter), _defineProperty(_ref3, "marginTop", spacing.menuGutter), _defineProperty(_ref3, "position", 'absolute'), _defineProperty(_ref3, "width", '100%'), _defineProperty(_ref3, "zIndex", 1), _ref3;
};

var PortalPlacementContext = /*#__PURE__*/(0,react.createContext)({
  getPortalPlacement: null
}); // NOTE: internal only

var MenuPlacer = /*#__PURE__*/function (_Component) {
  _inherits(MenuPlacer, _Component);

  var _super = _createSuper(MenuPlacer);

  function MenuPlacer() {
    var _this;

    _classCallCheck(this, MenuPlacer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      maxHeight: _this.props.maxMenuHeight,
      placement: null
    };
    _this.context = void 0;

    _this.getPlacement = function (ref) {
      var _this$props = _this.props,
          minMenuHeight = _this$props.minMenuHeight,
          maxMenuHeight = _this$props.maxMenuHeight,
          menuPlacement = _this$props.menuPlacement,
          menuPosition = _this$props.menuPosition,
          menuShouldScrollIntoView = _this$props.menuShouldScrollIntoView,
          theme = _this$props.theme;
      if (!ref) return; // DO NOT scroll if position is fixed

      var isFixedPosition = menuPosition === 'fixed';
      var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
      var state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl: ref,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll: shouldScroll,
        isFixedPosition: isFixedPosition,
        theme: theme
      });
      var getPortalPlacement = _this.context.getPortalPlacement;
      if (getPortalPlacement) getPortalPlacement(state);

      _this.setState(state);
    };

    _this.getUpdatedProps = function () {
      var menuPlacement = _this.props.menuPlacement;
      var placement = _this.state.placement || coercePlacement(menuPlacement);
      return index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2({}, _this.props), {}, {
        placement: placement,
        maxHeight: _this.state.maxHeight
      });
    };

    return _this;
  }

  _createClass(MenuPlacer, [{
    key: "render",
    value: function render() {
      var children = this.props.children;
      return children({
        ref: this.getPlacement,
        placerProps: this.getUpdatedProps()
      });
    }
  }]);

  return MenuPlacer;
}(react.Component);

MenuPlacer.contextType = PortalPlacementContext;

var Menu = function Menu(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('menu', props),
    className: cx({
      menu: true
    }, className),
    ref: innerRef
  }, innerProps), children);
}; // Menu List
// ==============================


var menuListCSS = function menuListCSS(_ref4) {
  var maxHeight = _ref4.maxHeight,
      baseUnit = _ref4.theme.spacing.baseUnit;
  return {
    maxHeight: maxHeight,
    overflowY: 'auto',
    paddingBottom: baseUnit,
    paddingTop: baseUnit,
    position: 'relative',
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: 'touch'
  };
};

var MenuList = function MenuList(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      innerRef = props.innerRef,
      isMulti = props.isMulti;
  return jsx("div", extends_extends({
    css: getStyles('menuList', props),
    className: cx({
      'menu-list': true,
      'menu-list--is-multi': isMulti
    }, className),
    ref: innerRef
  }, innerProps), children);
}; // ==============================
// Menu Notices
// ==============================


var noticeCSS = function noticeCSS(_ref5) {
  var _ref5$theme = _ref5.theme,
      baseUnit = _ref5$theme.spacing.baseUnit,
      colors = _ref5$theme.colors;
  return {
    color: colors.neutral40,
    padding: "".concat(baseUnit * 2, "px ").concat(baseUnit * 3, "px"),
    textAlign: 'center'
  };
};

var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;

var NoOptionsMessage = function NoOptionsMessage(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('noOptionsMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--no-options': true
    }, className)
  }, innerProps), children);
};

NoOptionsMessage.defaultProps = {
  children: 'No options'
};

var LoadingMessage = function LoadingMessage(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('loadingMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--loading': true
    }, className)
  }, innerProps), children);
};

LoadingMessage.defaultProps = {
  children: 'Loading...'
}; // ==============================
// Menu Portal
// ==============================

var menuPortalCSS = function menuPortalCSS(_ref6) {
  var rect = _ref6.rect,
      offset = _ref6.offset,
      position = _ref6.position;
  return {
    left: rect.left,
    position: position,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};

var MenuPortal = /*#__PURE__*/function (_Component2) {
  _inherits(MenuPortal, _Component2);

  var _super2 = _createSuper(MenuPortal);

  function MenuPortal() {
    var _this2;

    _classCallCheck(this, MenuPortal);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _this2.state = {
      placement: null
    };

    _this2.getPortalPlacement = function (_ref7) {
      var placement = _ref7.placement;
      var initialPlacement = coercePlacement(_this2.props.menuPlacement); // avoid re-renders if the placement has not changed

      if (placement !== initialPlacement) {
        _this2.setState({
          placement: placement
        });
      }
    };

    return _this2;
  }

  _createClass(MenuPortal, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          appendTo = _this$props2.appendTo,
          children = _this$props2.children,
          className = _this$props2.className,
          controlElement = _this$props2.controlElement,
          cx = _this$props2.cx,
          innerProps = _this$props2.innerProps,
          menuPlacement = _this$props2.menuPlacement,
          position = _this$props2.menuPosition,
          getStyles = _this$props2.getStyles;
      var isFixed = position === 'fixed'; // bail early if required elements aren't present

      if (!appendTo && !isFixed || !controlElement) {
        return null;
      }

      var placement = this.state.placement || coercePlacement(menuPlacement);
      var rect = getBoundingClientObj(controlElement);
      var scrollDistance = isFixed ? 0 : window.pageYOffset;
      var offset = rect[placement] + scrollDistance;
      var state = {
        offset: offset,
        position: position,
        rect: rect
      }; // same wrapper element whether fixed or portalled

      var menuWrapper = jsx("div", extends_extends({
        css: getStyles('menuPortal', state),
        className: cx({
          'menu-portal': true
        }, className)
      }, innerProps), children);
      return jsx(PortalPlacementContext.Provider, {
        value: {
          getPortalPlacement: this.getPortalPlacement
        }
      }, appendTo ? /*#__PURE__*/(0,react_dom.createPortal)(menuWrapper, appendTo) : menuWrapper);
    }
  }]);

  return MenuPortal;
}(react.Component);

var containerCSS = function containerCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      isRtl = _ref.isRtl;
  return {
    label: 'container',
    direction: isRtl ? 'rtl' : undefined,
    pointerEvents: isDisabled ? 'none' : undefined,
    // cancel mouse events when disabled
    position: 'relative'
  };
};

var SelectContainer = function SelectContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      isRtl = props.isRtl;
  return jsx("div", extends_extends({
    css: getStyles('container', props),
    className: cx({
      '--is-disabled': isDisabled,
      '--is-rtl': isRtl
    }, className)
  }, innerProps), children);
}; // ==============================
// Value Container
// ==============================


var valueContainerCSS = function valueContainerCSS(_ref2) {
  var spacing = _ref2.theme.spacing,
      isMulti = _ref2.isMulti,
      hasValue = _ref2.hasValue,
      controlShouldRenderValue = _ref2.selectProps.controlShouldRenderValue;
  return {
    alignItems: 'center',
    display: isMulti && hasValue && controlShouldRenderValue ? 'flex' : 'grid',
    flex: 1,
    flexWrap: 'wrap',
    padding: "".concat(spacing.baseUnit / 2, "px ").concat(spacing.baseUnit * 2, "px"),
    WebkitOverflowScrolling: 'touch',
    position: 'relative',
    overflow: 'hidden'
  };
};

var ValueContainer = function ValueContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      innerProps = props.innerProps,
      isMulti = props.isMulti,
      getStyles = props.getStyles,
      hasValue = props.hasValue;
  return jsx("div", extends_extends({
    css: getStyles('valueContainer', props),
    className: cx({
      'value-container': true,
      'value-container--is-multi': isMulti,
      'value-container--has-value': hasValue
    }, className)
  }, innerProps), children);
}; // ==============================
// Indicator Container
// ==============================


var indicatorsContainerCSS = function indicatorsContainerCSS() {
  return {
    alignItems: 'center',
    alignSelf: 'stretch',
    display: 'flex',
    flexShrink: 0
  };
};

var IndicatorsContainer = function IndicatorsContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      innerProps = props.innerProps,
      getStyles = props.getStyles;
  return jsx("div", extends_extends({
    css: getStyles('indicatorsContainer', props),
    className: cx({
      indicators: true
    }, className)
  }, innerProps), children);
};

var _templateObject;

var _excluded$2 = ["size"];

function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}

var _ref2 =  true ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : 0; // ==============================
// Dropdown & Clear Icons
// ==============================


var index_a7690a33_esm_Svg = function Svg(_ref) {
  var size = _ref.size,
      props = _objectWithoutProperties(_ref, _excluded$2);

  return jsx("svg", extends_extends({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};

var CrossIcon = function CrossIcon(props) {
  return jsx(index_a7690a33_esm_Svg, extends_extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};

var DownChevron = function DownChevron(props) {
  return jsx(index_a7690a33_esm_Svg, extends_extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}; // ==============================
// Dropdown & Clear Buttons
// ==============================


var baseCSS = function baseCSS(_ref3) {
  var isFocused = _ref3.isFocused,
      _ref3$theme = _ref3.theme,
      baseUnit = _ref3$theme.spacing.baseUnit,
      colors = _ref3$theme.colors;
  return {
    label: 'indicatorContainer',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    ':hover': {
      color: isFocused ? colors.neutral80 : colors.neutral40
    }
  };
};

var dropdownIndicatorCSS = baseCSS;

var DropdownIndicator = function DropdownIndicator(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('dropdownIndicator', props),
    className: cx({
      indicator: true,
      'dropdown-indicator': true
    }, className)
  }, innerProps), children || jsx(DownChevron, null));
};

var clearIndicatorCSS = baseCSS;

var ClearIndicator = function ClearIndicator(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('clearIndicator', props),
    className: cx({
      indicator: true,
      'clear-indicator': true
    }, className)
  }, innerProps), children || jsx(CrossIcon, null));
}; // ==============================
// Separator
// ==============================


var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4) {
  var isDisabled = _ref4.isDisabled,
      _ref4$theme = _ref4.theme,
      baseUnit = _ref4$theme.spacing.baseUnit,
      colors = _ref4$theme.colors;
  return {
    label: 'indicatorSeparator',
    alignSelf: 'stretch',
    backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
    marginBottom: baseUnit * 2,
    marginTop: baseUnit * 2,
    width: 1
  };
};

var IndicatorSeparator = function IndicatorSeparator(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return jsx("span", extends_extends({}, innerProps, {
    css: getStyles('indicatorSeparator', props),
    className: cx({
      'indicator-separator': true
    }, className)
  }));
}; // ==============================
// Loading
// ==============================


var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));

var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5) {
  var isFocused = _ref5.isFocused,
      size = _ref5.size,
      _ref5$theme = _ref5.theme,
      colors = _ref5$theme.colors,
      baseUnit = _ref5$theme.spacing.baseUnit;
  return {
    label: 'loadingIndicator',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    alignSelf: 'center',
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: 'center',
    verticalAlign: 'middle'
  };
};

var LoadingDot = function LoadingDot(_ref6) {
  var delay = _ref6.delay,
      offset = _ref6.offset;
  return jsx("span", {
    css: /*#__PURE__*/css({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: 'currentColor',
      borderRadius: '1em',
      display: 'inline-block',
      marginLeft: offset ? '1em' : undefined,
      height: '1em',
      verticalAlign: 'top',
      width: '1em'
    },  true ? "" : 0,  true ? "" : 0)
  });
};

var LoadingIndicator = function LoadingIndicator(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isRtl = props.isRtl;
  return jsx("div", extends_extends({
    css: getStyles('loadingIndicator', props),
    className: cx({
      indicator: true,
      'loading-indicator': true
    }, className)
  }, innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};

LoadingIndicator.defaultProps = {
  size: 4
};

var css$1 = function css(_ref) {
  var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      _ref$theme = _ref.theme,
      colors = _ref$theme.colors,
      borderRadius = _ref$theme.borderRadius,
      spacing = _ref$theme.spacing;
  return {
    label: 'control',
    alignItems: 'center',
    backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
    borderColor: isDisabled ? colors.neutral10 : isFocused ? colors.primary : colors.neutral20,
    borderRadius: borderRadius,
    borderStyle: 'solid',
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors.primary) : undefined,
    cursor: 'default',
    display: 'flex',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    minHeight: spacing.controlHeight,
    outline: '0 !important',
    position: 'relative',
    transition: 'all 100ms',
    '&:hover': {
      borderColor: isFocused ? colors.primary : colors.neutral30
    }
  };
};

var Control = function Control(props) {
  var children = props.children,
      cx = props.cx,
      getStyles = props.getStyles,
      className = props.className,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      innerRef = props.innerRef,
      innerProps = props.innerProps,
      menuIsOpen = props.menuIsOpen;
  return jsx("div", extends_extends({
    ref: innerRef,
    css: getStyles('control', props),
    className: cx({
      control: true,
      'control--is-disabled': isDisabled,
      'control--is-focused': isFocused,
      'control--menu-is-open': menuIsOpen
    }, className)
  }, innerProps), children);
};

var _excluded$1 = ["data"];

var groupCSS = function groupCSS(_ref) {
  var spacing = _ref.theme.spacing;
  return {
    paddingBottom: spacing.baseUnit * 2,
    paddingTop: spacing.baseUnit * 2
  };
};

var Group = function Group(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      Heading = props.Heading,
      headingProps = props.headingProps,
      innerProps = props.innerProps,
      label = props.label,
      theme = props.theme,
      selectProps = props.selectProps;
  return jsx("div", extends_extends({
    css: getStyles('group', props),
    className: cx({
      group: true
    }, className)
  }, innerProps), jsx(Heading, extends_extends({}, headingProps, {
    selectProps: selectProps,
    theme: theme,
    getStyles: getStyles,
    cx: cx
  }), label), jsx("div", null, children));
};

var groupHeadingCSS = function groupHeadingCSS(_ref2) {
  var spacing = _ref2.theme.spacing;
  return {
    label: 'group',
    color: '#999',
    cursor: 'default',
    display: 'block',
    fontSize: '75%',
    fontWeight: 500,
    marginBottom: '0.25em',
    paddingLeft: spacing.baseUnit * 3,
    paddingRight: spacing.baseUnit * 3,
    textTransform: 'uppercase'
  };
};

var GroupHeading = function GroupHeading(props) {
  var getStyles = props.getStyles,
      cx = props.cx,
      className = props.className;

  var _cleanCommonProps = cleanCommonProps(props);

  _cleanCommonProps.data;

  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);

  return jsx("div", extends_extends({
    css: getStyles('groupHeading', props),
    className: cx({
      'group-heading': true
    }, className)
  }, innerProps));
};

var index_a7690a33_esm_excluded = ["innerRef", "isDisabled", "isHidden", "inputClassName"];

var inputCSS = function inputCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      value = _ref.value,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return index_a7690a33_esm_objectSpread2({
    margin: spacing.baseUnit / 2,
    paddingBottom: spacing.baseUnit / 2,
    paddingTop: spacing.baseUnit / 2,
    visibility: isDisabled ? 'hidden' : 'visible',
    color: colors.neutral80,
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? 'translateZ(0)' : ''
  }, containerStyle);
};

var spacingStyle = {
  gridArea: '1 / 2',
  font: 'inherit',
  minWidth: '2px',
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: '1 1 auto',
  display: 'inline-grid',
  gridArea: '1 / 1 / 2 / 3',
  gridTemplateColumns: '0 min-content',
  '&:after': index_a7690a33_esm_objectSpread2({
    content: 'attr(data-value) " "',
    visibility: 'hidden',
    whiteSpace: 'pre'
  }, spacingStyle)
};

var inputStyle = function inputStyle(isHidden) {
  return index_a7690a33_esm_objectSpread2({
    label: 'input',
    color: 'inherit',
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: '100%'
  }, spacingStyle);
};

var Input = function Input(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      value = props.value;

  var _cleanCommonProps = cleanCommonProps(props),
      innerRef = _cleanCommonProps.innerRef,
      isDisabled = _cleanCommonProps.isDisabled,
      isHidden = _cleanCommonProps.isHidden,
      inputClassName = _cleanCommonProps.inputClassName,
      innerProps = _objectWithoutProperties(_cleanCommonProps, index_a7690a33_esm_excluded);

  return jsx("div", {
    className: cx({
      'input-container': true
    }, className),
    css: getStyles('input', props),
    "data-value": value || ''
  }, jsx("input", extends_extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};

var multiValueCSS = function multiValueCSS(_ref) {
  var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      borderRadius = _ref$theme.borderRadius,
      colors = _ref$theme.colors;
  return {
    label: 'multiValue',
    backgroundColor: colors.neutral10,
    borderRadius: borderRadius / 2,
    display: 'flex',
    margin: spacing.baseUnit / 2,
    minWidth: 0 // resolves flex/text-overflow bug

  };
};

var multiValueLabelCSS = function multiValueLabelCSS(_ref2) {
  var _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      colors = _ref2$theme.colors,
      cropWithEllipsis = _ref2.cropWithEllipsis;
  return {
    borderRadius: borderRadius / 2,
    color: colors.neutral80,
    fontSize: '85%',
    overflow: 'hidden',
    padding: 3,
    paddingLeft: 6,
    textOverflow: cropWithEllipsis || cropWithEllipsis === undefined ? 'ellipsis' : undefined,
    whiteSpace: 'nowrap'
  };
};

var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3) {
  var _ref3$theme = _ref3.theme,
      spacing = _ref3$theme.spacing,
      borderRadius = _ref3$theme.borderRadius,
      colors = _ref3$theme.colors,
      isFocused = _ref3.isFocused;
  return {
    alignItems: 'center',
    borderRadius: borderRadius / 2,
    backgroundColor: isFocused ? colors.dangerLight : undefined,
    display: 'flex',
    paddingLeft: spacing.baseUnit,
    paddingRight: spacing.baseUnit,
    ':hover': {
      backgroundColor: colors.dangerLight,
      color: colors.danger
    }
  };
};

var MultiValueGeneric = function MultiValueGeneric(_ref4) {
  var children = _ref4.children,
      innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};

var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;

function MultiValueRemove(_ref5) {
  var children = _ref5.children,
      innerProps = _ref5.innerProps;
  return jsx("div", extends_extends({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}

var MultiValue = function MultiValue(props) {
  var children = props.children,
      className = props.className,
      components = props.components,
      cx = props.cx,
      data = props.data,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      removeProps = props.removeProps,
      selectProps = props.selectProps;
  var Container = components.Container,
      Label = components.Label,
      Remove = components.Remove;
  return jsx(ClassNames, null, function (_ref6) {
    var css = _ref6.css,
        emotionCx = _ref6.cx;
    return jsx(Container, {
      data: data,
      innerProps: index_a7690a33_esm_objectSpread2({
        className: emotionCx(css(getStyles('multiValue', props)), cx({
          'multi-value': true,
          'multi-value--is-disabled': isDisabled
        }, className))
      }, innerProps),
      selectProps: selectProps
    }, jsx(Label, {
      data: data,
      innerProps: {
        className: emotionCx(css(getStyles('multiValueLabel', props)), cx({
          'multi-value__label': true
        }, className))
      },
      selectProps: selectProps
    }, children), jsx(Remove, {
      data: data,
      innerProps: index_a7690a33_esm_objectSpread2({
        className: emotionCx(css(getStyles('multiValueRemove', props)), cx({
          'multi-value__remove': true
        }, className)),
        'aria-label': "Remove ".concat(children || 'option')
      }, removeProps),
      selectProps: selectProps
    }));
  });
};

var optionCSS = function optionCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      isSelected = _ref.isSelected,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'option',
    backgroundColor: isSelected ? colors.primary : isFocused ? colors.primary25 : 'transparent',
    color: isDisabled ? colors.neutral20 : isSelected ? colors.neutral0 : 'inherit',
    cursor: 'default',
    display: 'block',
    fontSize: 'inherit',
    padding: "".concat(spacing.baseUnit * 2, "px ").concat(spacing.baseUnit * 3, "px"),
    width: '100%',
    userSelect: 'none',
    WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
    // provide some affordance on touch devices
    ':active': {
      backgroundColor: !isDisabled ? isSelected ? colors.primary : colors.primary50 : undefined
    }
  };
};

var Option = function Option(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      isSelected = props.isSelected,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('option', props),
    className: cx({
      option: true,
      'option--is-disabled': isDisabled,
      'option--is-focused': isFocused,
      'option--is-selected': isSelected
    }, className),
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};

var placeholderCSS = function placeholderCSS(_ref) {
  var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'placeholder',
    color: colors.neutral50,
    gridArea: '1 / 1 / 2 / 3',
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2
  };
};

var Placeholder = function Placeholder(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('placeholder', props),
    className: cx({
      placeholder: true
    }, className)
  }, innerProps), children);
};

var index_a7690a33_esm_css = function css(_ref) {
  var isDisabled = _ref.isDisabled,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'singleValue',
    color: isDisabled ? colors.neutral40 : colors.neutral80,
    gridArea: '1 / 1 / 2 / 3',
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2,
    maxWidth: '100%',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap'
  };
};

var SingleValue = function SingleValue(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      isDisabled = props.isDisabled,
      innerProps = props.innerProps;
  return jsx("div", extends_extends({
    css: getStyles('singleValue', props),
    className: cx({
      'single-value': true,
      'single-value--is-disabled': isDisabled
    }, className)
  }, innerProps), children);
};

var components = {
  ClearIndicator: ClearIndicator,
  Control: Control,
  DropdownIndicator: DropdownIndicator,
  DownChevron: DownChevron,
  CrossIcon: CrossIcon,
  Group: Group,
  GroupHeading: GroupHeading,
  IndicatorsContainer: IndicatorsContainer,
  IndicatorSeparator: IndicatorSeparator,
  Input: Input,
  LoadingIndicator: LoadingIndicator,
  Menu: Menu,
  MenuList: MenuList,
  MenuPortal: MenuPortal,
  LoadingMessage: LoadingMessage,
  NoOptionsMessage: NoOptionsMessage,
  MultiValue: MultiValue,
  MultiValueContainer: MultiValueContainer,
  MultiValueLabel: MultiValueLabel,
  MultiValueRemove: MultiValueRemove,
  Option: Option,
  Placeholder: Placeholder,
  SelectContainer: SelectContainer,
  SingleValue: SingleValue,
  ValueContainer: ValueContainer
};

var defaultComponents = function defaultComponents(props) {
  return index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2({}, components), props.components);
};


;// CONCATENATED MODULE: ./node_modules/react-select/dist/useStateManager-68425271.esm.js




var useStateManager_68425271_esm_excluded = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];

function useStateManager(_ref) {
  var _ref$defaultInputValu = _ref.defaultInputValue,
      defaultInputValue = _ref$defaultInputValu === void 0 ? '' : _ref$defaultInputValu,
      _ref$defaultMenuIsOpe = _ref.defaultMenuIsOpen,
      defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe,
      _ref$defaultValue = _ref.defaultValue,
      defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,
      propsInputValue = _ref.inputValue,
      propsMenuIsOpen = _ref.menuIsOpen,
      propsOnChange = _ref.onChange,
      propsOnInputChange = _ref.onInputChange,
      propsOnMenuClose = _ref.onMenuClose,
      propsOnMenuOpen = _ref.onMenuOpen,
      propsValue = _ref.value,
      restSelectProps = _objectWithoutProperties(_ref, useStateManager_68425271_esm_excluded);

  var _useState = (0,react.useState)(propsInputValue !== undefined ? propsInputValue : defaultInputValue),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      stateInputValue = _useState2[0],
      setStateInputValue = _useState2[1];

  var _useState3 = (0,react.useState)(propsMenuIsOpen !== undefined ? propsMenuIsOpen : defaultMenuIsOpen),
      _useState4 = slicedToArray_slicedToArray(_useState3, 2),
      stateMenuIsOpen = _useState4[0],
      setStateMenuIsOpen = _useState4[1];

  var _useState5 = (0,react.useState)(propsValue !== undefined ? propsValue : defaultValue),
      _useState6 = slicedToArray_slicedToArray(_useState5, 2),
      stateValue = _useState6[0],
      setStateValue = _useState6[1];

  var onChange = (0,react.useCallback)(function (value, actionMeta) {
    if (typeof propsOnChange === 'function') {
      propsOnChange(value, actionMeta);
    }

    setStateValue(value);
  }, [propsOnChange]);
  var onInputChange = (0,react.useCallback)(function (value, actionMeta) {
    var newValue;

    if (typeof propsOnInputChange === 'function') {
      newValue = propsOnInputChange(value, actionMeta);
    }

    setStateInputValue(newValue !== undefined ? newValue : value);
  }, [propsOnInputChange]);
  var onMenuOpen = (0,react.useCallback)(function () {
    if (typeof propsOnMenuOpen === 'function') {
      propsOnMenuOpen();
    }

    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = (0,react.useCallback)(function () {
    if (typeof propsOnMenuClose === 'function') {
      propsOnMenuClose();
    }

    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== undefined ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== undefined ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== undefined ? propsValue : stateValue;
  return index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2({}, restSelectProps), {}, {
    inputValue: inputValue,
    menuIsOpen: menuIsOpen,
    onChange: onChange,
    onInputChange: onInputChange,
    onMenuClose: onMenuClose,
    onMenuOpen: onMenuOpen,
    value: value
  });
}


;// CONCATENATED MODULE: ./node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === 'number' && value !== value;
};

function isEqual(first, second) {
  if (first === second) {
    return true;
  }

  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }

  return false;
}

function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }

  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }

  return true;
}

function memoizeOne(resultFn, isEqual) {
  if (isEqual === void 0) {
    isEqual = areInputsEqual;
  }

  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;

  function memoized() {
    var newArgs = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }

    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
      return lastResult;
    }

    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }

  return memoized;
}

/* harmony default export */ var memoize_one_esm = (memoizeOne);
;// CONCATENATED MODULE: ./node_modules/react-select/dist/Select-54ac8379.esm.js












function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}

var _ref =  true ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : 0;

var A11yText = function A11yText(props) {
  return jsx("span", extends_extends({
    css: _ref
  }, props));
};

var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable,
        isMulti = props.isMulti,
        isDisabled = props.isDisabled,
        tabSelectsValue = props.tabSelectsValue,
        context = props.context;

    switch (context) {
      case 'menu':
        return "Use Up and Down to choose options".concat(isDisabled ? '' : ', press Enter to select the currently focused option', ", press Escape to exit the menu").concat(tabSelectsValue ? ', press Tab to select the option and exit the menu' : '', ".");

      case 'input':
        return "".concat(props['aria-label'] || 'Select', " is focused ").concat(isSearchable ? ',type to refine list' : '', ", press Down to open the menu, ").concat(isMulti ? ' press left to focus selected values' : '');

      case 'value':
        return 'Use left and right to toggle between focused values, press Backspace to remove the currently focused value';

      default:
        return '';
    }
  },
  onChange: function onChange(props) {
    var action = props.action,
        _props$label = props.label,
        label = _props$label === void 0 ? '' : _props$label,
        labels = props.labels,
        isDisabled = props.isDisabled;

    switch (action) {
      case 'deselect-option':
      case 'pop-value':
      case 'remove-value':
        return "option ".concat(label, ", deselected.");

      case 'clear':
        return 'All selected options have been cleared.';

      case 'initial-input-focus':
        return "option".concat(labels.length > 1 ? 's' : '', " ").concat(labels.join(','), ", selected.");

      case 'select-option':
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");

      default:
        return '';
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context,
        focused = props.focused,
        options = props.options,
        _props$label2 = props.label,
        label = _props$label2 === void 0 ? '' : _props$label2,
        selectValue = props.selectValue,
        isDisabled = props.isDisabled,
        isSelected = props.isSelected;

    var getArrayIndex = function getArrayIndex(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : '';
    };

    if (context === 'value' && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }

    if (context === 'menu') {
      var disabled = isDisabled ? ' disabled' : '';
      var status = "".concat(isSelected ? 'selected' : 'focused').concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options, focused), ".");
    }

    return '';
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue,
        resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? ' for search term ' + inputValue : '', ".");
  }
};

var LiveRegion = function LiveRegion(props) {
  var ariaSelection = props.ariaSelection,
      focusedOption = props.focusedOption,
      focusedValue = props.focusedValue,
      focusableOptions = props.focusableOptions,
      isFocused = props.isFocused,
      selectValue = props.selectValue,
      selectProps = props.selectProps,
      id = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages,
      getOptionLabel = selectProps.getOptionLabel,
      inputValue = selectProps.inputValue,
      isMulti = selectProps.isMulti,
      isOptionDisabled = selectProps.isOptionDisabled,
      isSearchable = selectProps.isSearchable,
      menuIsOpen = selectProps.menuIsOpen,
      options = selectProps.options,
      screenReaderStatus = selectProps.screenReaderStatus,
      tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps['aria-label'];
  var ariaLive = selectProps['aria-live']; // Update aria live message configuration when prop changes

  var messages = (0,react.useMemo)(function () {
    return index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]); // Update aria live selected option when prop changes

  var ariaSelected = (0,react.useMemo)(function () {
    var message = '';

    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option,
          selectedOptions = ariaSelection.options,
          removedValue = ariaSelection.removedValue,
          removedValues = ariaSelection.removedValues,
          value = ariaSelection.value; // select-option when !isMulti does not return option so we assume selected option is value

      var asOption = function asOption(val) {
        return !Array.isArray(val) ? val : null;
      }; // If there is just one item from the action then get its label


      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel(selected) : ''; // If there are multiple items from the action then return an array of labels

      var multiSelected = selectedOptions || removedValues || undefined;
      var labels = multiSelected ? multiSelected.map(getOptionLabel) : [];

      var onChangeProps = index_a7690a33_esm_objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled(selected, selectValue),
        label: label,
        labels: labels
      }, ariaSelection);

      message = messages.onChange(onChangeProps);
    }

    return message;
  }, [ariaSelection, messages, isOptionDisabled, selectValue, getOptionLabel]);
  var ariaFocused = (0,react.useMemo)(function () {
    var focusMsg = '';
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));

    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused: focused,
        label: getOptionLabel(focused),
        isDisabled: isOptionDisabled(focused, selectValue),
        isSelected: isSelected,
        options: options,
        context: focused === focusedOption ? 'menu' : 'value',
        selectValue: selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }

    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel, isOptionDisabled, messages, options, selectValue]);
  var ariaResults = (0,react.useMemo)(function () {
    var resultsMsg = '';

    if (menuIsOpen && options.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue: inputValue,
        resultsMessage: resultsMessage
      });
    }

    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options, screenReaderStatus]);
  var ariaGuidance = (0,react.useMemo)(function () {
    var guidanceMsg = '';

    if (messages.guidance) {
      var context = focusedValue ? 'value' : menuIsOpen ? 'menu' : 'input';
      guidanceMsg = messages.guidance({
        'aria-label': ariaLabel,
        context: context,
        isDisabled: focusedOption && isOptionDisabled(focusedOption, selectValue),
        isMulti: isMulti,
        isSearchable: isSearchable,
        tabSelectsValue: tabSelectsValue
      });
    }

    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(react.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus';
  return jsx(react.Fragment, null, jsx(A11yText, {
    id: id
  }, isInitialFocus && ScreenReaderText), jsx(A11yText, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};

var diacritics = [{
  base: 'A',
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: 'AA',
  letters: "\uA732"
}, {
  base: 'AE',
  letters: "\xC6\u01FC\u01E2"
}, {
  base: 'AO',
  letters: "\uA734"
}, {
  base: 'AU',
  letters: "\uA736"
}, {
  base: 'AV',
  letters: "\uA738\uA73A"
}, {
  base: 'AY',
  letters: "\uA73C"
}, {
  base: 'B',
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: 'C',
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: 'D',
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: 'DZ',
  letters: "\u01F1\u01C4"
}, {
  base: 'Dz',
  letters: "\u01F2\u01C5"
}, {
  base: 'E',
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: 'F',
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: 'G',
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: 'H',
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: 'I',
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: 'J',
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: 'K',
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: 'L',
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: 'LJ',
  letters: "\u01C7"
}, {
  base: 'Lj',
  letters: "\u01C8"
}, {
  base: 'M',
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: 'N',
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: 'NJ',
  letters: "\u01CA"
}, {
  base: 'Nj',
  letters: "\u01CB"
}, {
  base: 'O',
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: 'OI',
  letters: "\u01A2"
}, {
  base: 'OO',
  letters: "\uA74E"
}, {
  base: 'OU',
  letters: "\u0222"
}, {
  base: 'P',
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: 'Q',
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: 'R',
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: 'S',
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: 'T',
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: 'TZ',
  letters: "\uA728"
}, {
  base: 'U',
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: 'V',
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: 'VY',
  letters: "\uA760"
}, {
  base: 'W',
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: 'X',
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: 'Y',
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: 'Z',
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: 'a',
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: 'aa',
  letters: "\uA733"
}, {
  base: 'ae',
  letters: "\xE6\u01FD\u01E3"
}, {
  base: 'ao',
  letters: "\uA735"
}, {
  base: 'au',
  letters: "\uA737"
}, {
  base: 'av',
  letters: "\uA739\uA73B"
}, {
  base: 'ay',
  letters: "\uA73D"
}, {
  base: 'b',
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: 'c',
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: 'd',
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: 'dz',
  letters: "\u01F3\u01C6"
}, {
  base: 'e',
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: 'f',
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: 'g',
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: 'h',
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: 'hv',
  letters: "\u0195"
}, {
  base: 'i',
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: 'j',
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: 'k',
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: 'l',
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: 'lj',
  letters: "\u01C9"
}, {
  base: 'm',
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: 'n',
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: 'nj',
  letters: "\u01CC"
}, {
  base: 'o',
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: 'oi',
  letters: "\u01A3"
}, {
  base: 'ou',
  letters: "\u0223"
}, {
  base: 'oo',
  letters: "\uA74F"
}, {
  base: 'p',
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: 'q',
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: 'r',
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: 's',
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: 't',
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: 'tz',
  letters: "\uA729"
}, {
  base: 'u',
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: 'v',
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: 'vy',
  letters: "\uA761"
}, {
  base: 'w',
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: 'x',
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: 'y',
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: 'z',
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp('[' + diacritics.map(function (d) {
  return d.letters;
}).join('') + ']', 'g');
var diacriticToBase = {};

for (var i = 0; i < diacritics.length; i++) {
  var diacritic = diacritics[i];

  for (var j = 0; j < diacritic.letters.length; j++) {
    diacriticToBase[diacritic.letters[j]] = diacritic.base;
  }
}

var stripDiacritics = function stripDiacritics(str) {
  return str.replace(anyDiacritic, function (match) {
    return diacriticToBase[match];
  });
};

var memoizedStripDiacriticsForInput = memoize_one_esm(stripDiacritics);

var trimString = function trimString(str) {
  return str.replace(/^\s+|\s+$/g, '');
};

var defaultStringify = function defaultStringify(option) {
  return "".concat(option.label, " ").concat(option.value);
};

var createFilter = function createFilter(config) {
  return function (option, rawInput) {
    // eslint-disable-next-line no-underscore-dangle
    if (option.data.__isNew__) return true;

    var _ignoreCase$ignoreAcc = index_a7690a33_esm_objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: 'any'
    }, config),
        ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
        ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
        stringify = _ignoreCase$ignoreAcc.stringify,
        trim = _ignoreCase$ignoreAcc.trim,
        matchFrom = _ignoreCase$ignoreAcc.matchFrom;

    var input = trim ? trimString(rawInput) : rawInput;
    var candidate = trim ? trimString(stringify(option)) : stringify(option);

    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }

    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }

    return matchFrom === 'start' ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};

var Select_54ac8379_esm_excluded = ["innerRef"];

function DummyInput(_ref) {
  var innerRef = _ref.innerRef,
      props = _objectWithoutProperties(_ref, Select_54ac8379_esm_excluded); // Remove animation props not meant for HTML elements


  var filteredProps = removeProps(props, 'onExited', 'in', 'enter', 'exit', 'appear');
  return jsx("input", extends_extends({
    ref: innerRef
  }, filteredProps, {
    css: /*#__PURE__*/css({
      label: 'dummyInput',
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: 'transparent',
      fontSize: 'inherit',
      gridArea: '1 / 1 / 2 / 3',
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: 'transparent',
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: 'relative',
      transform: 'scale(.01)'
    },  true ? "" : 0,  true ? "" : 0)
  }));
}

var cancelScroll = function cancelScroll(event) {
  event.preventDefault();
  event.stopPropagation();
};

function useScrollCapture(_ref) {
  var isEnabled = _ref.isEnabled,
      onBottomArrive = _ref.onBottomArrive,
      onBottomLeave = _ref.onBottomLeave,
      onTopArrive = _ref.onTopArrive,
      onTopLeave = _ref.onTopLeave;
  var isBottom = (0,react.useRef)(false);
  var isTop = (0,react.useRef)(false);
  var touchStart = (0,react.useRef)(0);
  var scrollTarget = (0,react.useRef)(null);
  var handleEventDelta = (0,react.useCallback)(function (event, delta) {
    if (scrollTarget.current === null) return;
    var _scrollTarget$current = scrollTarget.current,
        scrollTop = _scrollTarget$current.scrollTop,
        scrollHeight = _scrollTarget$current.scrollHeight,
        clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false; // reset bottom/top flags

    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave) onBottomLeave(event);
      isBottom.current = false;
    }

    if (isDeltaPositive && isTop.current) {
      if (onTopLeave) onTopLeave(event);
      isTop.current = false;
    } // bottom limit


    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }

      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true; // top limit
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }

      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    } // cancel scroll


    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = (0,react.useCallback)(function (event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = (0,react.useCallback)(function (event) {
    // set touch start so we can calculate touchmove delta
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = (0,react.useCallback)(function (event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = (0,react.useCallback)(function (el) {
    // bail early if no element is available to attach to
    if (!el) return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener('wheel', onWheel, notPassive);
    el.addEventListener('touchstart', onTouchStart, notPassive);
    el.addEventListener('touchmove', onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = (0,react.useCallback)(function (el) {
    // bail early if no element is available to detach from
    if (!el) return;
    el.removeEventListener('wheel', onWheel, false);
    el.removeEventListener('touchstart', onTouchStart, false);
    el.removeEventListener('touchmove', onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  (0,react.useEffect)(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    startListening(element);
    return function () {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function (element) {
    scrollTarget.current = element;
  };
}

var STYLE_KEYS = ['boxSizing', 'height', 'overflow', 'paddingRight', 'position'];
var LOCK_STYLES = {
  boxSizing: 'border-box',
  // account for possible declaration `width: 100%;` on body
  overflow: 'hidden',
  position: 'relative',
  height: '100%'
};

function preventTouchMove(e) {
  e.preventDefault();
}

function allowTouchMove(e) {
  e.stopPropagation();
}

function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;

  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
} // `ontouchstart` check works on most browsers
// `maxTouchPoints` works on IE10/11 and Surface


function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints;
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};

function useScrollLock(_ref) {
  var isEnabled = _ref.isEnabled,
      _ref$accountForScroll = _ref.accountForScrollbars,
      accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = (0,react.useRef)({});
  var scrollTarget = (0,react.useRef)(null);
  var addScrollLock = (0,react.useCallback)(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style;

    if (accountForScrollbars) {
      // store any styles already applied to the body
      STYLE_KEYS.forEach(function (key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    } // apply the lock styles and padding if this is the first scroll lock


    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function (key) {
        var val = LOCK_STYLES[key];

        if (targetStyle) {
          targetStyle[key] = val;
        }
      });

      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    } // account for touch devices


    if (target && isTouchDevice()) {
      // Mobile Safari ignores { overflow: hidden } declaration on the body.
      target.addEventListener('touchmove', preventTouchMove, listenerOptions); // Allow scroll on provided target

      if (touchScrollTarget) {
        touchScrollTarget.addEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    } // increment active scroll locks


    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = (0,react.useCallback)(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style; // safely decrement active scroll locks

    activeScrollLocks = Math.max(activeScrollLocks - 1, 0); // reapply original body styles, if any

    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function (key) {
        var val = originalStyles.current[key];

        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    } // remove touch listeners


    if (target && isTouchDevice()) {
      target.removeEventListener('touchmove', preventTouchMove, listenerOptions);

      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  (0,react.useEffect)(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function () {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function (element) {
    scrollTarget.current = element;
  };
}

function Select_54ac8379_esm_EMOTION_STRINGIFIED_CSS_ERROR_() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}

var blurSelectInput = function blurSelectInput() {
  return document.activeElement && document.activeElement.blur();
};

var Select_54ac8379_esm_ref2 =  true ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : 0;

function ScrollManager(_ref) {
  var children = _ref.children,
      lockEnabled = _ref.lockEnabled,
      _ref$captureEnabled = _ref.captureEnabled,
      captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled,
      onBottomArrive = _ref.onBottomArrive,
      onBottomLeave = _ref.onBottomLeave,
      onTopArrive = _ref.onTopArrive,
      onTopLeave = _ref.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive: onBottomArrive,
    onBottomLeave: onBottomLeave,
    onTopArrive: onTopArrive,
    onTopLeave: onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });

  var targetRef = function targetRef(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };

  return jsx(react.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: Select_54ac8379_esm_ref2
  }), children(targetRef));
}

var formatGroupLabel = function formatGroupLabel(group) {
  return group.label;
};

var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};

var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};

var isOptionDisabled = function isOptionDisabled(option) {
  return !!option.isDisabled;
};

var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: index_a7690a33_esm_css,
  valueContainer: valueContainerCSS
}; // Merge Utility
// Allows consumers to extend a base Select with additional styles

function mergeStyles(source) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // initialize with source styles

  var styles = _objectSpread2({}, source); // massage in target styles


  Object.keys(target).forEach(function (keyAsString) {
    var key = keyAsString;

    if (source[key]) {
      styles[key] = function (rsCss, props) {
        return target[key](source[key](rsCss, props), props);
      };
    } else {
      styles[key] = target[key];
    }
  });
  return styles;
}

var colors = {
  primary: '#2684FF',
  primary75: '#4C9AFF',
  primary50: '#B2D4FF',
  primary25: '#DEEBFF',
  danger: '#DE350B',
  dangerLight: '#FFBDAD',
  neutral0: 'hsl(0, 0%, 100%)',
  neutral5: 'hsl(0, 0%, 95%)',
  neutral10: 'hsl(0, 0%, 90%)',
  neutral20: 'hsl(0, 0%, 80%)',
  neutral30: 'hsl(0, 0%, 70%)',
  neutral40: 'hsl(0, 0%, 60%)',
  neutral50: 'hsl(0, 0%, 50%)',
  neutral60: 'hsl(0, 0%, 40%)',
  neutral70: 'hsl(0, 0%, 30%)',
  neutral80: 'hsl(0, 0%, 20%)',
  neutral90: 'hsl(0, 0%, 10%)'
};
var borderRadius = 4; // Used to calculate consistent margin/padding on elements

var baseUnit = 4; // The minimum height of the control

var controlHeight = 38; // The amount of space between the control and menu */

var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit: baseUnit,
  controlHeight: controlHeight,
  menuGutter: menuGutter
};
var defaultTheme = {
  borderRadius: borderRadius,
  colors: colors,
  spacing: spacing
};
var defaultProps = {
  'aria-live': 'polite',
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel: formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled: isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return 'Loading...';
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: 'bottom',
  menuPosition: 'absolute',
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return 'No options';
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: 'Select...',
  screenReaderStatus: function screenReaderStatus(_ref) {
    var count = _ref.count;
    return "".concat(count, " result").concat(count !== 1 ? 's' : '', " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true
};

function toCategorizedOption(props, option, selectValue, index) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);

  var isSelected = _isOptionSelected(props, option, selectValue);

  var label = getOptionLabel(props, option);
  var value = getOptionValue(props, option);
  return {
    type: 'option',
    data: option,
    isDisabled: isDisabled,
    isSelected: isSelected,
    label: label,
    value: value,
    index: index
  };
}

function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function (groupOrOption, groupOrOptionIndex) {
    if ('options' in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function (option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function (categorizedOption) {
        return isFocusable(props, categorizedOption);
      });
      return categorizedOptions.length > 0 ? {
        type: 'group',
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : undefined;
    }

    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : undefined;
  }).filter(notNullish);
}

function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === 'group') {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }

    return optionsAccumulator;
  }, []);
}

function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}

function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue,
      inputValue = _props$inputValue === void 0 ? '' : _props$inputValue;
  var data = categorizedOption.data,
      isSelected = categorizedOption.isSelected,
      label = categorizedOption.label,
      value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label,
    value: value,
    data: data
  }, inputValue);
}

function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue,
      lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);

  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);

    if (nextFocusedIndex > -1) {
      // the focused value is still in the selectValue, return it
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      // the focusedValue is not present in the next selectValue array by
      // reference, so return the new value at the same index
      return nextSelectValue[lastFocusedIndex];
    }
  }

  return null;
}

function getNextFocusedOption(state, options) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
}

var getOptionLabel = function getOptionLabel(props, data) {
  return props.getOptionLabel(data);
};

var getOptionValue = function getOptionValue(props, data) {
  return props.getOptionValue(data);
};

function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === 'function' ? props.isOptionDisabled(option, selectValue) : false;
}

function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) return true;

  if (typeof props.isOptionSelected === 'function') {
    return props.isOptionSelected(option, selectValue);
  }

  var candidate = getOptionValue(props, option);
  return selectValue.some(function (i) {
    return getOptionValue(props, i) === candidate;
  });
}

function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}

var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
  var hideSelectedOptions = props.hideSelectedOptions,
      isMulti = props.isMulti;
  if (hideSelectedOptions === undefined) return isMulti;
  return hideSelectedOptions;
};

var instanceId = 1;

var Select = /*#__PURE__*/function (_Component) {
  _inherits(Select, _Component);

  var _super = _createSuper(Select); // Misc. Instance Properties
  // ------------------------------
  // TODO
  // Refs
  // ------------------------------
  // Lifecycle
  // ------------------------------


  function Select(_props) {
    var _this;

    _classCallCheck(this, Select);

    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: undefined,
      prevProps: undefined
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = '';
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;

    _this.getControlRef = function (ref) {
      _this.controlRef = ref;
    };

    _this.focusedOptionRef = null;

    _this.getFocusedOptionRef = function (ref) {
      _this.focusedOptionRef = ref;
    };

    _this.menuListRef = null;

    _this.getMenuListRef = function (ref) {
      _this.menuListRef = ref;
    };

    _this.inputRef = null;

    _this.getInputRef = function (ref) {
      _this.inputRef = ref;
    };

    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;

    _this.onChange = function (newValue, actionMeta) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          name = _this$props.name;
      actionMeta.name = name;

      _this.ariaOnChange(newValue, actionMeta);

      onChange(newValue, actionMeta);
    };

    _this.setValue = function (newValue, action, option) {
      var _this$props2 = _this.props,
          closeMenuOnSelect = _this$props2.closeMenuOnSelect,
          isMulti = _this$props2.isMulti,
          inputValue = _this$props2.inputValue;

      _this.onInputChange('', {
        action: 'set-value',
        prevInputValue: inputValue
      });

      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });

        _this.onMenuClose();
      } // when the select value should change, we should reset focusedValue


      _this.setState({
        clearFocusValueOnUpdate: true
      });

      _this.onChange(newValue, {
        action: action,
        option: option
      });
    };

    _this.selectOption = function (newValue) {
      var _this$props3 = _this.props,
          blurInputOnSelect = _this$props3.blurInputOnSelect,
          isMulti = _this$props3.isMulti,
          name = _this$props3.name;
      var selectValue = _this.state.selectValue;

      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);

      var isDisabled = _this.isOptionDisabled(newValue, selectValue);

      if (deselected) {
        var candidate = _this.getOptionValue(newValue);

        _this.setValue(multiValueAsValue(selectValue.filter(function (i) {
          return _this.getOptionValue(i) !== candidate;
        })), 'deselect-option', newValue);
      } else if (!isDisabled) {
        // Select option if option is not disabled
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), 'select-option', newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), 'select-option');
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: 'select-option',
          option: newValue,
          name: name
        });

        return;
      }

      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };

    _this.removeValue = function (removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;

      var candidate = _this.getOptionValue(removedValue);

      var newValueArray = selectValue.filter(function (i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);

      _this.onChange(newValue, {
        action: 'remove-value',
        removedValue: removedValue
      });

      _this.focusInput();
    };

    _this.clearValue = function () {
      var selectValue = _this.state.selectValue;

      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: 'clear',
        removedValues: selectValue
      });
    };

    _this.popValue = function () {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);

      _this.onChange(newValue, {
        action: 'pop-value',
        removedValue: lastSelectedValue
      });
    };

    _this.getValue = function () {
      return _this.state.selectValue;
    };

    _this.cx = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };

    _this.getOptionLabel = function (data) {
      return getOptionLabel(_this.props, data);
    };

    _this.getOptionValue = function (data) {
      return getOptionValue(_this.props, data);
    };

    _this.getStyles = function (key, props) {
      var base = defaultStyles[key](props);
      base.boxSizing = 'border-box';
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };

    _this.getElementId = function (element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };

    _this.getComponents = function () {
      return defaultComponents(_this.props);
    };

    _this.buildCategorizedOptions = function () {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };

    _this.getCategorizedOptions = function () {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };

    _this.buildFocusableOptions = function () {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };

    _this.getFocusableOptions = function () {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };

    _this.ariaOnChange = function (value, actionMeta) {
      _this.setState({
        ariaSelection: index_a7690a33_esm_objectSpread2({
          value: value
        }, actionMeta)
      });
    };

    _this.onMenuMouseDown = function (event) {
      if (event.button !== 0) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      _this.focusInput();
    };

    _this.onMenuMouseMove = function (event) {
      _this.blockOptionHover = false;
    };

    _this.onControlMouseDown = function (event) {
      // Event captured by dropdown indicator
      if (event.defaultPrevented) {
        return;
      }

      var openMenuOnClick = _this.props.openMenuOnClick;

      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }

        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu('first');
        }
      } else {
        if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
          _this.onMenuClose();
        }
      }

      if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
        event.preventDefault();
      }
    };

    _this.onDropdownIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props,
          isMulti = _this$props4.isMulti,
          menuIsOpen = _this$props4.menuIsOpen;

      _this.focusInput();

      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });

        _this.onMenuClose();
      } else {
        _this.openMenu('first');
      }

      event.preventDefault();
    };

    _this.onClearIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      _this.clearValue();

      event.preventDefault();
      _this.openAfterFocus = false;

      if (event.type === 'touchend') {
        _this.focusInput();
      } else {
        setTimeout(function () {
          return _this.focusInput();
        });
      }
    };

    _this.onScroll = function (event) {
      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };

    _this.onCompositionStart = function () {
      _this.isComposing = true;
    };

    _this.onCompositionEnd = function () {
      _this.isComposing = false;
    };

    _this.onTouchStart = function (_ref2) {
      var touches = _ref2.touches;
      var touch = touches && touches.item(0);

      if (!touch) {
        return;
      }

      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };

    _this.onTouchMove = function (_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);

      if (!touch) {
        return;
      }

      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };

    _this.onTouchEnd = function (event) {
      if (_this.userIsDragging) return; // close the menu if the user taps outside
      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
      // on events on child elements, not the document (which we've attached this handler to).

      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      } // reset move vars


      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };

    _this.onControlTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onControlMouseDown(event);
    };

    _this.onClearIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onClearIndicatorMouseDown(event);
    };

    _this.onDropdownIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onDropdownIndicatorMouseDown(event);
    };

    _this.handleInputChange = function (event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;

      _this.setState({
        inputIsHiddenAfterUpdate: false
      });

      _this.onInputChange(inputValue, {
        action: 'input-change',
        prevInputValue: prevInputValue
      });

      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };

    _this.onInputFocus = function (event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }

      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });

      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu('first');
      }

      _this.openAfterFocus = false;
    };

    _this.onInputBlur = function (event) {
      var prevInputValue = _this.props.inputValue;

      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();

        return;
      }

      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }

      _this.onInputChange('', {
        action: 'input-blur',
        prevInputValue: prevInputValue
      });

      _this.onMenuClose();

      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };

    _this.onOptionHover = function (focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }

      _this.setState({
        focusedOption: focusedOption
      });
    };

    _this.shouldHideSelectedOptions = function () {
      return shouldHideSelectedOptions(_this.props);
    };

    _this.onKeyDown = function (event) {
      var _this$props5 = _this.props,
          isMulti = _this$props5.isMulti,
          backspaceRemovesValue = _this$props5.backspaceRemovesValue,
          escapeClearsValue = _this$props5.escapeClearsValue,
          inputValue = _this$props5.inputValue,
          isClearable = _this$props5.isClearable,
          isDisabled = _this$props5.isDisabled,
          menuIsOpen = _this$props5.menuIsOpen,
          onKeyDown = _this$props5.onKeyDown,
          tabSelectsValue = _this$props5.tabSelectsValue,
          openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state,
          focusedOption = _this$state.focusedOption,
          focusedValue = _this$state.focusedValue,
          selectValue = _this$state.selectValue;
      if (isDisabled) return;

      if (typeof onKeyDown === 'function') {
        onKeyDown(event);

        if (event.defaultPrevented) {
          return;
        }
      } // Block option hover events when the user has just pressed a key


      _this.blockOptionHover = true;

      switch (event.key) {
        case 'ArrowLeft':
          if (!isMulti || inputValue) return;

          _this.focusValue('previous');

          break;

        case 'ArrowRight':
          if (!isMulti || inputValue) return;

          _this.focusValue('next');

          break;

        case 'Delete':
        case 'Backspace':
          if (inputValue) return;

          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;

            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }

          break;

        case 'Tab':
          if (_this.isComposing) return;

          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }

          _this.selectOption(focusedOption);

          break;

        case 'Enter':
          if (event.keyCode === 229) {
            // ignore the keydown event from an Input Method Editor(IME)
            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
            break;
          }

          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;

            _this.selectOption(focusedOption);

            break;
          }

          return;

        case 'Escape':
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });

            _this.onInputChange('', {
              action: 'menu-close',
              prevInputValue: inputValue
            });

            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }

          break;

        case ' ':
          // space
          if (inputValue) {
            return;
          }

          if (!menuIsOpen) {
            _this.openMenu('first');

            break;
          }

          if (!focusedOption) return;

          _this.selectOption(focusedOption);

          break;

        case 'ArrowUp':
          if (menuIsOpen) {
            _this.focusOption('up');
          } else {
            _this.openMenu('last');
          }

          break;

        case 'ArrowDown':
          if (menuIsOpen) {
            _this.focusOption('down');
          } else {
            _this.openMenu('first');
          }

          break;

        case 'PageUp':
          if (!menuIsOpen) return;

          _this.focusOption('pageup');

          break;

        case 'PageDown':
          if (!menuIsOpen) return;

          _this.focusOption('pagedown');

          break;

        case 'Home':
          if (!menuIsOpen) return;

          _this.focusOption('first');

          break;

        case 'End':
          if (!menuIsOpen) return;

          _this.focusOption('last');

          break;

        default:
          return;
      }

      event.preventDefault();
    };

    _this.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    return _this;
  }

  _createClass(Select, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();

      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        // Listen to all scroll events, and filter them out inside of 'onScroll'
        document.addEventListener('scroll', this.onScroll, true);
      }

      if (this.props.autoFocus) {
        this.focusInput();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props,
          isDisabled = _this$props6.isDisabled,
          menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;

      if ( // ensure focus is restored correctly when the control becomes enabled
      isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
      isFocused && menuIsOpen && !prevProps.menuIsOpen) {
        this.focusInput();
      }

      if (isFocused && isDisabled && !prevProps.isDisabled) {
        // ensure select state gets blurred in case Select is programmatically disabled while focused
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } // scroll the focused option into view if necessary


      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener('scroll', this.onScroll, true);
    } // ==============================
    // Consumer Handlers
    // ==============================

  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange('', {
        action: 'menu-close',
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    } // ==============================
    // Methods
    // ==============================

  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) return;
      this.inputRef.blur();
    } // aliased for consumers

  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;

      var _this$state2 = this.state,
          selectValue = _this$state2.selectValue,
          isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === 'first' ? 0 : focusableOptions.length - 1;

      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);

        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      } // only scroll if the menu isn't already open


      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function () {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state,
          selectValue = _this$state3.selectValue,
          focusedValue = _this$state3.focusedValue; // Only multiselects support value focusing

      if (!this.props.isMulti) return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);

      if (!focusedValue) {
        focusedIndex = -1;
      }

      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) return;

      switch (direction) {
        case 'previous':
          if (focusedIndex === 0) {
            // don't cycle from the start to the end
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            // if nothing is focused, focus the last value first
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }

          break;

        case 'next':
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }

          break;
      }

      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'first';
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options = this.getFocusableOptions();
      if (!options.length) return;
      var nextFocus = 0; // handles 'first'

      var focusedIndex = options.indexOf(focusedOption);

      if (!focusedOption) {
        focusedIndex = -1;
      }

      if (direction === 'up') {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
      } else if (direction === 'down') {
        nextFocus = (focusedIndex + 1) % options.length;
      } else if (direction === 'pageup') {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) nextFocus = 0;
      } else if (direction === 'pagedown') {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options.length - 1) nextFocus = options.length - 1;
      } else if (direction === 'last') {
        nextFocus = options.length - 1;
      }

      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: // ==============================
    // Getters
    // ==============================
    function getTheme() {
      // Use the default theme if there are no customizations.
      if (!this.props.theme) {
        return defaultTheme;
      } // If the theme prop is a function, assume the function
      // knows how to merge the passed-in default theme with
      // its own modifications.


      if (typeof this.props.theme === 'function') {
        return this.props.theme(defaultTheme);
      } // Otherwise, if a plain theme object was passed in,
      // overlay it with the default theme.


      return index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2({}, defaultTheme), this.props.theme);
    }
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue,
          cx = this.cx,
          getStyles = this.getStyles,
          getValue = this.getValue,
          selectOption = this.selectOption,
          setValue = this.setValue,
          props = this.props;
      var isMulti = props.isMulti,
          isRtl = props.isRtl,
          options = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue: clearValue,
        cx: cx,
        getStyles: getStyles,
        getValue: getValue,
        hasValue: hasValue,
        isMulti: isMulti,
        isRtl: isRtl,
        options: options,
        selectOption: selectOption,
        selectProps: props,
        setValue: setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props,
          isClearable = _this$props7.isClearable,
          isMulti = _this$props7.isMulti; // single select, by default, IS NOT clearable
      // multi select, by default, IS clearable

      if (isClearable === undefined) return isMulti;
      return isClearable;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === 'function') {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context: context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel(data) {
      return this.props.formatGroupLabel(data);
    } // ==============================
    // Mouse Handlers
    // ==============================

  }, {
    key: "startListeningComposition",
    value: // ==============================
    // Composition Handlers
    // ==============================
    function startListeningComposition() {
      if (document && document.addEventListener) {
        document.addEventListener('compositionstart', this.onCompositionStart, false);
        document.addEventListener('compositionend', this.onCompositionEnd, false);
      }
    }
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener('compositionstart', this.onCompositionStart);
        document.removeEventListener('compositionend', this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: // ==============================
    // Touch Handlers
    // ==============================
    function startListeningToTouch() {
      if (document && document.addEventListener) {
        document.addEventListener('touchstart', this.onTouchStart, false);
        document.addEventListener('touchmove', this.onTouchMove, false);
        document.addEventListener('touchend', this.onTouchEnd, false);
      }
    }
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener('touchstart', this.onTouchStart);
        document.removeEventListener('touchmove', this.onTouchMove);
        document.removeEventListener('touchend', this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: // ==============================
    // Renderers
    // ==============================
    function renderInput() {
      var _this$props8 = this.props,
          isDisabled = _this$props8.isDisabled,
          isSearchable = _this$props8.isSearchable,
          inputId = _this$props8.inputId,
          inputValue = _this$props8.inputValue,
          tabIndex = _this$props8.tabIndex,
          form = _this$props8.form,
          menuIsOpen = _this$props8.menuIsOpen;

      var _this$getComponents = this.getComponents(),
          Input = _this$getComponents.Input;

      var _this$state4 = this.state,
          inputIsHidden = _this$state4.inputIsHidden,
          ariaSelection = _this$state4.ariaSelection;
      var commonProps = this.commonProps;
      var id = inputId || this.getElementId('input'); // aria attributes makes the JSX "noisy", separated for clarity

      var ariaAttributes = index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2({
        'aria-autocomplete': 'list',
        'aria-expanded': menuIsOpen,
        'aria-haspopup': true,
        'aria-errormessage': this.props['aria-errormessage'],
        'aria-invalid': this.props['aria-invalid'],
        'aria-label': this.props['aria-label'],
        'aria-labelledby': this.props['aria-labelledby'],
        role: 'combobox'
      }, menuIsOpen && {
        'aria-controls': this.getElementId('listbox'),
        'aria-owns': this.getElementId('listbox')
      }), !isSearchable && {
        'aria-readonly': true
      }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus' && {
        'aria-describedby': this.getElementId('live-region')
      } : {
        'aria-describedby': this.getElementId('placeholder')
      });

      if (!isSearchable) {
        // use a dummy input to maintain focus/blur functionality
        return /*#__PURE__*/react.createElement(DummyInput, extends_extends({
          id: id,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: noop,
          onFocus: this.onInputFocus,
          disabled: isDisabled,
          tabIndex: tabIndex,
          inputMode: "none",
          form: form,
          value: ""
        }, ariaAttributes));
      }

      return /*#__PURE__*/react.createElement(Input, extends_extends({}, commonProps, {
        autoCapitalize: "none",
        autoComplete: "off",
        autoCorrect: "off",
        id: id,
        innerRef: this.getInputRef,
        isDisabled: isDisabled,
        isHidden: inputIsHidden,
        onBlur: this.onInputBlur,
        onChange: this.handleInputChange,
        onFocus: this.onInputFocus,
        spellCheck: "false",
        tabIndex: tabIndex,
        form: form,
        type: "text",
        value: inputValue
      }, ariaAttributes));
    }
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;

      var _this$getComponents2 = this.getComponents(),
          MultiValue = _this$getComponents2.MultiValue,
          MultiValueContainer = _this$getComponents2.MultiValueContainer,
          MultiValueLabel = _this$getComponents2.MultiValueLabel,
          MultiValueRemove = _this$getComponents2.MultiValueRemove,
          SingleValue = _this$getComponents2.SingleValue,
          Placeholder = _this$getComponents2.Placeholder;

      var commonProps = this.commonProps;
      var _this$props9 = this.props,
          controlShouldRenderValue = _this$props9.controlShouldRenderValue,
          isDisabled = _this$props9.isDisabled,
          isMulti = _this$props9.isMulti,
          inputValue = _this$props9.inputValue,
          placeholder = _this$props9.placeholder;
      var _this$state5 = this.state,
          selectValue = _this$state5.selectValue,
          focusedValue = _this$state5.focusedValue,
          isFocused = _this$state5.isFocused;

      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /*#__PURE__*/react.createElement(Placeholder, extends_extends({}, commonProps, {
          key: "placeholder",
          isDisabled: isDisabled,
          isFocused: isFocused,
          innerProps: {
            id: this.getElementId('placeholder')
          }
        }), placeholder);
      }

      if (isMulti) {
        return selectValue.map(function (opt, index) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /*#__PURE__*/react.createElement(MultiValue, extends_extends({}, commonProps, {
            components: {
              Container: MultiValueContainer,
              Label: MultiValueLabel,
              Remove: MultiValueRemove
            },
            isFocused: isOptionFocused,
            isDisabled: isDisabled,
            key: key,
            index: index,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e) {
                e.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, 'value'));
        });
      }

      if (inputValue) {
        return null;
      }

      var singleValue = selectValue[0];
      return /*#__PURE__*/react.createElement(SingleValue, extends_extends({}, commonProps, {
        data: singleValue,
        isDisabled: isDisabled
      }), this.formatOptionLabel(singleValue, 'value'));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(),
          ClearIndicator = _this$getComponents3.ClearIndicator;

      var commonProps = this.commonProps;
      var _this$props10 = this.props,
          isDisabled = _this$props10.isDisabled,
          isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;

      if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }

      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/react.createElement(ClearIndicator, extends_extends({}, commonProps, {
        innerProps: innerProps,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(),
          LoadingIndicator = _this$getComponents4.LoadingIndicator;

      var commonProps = this.commonProps;
      var _this$props11 = this.props,
          isDisabled = _this$props11.isDisabled,
          isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator || !isLoading) return null;
      var innerProps = {
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/react.createElement(LoadingIndicator, extends_extends({}, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(),
          DropdownIndicator = _this$getComponents5.DropdownIndicator,
          IndicatorSeparator = _this$getComponents5.IndicatorSeparator; // separator doesn't make sense without the dropdown indicator


      if (!DropdownIndicator || !IndicatorSeparator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /*#__PURE__*/react.createElement(IndicatorSeparator, extends_extends({}, commonProps, {
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(),
          DropdownIndicator = _this$getComponents6.DropdownIndicator;

      if (!DropdownIndicator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/react.createElement(DropdownIndicator, extends_extends({}, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;

      var _this$getComponents7 = this.getComponents(),
          Group = _this$getComponents7.Group,
          GroupHeading = _this$getComponents7.GroupHeading,
          Menu = _this$getComponents7.Menu,
          MenuList = _this$getComponents7.MenuList,
          MenuPortal = _this$getComponents7.MenuPortal,
          LoadingMessage = _this$getComponents7.LoadingMessage,
          NoOptionsMessage = _this$getComponents7.NoOptionsMessage,
          Option = _this$getComponents7.Option;

      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props,
          captureMenuScroll = _this$props12.captureMenuScroll,
          inputValue = _this$props12.inputValue,
          isLoading = _this$props12.isLoading,
          loadingMessage = _this$props12.loadingMessage,
          minMenuHeight = _this$props12.minMenuHeight,
          maxMenuHeight = _this$props12.maxMenuHeight,
          menuIsOpen = _this$props12.menuIsOpen,
          menuPlacement = _this$props12.menuPlacement,
          menuPosition = _this$props12.menuPosition,
          menuPortalTarget = _this$props12.menuPortalTarget,
          menuShouldBlockScroll = _this$props12.menuShouldBlockScroll,
          menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView,
          noOptionsMessage = _this$props12.noOptionsMessage,
          onMenuScrollToTop = _this$props12.onMenuScrollToTop,
          onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen) return null; // TODO: Internal Option Type here

      var render = function render(props, id) {
        var type = props.type,
            data = props.data,
            isDisabled = props.isDisabled,
            isSelected = props.isSelected,
            label = props.label,
            value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? undefined : function () {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? undefined : function () {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId('option'), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /*#__PURE__*/react.createElement(Option, extends_extends({}, commonProps, {
          innerProps: innerProps,
          data: data,
          isDisabled: isDisabled,
          isSelected: isSelected,
          key: optionId,
          label: label,
          type: type,
          value: value,
          isFocused: isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : undefined
        }), _this4.formatOptionLabel(props.data, 'menu'));
      };

      var menuUI;

      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function (item) {
          if (item.type === 'group') {
            var _data = item.data,
                options = item.options,
                groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId('group'), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /*#__PURE__*/react.createElement(Group, extends_extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options,
              Heading: GroupHeading,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function (option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === 'option') {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage({
          inputValue: inputValue
        });
        if (message === null) return null;
        menuUI = /*#__PURE__*/react.createElement(LoadingMessage, commonProps, message);
      } else {
        var _message = noOptionsMessage({
          inputValue: inputValue
        });

        if (_message === null) return null;
        menuUI = /*#__PURE__*/react.createElement(NoOptionsMessage, commonProps, _message);
      }

      var menuPlacementProps = {
        minMenuHeight: minMenuHeight,
        maxMenuHeight: maxMenuHeight,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition,
        menuShouldScrollIntoView: menuShouldScrollIntoView
      };
      var menuElement = /*#__PURE__*/react.createElement(MenuPlacer, extends_extends({}, commonProps, menuPlacementProps), function (_ref4) {
        var ref = _ref4.ref,
            _ref4$placerProps = _ref4.placerProps,
            placement = _ref4$placerProps.placement,
            maxHeight = _ref4$placerProps.maxHeight;
        return /*#__PURE__*/react.createElement(Menu, extends_extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId('listbox')
          },
          isLoading: isLoading,
          placement: placement
        }), /*#__PURE__*/react.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function (scrollTargetRef) {
          return /*#__PURE__*/react.createElement(MenuList, extends_extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);

              scrollTargetRef(instance);
            },
            isLoading: isLoading,
            maxHeight: maxHeight,
            focusedOption: focusedOption
          }), menuUI);
        }));
      }); // positioning behaviour is almost identical for portalled and fixed,
      // so we use the same component. the actual portalling logic is forked
      // within the component based on `menuPosition`

      return menuPortalTarget || menuPosition === 'fixed' ? /*#__PURE__*/react.createElement(MenuPortal, extends_extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;

      var _this$props13 = this.props,
          delimiter = _this$props13.delimiter,
          isDisabled = _this$props13.isDisabled,
          isMulti = _this$props13.isMulti,
          name = _this$props13.name;
      var selectValue = this.state.selectValue;
      if (!name || isDisabled) return;

      if (isMulti) {
        if (delimiter) {
          var value = selectValue.map(function (opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter);
          return /*#__PURE__*/react.createElement("input", {
            name: name,
            type: "hidden",
            value: value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
            return /*#__PURE__*/react.createElement("input", {
              key: "i-".concat(i),
              name: name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /*#__PURE__*/react.createElement("input", {
            name: name,
            type: "hidden"
          });
          return /*#__PURE__*/react.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';

        return /*#__PURE__*/react.createElement("input", {
          name: name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state,
          ariaSelection = _this$state6.ariaSelection,
          focusedOption = _this$state6.focusedOption,
          focusedValue = _this$state6.focusedValue,
          isFocused = _this$state6.isFocused,
          selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /*#__PURE__*/react.createElement(LiveRegion, extends_extends({}, commonProps, {
        id: this.getElementId('live-region'),
        ariaSelection: ariaSelection,
        focusedOption: focusedOption,
        focusedValue: focusedValue,
        isFocused: isFocused,
        selectValue: selectValue,
        focusableOptions: focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(),
          Control = _this$getComponents8.Control,
          IndicatorsContainer = _this$getComponents8.IndicatorsContainer,
          SelectContainer = _this$getComponents8.SelectContainer,
          ValueContainer = _this$getComponents8.ValueContainer;

      var _this$props14 = this.props,
          className = _this$props14.className,
          id = _this$props14.id,
          isDisabled = _this$props14.isDisabled,
          menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /*#__PURE__*/react.createElement(SelectContainer, extends_extends({}, commonProps, {
        className: className,
        innerProps: {
          id: id,
          onKeyDown: this.onKeyDown
        },
        isDisabled: isDisabled,
        isFocused: isFocused
      }), this.renderLiveRegion(), /*#__PURE__*/react.createElement(Control, extends_extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: isDisabled,
        isFocused: isFocused,
        menuIsOpen: menuIsOpen
      }), /*#__PURE__*/react.createElement(ValueContainer, extends_extends({}, commonProps, {
        isDisabled: isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /*#__PURE__*/react.createElement(IndicatorsContainer, extends_extends({}, commonProps, {
        isDisabled: isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps,
          clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
          inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate,
          ariaSelection = state.ariaSelection,
          isFocused = state.isFocused,
          prevWasFocused = state.prevWasFocused;
      var options = props.options,
          value = props.value,
          menuIsOpen = props.menuIsOpen,
          inputValue = props.inputValue,
          isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};

      if (prevProps && (value !== prevProps.value || options !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue: selectValue,
          focusedOption: focusedOption,
          focusedValue: focusedValue,
          clearFocusValueOnUpdate: false
        };
      } // some updates should toggle the state of the input visibility


      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: undefined
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;

      if (isFocused && !hasKeptFocus) {
        // If `value` or `defaultValue` props are not empty then announce them
        // when the Select is initially focused
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: 'initial-input-focus'
        };
        hasKeptFocus = !prevWasFocused;
      } // If the 'initial-input-focus' action has been set already
      // then reset the ariaSelection to null


      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus') {
        newAriaSelection = null;
      }

      return index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2(index_a7690a33_esm_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);

  return Select;
}(react.Component);

Select.defaultProps = defaultProps;

;// CONCATENATED MODULE: ./node_modules/react-select/dist/react-select.esm.js






















var StateManagedSelect = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {
  var baseSelectProps = useStateManager(props);
  return /*#__PURE__*/react.createElement(Select, extends_extends({
    ref: ref
  }, baseSelectProps));
});

var NonceProvider = /*#__PURE__*/function (_Component) {
  _inherits(NonceProvider, _Component);

  var _super = _createSuper(NonceProvider);

  function NonceProvider(props) {
    var _this;

    _classCallCheck(this, NonceProvider);

    _this = _super.call(this, props);

    _this.createEmotionCache = function (nonce, key) {
      return emotion_cache_browser_esm({
        nonce: nonce,
        key: key
      });
    };

    _this.createEmotionCache = memoize_one_esm(_this.createEmotionCache);
    return _this;
  }

  _createClass(NonceProvider, [{
    key: "render",
    value: function render() {
      var emotionCache = this.createEmotionCache(this.props.nonce, this.props.cacheKey);
      return /*#__PURE__*/react.createElement(CacheProvider, {
        value: emotionCache
      }, this.props.children);
    }
  }]);

  return NonceProvider;
}(react.Component);

/* harmony default export */ var react_select_esm = (StateManagedSelect);

;// CONCATENATED MODULE: ./src/util/filter-utils.js
var capacityOptions=[{label:"Alle"},{value:"0,10",label:"0 - 10",type:"between"},{value:"11,20",label:"11 - 20",type:"between"},{value:"21,30",label:"21 - 30",type:"between"},{value:"31,80",label:"31 - 80",type:"between"},{value:"81",label:"81+",type:"gt"}];var facilityOptions=[{value:"monitorEquipment",label:"Projektor/Skærm"},{value:"wheelchairAccessible",label:"Handikapvenligt"},{value:"videoConferenceEquipment",label:"Videokonference"},{value:"catering",label:"Mulighed for tilkøb af mad og drikke"}];var calendarTimeSelect=[{value:"auto",label:"auto"},{value:"06",label:"06:00"},{value:"07",label:"07:00"},{value:"08",label:"08:00"},{value:"09",label:"09:00"},{value:"10",label:"10:00"},{value:"11",label:"11:00"},{value:"12",label:"12:00"},{value:"13",label:"13:00"},{value:"14",label:"14:00"},{value:"15",label:"15:00"},{value:"16",label:"16:00"},{value:"17",label:"17:00"},{value:"18",label:"18:00"},{value:"19",label:"19:00"},{value:"20",label:"20:00"},{value:"21",label:"21:00"},{value:"22",label:"22:00"},{value:"23",label:"23:00"}];var resourceLimit=50;
;// CONCATENATED MODULE: ./src/components/calendar-header.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var calendar_header = ({});
;// CONCATENATED MODULE: ./src/components/calendar-header.js
/**
 * Calendar header component.
 *
 * @param {object} props Props.
 * @param {object} props.date Date.
 * @param {Function} props.setDate Set date function.
 * @param {Function} props.setIsLoading Loading state setter.
 * @param {Function} props.setTimeScroll Timescroll state setter.
 * @param {string} props.scrollTime Seleted scrollTime
 * @returns {JSX.Element} Calendar header component.
 */function CalendarHeader(_ref){var date=_ref.date,setDate=_ref.setDate,setIsLoading=_ref.setIsLoading,setTimeScroll=_ref.setTimeScroll,scrollTime=_ref.scrollTime;var onChangeDate=function onChangeDate(event){switch(event.target.id){case"calendar-today":setDate(new Date());break;case"calendar-back":if(new Date()<date){setDate(new Date(dayjs_min(date).subtract(1,"day").format("YYYY-MM-DD")));setIsLoading(true);}break;case"calendar-forward":setDate(new Date(dayjs_min(date).add(1,"day").format("YYYY-MM-DD")));setIsLoading(true);break;case"calendar-datepicker":setDate(new Date(event.target.value));break;default:}};var getScrollTimeObj=function getScrollTimeObj(){if(!scrollTime){return false;}return{value:scrollTime,label:scrollTime};};return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col no-gutter",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"row calendar-header-wrapper",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-2 col-sm-6 col-xs-6 small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"calendar-today",className:"booking-btn",type:"button",onClick:onChangeDate,children:"I dag"})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"calendar-hidden-lg col-sm-6 col-xs-6 small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"calendar-nav",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"calendar-back",className:"booking-btn",type:"button",disabled:new Date()>date,onClick:onChangeDate,children:"\u2039"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"calendar-forward",className:"booking-btn",type:"button",onClick:onChangeDate,children:"\u203A"})]})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"col-md-8 col-sm-12 col-xs-12 small-padding datepicker-container",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"datepicker",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"V\xE6lg dato"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"calendar-datepicker",className:"datepicker-label",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{hidden:true,children:"Dato"}),/*#__PURE__*/(0,jsx_runtime.jsx)("input",{type:"date",id:"calendar-datepicker",min:dayjs_min(new Date()).format("YYYY-MM-DD"),value:dayjs_min(date).format("YYYY-MM-DD"),onChange:onChangeDate}),/*#__PURE__*/(0,jsx_runtime.jsxs)("button",{type:"button",id:"calendar_text",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:dayjs_min(date).format("D. MMMM YYYY")})," ",/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"\uD83D\uDCC5"})})]})]})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"timepicker",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"V\xE6lg start-tidspunkt"}),/*#__PURE__*/(0,jsx_runtime.jsx)(react_select_esm,{id:"calendar-hours-filter",className:"filter",defaultValue:getScrollTimeObj(),placeholder:"Tid...",placeholderClassName:"dropdown-placeholder",closeMenuOnSelect:true,options:calendarTimeSelect,onChange:function onChange(selectedHour){setTimeScroll(selectedHour);},loadingMessage:function loadingMessage(){return"Henter tider..";},isSearchable:false,menuPlacement:"bottom",menuPortalTarget:document.body,styles:{menuPortal:function menuPortal(base){return objectSpread2_objectSpread2(objectSpread2_objectSpread2({},base),{},{zIndex:9999});}}})]})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-2 calendar-hidden-sm small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"calendar-nav",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"calendar-back",className:"booking-btn",type:"button",disabled:new Date()>date,onClick:onChangeDate,children:"\u2039"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"calendar-forward",className:"booking-btn",type:"button",onClick:onChangeDate,children:"\u203A"})]})})]})})});}/* harmony default export */ var components_calendar_header = (CalendarHeader);
;// CONCATENATED MODULE: ./src/components/loading-spinner.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var loading_spinner = ({});
;// CONCATENATED MODULE: ./src/components/loading-spinner.js
/**
 * Loading spinner component.
 *
 * @param {object} props Props.
 * @param {string} props.size Size of spinner.
 * @returns {JSX.Element} Loading spinner component.
 */function LoadingSpinner(_ref){var _ref$size=_ref.size,size=_ref$size===void 0?"default":_ref$size;return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"".concat(size==="small"?"small-loader":"loader"),children:/*#__PURE__*/(0,jsx_runtime.jsx)("img",{src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAACMBJREFUeF7tnXeofUcRxz8BBcUCFowae1RSrFFjLxgVVGKLvcUSgyYW7IoRFGOLBTVWbLEXjN3YsGKLqLFG1CQqRqNiQVSCDeUTzwk3791ydmbPfXffOwOP3x+/ndmd7/ees3tmZ2f3oV25B3AwcAhwaOfGqcBpwI+AD7fo2j4NDvpawOuB268Y++eBo4EzW/KxNUIeB7yqEODHAq8p1Nmx5i0Rcj3ge0Gk1P1BUHetai0R8mPggCA6p3fzTVB9fWqtEPIS4ClJWLTxtKSN0dVbIcRV00FJNM4C9k/aGF29FULOBS5SAY2rAb+sYGc0Ey0QIog/r4SA3y4fqWRrFDMtEHI74AuVvH8O8NxKtkYx0wIhVwJ+Vcn7OwGfrWRrFDMtEKLjfwEuWQGBfYHfV7AzmolahNyxW+dfH7gpsB9gXOlbwA+BTwJ/TnihnRsl9FX1o/IGSRujq9cgxLDEMStG+jPA9/e7gx49HXhRULdX08YJSRujq2cJOaNwbf8u4MFBr74J3CSh65O78ZIh5GvAzQMePjP4a78M8IdAf6pcOvnKDHZbrhYl5MnAS8u7O18jutq5PPDRgifFp+puwO8SY12raoQQwfx0cpQ/7SbpvwXtPHXAfGCbzI8mOLScWoSQGhOso74V8NXE8K/QrZpc2fWrp+8C/rmiOidhe8dUI4S8F7hfhRE3tXFUwd9BJiKE+LpxGzUrbwIelTWy2/QjhNT6anZyvvtuAzTrT4QQY0F3yHYMHAc8v4KdXWUiQsgLgWdUQMHl6Mcq2NlVJiKEPAh4ZwUUrlFxn6PCcDbDRIQQv3q/kZzY319ppbYZKFYcRYQQu888Jf8GDIP/qaIfu8ZUlBAB8LUlMaVicNEg4yRzEMgQojkDhS8YiOw/gcOArwxsvyebZQkRNGNbr14xp5iLa2wpGrvaM+TUIESwLgH0MSXjSs4RxpP6uJIbVJMMQKAWIQO6mpoMQWAiZAhKa2wzEbJGsId0NREyBKU1tpkIWSPYQ7qaCBmC0hrbTISsEewhXU2EDEFpjW0mQtYI9pCuhhByZcC9C7MUfz3E6NRmGwKXAzzn8kfgF8B/FmG0iBBjU7cBrglcdEbZ/XTDIB8AXjwBvxQB06WO6FJt3UPq5V/AT4AvAh7zvoBsJeTOwJsBc55WiVmBtp/2NS6IlCmvp8xUl1iG42+ARwKf6hvNEvJQ4G2rWJjz/6Z3NpOqGfCvREUsIgl6D+m3xXtCjM7+tqTnmbY+KU1klgf9K1HLZOif98PuCXk7IEtRaTKPNursAj3P0XsWPipycKSE3As4OWql0/svcMXEU5bsfsfVnXOdD7JyhIQ8r0tayxpzgj9/csoaa0xf353Is3K8hHwCuEvWUre/nj12VmEYO2LCxEETCLNyioT4qA1Z5q7qzKz4B6xqtEv/v9aJgHMk5Ozu1GwWq8z5wWzfO60fTYnaOu6zJcQJ3Yk9K48HTswaaVRf319ZYewnS4hZ6E7sWTHnyrJ6e1EsN/i5Co4fJyEWZPlQBWMbXyWhgo+LTGQ+rGdt3rP/MJTdVUUll/nzsgoFxkbEay2mxeBJiZ58uxzWE2JUN5rMZukkw/OT/L+MlGH2iHhM8IzZ4GKk4qcdn2coMoJdqHPtLrRe6prYu+XB1vC71TvfN7DYpO2OmvJ1t2F/ccADrUNOKlvY8/7A93srizaoDJK5uXL1OVRb3ceCMyZQT7IYgUd3RXmuO6eJZQY9tLStKOeqLVzfhyZPm0j97e4vEu/fy8RdtsNQHN0CF0ePls+VVYTsZSB3xPeJkB2BfXGnEyETIRuGwIYNZ3pCJkI2DIENG870hEyEbBgCGzac6QnZpYRcDLhOV0z5xt2WsEljHo32qolaxfR3Gj5DSfppzM/kQLe/+2LR+vn37ABrPCFWhXsWcNUlgzFu85iG84DN130tcN8lPhqfsv7XGzOkZAl5K/CwgQOw6IxtW6tzYm0W/bzQQD9t+4iBbbc1yxAS3SG7dUP1TjyS8aUAuOEd1Cght0iUeP0HYAR00+ueuK/hUYsLBwhRRYy+XqobIcSBWkjZDqPiXopzyibL6wD3NKJiKXYL8xRN9BFCjgROio5yRm+Tt34d28I9iwLfxcqs9sESIeQVwBMG97C44b0rZN1XGMZcE/fpdvSy9sXqiSVGIoQ4yTnZZeV44NlZIyPpOzaX8ln5MnDbEiMRQv4KOI9k5ePA4VkjI+k7trtWsO3CxVpigyVCiNeYHji4h8UNnTRX3cxToZuQieyE3ndqVknRhZgRQko+Bpeh4enTt4TgGl/JsZnKkxUXPw8vMRIhxEnq5SWdLGh7s+7isKgpD+P38bP+0KkXkZmmZFwpcxub9qxNnBWxcmIfLBFCvJHtM4N7mN/QuM/BpWv0GVNe1OItP8vENh5GjYhzpKReJaI8o1N8k1CEEPsbcjPbMl+ODgbh/D7wo3ReAt+8/owyC0ok1dUxviFBiMHIY0v1o4TYT+kNbf3Yit+rnaK/Wld4EVG36Iu568Sx+nFXKmITumMlQ4iDLL2pzbln1atmkfPmEi8Lfy8D7T3AA0tR7do75pKPOzG5ZbCvbcnWETtDbmxzkL7P/Tcixr18BWREG9F8ZON25juvit9ZPMBIb1iyT0jfse/pGwKHdP9aJuK0mT/PMWaiu+bDajsjZpiboxwVX3smoOtn76t5zt+Z8TO72KnyhEQdLNEzDH6pEoUFbQ37W7NqY6XWEzKmg9EKO/PG5FVNNQ5njuZvC4T4AVm80bMAsfQ7fjQmOsMtEJI5/7gVP+eAD44NasZ+C4SYXHBuQZLBMjz2B87KADa2bguEiIHxKUMtGTmzqyGZsTG6biuEeEK1OAyxBT1tbCs6OTrChR20QohuueZ3xRURKx7tF1Fct05LhGSKhDVTXK0lQvyxRiqnqvOOdf/So/21Roh++to6YUDRTkkwftZUCdsWCel/fNb46mNnxpYU42d9bGmjvzcWPUH/A6IhQT7dUjKkAAAAAElFTkSuQmCC",alt:"loading"})});}LoadingSpinner.defaultProps={size:"default"};/* harmony default export */ var components_loading_spinner = (LoadingSpinner);
;// CONCATENATED MODULE: ./src/components/calendar.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var calendar = ({});
;// CONCATENATED MODULE: ./src/components/calendar.js
// FullCalendar must be imported before FullCalendar plugins
/**
 * Calendar component.
 *
 * @param {object} props Props.
 * @param {Array} props.resources Resources to show calendar for.
 * @param {Date} props.date Date to show calendar for.
 * @param {Function} props.setDate Set date function.
 * @param {object} props.calendarSelection The current calendar selection.
 * @param {Function} props.setCalendarSelection Set calendar selection function.
 * @param {object} props.config Config for the app.
 * @param {Function} props.setShowResourceDetails Setter for showResourceDetails
 * @param {object} props.urlResource The resource object loaded from URL id.
 * @param {Function} props.setDisplayState State of the calendar - "minimized" or "maximized"
 * @param {boolean} props.userHasInteracted Has the user interacted with filters
 * @param {boolean} props.isLoading Loading state
 * @param {Function} props.setIsLoading Loading state setter
 * @returns {JSX.Element} Calendar component.
 */function Calendar(_ref){var resources=_ref.resources,date=_ref.date,setDate=_ref.setDate,calendarSelection=_ref.calendarSelection,setCalendarSelection=_ref.setCalendarSelection,config=_ref.config,setShowResourceDetails=_ref.setShowResourceDetails,urlResource=_ref.urlResource,setDisplayState=_ref.setDisplayState,userHasInteracted=_ref.userHasInteracted,isLoading=_ref.isLoading,setIsLoading=_ref.setIsLoading;var calendarRef=(0,react.useRef)();var dateNow=new Date();var _useState=(0,react.useState)(),_useState2=slicedToArray_slicedToArray(_useState,2),internalSelection=_useState2[0],setInternalSelection=_useState2[1];var _useState3=(0,react.useState)(),_useState4=slicedToArray_slicedToArray(_useState3,2),calendarSelectionResourceTitle=_useState4[0],setCalendarSelectionResourceTitle=_useState4[1];var _useState5=(0,react.useState)(),_useState6=slicedToArray_slicedToArray(_useState5,2),calendarSelectionResourceId=_useState6[0],setCalendarSelectionResourceId=_useState6[1];var _useState7=(0,react.useState)([]),_useState8=slicedToArray_slicedToArray(_useState7,2),calendarResources=_useState8[0],setCalendarResources=_useState8[1];var _useState9=(0,react.useState)([]),_useState10=slicedToArray_slicedToArray(_useState9,2),calendarEvents=_useState10[0],setCalendarEvents=_useState10[1];removeEmptyAriaLabelled();tabindexCalendar();/**
   * OnCalenderSelection.
   *
   * @param {object} selection The new selection object.
   * @returns {void} Nothing is returned
   */var onCalendarSelection=function onCalendarSelection(selection){if(selection.start<dateNow){return false;}var newSelection={allDay:selection.allDay,resourceId:urlResource?urlResource.resourceMail:selection.resource.id,end:selection.end,start:selection.start};var serialized=JSON.stringify(newSelection);setInternalSelection(serialized);if(typeof selection.resource!=="undefined"&&selection.resource!==null){setCalendarSelectionResourceId(selection.resource.extendedProps.resourceId);}setCalendarSelection(newSelection);if(selection.resource){setCalendarSelectionResourceTitle(selection.resource.title);}else if(urlResource){setCalendarSelectionResourceTitle(urlResource.resourceName);}return undefined;};var setTimeScroll=function setTimeScroll(selectedTime){var _calendarRef$current;localStorage.setItem("setTimeScroll",selectedTime.value);calendarRef===null||calendarRef===void 0?void 0:(_calendarRef$current=calendarRef.current)===null||_calendarRef$current===void 0?void 0:_calendarRef$current.getApi().scrollToTime(getScrollTime());};/**
   * Function that decides if a selection is allowed.
   *
   * @param {object} selectInfo The current selection.
   * @returns {boolean} Allowed selection?
   */var selectAllow=function selectAllow(selectInfo){var _selectInfo$resource,_selectResource$exten;// eslint-disable-next-line no-underscore-dangle
var selectResource=selectInfo===null||selectInfo===void 0?void 0:(_selectInfo$resource=selectInfo.resource)===null||_selectInfo$resource===void 0?void 0:_selectInfo$resource._resource;// Allow all selections for resources where acceptConflict is true.
if((selectResource===null||selectResource===void 0?void 0:(_selectResource$exten=selectResource.extendedProps)===null||_selectResource$exten===void 0?void 0:_selectResource$exten.acceptConflict)===true){return true;}var selectStart=new Date(selectInfo.startStr);var selectEnd=new Date(selectInfo.endStr);// Disallow selections that overlap other events.
return!calendarEvents.some(function(event){if(event.resourceId!==selectResource.id){return false;}var eventStart=new Date(event.start);var eventEnd=new Date(event.end);return selectStart<eventEnd&&selectEnd>eventStart;});};// Set calendar selection.
(0,react.useEffect)(function(){if(calendarSelection){var _calendarRef$current2;calendarRef===null||calendarRef===void 0?void 0:(_calendarRef$current2=calendarRef.current)===null||_calendarRef$current2===void 0?void 0:_calendarRef$current2.getApi().select(calendarSelection);}},[internalSelection]);// Go to calendar date when date changes.
(0,react.useEffect)(function(){if(calendarSelection){var _calendarRef$current3,_calendarRef$current4;calendarRef===null||calendarRef===void 0?void 0:(_calendarRef$current3=calendarRef.current)===null||_calendarRef$current3===void 0?void 0:_calendarRef$current3.getApi().gotoDate(date);calendarRef===null||calendarRef===void 0?void 0:(_calendarRef$current4=calendarRef.current)===null||_calendarRef$current4===void 0?void 0:_calendarRef$current4.getApi().select(calendarSelection);}},[date]);// Get events for the given resources.
(0,react.useEffect)(function(){if(config&&(resources===null||resources===void 0?void 0:resources.length)>0&&date!==null){Api.fetchEvents(config.api_endpoint,resources,dayjs_min_default()(date).startOf("day")).then(function(loadedEvents){setCalendarEvents(loadedEvents.map(function(value){return handleBusyIntervals(value);}));setTimeout(function(){setIsLoading(false);},200);}).catch(function(fetchEventsError){setIsLoading(false);toast.error("Der opstod en fejl. Prøv igen senere.",fetchEventsError);});}setCalendarResources(resources.map(function(value){return calendar_utils_handleResources(value,date);}));if(resources&&(resources===null||resources===void 0?void 0:resources.length)===0){setIsLoading(false);}},[resources,date]);(0,react.useEffect)(function(){var highlightElement=document.querySelector("div.fc-highlight");if(highlightElement!==null){setTimeout(function(){document.querySelector("div.fc-highlight").innerHTML=server_browser.renderToString(/*#__PURE__*/(0,jsx_runtime.jsx)(calendar_selection_box,{calendarSelection:calendarSelection,calendarSelectionResourceTitle:calendarSelectionResourceTitle,calendarSelectionResourceId:calendarSelectionResourceId}));document.getElementById("calendar-selection-choice-confirm").addEventListener("mousedown",function(e){var _calendarSelection$re;e.stopPropagation();var resourceId=e.target.getAttribute("data-resource-id");var paramsObj={from:calendarSelection.start.toISOString(),to:calendarSelection.end.toISOString(),resourceMail:(_calendarSelection$re=calendarSelection.resourceId)!==null&&_calendarSelection$re!==void 0?_calendarSelection$re:undefined,resource:resourceId};if(config!==null&&config!==void 0&&config.step_one){var formId=null;if(resources&&calendarSelection!==null&&calendarSelection!==void 0&&calendarSelection.resourceId){var resourcesFound=resources.filter(function(res){return res.resourceMail===calendarSelection.resourceId;});if(resourcesFound.length===1){formId=resourcesFound[0].formId;}}var target=formId||config.redirect_url;if(paramsObj.from===undefined||paramsObj.to===undefined||paramsObj.resourceMail===undefined||paramsObj.resource===undefined){window.open(target,"_self");}else{var paramsStr=new URLSearchParams(paramsObj).toString();var separator=target.indexOf("?")>-1?"&":"?";window.open("".concat(target+separator+paramsStr),"_self");}}else{setDisplayState("minimized");}return false;});document.getElementById("calendar-selection-container").addEventListener("mousedown",function(e){e.stopPropagation();});document.getElementById("calendar-selection-close").addEventListener("mousedown",function(e){e.stopPropagation();calendarRef.current.getApi().unselect();setCalendarSelection({});});},1);}},[calendarSelection,calendarEvents]);/** @param {string} resource Object of the resource to load */var triggerResourceView=function triggerResourceView(resource){// eslint-disable-next-line no-underscore-dangle
setShowResourceDetails(resource._resource.id);};var renderCalendarCellInfoButton=function renderCalendarCellInfoButton(resource,triggerResourceViewEv){return/*#__PURE__*/(0,jsx_runtime.jsx)(components_calendar_cell_info_button,{resource:resource,onClickEvent:triggerResourceViewEv});};var resourceAreaColumns=[{headerContent:"Ressourcer",cellContent:function cellContent(arg){return renderCalendarCellInfoButton(arg.resource,triggerResourceView);}},{headerContent:["Kapacitet"],headerClassNames:"resource-calendar-capacity-header",width:"85px",cellClassNames:"resource-calendar-capacity-value",cellContent:function cellContent(arg){return arg.resource.extendedProps.capacity;}}];return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"Calendar no-gutter col",role:"application",children:[(!resources||resources&&resources.length===0)&&!userHasInteracted&&/*#__PURE__*/(0,jsx_runtime.jsx)(no_result_overlay,{state:"initial"}),(!resources||resources&&resources.length===0)&&userHasInteracted&&/*#__PURE__*/(0,jsx_runtime.jsx)(no_result_overlay,{state:"noresult"}),isLoading&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{}),/*#__PURE__*/(0,jsx_runtime.jsx)(components_calendar_header,{date:date,setDate:setDate,setIsLoading:setIsLoading,scrollTime:getScrollTime(true,true),setTimeScroll:setTimeScroll}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row","aria-hidden":"true",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"col small-padding",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{hidden:true,id:"calendar-caption",children:"Kalender booking element"}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist_main,{ref:calendarRef,plugins:[resource_timegrid_main,interaction_main,_fullcalendar_daygrid_main,_fullcalendar_timegrid_main,_fullcalendar_list_main,_fullcalendar_resource_timeline_main],titleFormat:{year:"numeric",month:"long",day:"numeric"},headerToolbar:"",height:"650px",scrollTime:getScrollTime(),initialView:"resourceTimelineDay",duration:"days: 3",selectConstraint:"businessHours",selectMirror:true,displayEventTime:true,scrollTimeReset:false,slotLabelFormat:{hour:"numeric",omitZeroMinute:false},resourcesInitiallyExpanded:true,nowIndicator:true,navLinks:true,slotDuration:"00:15:00",allDaySlot:false,selectable:true,selectAllow:selectAllow,unselectAuto:false,schedulerLicenseKey:config.license_key,slotMinTime:"00:00:00",slotMaxTime:"24:00:00",selectOverlap:true,nextDayThreshold:"21:00:00",editable:false,dayMaxEvents:true,locale:locales_da/* default */.Z,select:onCalendarSelection,resources:calendarResources,validRange:{start:dateNow},resourceOrder:"resourceId",resourceGroupField:"building",resourceAreaColumns:resourceAreaColumns,events:calendarEvents})]})})]});}Calendar.defaultProps={calendarSelection:null,urlResource:null,validUrlParams:{},resources:{}};/* harmony default export */ var components_calendar = (Calendar);
;// CONCATENATED MODULE: ./src/components/minimized-display.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var minimized_display = ({});
;// CONCATENATED MODULE: ./src/components/minimized-display.js
/**
 * Minimized display component.
 *
 * @param {object} props Props.
 * @param {Function} props.setDisplayState Set display state function.
 * @param {object} props.resource Resource.
 * @param {object} props.calendarSelection A selection in calendar.
 * @returns {JSX.Element} Calendar header component.
 */function MinimizedDisplay(_ref){var _resource$locationDis,_resource$resourceDis;var setDisplayState=_ref.setDisplayState,resource=_ref.resource,calendarSelection=_ref.calendarSelection;var onChangeBooking=function onChangeBooking(){return setDisplayState("maximized");};var formatUrlDate=function formatUrlDate(dateString){return dayjs_min_default()(dateString).format("DD/MM/YYYY - HH:mm");};return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-12",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"minimized-display col-md-12",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"location",children:(_resource$locationDis=resource.locationDisplayName)!==null&&_resource$locationDis!==void 0?_resource$locationDis:resource.location}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"subject",children:(_resource$resourceDis=resource.resourceDisplayName)!==null&&_resource$resourceDis!==void 0?_resource$resourceDis:resource.resourceName})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:formatUrlDate(calendarSelection.start)}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"\u2192"}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:formatUrlDate(calendarSelection.end)})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{id:"change-booking",type:"button",onClick:onChangeBooking,children:"\xC6ndr\xE9r valg"})})]})})});}/* harmony default export */ var components_minimized_display = (MinimizedDisplay);
;// CONCATENATED MODULE: ./src/components/info-box.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var info_box = ({});
;// CONCATENATED MODULE: ./src/components/info-box.js
/**
 * Information box component.
 *
 * @param {object} props Props.
 * @param {object} props.config Object containing configuration from drupal
 * @returns {JSX.Element} Info box component
 */function InfoBox(_ref){var config=_ref.config;var _useState=(0,react.useState)(true),_useState2=slicedToArray_slicedToArray(_useState,2),display=_useState2[0],setDisplay=_useState2[1];var infoBoxColor=config.info_box_color;var infoBoxHeader=config.info_box_header;var infoBoxContent=config.info_box_content;return display&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"info-box-wrapper",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"row info-box",style:{backgroundColor:"".concat(infoBoxColor,"em")},children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"col-md-11 col-sm-11 col-xs-11 info-box-content",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"info-box-content-header",children:/*#__PURE__*/(0,jsx_runtime.jsx)("b",{children:infoBoxHeader})}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"info-box-content-text",children:infoBoxContent})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-1 col-sm-1 col-xs-1 info-box-close",onClick:function onClick(){return setDisplay(false);},role:"presentation",children:/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"x"})})]})});}/* harmony default export */ var components_info_box = (InfoBox);
;// CONCATENATED MODULE: ./src/components/list.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var list = ({});
// EXTERNAL MODULE: ./node_modules/dompurify/dist/purify.js
var purify = __webpack_require__(8703);
var purify_default = /*#__PURE__*/__webpack_require__.n(purify);
// EXTERNAL MODULE: ./node_modules/html-react-parser/index.js
var html_react_parser = __webpack_require__(6854);
;// CONCATENATED MODULE: ./node_modules/html-react-parser/index.mjs

var domToReact = html_react_parser.domToReact;
var htmlToDOM = html_react_parser.htmlToDOM;
var attributesToProps = html_react_parser.attributesToProps; // domhandler

var Comment = html_react_parser.Comment;
var html_react_parser_Element = html_react_parser.Element;
var ProcessingInstruction = html_react_parser.ProcessingInstruction;
var Text = html_react_parser.Text;
/* harmony default export */ var node_modules_html_react_parser = (html_react_parser);
;// CONCATENATED MODULE: ./src/assets/projector.svg
var projector_path;

var projector_excluded = ["title", "titleId"];

function projector_extends() { projector_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return projector_extends.apply(this, arguments); }

function projector_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = projector_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function projector_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgProjector(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = projector_objectWithoutProperties(_ref, projector_excluded);

  return /*#__PURE__*/react.createElement("svg", projector_extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 25,
    height: 24,
    fill: "none",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, projector_path || (projector_path = /*#__PURE__*/react.createElement("path", {
    fill: "#343A40",
    d: "M11.992 7.734a.647.647 0 0 0 .469.196.627.627 0 0 0 .43-.196l.43-.43a.627.627 0 0 0 .195-.429.647.647 0 0 0-.196-.469L10.664 3.75a.588.588 0 0 0-.43-.156.587.587 0 0 0-.43.156l-.468.469a.587.587 0 0 0-.156.43c0 .156.039.312.156.43l2.656 2.655Zm3.945-.234h.626a.642.642 0 0 0 .625-.625v-3.75c0-.313-.313-.625-.625-.625h-.625a.642.642 0 0 0-.626.625v3.75c0 .352.274.625.626.625Zm3.633.234a.627.627 0 0 0 .43.196.647.647 0 0 0 .469-.196l2.656-2.656a.587.587 0 0 0 .156-.43.587.587 0 0 0-.156-.43l-.469-.468a.587.587 0 0 0-.43-.156.587.587 0 0 0-.43.156l-2.655 2.656a.647.647 0 0 0-.196.469c0 .156.078.313.196.43l.43.43ZM4.375 14.063a.925.925 0 0 0-.938.937c0 .547.391.938.938.938.508 0 .938-.391.938-.938a.95.95 0 0 0-.938-.938ZM23.125 10H18.75c-.742-.352-1.602-.625-2.5-.625-.938 0-1.797.273-2.54.625H1.876C.82 10 0 10.86 0 11.875v6.25C0 19.18.82 20 1.875 20H2.5l.508 2.031c.039.274.312.469.586.469h.898a.669.669 0 0 0 .625-.469L5.625 20h8.086a5.387 5.387 0 0 0 5.04 0h.624l.508 2.031c.039.274.312.469.586.469h.898a.669.669 0 0 0 .625-.469L22.5 20h.625C24.141 20 25 19.18 25 18.125v-6.25C25 10.859 24.14 10 23.125 10Zm-11.563 8.125H1.876v-6.25h9.688A5.762 5.762 0 0 0 10.624 15c0 1.172.352 2.266.938 3.125Zm4.688.625c-2.07 0-3.75-1.68-3.75-3.75 0-2.031 1.68-3.75 3.75-3.75 2.031 0 3.75 1.719 3.75 3.75-.04 2.07-1.719 3.75-3.75 3.75Zm6.875-.625h-2.227c.586-.86.938-1.953.938-3.086a5.793 5.793 0 0 0-.938-3.164h2.227v6.25Zm-16.25-4.063a.925.925 0 0 0-.938.938c0 .547.391.938.938.938.508 0 .938-.391.938-.938a.95.95 0 0 0-.938-.938Z"
  })));
}

var projector_ForwardRef = /*#__PURE__*/react.forwardRef(SvgProjector);
/* harmony default export */ var projector = (__webpack_require__.p + "static/media/projector.4659306b067a318c4fbc44fae154dfbc.svg");

;// CONCATENATED MODULE: ./src/assets/wheelchair.svg
var wheelchair_path;

var wheelchair_excluded = ["title", "titleId"];

function wheelchair_extends() { wheelchair_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return wheelchair_extends.apply(this, arguments); }

function wheelchair_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = wheelchair_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function wheelchair_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgWheelchair(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = wheelchair_objectWithoutProperties(_ref, wheelchair_excluded);

  return /*#__PURE__*/react.createElement("svg", wheelchair_extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 25,
    height: 24,
    fill: "none",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, wheelchair_path || (wheelchair_path = /*#__PURE__*/react.createElement("path", {
    fill: "#343A40",
    d: "M22.031 18.125c-.117-.234-.43-.313-.664-.195l-1.562.82-2.422-5.352a.881.881 0 0 0-.82-.585h-6.055l-.274-1.876h5.547a.475.475 0 0 0 .469-.468V9.53a.504.504 0 0 0-.469-.469H10L9.61 6.25a1.823 1.823 0 0 0 1.6-1.953c-.038-.938-.82-1.719-1.796-1.758C8.36 2.461 7.5 3.32 7.5 4.375c0 .195-.117-.586 1.25 9.531.04.469.43.781.938.781h6.25l2.539 5.704c.234.507.78.703 1.289.468l2.46-1.25a.455.455 0 0 0 .196-.625l-.39-.859Zm-7.304-1.563h-.47a4.949 4.949 0 0 1-4.882 4.063c-2.773 0-5-2.227-5-5 0-1.68.86-3.203 2.148-4.102l-.273-2.03a6.897 6.897 0 0 0-3.75 6.132A6.836 6.836 0 0 0 9.375 22.5a6.85 6.85 0 0 0 6.21-3.945l-.858-1.992Z"
  })));
}

var wheelchair_ForwardRef = /*#__PURE__*/react.forwardRef(SvgWheelchair);
/* harmony default export */ var wheelchair = (__webpack_require__.p + "static/media/wheelchair.e3d8722786cb3690e05f393ae81bb132.svg");

;// CONCATENATED MODULE: ./src/assets/videocamera.svg
var videocamera_path;

var videocamera_excluded = ["title", "titleId"];

function videocamera_extends() { videocamera_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return videocamera_extends.apply(this, arguments); }

function videocamera_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = videocamera_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function videocamera_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgVideocamera(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = videocamera_objectWithoutProperties(_ref, videocamera_excluded);

  return /*#__PURE__*/react.createElement("svg", videocamera_extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 25,
    height: 24,
    fill: "none",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, videocamera_path || (videocamera_path = /*#__PURE__*/react.createElement("path", {
    fill: "#343A40",
    d: "M22.46 6.25a1.26 1.26 0 0 0-.702.234L17.5 9.18V6.875C17.5 5.859 16.562 5 15.469 5H3.242C2.148 5 1.25 5.86 1.25 6.875v11.29C1.25 19.18 2.148 20 3.242 20H15.47c1.094 0 2.031-.82 2.031-1.836V15.86l4.258 2.696c.234.156.469.195.703.195.664 0 1.289-.508 1.289-1.21V7.5c0-.742-.625-1.25-1.29-1.25Zm-6.835 4.063v7.773c-.04.039-.078.039-.156.039H3.242c-.078 0-.117 0-.117-.04V6.954c0-.039.04-.078.117-.078H15.47c.078 0 .117.04.156.078v3.36Zm6.25 6.093L17.5 13.672v-2.305l4.375-2.734v7.773Z"
  })));
}

var videocamera_ForwardRef = /*#__PURE__*/react.forwardRef(SvgVideocamera);
/* harmony default export */ var videocamera = (__webpack_require__.p + "static/media/videocamera.f6b43574df0e599834335fef09ed5b83.svg");

;// CONCATENATED MODULE: ./src/assets/food.svg
var food_path;

var food_excluded = ["title", "titleId"];

function food_extends() { food_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return food_extends.apply(this, arguments); }

function food_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = food_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function food_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgFood(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = food_objectWithoutProperties(_ref, food_excluded);

  return /*#__PURE__*/react.createElement("svg", food_extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 25,
    height: 24,
    fill: "none",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, food_path || (food_path = /*#__PURE__*/react.createElement("path", {
    fill: "#343A40",
    d: "M21.914 12.188c-.664-.079-1.055-.274-1.523-.508-.508-.235-2.774-1.524-5.82 0-2.071 1.015-3.516.312-4.18 0-.47-.235-2.774-1.524-5.82 0-.47.234-.86.43-1.524.508a.604.604 0 0 0-.547.624v.626c0 .351.313.664.703.624 1.016-.117 1.64-.43 2.188-.703 2.07-1.015 3.554-.312 4.18 0 3.046 1.524 5.312.235 5.82 0 2.187-1.093 3.75-.195 4.18 0 .546.274 1.171.586 2.187.704.39.039.742-.274.742-.626v-.624c-.04-.352-.273-.586-.586-.626ZM21.25 3.75H3.75c-.703 0-1.25.586-1.25 1.25v3.75c0 .703.547 1.25 1.25 1.25h17.5c.664 0 1.25-.547 1.25-1.25V5c0-.664-.586-1.25-1.25-1.25Zm-.625 4.375H4.375v-2.5h16.25v2.5ZM21.25 15H3.75c-.703 0-1.25.586-1.25 1.25V20c0 .703.547 1.25 1.25 1.25h17.5c.664 0 1.25-.547 1.25-1.25v-3.75c0-.664-.586-1.25-1.25-1.25Zm-.625 4.375H4.375v-2.5h9.063l2.812 1.875 2.813-1.875h1.562v2.5Z"
  })));
}

var food_ForwardRef = /*#__PURE__*/react.forwardRef(SvgFood);
/* harmony default export */ var food = (__webpack_require__.p + "static/media/food.1084fae3ca1b3cf79e330f888cace000.svg");

;// CONCATENATED MODULE: ./src/assets/candles.svg
var candles_path;

var candles_excluded = ["title", "titleId"];

function candles_extends() { candles_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return candles_extends.apply(this, arguments); }

function candles_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = candles_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function candles_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgCandles(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = candles_objectWithoutProperties(_ref, candles_excluded);

  return /*#__PURE__*/react.createElement("svg", candles_extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 25,
    height: 24,
    fill: "none",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, candles_path || (candles_path = /*#__PURE__*/react.createElement("path", {
    fill: "#343A40",
    d: "M16.25 6.25c.664 0 1.25-.547 1.25-1.25 0-.664-1.25-2.5-1.25-2.5S15 4.336 15 5c0 .703.547 1.25 1.25 1.25Zm-3.75 0c.664 0 1.25-.547 1.25-1.25 0-.664-1.25-2.5-1.25-2.5S11.25 4.336 11.25 5c0 .703.547 1.25 1.25 1.25Zm7.813 1.25h-.625a.642.642 0 0 0-.625.625v5.625h1.875V8.125c0-.313-.313-.625-.625-.625ZM20 6.25c.664 0 1.25-.547 1.25-1.25 0-.664-1.25-2.5-1.25-2.5S18.75 4.336 18.75 5c0 .703.547 1.25 1.25 1.25Zm3.75 0C24.414 6.25 25 5.703 25 5c0-.664-1.25-2.5-1.25-2.5S22.5 4.336 22.5 5c0 .703.547 1.25 1.25 1.25ZM16.562 7.5h-.625a.642.642 0 0 0-.624.625v5.625h1.874V8.125c0-.313-.312-.625-.625-.625ZM1.25 6.25c.664 0 1.25-.547 1.25-1.25 0-.664-1.25-2.5-1.25-2.5S0 4.336 0 5c0 .703.547 1.25 1.25 1.25ZM5.313 7.5h-.625a.642.642 0 0 0-.625.625v5.625h1.875V8.125c0-.313-.313-.625-.625-.625ZM8.75 6.25C9.414 6.25 10 5.703 10 5c0-.664-1.25-2.5-1.25-2.5S7.5 4.336 7.5 5c0 .703.547 1.25 1.25 1.25ZM24.375 7.5h-.625a.642.642 0 0 0-.625.625v5.313c0 .898-.703 1.562-1.563 1.562h-8.125V8.125c0-.313-.312-.625-.624-.625h-.626a.642.642 0 0 0-.624.625V15H3.437c-.898 0-1.562-.664-1.562-1.563V8.125c0-.313-.313-.625-.625-.625H.625A.642.642 0 0 0 0 8.125v5.313a3.418 3.418 0 0 0 3.438 3.437h8.124v3.75H4.375a.642.642 0 0 0-.625.625v.625c0 .352.273.625.625.625h16.25a.642.642 0 0 0 .625-.625v-.625c0-.313-.313-.625-.625-.625h-7.188v-3.75h8.126A3.443 3.443 0 0 0 25 13.437V8.125c0-.313-.313-.625-.625-.625ZM5 6.25c.664 0 1.25-.547 1.25-1.25C6.25 4.336 5 2.5 5 2.5S3.75 4.336 3.75 5c0 .703.547 1.25 1.25 1.25ZM9.063 7.5h-.626a.642.642 0 0 0-.624.625v5.625h1.875V8.125c0-.313-.313-.625-.626-.625Z"
  })));
}

var candles_ForwardRef = /*#__PURE__*/react.forwardRef(SvgCandles);
/* harmony default export */ var candles = (__webpack_require__.p + "static/media/candles.53c193adf092f5623638f108f45882c2.svg");

;// CONCATENATED MODULE: ./src/util/resource-utils.js
/**
 * Get facilities for a resource.
 *
 * @param {object} resource The resource object to get facilities from.
 * @returns {object} Object of facility objects.
 */function getResourceFacilities(resource){var resourceObj=resource;if(resource.extendedProps){resourceObj=resource.extendedProps;}return objectSpread2_objectSpread2(objectSpread2_objectSpread2(objectSpread2_objectSpread2(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},resourceObj.monitorEquipment&&{monitorequipment:{title:"Projektor / Skærm",icon:/*#__PURE__*/(0,jsx_runtime.jsx)(projector_ForwardRef,{})}}),resourceObj.wheelchairAccessible&&{wheelchairaccessible:{title:"Handicapvenligt",icon:/*#__PURE__*/(0,jsx_runtime.jsx)(wheelchair_ForwardRef,{})}}),resourceObj.videoConferenceEquipment&&{videoconferenceequipment:{title:"Videoconference",icon:/*#__PURE__*/(0,jsx_runtime.jsx)(videocamera_ForwardRef,{})}}),resourceObj.catering&&{catering:{title:"Forplejning",icon:/*#__PURE__*/(0,jsx_runtime.jsx)(food_ForwardRef,{})}}),resourceObj.holidayOpeningHours&&{holidayOpeningHours:{title:"Tilgængelig på helligdag",icon:/*#__PURE__*/(0,jsx_runtime.jsx)(candles_ForwardRef,{})}});}
;// CONCATENATED MODULE: ./src/assets/chair.svg
var chair_path;

var chair_excluded = ["title", "titleId"];

function chair_extends() { chair_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return chair_extends.apply(this, arguments); }

function chair_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = chair_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function chair_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgChair(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = chair_objectWithoutProperties(_ref, chair_excluded);

  return /*#__PURE__*/react.createElement("svg", chair_extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 18,
    height: 24,
    fill: "none",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, chair_path || (chair_path = /*#__PURE__*/react.createElement("path", {
    fill: "#343A40",
    d: "m17.633 15.273-.43-1.25a2.138 2.138 0 0 0-1.953-1.484V7.5c0-2.734-2.266-5-5-5h-2.5c-2.773 0-5 2.266-5 5l-.04 5.04a2.138 2.138 0 0 0-1.952 1.483l-.43 1.25a2.296 2.296 0 0 0 .313 1.954c.234.312.507.546.82.703l.039 3.945c0 .352.273.625.625.625h.625a.642.642 0 0 0 .625-.625v-3.75h11.25v3.75c0 .352.273.625.625.625h.625a.642.642 0 0 0 .625-.625V17.93c.313-.157.586-.39.82-.703.39-.547.508-1.29.313-1.954Zm-5.82-10.43c.898.548 1.562 1.524 1.562 2.657v5h-1.563V4.844Zm-3.75-.468h1.874V12.5H8.063V4.375Zm-1.876.469V12.5H4.625v-5c0-1.133.625-2.11 1.563-2.656ZM2.125 15.859l.43-1.25c.039-.117.156-.234.273-.234h12.305c.117 0 .234.117.273.234l.43 1.25c.078.196-.078.391-.274.391H2.438c-.235 0-.391-.195-.313-.39Z"
  })));
}

var chair_ForwardRef = /*#__PURE__*/react.forwardRef(SvgChair);
/* harmony default export */ var chair = (__webpack_require__.p + "static/media/chair.c85c75b93123f6e4be91aa7992225246.svg");

;// CONCATENATED MODULE: ./src/assets/arrow.svg
var arrow_path;

var arrow_excluded = ["title", "titleId"];

function arrow_extends() { arrow_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return arrow_extends.apply(this, arguments); }

function arrow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = arrow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function arrow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function SvgArrow(_ref, svgRef) {
  var title = _ref.title,
      titleId = _ref.titleId,
      props = arrow_objectWithoutProperties(_ref, arrow_excluded);

  return /*#__PURE__*/react.createElement("svg", arrow_extends({
    width: 14,
    height: 14,
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/react.createElement("title", {
    id: titleId
  }, title) : null, arrow_path || (arrow_path = /*#__PURE__*/react.createElement("path", {
    d: "M12.6151 0C12.4785 0 12.3146 0.0546385 12.1507 0.109277L0.785859 5.35457C-0.525465 5.9556 -0.0883571 7.89526 1.30492 7.89526H6.11311V12.7034C6.11311 13.523 6.79609 13.9875 7.45175 13.9875C7.91618 13.9875 8.40793 13.7689 8.6538 13.2225L13.8991 1.85771C14.2816 0.956174 13.5166 0 12.6151 0ZM13.1068 1.50256L7.86154 12.84C7.77958 13.0313 7.64299 13.1406 7.45175 13.1406C7.28784 13.1406 6.98733 13.0313 6.98733 12.7034V7.02105H1.30492C1.00441 7.02105 0.922455 6.77517 0.895136 6.6659C0.867816 6.5293 0.867816 6.28343 1.16833 6.14683L12.4785 0.928854C12.5331 0.901535 12.5878 0.874216 12.6151 0.874216C12.779 0.874216 12.9429 0.983493 13.0522 1.14741C13.1068 1.22937 13.1615 1.36596 13.1068 1.50256Z",
    fill: "black"
  })));
}

var arrow_ForwardRef = /*#__PURE__*/react.forwardRef(SvgArrow);
/* harmony default export */ var arrow = (__webpack_require__.p + "static/media/arrow.f7e0fdd4369b638e44bd5e8a1b63a1d9.svg");

;// CONCATENATED MODULE: ./src/components/list.js
/**
 * @param {object} props Props.
 * @param {object} props.resources Resources object
 * @param {Function} props.setShowResourceDetails Setter for showResourceDetails resource object
 * @returns {JSX.Element} List of resources
 */function List(_ref){var resources=_ref.resources,setShowResourceDetails=_ref.setShowResourceDetails;var showResourceView=function showResourceView(event){var key=event.target.getAttribute("data-key");if(resources[key]){setShowResourceDetails(resources[key].resourceMail);}};/**
   * Get facilities list.
   *
   * @param {object} resource Resource object
   * @returns {string} Facilities list.
   */var getFacilitiesList=function getFacilitiesList(resource){var facilities=getResourceFacilities(resource);return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"facility-container",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"facility-item",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"facility-icon",children:[/*#__PURE__*/(0,jsx_runtime.jsx)(chair_ForwardRef,{})," ",resource.capacity]})}),Object.values(facilities).map(function(value){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"facility-item",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"facility-icon",children:value.icon})},value.title);})]});};return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:Object.keys(resources).map(function(key){var _resources$key$resour,_resources$key$locati;var sanitizedDescription=resources[key].resourceDescription?node_modules_html_react_parser(purify_default().sanitize(resources[key].resourceDescription,{})):"";return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"list-resource",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"image-wrapper",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"image",children:/*#__PURE__*/(0,jsx_runtime.jsx)("img",{alt:resources[key].resourceDisplayName,src:resources[key].resourceImage})})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"list-resource-details col-md-10",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"headline",children:/*#__PURE__*/(0,jsx_runtime.jsx)("b",{children:(_resources$key$resour=resources[key].resourceDisplayName)!==null&&_resources$key$resour!==void 0?_resources$key$resour:resources[key].resourceName})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"details",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{className:"location",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"location-icon",children:/*#__PURE__*/(0,jsx_runtime.jsx)(arrow_ForwardRef,{})}),(_resources$key$locati=resources[key].locationDisplayName)!==null&&_resources$key$locati!==void 0?_resources$key$locati:resources[key].location,", ",resources[key].streetName," ",resources[key].postalCode," ",resources[key].city]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"facilities",children:getFacilitiesList(resources[key])})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"description",children:sanitizedDescription})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"list-resource-actions col-md-2",children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",className:"booking-btn","data-key":key,onClick:showResourceView,children:"Vis resource"})})]},key);})});}/* harmony default export */ var components_list = (List);
;// CONCATENATED MODULE: ./src/components/list-container.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var list_container = ({});
;// CONCATENATED MODULE: ./src/components/list-container.js
/**
 * @param {object} props Props.
 * @param {object} props.resources Resources object
 * @param {object} props.setShowResourceDetails Resource object to show details for
 * @param {boolean} props.userHasInteracted Has the user interacted with filters
 * @param {boolean} props.isLoading Loading state.
 * @param {boolean} props.setIsLoading Set loading state.
 * @returns {JSX.Element} List element containing resources
 */function ListContainer(_ref){var resources=_ref.resources,setShowResourceDetails=_ref.setShowResourceDetails,userHasInteracted=_ref.userHasInteracted,isLoading=_ref.isLoading,setIsLoading=_ref.setIsLoading;(0,react.useEffect)(function(){setIsLoading(false);},[resources]);return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"List no-gutter col-md-12 ".concat(isLoading===true?"list-loading":""),children:[isLoading&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{}),(!resources||resources&&resources.length===0)&&!userHasInteracted&&/*#__PURE__*/(0,jsx_runtime.jsx)(no_result_overlay,{state:"initial"}),(!resources||resources&&resources.length===0)&&userHasInteracted&&/*#__PURE__*/(0,jsx_runtime.jsx)(no_result_overlay,{state:"noresult"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-12",children:resources&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_list,{resources:resources,setShowResourceDetails:setShowResourceDetails})})})]});}ListContainer.defaultProps={resources:{},userHasInteracted:false};/* harmony default export */ var components_list_container = (ListContainer);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function assertThisInitialized_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function getPrototypeOf_getPrototypeOf(o) {
  getPrototypeOf_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return getPrototypeOf_getPrototypeOf(o);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/superPropBase.js

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf_getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/get.js

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function isNativeReflectConstruct_isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function possibleConstructorReturn_possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized_assertThisInitialized(self);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js



function createSuper_createSuper(Derived) {
  var hasNativeReflectConstruct = isNativeReflectConstruct_isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = getPrototypeOf_getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf_getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return possibleConstructorReturn_possibleConstructorReturn(this, result);
  };
}
;// CONCATENATED MODULE: ./node_modules/ol/events/Event.js



/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var BaseEvent = /*#__PURE__*/function () {
  /**
   * @param {string} type Type.
   */
  function BaseEvent(type) {
    _classCallCheck(this, BaseEvent);

    /**
     * @type {boolean}
     */
    this.propagationStopped;
    /**
     * @type {boolean}
     */

    this.defaultPrevented;
    /**
     * The event type.
     * @type {string}
     * @api
     */

    this.type = type;
    /**
     * The event target.
     * @type {Object}
     * @api
     */

    this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */


  _createClass(BaseEvent, [{
    key: "preventDefault",
    value: function preventDefault() {
      this.defaultPrevented = true;
    }
    /**
     * Stop event propagation.
     * @api
     */

  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
  }]);

  return BaseEvent;
}();
/**
 * @param {Event|import("./Event.js").default} evt Event
 */


function stopPropagation(evt) {
  evt.stopPropagation();
}
/**
 * @param {Event|import("./Event.js").default} evt Event
 */

function Event_preventDefault(evt) {
  evt.preventDefault();
}
/* harmony default export */ var events_Event = (BaseEvent);
;// CONCATENATED MODULE: ./node_modules/ol/ObjectEventType.js
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ var ObjectEventType = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
});
/**
 * @typedef {'propertychange'} Types
 */
;// CONCATENATED MODULE: ./node_modules/ol/Disposable.js



/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable = /*#__PURE__*/function () {
  function Disposable() {
    _classCallCheck(this, Disposable);

    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    this.disposed = false;
  }
  /**
   * Clean up.
   */


  _createClass(Disposable, [{
    key: "dispose",
    value: function dispose() {
      if (!this.disposed) {
        this.disposed = true;
        this.disposeInternal();
      }
    }
    /**
     * Extension point for disposable objects.
     * @protected
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {}
  }]);

  return Disposable;
}();

/* harmony default export */ var ol_Disposable = (Disposable);
;// CONCATENATED MODULE: ./node_modules/ol/array.js
/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function array_binarySearch(haystack, needle, comparator) {
  var mid, cmp;
  comparator = comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }
  /* Key not found. */


  return found ? low : ~low;
}
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */

function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */

/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */

function linearFindNearest(arr, target, direction) {
  var n = arr.length;

  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;

    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (typeof direction === 'function') {
            if (direction(target, arr[i - 1], arr[i]) > 0) {
              return i - 1;
            } else {
              return i;
            }
          } else if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }

    return n - 1;
  }
}
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */

function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */

function array_extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;

  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */

function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;

  if (found) {
    arr.splice(i, 1);
  }

  return found;
}
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */

function equals(arr1, arr2) {
  var len1 = arr1.length;

  if (len1 !== arr2.length) {
    return false;
  }

  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */

function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;

  for (i = 0; i < length; i++) {
    tmp[i] = {
      index: i,
      value: arr[i]
    };
  }

  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });

  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */

function isSorted(arr, func, strict) {
  var compare = func || numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }

    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
;// CONCATENATED MODULE: ./node_modules/ol/functions.js
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @return {boolean} true.
 */

function TRUE() {
  return true;
}
/**
 * Always returns false.
 * @return {boolean} false.
 */

function functions_FALSE() {
  return false;
}
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */

function VOID() {}
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */

function functions_memoizeOne(fn) {
  var called = false;
  /** @type {ReturnType} */

  var lastResult;
  /** @type {Array<any>} */

  var lastArgs;
  var lastThis;
  return function () {
    var nextArgs = Array.prototype.slice.call(arguments);

    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }

    return lastResult;
  };
}
/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */

function toPromise(getter) {
  function promiseGetter() {
    var value;

    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }

    if (value instanceof Promise) {
      return value;
    }

    return Promise.resolve(value);
  }

  return promiseGetter();
}
;// CONCATENATED MODULE: ./node_modules/ol/obj.js
/**
 * @module ol/obj
 */

/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function obj_clear(object) {
  for (var property in object) {
    delete object[property];
  }
}
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */

function obj_isEmpty(object) {
  var property;

  for (property in object) {
    return false;
  }

  return !property;
}
;// CONCATENATED MODULE: ./node_modules/ol/events/Target.js





/**
 * @module ol/events/Target
 */




/**
 * @typedef {EventTarget|Target} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */

var Target = /*#__PURE__*/function (_Disposable) {
  _inherits(Target, _Disposable);

  var _super = createSuper_createSuper(Target);

  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  function Target(target) {
    var _this;

    _classCallCheck(this, Target);

    _this = _super.call(this);
    /**
     * @private
     * @type {*}
     */

    _this.eventTarget_ = target;
    /**
     * @private
     * @type {Object<string, number>}
     */

    _this.pendingRemovals_ = null;
    /**
     * @private
     * @type {Object<string, number>}
     */

    _this.dispatching_ = null;
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>}
     */

    _this.listeners_ = null;
    return _this;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */


  _createClass(Target, [{
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      if (!type || !listener) {
        return;
      }

      var listeners = this.listeners_ || (this.listeners_ = {});
      var listenersForType = listeners[type] || (listeners[type] = []);

      if (!listenersForType.includes(listener)) {
        listenersForType.push(listener);
      }
    }
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */

  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      var isString = typeof event === 'string';
      var type = isString ? event : event.type;
      var listeners = this.listeners_ && this.listeners_[type];

      if (!listeners) {
        return;
      }

      var evt = isString ? new events_Event(event) :
      /** @type {Event} */
      event;

      if (!evt.target) {
        evt.target = this.eventTarget_ || this;
      }

      var dispatching = this.dispatching_ || (this.dispatching_ = {});
      var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});

      if (!(type in dispatching)) {
        dispatching[type] = 0;
        pendingRemovals[type] = 0;
      }

      ++dispatching[type];
      var propagate;

      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if ('handleEvent' in listeners[i]) {
          propagate =
          /** @type {import("../events.js").ListenerObject} */
          listeners[i].handleEvent(evt);
        } else {
          propagate =
          /** @type {import("../events.js").ListenerFunction} */
          listeners[i].call(this, evt);
        }

        if (propagate === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }

      if (--dispatching[type] === 0) {
        var pr = pendingRemovals[type];
        delete pendingRemovals[type];

        while (pr--) {
          this.removeEventListener(type, VOID);
        }

        delete dispatching[type];
      }

      return propagate;
    }
    /**
     * Clean up.
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.listeners_ && obj_clear(this.listeners_);
    }
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */

  }, {
    key: "getListeners",
    value: function getListeners(type) {
      return this.listeners_ && this.listeners_[type] || undefined;
    }
    /**
     * @param {string} [type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */

  }, {
    key: "hasListener",
    value: function hasListener(type) {
      if (!this.listeners_) {
        return false;
      }

      return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */

  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      var listeners = this.listeners_ && this.listeners_[type];

      if (listeners) {
        var index = listeners.indexOf(listener);

        if (index !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            // make listener a no-op, and remove later in #dispatchEvent()
            listeners[index] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);

            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    }
  }]);

  return Target;
}(ol_Disposable);

/* harmony default export */ var events_Target = (Target);
;// CONCATENATED MODULE: ./node_modules/ol/events/EventType.js
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ var EventType = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',

  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',
  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel'
});
;// CONCATENATED MODULE: ./node_modules/ol/events.js
/**
 * @module ol/events
 */

/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */

function listen(target, type, _listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    _listener = _listener.bind(thisArg);
  }

  if (once) {
    var originalListener = _listener;

    _listener = function listener() {
      target.removeEventListener(type, _listener);
      originalListener.apply(this, arguments);
    };
  }

  var eventsKey = {
    target: target,
    type: type,
    listener: _listener
  };
  target.addEventListener(type, _listener);
  return eventsKey;
}
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */

function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */

function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    obj_clear(key);
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/Observable.js





/**
 * @module ol/Observable
 */



/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */

/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */

/**
 * @typedef {'change'|'error'} EventTypes
 */

/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */

var Observable = /*#__PURE__*/function (_EventTarget) {
  _inherits(Observable, _EventTarget);

  var _super = createSuper_createSuper(Observable);

  function Observable() {
    var _this;

    _classCallCheck(this, Observable);

    _this = _super.call(this);
    _this.on =
    /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    _this.onInternal;
    _this.once =
    /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    _this.onceInternal;
    _this.un =
    /** @type {ObservableOnSignature<void>} */
    _this.unInternal;
    /**
     * @private
     * @type {number}
     */

    _this.revision_ = 0;
    return _this;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */


  _createClass(Observable, [{
    key: "changed",
    value: function changed() {
      ++this.revision_;
      this.dispatchEvent(EventType.CHANGE);
    }
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */

  }, {
    key: "getRevision",
    value: function getRevision() {
      return this.revision_;
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */

  }, {
    key: "onInternal",
    value: function onInternal(type, listener) {
      if (Array.isArray(type)) {
        var len = type.length;
        var keys = new Array(len);

        for (var i = 0; i < len; ++i) {
          keys[i] = listen(this, type[i], listener);
        }

        return keys;
      } else {
        return listen(this,
        /** @type {string} */
        type, listener);
      }
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */

  }, {
    key: "onceInternal",
    value: function onceInternal(type, listener) {
      var key;

      if (Array.isArray(type)) {
        var len = type.length;
        key = new Array(len);

        for (var i = 0; i < len; ++i) {
          key[i] = listenOnce(this, type[i], listener);
        }
      } else {
        key = listenOnce(this,
        /** @type {string} */
        type, listener);
      }
      /** @type {Object} */


      listener.ol_key = key;
      return key;
    }
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */

  }, {
    key: "unInternal",
    value: function unInternal(type, listener) {
      var key =
      /** @type {Object} */
      listener.ol_key;

      if (key) {
        unByKey(key);
      } else if (Array.isArray(type)) {
        for (var i = 0, ii = type.length; i < ii; ++i) {
          this.removeEventListener(type[i], listener);
        }
      } else {
        this.removeEventListener(type, listener);
      }
    }
  }]);

  return Observable;
}(events_Target);
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */


Observable.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */

Observable.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */

Observable.prototype.un;
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */

function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
    /** @type {import("./events.js").EventsKey} */
    key);
  }
}
/* harmony default export */ var ol_Observable = (Observable);
;// CONCATENATED MODULE: ./node_modules/ol/util.js
/**
 * @module ol/util
 */

/**
 * @return {never} Any return.
 */
function util_abstract() {
  throw new Error('Unimplemented abstract method.');
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */

var uidCounter_ = 0;
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */

function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
/**
 * OpenLayers version.
 * @type {string}
 */

var VERSION = '7.1.0';
;// CONCATENATED MODULE: ./node_modules/ol/Object.js






/**
 * @module ol/Object
 */





/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */

var ObjectEvent = /*#__PURE__*/function (_Event) {
  _inherits(ObjectEvent, _Event);

  var _super = createSuper_createSuper(ObjectEvent);

  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  function ObjectEvent(type, key, oldValue) {
    var _this;

    _classCallCheck(this, ObjectEvent);

    _this = _super.call(this, type);
    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */

    _this.key = key;
    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */

    _this.oldValue = oldValue;
    return _this;
  }

  return _createClass(ObjectEvent);
}(events_Event);
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */

var BaseObject = /*#__PURE__*/function (_Observable) {
  _inherits(BaseObject, _Observable);

  var _super2 = createSuper_createSuper(BaseObject);

  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  function BaseObject(values) {
    var _this2;

    _classCallCheck(this, BaseObject);

    _this2 = _super2.call(this);
    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */

    _this2.on;
    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */

    _this2.once;
    /***
     * @type {ObjectOnSignature<void>}
     */

    _this2.un; // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.

    getUid(assertThisInitialized_assertThisInitialized(_this2));
    /**
     * @private
     * @type {Object<string, *>}
     */

    _this2.values_ = null;

    if (values !== undefined) {
      _this2.setProperties(values);
    }

    return _this2;
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */


  _createClass(BaseObject, [{
    key: "get",
    value: function get(key) {
      var value;

      if (this.values_ && this.values_.hasOwnProperty(key)) {
        value = this.values_[key];
      }

      return value;
    }
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */

  }, {
    key: "getKeys",
    value: function getKeys() {
      return this.values_ && Object.keys(this.values_) || [];
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */

  }, {
    key: "getProperties",
    value: function getProperties() {
      return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
     * @return {boolean} The object has properties.
     */

  }, {
    key: "hasProperties",
    value: function hasProperties() {
      return !!this.values_;
    }
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */

  }, {
    key: "notify",
    value: function notify(key, oldValue) {
      var eventType;
      eventType = "change:".concat(key);

      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }

      eventType = ObjectEventType.PROPERTYCHANGE;

      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */

  }, {
    key: "addChangeListener",
    value: function addChangeListener(key, listener) {
      this.addEventListener("change:".concat(key), listener);
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */

  }, {
    key: "removeChangeListener",
    value: function removeChangeListener(key, listener) {
      this.removeEventListener("change:".concat(key), listener);
    }
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */

  }, {
    key: "set",
    value: function set(key, value, silent) {
      var values = this.values_ || (this.values_ = {});

      if (silent) {
        values[key] = value;
      } else {
        var oldValue = values[key];
        values[key] = value;

        if (oldValue !== value) {
          this.notify(key, oldValue);
        }
      }
    }
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */

  }, {
    key: "setProperties",
    value: function setProperties(values, silent) {
      for (var key in values) {
        this.set(key, values[key], silent);
      }
    }
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */

  }, {
    key: "applyProperties",
    value: function applyProperties(source) {
      if (!source.values_) {
        return;
      }

      Object.assign(this.values_ || (this.values_ = {}), source.values_);
    }
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [silent] Unset without triggering an event.
     * @api
     */

  }, {
    key: "unset",
    value: function unset(key, silent) {
      if (this.values_ && key in this.values_) {
        var oldValue = this.values_[key];
        delete this.values_[key];

        if (obj_isEmpty(this.values_)) {
          this.values_ = null;
        }

        if (!silent) {
          this.notify(key, oldValue);
        }
      }
    }
  }]);

  return BaseObject;
}(ol_Observable);

/* harmony default export */ var ol_Object = (BaseObject);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/construct.js


function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js




function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, getPrototypeOf_getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}
;// CONCATENATED MODULE: ./node_modules/ol/AssertionError.js






/**
 * @module ol/AssertionError
 */

/** @type {Object<number, string>} */
var messages = {
  1: 'The view center is not defined',
  2: 'The view resolution is not defined',
  3: 'The view rotation is not defined',
  4: '`image` and `src` cannot be provided at the same time',
  5: '`imgSize` must be set when `image` is provided',
  7: '`format` must be set when `url` is set',
  8: 'Unknown `serverType` configured',
  9: '`url` must be configured or set using `#setUrl()`',
  10: 'The default `geometryFunction` can only handle `Point` geometries',
  11: '`options.featureTypes` must be an Array',
  12: '`options.geometryName` must also be provided when `options.bbox` is set',
  13: 'Invalid corner',
  14: 'Invalid color',
  15: 'Tried to get a value for a key that does not exist in the cache',
  16: 'Tried to set a value for a key that is used already',
  17: '`resolutions` must be sorted in descending order',
  18: 'Either `origin` or `origins` must be configured, never both',
  19: 'Number of `tileSizes` and `resolutions` must be equal',
  20: 'Number of `origins` and `resolutions` must be equal',
  22: 'Either `tileSize` or `tileSizes` must be configured, never both',
  24: 'Invalid extent or geometry provided as `geometry`',
  25: 'Cannot fit empty extent provided as `geometry`',
  26: 'Features must have an id set',
  27: 'Features must have an id set',
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: 'The passed `feature` was already added to the source',
  31: 'Tried to enqueue an `element` that was already added to the queue',
  32: 'Transformation matrix cannot be inverted',
  33: 'Invalid units',
  34: 'Invalid geometry layout',
  36: 'Unknown SRS type',
  37: 'Unknown geometry type found',
  38: '`styleMapValue` has an unknown type',
  39: 'Unknown geometry type',
  40: 'Expected `feature` to have a geometry',
  41: 'Expected an `ol/style/Style` or an array of `ol/style/Style.js`',
  42: 'Question unknown, the answer is 42',
  43: 'Expected `layers` to be an array or a `Collection`',
  47: 'Expected `controls` to be an array or an `ol/Collection`',
  48: 'Expected `interactions` to be an array or an `ol/Collection`',
  49: 'Expected `overlays` to be an array or an `ol/Collection`',
  50: '`options.featureTypes` should be an Array',
  51: 'Either `url` or `tileJSON` options must be provided',
  52: 'Unknown `serverType` configured',
  53: 'Unknown `tierSizeCalculation` configured',
  55: 'The {-y} placeholder requires a tile grid with extent',
  56: 'mapBrowserEvent must originate from a pointer event',
  57: 'At least 2 conditions are required',
  59: 'Invalid command found in the PBF',
  60: 'Missing or invalid `size`',
  61: 'Cannot determine IIIF Image API version from provided image information JSON',
  62: 'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`',
  64: 'Layer opacity must be a number',
  66: '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`',
  67: 'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both',
  68: 'A VectorTile source can only be rendered if it has a projection compatible with the view projection'
};
/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */

var AssertionError = /*#__PURE__*/function (_Error) {
  _inherits(AssertionError, _Error);

  var _super = createSuper_createSuper(AssertionError);

  /**
   * @param {number} code Error code.
   */
  function AssertionError(code) {
    var _this;

    _classCallCheck(this, AssertionError);

    var message = messages[code];
    _this = _super.call(this, message);
    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @deprecated ol/AssertionError and error codes will be removed in v8.0
     * @api
     */

    _this.code = code;
    /**
     * @type {string}
     */

    _this.name = 'AssertionError'; // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40

    _this.message = message;
    return _this;
  }

  return _createClass(AssertionError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

/* harmony default export */ var ol_AssertionError = (AssertionError);
;// CONCATENATED MODULE: ./node_modules/ol/CollectionEventType.js
/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ var CollectionEventType = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',

  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
});
;// CONCATENATED MODULE: ./node_modules/ol/Collection.js





/**
 * @module ol/Collection
 */




/**
 * @enum {string}
 * @private
 */

var Property = {
  LENGTH: 'length'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */

var CollectionEvent = /*#__PURE__*/function (_Event) {
  _inherits(CollectionEvent, _Event);

  var _super = createSuper_createSuper(CollectionEvent);

  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  function CollectionEvent(type, element, index) {
    var _this;

    _classCallCheck(this, CollectionEvent);

    _this = _super.call(this, type);
    /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */

    _this.element = element;
    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */

    _this.index = index;
    return _this;
  }

  return _createClass(CollectionEvent);
}(events_Event);
/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */

var Collection = /*#__PURE__*/function (_BaseObject) {
  _inherits(Collection, _BaseObject);

  var _super2 = createSuper_createSuper(Collection);

  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  function Collection(array, options) {
    var _this2;

    _classCallCheck(this, Collection);

    _this2 = _super2.call(this);
    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */

    _this2.on;
    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */

    _this2.once;
    /***
     * @type {CollectionOnSignature<T, void>}
     */

    _this2.un;
    options = options || {};
    /**
     * @private
     * @type {boolean}
     */

    _this2.unique_ = !!options.unique;
    /**
     * @private
     * @type {!Array<T>}
     */

    _this2.array_ = array ? array : [];

    if (_this2.unique_) {
      for (var i = 0, ii = _this2.array_.length; i < ii; ++i) {
        _this2.assertUnique_(_this2.array_[i], i);
      }
    }

    _this2.updateLength_();

    return _this2;
  }
  /**
   * Remove all elements from the collection.
   * @api
   */


  _createClass(Collection, [{
    key: "clear",
    value: function clear() {
      while (this.getLength() > 0) {
        this.pop();
      }
    }
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */

  }, {
    key: "extend",
    value: function extend(arr) {
      for (var i = 0, ii = arr.length; i < ii; ++i) {
        this.push(arr[i]);
      }

      return this;
    }
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */

  }, {
    key: "forEach",
    value: function forEach(f) {
      var array = this.array_;

      for (var i = 0, ii = array.length; i < ii; ++i) {
        f(array[i], i, array);
      }
    }
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */

  }, {
    key: "getArray",
    value: function getArray() {
      return this.array_;
    }
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */

  }, {
    key: "item",
    value: function item(index) {
      return this.array_[index];
    }
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */

  }, {
    key: "getLength",
    value: function getLength() {
      return this.get(Property.LENGTH);
    }
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */

  }, {
    key: "insertAt",
    value: function insertAt(index, elem) {
      if (index < 0 || index > this.getLength()) {
        throw new Error('Index out of bounds: ' + index);
      }

      if (this.unique_) {
        this.assertUnique_(elem);
      }

      this.array_.splice(index, 0, elem);
      this.updateLength_();
      this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
    }
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */

  }, {
    key: "pop",
    value: function pop() {
      return this.removeAt(this.getLength() - 1);
    }
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */

  }, {
    key: "push",
    value: function push(elem) {
      if (this.unique_) {
        this.assertUnique_(elem);
      }

      var n = this.getLength();
      this.insertAt(n, elem);
      return this.getLength();
    }
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */

  }, {
    key: "remove",
    value: function remove(elem) {
      var arr = this.array_;

      for (var i = 0, ii = arr.length; i < ii; ++i) {
        if (arr[i] === elem) {
          return this.removeAt(i);
        }
      }

      return undefined;
    }
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */

  }, {
    key: "removeAt",
    value: function removeAt(index) {
      if (index < 0 || index >= this.getLength()) {
        return undefined;
      }

      var prev = this.array_[index];
      this.array_.splice(index, 1);
      this.updateLength_();
      this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType.REMOVE, prev, index));
      return prev;
    }
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */

  }, {
    key: "setAt",
    value: function setAt(index, elem) {
      var n = this.getLength();

      if (index >= n) {
        this.insertAt(index, elem);
        return;
      }

      if (index < 0) {
        throw new Error('Index out of bounds: ' + index);
      }

      if (this.unique_) {
        this.assertUnique_(elem, index);
      }

      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType.REMOVE, prev, index));
      this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType.ADD, elem, index));
    }
    /**
     * @private
     */

  }, {
    key: "updateLength_",
    value: function updateLength_() {
      this.set(Property.LENGTH, this.array_.length);
    }
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [except] Optional index to ignore.
     */

  }, {
    key: "assertUnique_",
    value: function assertUnique_(elem, except) {
      for (var i = 0, ii = this.array_.length; i < ii; ++i) {
        if (this.array_[i] === elem && i !== except) {
          throw new ol_AssertionError(58);
        }
      }
    }
  }]);

  return Collection;
}(ol_Object);

/* harmony default export */ var ol_Collection = (Collection);
;// CONCATENATED MODULE: ./node_modules/ol/has.js
/**
 * @module ol/has
 */
var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */

var FIREFOX = ua.includes('firefox');
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */

var SAFARI = ua.includes('safari') && !ua.includes('chrom');
/**
 * https://bugs.webkit.org/show_bug.cgi?id=237906
 * @type {boolean}
 */

var SAFARI_BUG_237906 = SAFARI && (ua.includes('version/15.4') || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */

var has_WEBKIT = ua.includes('webkit') && !ua.includes('edge');
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */

var has_MAC = ua.includes('macintosh');
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */

var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */

var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */

var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
/**
 * @type {boolean}
 */

var PASSIVE_EVENT_LISTENERS = function () {
  var passive = false;

  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        passive = true;
      }
    });
    window.addEventListener('_', null, options);
    window.removeEventListener('_', null, options);
  } catch (error) {// passive not supported
  }

  return passive;
}();
;// CONCATENATED MODULE: ./node_modules/ol/asserts.js
/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */

function asserts_assert(assertion, errorCode) {
  if (!assertion) {
    throw new ol_AssertionError(errorCode);
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/transform.js
/**
 * @module ol/transform
 */


/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */

var tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */

function create() {
  return [1, 0, 0, 1, 0, 0];
}
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */

function transform_reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */

function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */

function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */

function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */

function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */

function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */

function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */

function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */

function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */

function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */

function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return transform_toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */

function invert(source) {
  return makeInverse(source, source);
}
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */

function makeInverse(target, source) {
  var det = determinant(source);
  asserts_assert(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = source[0];
  var b = source[1];
  var c = source[2];
  var d = source[3];
  var e = source[4];
  var f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */

function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */

var transformStringDiv;
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */

function transform_toString(mat) {
  var transformString = 'matrix(' + mat.join(', ') + ')';

  if (WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }

  var node = transformStringDiv || (transformStringDiv = document.createElement('div'));
  node.style.transform = transformString;
  return node.style.transform;
}
;// CONCATENATED MODULE: ./node_modules/ol/extent/Relationship.js
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ var Relationship = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
});
;// CONCATENATED MODULE: ./node_modules/ol/extent.js


/**
 * @module ol/extent
 */


/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */

function boundingExtent(coordinates) {
  var extent = createEmpty();

  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */

function _boundingExtentXYs(xs, ys, dest) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */


function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
}
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */

function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  } else {
    return extent.slice();
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */

function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;

  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }

  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }

  return dx * dx + dy * dy;
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */

function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */

function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */

function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */

function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = Relationship.UNKNOWN;

  if (x < minX) {
    relationship = relationship | Relationship.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship.RIGHT;
  }

  if (y < minY) {
    relationship = relationship | Relationship.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship.ABOVE;
  }

  if (relationship === Relationship.UNKNOWN) {
    relationship = Relationship.INTERSECTING;
  }

  return relationship;
}
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */

function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */

function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  } else {
    return [minX, minY, maxX, maxY];
  }
}
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromCoordinate(coordinate, dest) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromCoordinates(coordinates, dest) {
  var extent = createOrUpdateEmpty(dest);
  return extendCoordinates(extent, coordinates);
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  var extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromRings(rings, dest) {
  var extent = createOrUpdateEmpty(dest);
  return extendRings(extent, rings);
}
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */

function extent_equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */

function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */

function extent_extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }

  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }

  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }

  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }

  return extent1;
}
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */

function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }

  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }

  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }

  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */

function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */

function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */

function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */

function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */

function forEachCorner(extent, callback) {
  var val;
  val = callback(getBottomLeft(extent));

  if (val) {
    return val;
  }

  val = callback(getBottomRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopLeft(extent));

  if (val) {
    return val;
  }

  return false;
}
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */

function getArea(extent) {
  var area = 0;

  if (!extent_isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }

  return area;
}
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */

function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */

function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */

function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */

function getCorner(extent, corner) {
  var coordinate;

  if (corner === 'bottom-left') {
    coordinate = getBottomLeft(extent);
  } else if (corner === 'bottom-right') {
    coordinate = getBottomRight(extent);
  } else if (corner === 'top-left') {
    coordinate = getTopLeft(extent);
  } else if (corner === 'top-right') {
    coordinate = getTopRight(extent);
  } else {
    asserts_assert(false, 13); // Invalid corner
  }

  return coordinate;
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */

function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */

function getForViewAndSize(center, resolution, rotation, size, dest) {
  var _getRotatedViewport = getRotatedViewport(center, resolution, rotation, size),
      _getRotatedViewport2 = slicedToArray_slicedToArray(_getRotatedViewport, 8),
      x0 = _getRotatedViewport2[0],
      y0 = _getRotatedViewport2[1],
      x1 = _getRotatedViewport2[2],
      y1 = _getRotatedViewport2[3],
      x2 = _getRotatedViewport2[4],
      y2 = _getRotatedViewport2[5],
      x3 = _getRotatedViewport2[6],
      y3 = _getRotatedViewport2[7];

  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
}
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */

function getRotatedViewport(center, resolution, rotation, size) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  return [x - xCos + ySin, y - xSin - yCos, x - xCos - ySin, y - xSin + yCos, x + xCos - ySin, y + xSin + yCos, x + xCos + ySin, y + xSin - yCos, x - xCos + ySin, y - xSin - yCos];
}
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */

function getHeight(extent) {
  return extent[3] - extent[1];
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */

function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */

function getIntersection(extent1, extent2, dest) {
  var intersection = dest ? dest : createEmpty();

  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }

    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }

    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }

    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }

  return intersection;
}
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */

function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */

function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */

function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */

function getTopRight(extent) {
  return [extent[2], extent[3]];
}
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */

function getWidth(extent) {
  return extent[2] - extent[0];
}
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */

function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */

function extent_isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */

function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  } else {
    return extent;
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */

function scaleFromCenter(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */

function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);

  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;

    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }

    if (!intersects && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }

  return intersects;
}
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */

function applyTransform(extent, transformFn, dest, stops) {
  var coordinates = [];

  if (stops > 1) {
    var width = extent[2] - extent[0];
    var height = extent[3] - extent[1];

    for (var i = 0; i < stops; ++i) {
      coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);
    }
  } else {
    coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];
  }

  transformFn(coordinates, coordinates, 2);
  var xs = [];
  var ys = [];

  for (var _i = 0, l = coordinates.length; _i < l; _i += 2) {
    xs.push(coordinates[_i]);
    ys.push(coordinates[_i + 1]);
  }

  return _boundingExtentXYs(xs, ys, dest);
}
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */

function wrapX(extent, projection) {
  var projectionExtent = projection.getExtent();
  var center = getCenter(extent);

  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    var offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }

  return extent;
}
/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Array<Extent>} The extent within the real world extent.
 */

function wrapAndSliceX(extent, projection) {
  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();

    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }

    wrapX(extent, projection);
    var worldWidth = getWidth(projectionExtent);

    if (getWidth(extent) > worldWidth) {
      // the extent wraps around on itself
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    } else if (extent[0] < projectionExtent[0]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [[extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2], extent[3]]];
    } else if (extent[2] > projectionExtent[2]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [[extent[0], extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]];
    }
  }

  return [extent];
}
;// CONCATENATED MODULE: ./node_modules/ol/math.js
/**
 * @module ol/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function math_clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */

function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;

  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return math_squaredDistance(x, y, x1, y1);
}
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */

function math_squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */

function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);

    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);

      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    } // Swap max row with i-th (current) row


    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column

    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];

      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  } // Solve Ax=b for upper triangular matrix A (mat)


  var x = new Array(n);

  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];

    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }

  return x;
}
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */

function math_toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */

function math_toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */

function math_modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */

function lerp(a, b, x) {
  return a + x * (b - a);
}
/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */

function math_toFixed(n, decimals) {
  var factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */

function round(n, decimals) {
  return Math.round(math_toFixed(n, decimals));
}
/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */

function floor(n, decimals) {
  return Math.floor(math_toFixed(n, decimals));
}
/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */

function ceil(n, decimals) {
  return Math.ceil(math_toFixed(n, decimals));
}
;// CONCATENATED MODULE: ./node_modules/ol/color.js
/**
 * @module ol/color
 */


/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */

/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */

var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */

var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */

function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return color_toString(color);
  }
}
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */

function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;

  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}
/**
 * @param {string} s String.
 * @return {Color} Color.
 */


var fromString = function () {
  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;
  /**
   * @type {Object<string, Color>}
   */

  var cache = {};
  /**
   * @type {number}
   */

  var cacheSize = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function (s) {
      var color;

      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;

          for (var key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }

        color = fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }

      return color;
    }
  );
}();
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */

function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}
/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */

function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits

    var d; // number of digits per channel

    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }

    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);

    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }

    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;

      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }

    color = [r, g, b, a / 255];
  } else if (s.startsWith('rgba(')) {
    // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.startsWith('rgb(')) {
    // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    asserts_assert(false, 14); // Invalid color
  }

  return color;
}
/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */


function normalize(color) {
  color[0] = math_clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = math_clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = math_clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = math_clamp(color[3], 0, 1);
  return color;
}
/**
 * @param {Color} color Color.
 * @return {string} String.
 */

function color_toString(color) {
  var r = color[0];

  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }

  var g = color[1];

  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }

  var b = color[2];

  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }

  var a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */

function isStringColor(s) {
  if (NAMED_COLOR_RE_.test(s)) {
    s = fromNamed(s);
  }

  return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');
}
;// CONCATENATED MODULE: ./node_modules/ol/style/IconImageCache.js



/**
 * @module ol/style/IconImageCache
 */

/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */

var IconImageCache = /*#__PURE__*/function () {
  function IconImageCache() {
    _classCallCheck(this, IconImageCache);

    /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */
    this.cache_ = {};
    /**
     * @type {number}
     * @private
     */

    this.cacheSize_ = 0;
    /**
     * @type {number}
     * @private
     */

    this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */


  _createClass(IconImageCache, [{
    key: "clear",
    value: function clear() {
      this.cache_ = {};
      this.cacheSize_ = 0;
    }
    /**
     * @return {boolean} Can expire cache.
     */

  }, {
    key: "canExpireCache",
    value: function canExpireCache() {
      return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
     * FIXME empty description for jsdoc
     */

  }, {
    key: "expire",
    value: function expire() {
      if (this.canExpireCache()) {
        var i = 0;

        for (var key in this.cache_) {
          var iconImage = this.cache_[key];

          if ((i++ & 3) === 0 && !iconImage.hasListener()) {
            delete this.cache_[key];
            --this.cacheSize_;
          }
        }
      }
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */

  }, {
    key: "get",
    value: function get(src, crossOrigin, color) {
      var key = getKey(src, crossOrigin, color);
      return key in this.cache_ ? this.cache_[key] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @param {import("./IconImage.js").default} iconImage Icon image.
     */

  }, {
    key: "set",
    value: function set(src, crossOrigin, color, iconImage) {
      var key = getKey(src, crossOrigin, color);
      this.cache_[key] = iconImage;
      ++this.cacheSize_;
    }
    /**
     * Set the cache size of the icon cache. Default is `32`. Change this value when
     * your map uses more than 32 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */

  }, {
    key: "setSize",
    value: function setSize(maxCacheSize) {
      this.maxCacheSize_ = maxCacheSize;
      this.expire();
    }
  }]);

  return IconImageCache;
}();
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */


function getKey(src, crossOrigin, color) {
  var colorString = color ? asString(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}

/* harmony default export */ var style_IconImageCache = ((/* unused pure expression or super */ null && (IconImageCache)));
/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */

var shared = new IconImageCache();
;// CONCATENATED MODULE: ./node_modules/ol/layer/Property.js
/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ var layer_Property = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  MAX_ZOOM: 'maxZoom',
  MIN_ZOOM: 'minZoom',
  SOURCE: 'source',
  MAP: 'map'
});
;// CONCATENATED MODULE: ./node_modules/ol/layer/Base.js







/**
 * @module ol/layer/Base
 */





/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */

/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */

var BaseLayer = /*#__PURE__*/function (_BaseObject) {
  _inherits(BaseLayer, _BaseObject);

  var _super = createSuper_createSuper(BaseLayer);

  /**
   * @param {Options} options Layer options.
   */
  function BaseLayer(options) {
    var _this;

    _classCallCheck(this, BaseLayer);

    _this = _super.call(this);
    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {BaseLayerOnSignature<void>}
     */

    _this.un;
    /**
     * @type {BackgroundColor|false}
     * @private
     */

    _this.background_ = options.background;
    /**
     * @type {Object<string, *>}
     */

    var properties = Object.assign({}, options);

    if (typeof options.properties === 'object') {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }

    properties[layer_Property.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
    asserts_assert(typeof properties[layer_Property.OPACITY] === 'number', 64); // Layer opacity must be a number

    properties[layer_Property.VISIBLE] = options.visible !== undefined ? options.visible : true;
    properties[layer_Property.Z_INDEX] = options.zIndex;
    properties[layer_Property.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[layer_Property.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
    properties[layer_Property.MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
    properties[layer_Property.MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
    /**
     * @type {string}
     * @private
     */

    _this.className_ = properties.className !== undefined ? properties.className : 'ol-layer';
    delete properties.className;

    _this.setProperties(properties);
    /**
     * @type {import("./Layer.js").State}
     * @private
     */


    _this.state_ = null;
    return _this;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */


  _createClass(BaseLayer, [{
    key: "getBackground",
    value: function getBackground() {
      return this.background_;
    }
    /**
     * @return {string} CSS class name.
     */

  }, {
    key: "getClassName",
    value: function getClassName() {
      return this.className_;
    }
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */

  }, {
    key: "getLayerState",
    value: function getLayerState(managed) {
      /** @type {import("./Layer.js").State} */
      var state = this.state_ ||
      /** @type {?} */
      {
        layer: this,
        managed: managed === undefined ? true : managed
      };
      var zIndex = this.getZIndex();
      state.opacity = math_clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
      state.visible = this.getVisible();
      state.extent = this.getExtent();
      state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
      state.maxResolution = this.getMaxResolution();
      state.minResolution = Math.max(this.getMinResolution(), 0);
      state.minZoom = this.getMinZoom();
      state.maxZoom = this.getMaxZoom();
      this.state_ = state;
      return state;
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */

  }, {
    key: "getLayersArray",
    value: function getLayersArray(array) {
      return util_abstract();
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */

  }, {
    key: "getLayerStatesArray",
    value: function getLayerStatesArray(states) {
      return util_abstract();
    }
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */

  }, {
    key: "getExtent",
    value: function getExtent() {
      return (
        /** @type {import("../extent.js").Extent|undefined} */
        this.get(layer_Property.EXTENT)
      );
    }
    /**
     * Return the maximum resolution of the layer.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */

  }, {
    key: "getMaxResolution",
    value: function getMaxResolution() {
      return (
        /** @type {number} */
        this.get(layer_Property.MAX_RESOLUTION)
      );
    }
    /**
     * Return the minimum resolution of the layer.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */

  }, {
    key: "getMinResolution",
    value: function getMinResolution() {
      return (
        /** @type {number} */
        this.get(layer_Property.MIN_RESOLUTION)
      );
    }
    /**
     * Return the minimum zoom level of the layer.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */

  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return (
        /** @type {number} */
        this.get(layer_Property.MIN_ZOOM)
      );
    }
    /**
     * Return the maximum zoom level of the layer.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */

  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return (
        /** @type {number} */
        this.get(layer_Property.MAX_ZOOM)
      );
    }
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */

  }, {
    key: "getOpacity",
    value: function getOpacity() {
      return (
        /** @type {number} */
        this.get(layer_Property.OPACITY)
      );
    }
    /**
     * @abstract
     * @return {import("../source/Source.js").State} Source state.
     */

  }, {
    key: "getSourceState",
    value: function getSourceState() {
      return util_abstract();
    }
    /**
     * Return the visibility of the layer (`true` or `false`).
     * @return {boolean} The visibility of the layer.
     * @observable
     * @api
     */

  }, {
    key: "getVisible",
    value: function getVisible() {
      return (
        /** @type {boolean} */
        this.get(layer_Property.VISIBLE)
      );
    }
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. The default Z-index is 0.
     * @return {number} The Z-index of the layer.
     * @observable
     * @api
     */

  }, {
    key: "getZIndex",
    value: function getZIndex() {
      return (
        /** @type {number} */
        this.get(layer_Property.Z_INDEX)
      );
    }
    /**
     * Sets the background color.
     * @param {BackgroundColor} [background] Background color.
     */

  }, {
    key: "setBackground",
    value: function setBackground(background) {
      this.background_ = background;
      this.changed();
    }
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setExtent",
    value: function setExtent(extent) {
      this.set(layer_Property.EXTENT, extent);
    }
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setMaxResolution",
    value: function setMaxResolution(maxResolution) {
      this.set(layer_Property.MAX_RESOLUTION, maxResolution);
    }
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setMinResolution",
    value: function setMinResolution(minResolution) {
      this.set(layer_Property.MIN_RESOLUTION, minResolution);
    }
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setMaxZoom",
    value: function setMaxZoom(maxZoom) {
      this.set(layer_Property.MAX_ZOOM, maxZoom);
    }
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setMinZoom",
    value: function setMinZoom(minZoom) {
      this.set(layer_Property.MIN_ZOOM, minZoom);
    }
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      asserts_assert(typeof opacity === 'number', 64); // Layer opacity must be a number

      this.set(layer_Property.OPACITY, opacity);
    }
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      this.set(layer_Property.VISIBLE, visible);
    }
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */

  }, {
    key: "setZIndex",
    value: function setZIndex(zindex) {
      this.set(layer_Property.Z_INDEX, zindex);
    }
    /**
     * Clean up.
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.state_) {
        this.state_.layer = null;
        this.state_ = null;
      }

      _get(getPrototypeOf_getPrototypeOf(BaseLayer.prototype), "disposeInternal", this).call(this);
    }
  }]);

  return BaseLayer;
}(ol_Object);

/* harmony default export */ var Base = (BaseLayer);
;// CONCATENATED MODULE: ./node_modules/ol/render/EventType.js
/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ var render_EventType = ({
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: 'prerender',

  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
});
/**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */

/**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */
;// CONCATENATED MODULE: ./node_modules/ol/layer/Layer.js







/**
 * @module ol/layer/Layer
 */






/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:source'|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */

/**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */

/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */

var Layer = /*#__PURE__*/function (_BaseLayer) {
  _inherits(Layer, _BaseLayer);

  var _super = createSuper_createSuper(Layer);

  /**
   * @param {Options<SourceType>} options Layer options.
   */
  function Layer(options) {
    var _this;

    _classCallCheck(this, Layer);

    var baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    _this = _super.call(this, baseOptions);
    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {LayerOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapPrecomposeKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapRenderKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.sourceChangeKey_ = null;
    /**
     * @private
     * @type {RendererType}
     */

    _this.renderer_ = null;
    /**
     * @protected
     * @type {boolean}
     */

    _this.rendered = false; // Overwrite default render method with a custom one

    if (options.render) {
      _this.render = options.render;
    }

    if (options.map) {
      _this.setMap(options.map);
    }

    _this.addChangeListener(layer_Property.SOURCE, _this.handleSourcePropertyChange_);

    var source = options.source ?
    /** @type {SourceType} */
    options.source : null;

    _this.setSource(source);

    return _this;
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  _createClass(Layer, [{
    key: "getLayersArray",
    value: function getLayersArray(array) {
      array = array ? array : [];
      array.push(this);
      return array;
    }
    /**
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */

  }, {
    key: "getLayerStatesArray",
    value: function getLayerStatesArray(states) {
      states = states ? states : [];
      states.push(this.getLayerState());
      return states;
    }
    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */

  }, {
    key: "getSource",
    value: function getSource() {
      return (
        /** @type {SourceType} */
        this.get(layer_Property.SOURCE) || null
      );
    }
    /**
     * @return {SourceType|null} The source being rendered.
     */

  }, {
    key: "getRenderSource",
    value: function getRenderSource() {
      return this.getSource();
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     */

  }, {
    key: "getSourceState",
    value: function getSourceState() {
      var source = this.getSource();
      return !source ? 'undefined' : source.getState();
    }
    /**
     * @private
     */

  }, {
    key: "handleSourceChange_",
    value: function handleSourceChange_() {
      this.changed();
    }
    /**
     * @private
     */

  }, {
    key: "handleSourcePropertyChange_",
    value: function handleSourcePropertyChange_() {
      if (this.sourceChangeKey_) {
        unlistenByKey(this.sourceChangeKey_);
        this.sourceChangeKey_ = null;
      }

      var source = this.getSource();

      if (source) {
        this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
      }

      this.changed();
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
     * an array of features.
     */

  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      if (!this.renderer_) {
        return new Promise(function (resolve) {
          return resolve([]);
        });
      }

      return this.renderer_.getFeatures(pixel);
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */

  }, {
    key: "getData",
    value: function getData(pixel) {
      if (!this.renderer_ || !this.rendered) {
        return null;
      }

      return this.renderer_.getData(pixel);
    }
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement} The rendered element.
     */

  }, {
    key: "render",
    value: function render(frameState, target) {
      var layerRenderer = this.getRenderer();

      if (layerRenderer.prepareFrame(frameState)) {
        this.rendered = true;
        return layerRenderer.renderFrame(frameState, target);
      }
    }
    /**
     * Called when a layer is not visible during a map render.
     */

  }, {
    key: "unrender",
    value: function unrender() {
      this.rendered = false;
    }
    /**
     * For use inside the library only.
     * @param {import("../Map.js").default|null} map Map.
     */

  }, {
    key: "setMapInternal",
    value: function setMapInternal(map) {
      if (!map) {
        this.unrender();
      }

      this.set(layer_Property.MAP, map);
    }
    /**
     * For use inside the library only.
     * @return {import("../Map.js").default|null} Map.
     */

  }, {
    key: "getMapInternal",
    value: function getMapInternal() {
      return this.get(layer_Property.MAP);
    }
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */

  }, {
    key: "setMap",
    value: function setMap(map) {
      if (this.mapPrecomposeKey_) {
        unlistenByKey(this.mapPrecomposeKey_);
        this.mapPrecomposeKey_ = null;
      }

      if (!map) {
        this.changed();
      }

      if (this.mapRenderKey_) {
        unlistenByKey(this.mapRenderKey_);
        this.mapRenderKey_ = null;
      }

      if (map) {
        this.mapPrecomposeKey_ = listen(map, render_EventType.PRECOMPOSE, function (evt) {
          var renderEvent =
          /** @type {import("../render/Event.js").default} */
          evt;
          var layerStatesArray = renderEvent.frameState.layerStatesArray;
          var layerState = this.getLayerState(false); // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.

          asserts_assert(!layerStatesArray.some(function (arrayLayerState) {
            return arrayLayerState.layer === layerState.layer;
          }), 67);
          layerStatesArray.push(layerState);
        }, this);
        this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
        this.changed();
      }
    }
    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */

  }, {
    key: "setSource",
    value: function setSource(source) {
      this.set(layer_Property.SOURCE, source);
    }
    /**
     * Get the renderer for this layer.
     * @return {RendererType|null} The layer renderer.
     */

  }, {
    key: "getRenderer",
    value: function getRenderer() {
      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }

      return this.renderer_;
    }
    /**
     * @return {boolean} The layer has a renderer.
     */

  }, {
    key: "hasRenderer",
    value: function hasRenderer() {
      return !!this.renderer_;
    }
    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */

  }, {
    key: "createRenderer",
    value: function createRenderer() {
      return null;
    }
    /**
     * Clean up.
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.renderer_) {
        this.renderer_.dispose();
        delete this.renderer_;
      }

      this.setSource(null);

      _get(getPrototypeOf_getPrototypeOf(Layer.prototype), "disposeInternal", this).call(this);
    }
  }]);

  return Layer;
}(Base);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */


function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }

  var resolution = viewState.resolution;

  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }

  var zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
/* harmony default export */ var layer_Layer = (Layer);
;// CONCATENATED MODULE: ./node_modules/ol/coordinate.js
/**
 * @module ol/coordinate
 */



/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */

function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */

function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;

  if (dx === 0 && dy === 0) {
    dx = 1;
  }

  var d = Math.sqrt(dx * dx + dy * dy);
  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;
  return [x, y];
}
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */

function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;

  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }

  return [x, y];
}
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */

function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */

function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
  var normalizedDegrees = modulo(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var decimals = fractionDigits || 0;
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = toFixed(x - deg * 3600 - min * 60, decimals);

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  var hdms = deg + "\xB0";

  if (min !== 0 || sec !== 0) {
    hdms += ' ' + padNumber(min, 2) + "\u2032";
  }

  if (sec !== 0) {
    hdms += ' ' + padNumber(sec, 2, decimals) + "\u2033";
  }

  if (normalizedDegrees !== 0) {
    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
  }

  return hdms;
}
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */

function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(fractionDigits)).replace('{y}', coordinate[1].toFixed(fractionDigits));
  } else {
    return '';
  }
}
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */

function coordinate_equals(coordinate1, coordinate2) {
  var equals = true;

  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }

  return equals;
}
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */

function coordinate_rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */

function coordinate_scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */

function coordinate_squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */

function distance(coord1, coord2) {
  return Math.sqrt(coordinate_squaredDistance(coord1, coord2));
}
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */

function squaredDistanceToSegment(coordinate, segment) {
  return coordinate_squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */

function toStringHDMS(coordinate, fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], fractionDigits);
  } else {
    return '';
  }
}
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */

function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, '{x}, {y}', fractionDigits);
}
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */

function coordinate_wrapX(coordinate, projection) {
  if (projection.canWrapX()) {
    var worldWidth = getWidth(projection.getExtent());
    var worldsAway = getWorldsAway(coordinate, projection, worldWidth);

    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }

  return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */

function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  var projectionExtent = projection.getExtent();
  var worldsAway = 0;

  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
  }

  return worldsAway;
}
;// CONCATENATED MODULE: ./node_modules/ol/renderer/Map.js





/**
 * @module ol/renderer/Map
 */








/**
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 * @template T
 */

/**
 * @abstract
 */

var MapRenderer = /*#__PURE__*/function (_Disposable) {
  _inherits(MapRenderer, _Disposable);

  var _super = createSuper_createSuper(MapRenderer);

  /**
   * @param {import("../Map.js").default} map Map.
   */
  function MapRenderer(map) {
    var _this;

    _classCallCheck(this, MapRenderer);

    _this = _super.call(this);
    /**
     * @private
     * @type {import("../Map.js").default}
     */

    _this.map_ = map;
    return _this;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */


  _createClass(MapRenderer, [{
    key: "dispatchRenderEvent",
    value: function dispatchRenderEvent(type, frameState) {
      util_abstract();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @protected
     */

  }, {
    key: "calculateMatrices2D",
    value: function calculateMatrices2D(frameState) {
      var viewState = frameState.viewState;
      var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
      var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
      compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
      makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */

  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
      var result;
      var viewState = frameState.viewState;
      /**
       * @param {boolean} managed Managed layer.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @return {T|undefined} Callback result.
       */

      function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
        return callback.call(thisArg, feature, managed ? layer : null, geometry);
      }

      var projection = viewState.projection;
      var translatedCoordinate = coordinate_wrapX(coordinate.slice(), projection);
      var offsets = [[0, 0]];

      if (projection.canWrapX() && checkWrapped) {
        var projectionExtent = projection.getExtent();
        var worldWidth = getWidth(projectionExtent);
        offsets.push([-worldWidth, 0], [worldWidth, 0]);
      }

      var layerStates = frameState.layerStatesArray;
      var numLayers = layerStates.length;
      var matches =
      /** @type {Array<HitMatch<T>>} */
      [];
      var tmpCoord = [];

      for (var i = 0; i < offsets.length; i++) {
        for (var j = numLayers - 1; j >= 0; --j) {
          var layerState = layerStates[j];
          var layer = layerState.layer;

          if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
            var layerRenderer = layer.getRenderer();
            var source = layer.getSource();

            if (layerRenderer && source) {
              var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;

              var _callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);

              tmpCoord[0] = coordinates[0] + offsets[i][0];
              tmpCoord[1] = coordinates[1] + offsets[i][1];
              result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, _callback, matches);
            }

            if (result) {
              return result;
            }
          }
        }
      }

      if (matches.length === 0) {
        return undefined;
      }

      var order = 1 / matches.length;
      matches.forEach(function (m, i) {
        return m.distanceSq += i * order;
      });
      matches.sort(function (a, b) {
        return a.distanceSq - b.distanceSq;
      });
      matches.some(function (m) {
        return result = m.callback(m.feature, m.layer, m.geometry);
      });
      return result;
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */

  }, {
    key: "hasFeatureAtCoordinate",
    value: function hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
      var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
      return hasFeature !== undefined;
    }
    /**
     * @return {import("../Map.js").default} Map.
     */

  }, {
    key: "getMap",
    value: function getMap() {
      return this.map_;
    }
    /**
     * Render.
     * @abstract
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */

  }, {
    key: "renderFrame",
    value: function renderFrame(frameState) {
      util_abstract();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @protected
     */

  }, {
    key: "scheduleExpireIconCache",
    value: function scheduleExpireIconCache(frameState) {
      if (shared.canExpireCache()) {
        frameState.postRenderFunctions.push(expireIconCache);
      }
    }
  }]);

  return MapRenderer;
}(ol_Disposable);
/**
 * @param {import("../Map.js").default} map Map.
 * @param {import("../Map.js").FrameState} frameState Frame state.
 */


function expireIconCache(map, frameState) {
  shared.expire();
}

/* harmony default export */ var renderer_Map = (MapRenderer);
;// CONCATENATED MODULE: ./node_modules/ol/render/Event.js





/**
 * @module ol/render/Event
 */


var RenderEvent = /*#__PURE__*/function (_Event) {
  _inherits(RenderEvent, _Event);

  var _super = createSuper_createSuper(RenderEvent);

  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  function RenderEvent(type, inversePixelTransform, frameState, context) {
    var _this;

    _classCallCheck(this, RenderEvent);

    _this = _super.call(this, type);
    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */

    _this.inversePixelTransform = inversePixelTransform;
    /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */

    _this.frameState = frameState;
    /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */

    _this.context = context;
    return _this;
  }

  return _createClass(RenderEvent);
}(events_Event);

/* harmony default export */ var render_Event = (RenderEvent);
;// CONCATENATED MODULE: ./node_modules/ol/css.js
/**
 * @module ol/css
 */

/**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */

var CLASS_SELECTABLE = 'ol-selectable';
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */

var CLASS_UNSELECTABLE = 'ol-unselectable';
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */

var CLASS_UNSUPPORTED = 'ol-unsupported';
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */

var CLASS_CONTROL = 'ol-control';
/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */

var CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */

var fontRegEx = new RegExp(['^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)', '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?', '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))', '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))', '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'].join(''), 'i');
var fontRegExMatchIndex = ['style', 'variant', 'weight', 'size', 'lineHeight', 'family'];
/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters|null} The font parameters (or null if the input spec is invalid).
 */

var getFontParameters = function getFontParameters(fontSpec) {
  var match = fontSpec.match(fontRegEx);

  if (!match) {
    return null;
  }

  var style =
  /** @type {FontParameters} */
  {
    lineHeight: 'normal',
    size: '1.2em',
    style: 'normal',
    weight: 'normal',
    variant: 'normal'
  };

  for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    var value = match[i + 1];

    if (value !== undefined) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }

  style.families = style.family.split(/,\s?/);
  return style;
};
;// CONCATENATED MODULE: ./node_modules/ol/dom.js

/**
 * @module ol/dom
 */
//FIXME Move this function to the canvas module

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */

function createCanvasContext2D(width, height, canvasPool, settings) {
  /** @type {HTMLCanvasElement|OffscreenCanvas} */
  var canvas;

  if (canvasPool && canvasPool.length) {
    canvas = canvasPool.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement('canvas');
  }

  if (width) {
    canvas.width = width;
  }

  if (height) {
    canvas.height = height;
  } //FIXME Allow OffscreenCanvasRenderingContext2D as return type


  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext('2d', settings)
  );
}
/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */

function releaseCanvas(context) {
  var canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */

function dom_outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */

function dom_outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */

function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;

  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */

function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
/**
 * @param {Node} node The node to remove the children from.
 */

function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */

function replaceChildren(node, children) {
  var oldChildren = node.childNodes;

  for (var i = 0; true; ++i) {
    var oldChild = oldChildren[i];
    var newChild = children[i]; // check if our work is done

    if (!oldChild && !newChild) {
      break;
    } // check if children match


    if (oldChild === newChild) {
      continue;
    } // check if a new child needs to be added


    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    } // check if an old child needs to be removed


    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    } // reorder


    node.insertBefore(newChild, oldChild);
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas.js
/**
 * @module ol/render/canvas
 */





/**
 * @typedef {'Circle' | 'Image' | 'LineString' | 'Polygon' | 'Text' | 'Default'} BuilderType
 */

/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle FillStyle.
 */

/**
 * @typedef Label
 * @property {number} width Width.
 * @property {number} height Height.
 * @property {Array<string|number>} contextInstructions ContextInstructions.
 */

/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle] Current FillStyle.
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle] Current StrokeStyle.
 * @property {CanvasLineCap} [currentLineCap] Current LineCap.
 * @property {Array<number>} currentLineDash Current LineDash.
 * @property {number} [currentLineDashOffset] Current LineDashOffset.
 * @property {CanvasLineJoin} [currentLineJoin] Current LineJoin.
 * @property {number} [currentLineWidth] Current LineWidth.
 * @property {number} [currentMiterLimit] Current MiterLimit.
 * @property {number} [lastStroke] Last stroke.
 * @property {import("../colorlike.js").ColorLike} [fillStyle] FillStyle.
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {CanvasLineCap} [lineCap] LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} [lineDashOffset] LineDashOffset.
 * @property {CanvasLineJoin} [lineJoin] LineJoin.
 * @property {number} [lineWidth] LineWidth.
 * @property {number} [miterLimit] MiterLimit.
 */

/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} lineWidth LineWidth.
 * @property {number} miterLimit MiterLimit.
 * @property {import("../colorlike.js").ColorLike} strokeStyle StrokeStyle.
 */

/**
 * @typedef {Object} TextState
 * @property {string} font Font.
 * @property {CanvasTextAlign} [textAlign] TextAlign.
 * @property {import("../style/Text.js").TextJustify} [justify] Justify.
 * @property {CanvasTextBaseline} textBaseline TextBaseline.
 * @property {import("../style/Text.js").TextPlacement} [placement] Placement.
 * @property {number} [maxAngle] MaxAngle.
 * @property {boolean} [overflow] Overflow.
 * @property {import("../style/Fill.js").default} [backgroundFill] BackgroundFill.
 * @property {import("../style/Stroke.js").default} [backgroundStroke] BackgroundStroke.
 * @property {import("../size.js").Size} [scale] Scale.
 * @property {Array<number>} [padding] Padding.
 */

/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */

/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */

/**
 * @const
 * @type {string}
 */

var defaultFont = '10px sans-serif';
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

var defaultFillStyle = '#000';
/**
 * @const
 * @type {CanvasLineCap}
 */

var defaultLineCap = 'round';
/**
 * @const
 * @type {Array<number>}
 */

var defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

var defaultLineDashOffset = 0;
/**
 * @const
 * @type {CanvasLineJoin}
 */

var defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

var defaultMiterLimit = 10;
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

var defaultStrokeStyle = '#000';
/**
 * @const
 * @type {CanvasTextAlign}
 */

var defaultTextAlign = 'center';
/**
 * @const
 * @type {CanvasTextBaseline}
 */

var defaultTextBaseline = 'middle';
/**
 * @const
 * @type {Array<number>}
 */

var defaultPadding = [0, 0, 0, 0];
/**
 * @const
 * @type {number}
 */

var defaultLineWidth = 1;
/**
 * @type {BaseObject}
 */

var checkedFonts = new ol_Object();
/**
 * @type {CanvasRenderingContext2D}
 */

var measureContext = null;
/**
 * @type {string}
 */

var measureFont;
/**
 * @type {!Object<string, number>}
 */

var textHeights = {};
/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */

var registerFont = function () {
  var retries = 100;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = "wmytzilWMYTZIL@#/&?$%10\uF013";
  var interval, referenceWidth;
  /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */

  function isAvailable(fontStyle, fontWeight, fontFamily) {
    var available = true;

    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);

      if (fontFamily != referenceFont) {
        var width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text); // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.

        available = available && width != referenceWidth;
      }
    }

    if (available) {
      return true;
    }

    return false;
  }

  function check() {
    var done = true;
    var fonts = checkedFonts.getKeys();

    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];

      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split('\n'))) {
          obj_clear(textHeights); // Make sure that loaded fonts are picked up by Safari

          measureContext = null;
          measureFont = undefined;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }

    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    var font = getFontParameters(fontSpec);

    if (!font) {
      return;
    }

    var families = font.families;

    for (var i = 0, ii = families.length; i < ii; ++i) {
      var family = families[i];
      var key = font.style + '\n' + font.weight + '\n' + family;

      if (checkedFonts.get(key) === undefined) {
        checkedFonts.set(key, retries, true);

        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);

          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */

var measureTextHeight = function () {
  /**
   * @type {HTMLDivElement}
   */
  var measureElement;
  return function (fontSpec) {
    var height = textHeights[fontSpec];

    if (height == undefined) {
      if (WORKER_OFFSCREEN_CANVAS) {
        var font = getFontParameters(fontSpec);
        var metrics = measureText(fontSpec, 'Žg');
        var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement('div');
          measureElement.innerHTML = 'M';
          measureElement.style.minHeight = '0';
          measureElement.style.maxHeight = 'none';
          measureElement.style.height = 'auto';
          measureElement.style.padding = '0';
          measureElement.style.border = 'none';
          measureElement.style.position = 'absolute';
          measureElement.style.display = 'block';
          measureElement.style.left = '-99999px';
        }

        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }

      textHeights[fontSpec] = height;
    }

    return height;
  };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */

function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }

  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }

  return measureContext.measureText(text);
}
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */


function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */

function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }

  var width = text.split('\n').reduce(function (prev, curr) {
    return Math.max(prev, measureTextWidth(font, curr));
  }, 0);
  cache[text] = width;
  return width;
}
/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */

function getTextDimensions(baseStyle, chunks) {
  var widths = [];
  var heights = [];
  var lineWidths = [];
  var width = 0;
  var lineWidth = 0;
  var height = 0;
  var lineHeight = 0;

  for (var i = 0, ii = chunks.length; i <= ii; i += 2) {
    var text = chunks[i];

    if (text === '\n' || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }

    var font = chunks[i + 1] || baseStyle.font;
    var currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    var currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }

  return {
    width: width,
    height: height,
    widths: widths,
    heights: heights,
    lineWidths: lineWidths
  };
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */

function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */

function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
  context.save();

  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }

  if (transform) {
    context.setTransform.apply(context, transform);
  }

  if (
  /** @type {*} */
  labelOrImage.contextInstructions) {
    // label
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    executeLabelInstructions(
    /** @type {Label} */
    labelOrImage, context);
  } else if (scale[0] < 0 || scale[1] < 0) {
    // flipped image
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    context.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, 0, 0, w, h);
  } else {
    // if image not flipped translate and scale can be avoided
    context.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
  }

  context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */

function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;

  for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/renderer/Composite.js







/**
 * @module ol/renderer/Composite
 */









/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */

var CompositeMapRenderer = /*#__PURE__*/function (_MapRenderer) {
  _inherits(CompositeMapRenderer, _MapRenderer);

  var _super = createSuper_createSuper(CompositeMapRenderer);

  /**
   * @param {import("../Map.js").default} map Map.
   */
  function CompositeMapRenderer(map) {
    var _this;

    _classCallCheck(this, CompositeMapRenderer);

    _this = _super.call(this, map);
    /**
     * @type {import("../events.js").EventsKey}
     */

    _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
    /**
     * @private
     * @type {HTMLDivElement}
     */

    _this.element_ = document.createElement('div');
    var style = _this.element_.style;
    style.position = 'absolute';
    style.width = '100%';
    style.height = '100%';
    style.zIndex = '0';
    _this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';
    var container = map.getViewport();
    container.insertBefore(_this.element_, container.firstChild || null);
    /**
     * @private
     * @type {Array<HTMLElement>}
     */

    _this.children_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */


  _createClass(CompositeMapRenderer, [{
    key: "dispatchRenderEvent",
    value: function dispatchRenderEvent(type, frameState) {
      var map = this.getMap();

      if (map.hasListener(type)) {
        var event = new render_Event(type, undefined, frameState);
        map.dispatchEvent(event);
      }
    }
  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      unlistenByKey(this.fontChangeListenerKey_);
      this.element_.parentNode.removeChild(this.element_);

      _get(getPrototypeOf_getPrototypeOf(CompositeMapRenderer.prototype), "disposeInternal", this).call(this);
    }
    /**
     * Render.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */

  }, {
    key: "renderFrame",
    value: function renderFrame(frameState) {
      if (!frameState) {
        if (this.renderedVisible_) {
          this.element_.style.display = 'none';
          this.renderedVisible_ = false;
        }

        return;
      }

      this.calculateMatrices2D(frameState);
      this.dispatchRenderEvent(render_EventType.PRECOMPOSE, frameState);
      var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
        return a.zIndex - b.zIndex;
      });
      var viewState = frameState.viewState;
      this.children_.length = 0;
      /**
       * @type {Array<import("../layer/BaseVector.js").default>}
       */

      var declutterLayers = [];
      var previousElement = null;

      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        var layerState = layerStatesArray[i];
        frameState.layerIndex = i;
        var layer = layerState.layer;
        var sourceState = layer.getSourceState();

        if (!inView(layerState, viewState) || sourceState != 'ready' && sourceState != 'undefined') {
          layer.unrender();
          continue;
        }

        var element = layer.render(frameState, previousElement);

        if (!element) {
          continue;
        }

        if (element !== previousElement) {
          this.children_.push(element);
          previousElement = element;
        }

        if ('getDeclutter' in layer) {
          declutterLayers.push(
          /** @type {import("../layer/BaseVector.js").default} */
          layer);
        }
      }

      for (var _i = declutterLayers.length - 1; _i >= 0; --_i) {
        declutterLayers[_i].renderDeclutter(frameState);
      }

      replaceChildren(this.element_, this.children_);
      this.dispatchRenderEvent(render_EventType.POSTCOMPOSE, frameState);

      if (!this.renderedVisible_) {
        this.element_.style.display = '';
        this.renderedVisible_ = true;
      }

      this.scheduleExpireIconCache(frameState);
    }
  }]);

  return CompositeMapRenderer;
}(renderer_Map);

/* harmony default export */ var Composite = (CompositeMapRenderer);
;// CONCATENATED MODULE: ./node_modules/ol/layer/Group.js





/**
 * @module ol/layer/Group
 */











/**
 * @typedef {'addlayer'|'removelayer'} EventType
 */

/**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */

var GroupEvent = /*#__PURE__*/function (_Event) {
  _inherits(GroupEvent, _Event);

  var _super = createSuper_createSuper(GroupEvent);

  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  function GroupEvent(type, layer) {
    var _this;

    _classCallCheck(this, GroupEvent);

    _this = _super.call(this, type);
    /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */

    _this.layer = layer;
    return _this;
  }

  return _createClass(GroupEvent);
}(events_Event);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */

var Group_Property = {
  LAYERS: 'layers'
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */

var LayerGroup = /*#__PURE__*/function (_BaseLayer) {
  _inherits(LayerGroup, _BaseLayer);

  var _super2 = createSuper_createSuper(LayerGroup);

  /**
   * @param {Options} [options] Layer options.
   */
  function LayerGroup(options) {
    var _this2;

    _classCallCheck(this, LayerGroup);

    options = options || {};
    var baseOptions =
    /** @type {Options} */
    Object.assign({}, options);
    delete baseOptions.layers;
    var layers = options.layers;
    _this2 = _super2.call(this, baseOptions);
    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */

    _this2.on;
    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */

    _this2.once;
    /***
     * @type {GroupOnSignature<void>}
     */

    _this2.un;
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */

    _this2.layersListenerKeys_ = [];
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this2.listenerKeys_ = {};

    _this2.addChangeListener(Group_Property.LAYERS, _this2.handleLayersChanged_);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new ol_Collection(layers.slice(), {
          unique: true
        });
      } else {
        asserts_assert(typeof
        /** @type {?} */
        layers.getArray === 'function', 43); // Expected `layers` to be an array or a `Collection`
      }
    } else {
      layers = new ol_Collection(undefined, {
        unique: true
      });
    }

    _this2.setLayers(layers);

    return _this2;
  }
  /**
   * @private
   */


  _createClass(LayerGroup, [{
    key: "handleLayerChange_",
    value: function handleLayerChange_() {
      this.changed();
    }
    /**
     * @private
     */

  }, {
    key: "handleLayersChanged_",
    value: function handleLayersChanged_() {
      this.layersListenerKeys_.forEach(unlistenByKey);
      this.layersListenerKeys_.length = 0;
      var layers = this.getLayers();
      this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));

      for (var id in this.listenerKeys_) {
        this.listenerKeys_[id].forEach(unlistenByKey);
      }

      obj_clear(this.listenerKeys_);
      var layersArray = layers.getArray();

      for (var i = 0, ii = layersArray.length; i < ii; i++) {
        var layer = layersArray[i];
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent('addlayer', layer));
      }

      this.changed();
    }
    /**
     * @param {BaseLayer} layer The layer.
     */

  }, {
    key: "registerLayerListeners_",
    value: function registerLayerListeners_(layer) {
      var listenerKeys = [listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(layer, EventType.CHANGE, this.handleLayerChange_, this)];

      if (layer instanceof LayerGroup) {
        listenerKeys.push(listen(layer, 'addlayer', this.handleLayerGroupAdd_, this), listen(layer, 'removelayer', this.handleLayerGroupRemove_, this));
      }

      this.listenerKeys_[getUid(layer)] = listenerKeys;
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */

  }, {
    key: "handleLayerGroupAdd_",
    value: function handleLayerGroupAdd_(event) {
      this.dispatchEvent(new GroupEvent('addlayer', event.layer));
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */

  }, {
    key: "handleLayerGroupRemove_",
    value: function handleLayerGroupRemove_(event) {
      this.dispatchEvent(new GroupEvent('removelayer', event.layer));
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */

  }, {
    key: "handleLayersAdd_",
    value: function handleLayersAdd_(collectionEvent) {
      var layer = collectionEvent.element;
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent('addlayer', layer));
      this.changed();
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */

  }, {
    key: "handleLayersRemove_",
    value: function handleLayersRemove_(collectionEvent) {
      var layer = collectionEvent.element;
      var key = getUid(layer);
      this.listenerKeys_[key].forEach(unlistenByKey);
      delete this.listenerKeys_[key];
      this.dispatchEvent(new GroupEvent('removelayer', layer));
      this.changed();
    }
    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!Collection<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */

  }, {
    key: "getLayers",
    value: function getLayers() {
      return (
        /** @type {!Collection<import("./Base.js").default>} */
        this.get(Group_Property.LAYERS)
      );
    }
    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!Collection<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */

  }, {
    key: "setLayers",
    value: function setLayers(layers) {
      var collection = this.getLayers();

      if (collection) {
        var currentLayers = collection.getArray();

        for (var i = 0, ii = currentLayers.length; i < ii; ++i) {
          this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
        }
      }

      this.set(Group_Property.LAYERS, layers);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */

  }, {
    key: "getLayersArray",
    value: function getLayersArray(array) {
      array = array !== undefined ? array : [];
      this.getLayers().forEach(function (layer) {
        layer.getLayersArray(array);
      });
      return array;
    }
    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If dest is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [dest] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */

  }, {
    key: "getLayerStatesArray",
    value: function getLayerStatesArray(dest) {
      var states = dest !== undefined ? dest : [];
      var pos = states.length;
      this.getLayers().forEach(function (layer) {
        layer.getLayerStatesArray(states);
      });
      var ownLayerState = this.getLayerState();
      var defaultZIndex = ownLayerState.zIndex;

      if (!dest && ownLayerState.zIndex === undefined) {
        defaultZIndex = 0;
      }

      for (var i = pos, ii = states.length; i < ii; i++) {
        var layerState = states[i];
        layerState.opacity *= ownLayerState.opacity;
        layerState.visible = layerState.visible && ownLayerState.visible;
        layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
        layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
        layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
        layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);

        if (ownLayerState.extent !== undefined) {
          if (layerState.extent !== undefined) {
            layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
          } else {
            layerState.extent = ownLayerState.extent;
          }
        }

        if (layerState.zIndex === undefined) {
          layerState.zIndex = defaultZIndex;
        }
      }

      return states;
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     */

  }, {
    key: "getSourceState",
    value: function getSourceState() {
      return 'ready';
    }
  }]);

  return LayerGroup;
}(Base);

/* harmony default export */ var layer_Group = (LayerGroup);
;// CONCATENATED MODULE: ./node_modules/ol/MapEvent.js





/**
 * @module ol/MapEvent
 */

/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */

var MapEvent = /*#__PURE__*/function (_Event) {
  _inherits(MapEvent, _Event);

  var _super = createSuper_createSuper(MapEvent);

  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  function MapEvent(type, map, frameState) {
    var _this;

    _classCallCheck(this, MapEvent);

    _this = _super.call(this, type);
    /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */

    _this.map = map;
    /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */

    _this.frameState = frameState !== undefined ? frameState : null;
    return _this;
  }

  return _createClass(MapEvent);
}(events_Event);

/* harmony default export */ var ol_MapEvent = (MapEvent);
;// CONCATENATED MODULE: ./node_modules/ol/MapBrowserEvent.js







/**
 * @module ol/MapBrowserEvent
 */

/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */

var MapBrowserEvent = /*#__PURE__*/function (_MapEvent) {
  _inherits(MapBrowserEvent, _MapEvent);

  var _super = createSuper_createSuper(MapBrowserEvent);

  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  function MapBrowserEvent(type, map, originalEvent, dragging, frameState, activePointers) {
    var _this;

    _classCallCheck(this, MapBrowserEvent);

    _this = _super.call(this, type, map, frameState);
    /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */

    _this.originalEvent = originalEvent;
    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */

    _this.pixel_ = null;
    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */

    _this.coordinate_ = null;
    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */

    _this.dragging = dragging !== undefined ? dragging : false;
    /**
     * @type {Array<PointerEvent>|undefined}
     */

    _this.activePointers = activePointers;
    return _this;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */


  _createClass(MapBrowserEvent, [{
    key: "pixel",
    get: function get() {
      if (!this.pixel_) {
        this.pixel_ = this.map.getEventPixel(this.originalEvent);
      }

      return this.pixel_;
    },
    set: function set(pixel) {
      this.pixel_ = pixel;
    }
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */

  }, {
    key: "coordinate",
    get: function get() {
      if (!this.coordinate_) {
        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
      }

      return this.coordinate_;
    },
    set: function set(coordinate) {
      this.coordinate_ = coordinate;
    }
    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     */

  }, {
    key: "preventDefault",
    value: function preventDefault() {
      _get(getPrototypeOf_getPrototypeOf(MapBrowserEvent.prototype), "preventDefault", this).call(this);

      if ('preventDefault' in this.originalEvent) {
        /** @type {UIEvent} */
        this.originalEvent.preventDefault();
      }
    }
    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     */

  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      _get(getPrototypeOf_getPrototypeOf(MapBrowserEvent.prototype), "stopPropagation", this).call(this);

      if ('stopPropagation' in this.originalEvent) {
        /** @type {UIEvent} */
        this.originalEvent.stopPropagation();
      }
    }
  }]);

  return MapBrowserEvent;
}(ol_MapEvent);

/* harmony default export */ var ol_MapBrowserEvent = (MapBrowserEvent);
;// CONCATENATED MODULE: ./node_modules/ol/MapBrowserEventType.js
/**
 * @module ol/MapBrowserEventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */

/* harmony default export */ var ol_MapBrowserEventType = ({
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: EventType.CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: EventType.DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});
/***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */
;// CONCATENATED MODULE: ./node_modules/ol/pointer/EventType.js
/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ var pointer_EventType = ({
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});
;// CONCATENATED MODULE: ./node_modules/ol/MapBrowserEventHandler.js








/**
 * @module ol/MapBrowserEventHandler
 */









var MapBrowserEventHandler = /*#__PURE__*/function (_Target) {
  _inherits(MapBrowserEventHandler, _Target);

  var _super = createSuper_createSuper(MapBrowserEventHandler);

  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  function MapBrowserEventHandler(map, moveTolerance) {
    var _this;

    _classCallCheck(this, MapBrowserEventHandler);

    _this = _super.call(this, map);
    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */

    _this.map_ = map;
    /**
     * @type {any}
     * @private
     */

    _this.clickTimeoutId_;
    /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */

    _this.emulateClicks_ = false;
    /**
     * @type {boolean}
     * @private
     */

    _this.dragging_ = false;
    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */

    _this.dragListenerKeys_ = [];
    /**
     * @type {number}
     * @private
     */

    _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */

    _this.down_ = null;

    var element = _this.map_.getViewport();
    /**
     * @type {Array<PointerEvent>}
     * @private
     */


    _this.activePointers_ = [];
    /**
     * @type {!Object<number, Event>}
     * @private
     */

    _this.trackedTouches_ = {};
    _this.element_ = element;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.pointerdownListenerKey_ = listen(element, pointer_EventType.POINTERDOWN, _this.handlePointerDown_, assertThisInitialized_assertThisInitialized(_this));
    /**
     * @type {PointerEvent}
     * @private
     */

    _this.originalPointerMoveEvent_;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.relayedListenerKey_ = listen(element, pointer_EventType.POINTERMOVE, _this.relayMoveEvent_, assertThisInitialized_assertThisInitialized(_this));
    /**
     * @private
     */

    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(assertThisInitialized_assertThisInitialized(_this));

    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {
      passive: false
    } : false);

    return _this;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  _createClass(MapBrowserEventHandler, [{
    key: "emulateClick_",
    value: function emulateClick_(pointerEvent) {
      var newEvent = new ol_MapBrowserEvent(ol_MapBrowserEventType.CLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);

      if (this.clickTimeoutId_ !== undefined) {
        // double-click
        clearTimeout(this.clickTimeoutId_);
        this.clickTimeoutId_ = undefined;
        newEvent = new ol_MapBrowserEvent(ol_MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      } else {
        // click
        this.clickTimeoutId_ = setTimeout(
        /** @this {MapBrowserEventHandler} */
        function () {
          this.clickTimeoutId_ = undefined;
          var newEvent = new ol_MapBrowserEvent(ol_MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
        }.bind(this), 250);
      }
    }
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */

  }, {
    key: "updateActivePointers_",
    value: function updateActivePointers_(pointerEvent) {
      var event = pointerEvent;
      var id = event.pointerId;

      if (event.type == ol_MapBrowserEventType.POINTERUP || event.type == ol_MapBrowserEventType.POINTERCANCEL) {
        delete this.trackedTouches_[id];

        for (var pointerId in this.trackedTouches_) {
          if (this.trackedTouches_[pointerId].target !== event.target) {
            // Some platforms assign a new pointerId when the target changes.
            // If this happens, delete one tracked pointer. If there is more
            // than one tracked pointer for the old target, it will be cleared
            // by subsequent POINTERUP events from other pointers.
            delete this.trackedTouches_[pointerId];
            break;
          }
        }
      } else if (event.type == ol_MapBrowserEventType.POINTERDOWN || event.type == ol_MapBrowserEventType.POINTERMOVE) {
        this.trackedTouches_[id] = event;
      }

      this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */

  }, {
    key: "handlePointerUp_",
    value: function handlePointerUp_(pointerEvent) {
      this.updateActivePointers_(pointerEvent);
      var newEvent = new ol_MapBrowserEvent(ol_MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
      this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen
      // contact. isMouseActionButton returns true in these cases (evt.button is set
      // to 0).
      // See http://www.w3.org/TR/pointerevents/#button-states
      // We only fire click, singleclick, and doubleclick if nobody has called
      // event.preventDefault().

      if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
        this.emulateClick_(this.down_);
      }

      if (this.activePointers_.length === 0) {
        this.dragListenerKeys_.forEach(unlistenByKey);
        this.dragListenerKeys_.length = 0;
        this.dragging_ = false;
        this.down_ = null;
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */

  }, {
    key: "isMouseActionButton_",
    value: function isMouseActionButton_(pointerEvent) {
      return pointerEvent.button === 0;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */

  }, {
    key: "handlePointerDown_",
    value: function handlePointerDown_(pointerEvent) {
      this.emulateClicks_ = this.activePointers_.length === 0;
      this.updateActivePointers_(pointerEvent);
      var newEvent = new ol_MapBrowserEvent(ol_MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
      this.dispatchEvent(newEvent); // Store a copy of the down event

      this.down_ =
      /** @type {PointerEvent} */
      {};

      for (var property in pointerEvent) {
        var value = pointerEvent[property];
        this.down_[property] = typeof value === 'function' ? VOID : value;
      }

      if (this.dragListenerKeys_.length === 0) {
        var doc = this.map_.getOwnerDocument();
        this.dragListenerKeys_.push(listen(doc, ol_MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, ol_MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        listen(this.element_, ol_MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));

        if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
          this.dragListenerKeys_.push(listen(this.element_.getRootNode(), ol_MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
        }
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */

  }, {
    key: "handlePointerMove_",
    value: function handlePointerMove_(pointerEvent) {
      // Between pointerdown and pointerup, pointermove events are triggered.
      // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
      // moved a significant distance.
      if (this.isMoving_(pointerEvent)) {
        this.updateActivePointers_(pointerEvent);
        this.dragging_ = true;
        var newEvent = new ol_MapBrowserEvent(ol_MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
      }
    }
    /**
     * Wrap and relay a pointermove event.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */

  }, {
    key: "relayMoveEvent_",
    value: function relayMoveEvent_(pointerEvent) {
      this.originalPointerMoveEvent_ = pointerEvent;
      var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
      this.dispatchEvent(new ol_MapBrowserEvent(ol_MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));
    }
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */

  }, {
    key: "handleTouchMove_",
    value: function handleTouchMove_(event) {
      // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
      // may not be initialized yet when we get here on a platform without native pointer events.
      var originalEvent = this.originalPointerMoveEvent_;

      if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {
        event.preventDefault();
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */

  }, {
    key: "isMoving_",
    value: function isMoving_(pointerEvent) {
      return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
     * Clean up.
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      if (this.relayedListenerKey_) {
        unlistenByKey(this.relayedListenerKey_);
        this.relayedListenerKey_ = null;
      }

      this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);

      if (this.pointerdownListenerKey_) {
        unlistenByKey(this.pointerdownListenerKey_);
        this.pointerdownListenerKey_ = null;
      }

      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.element_ = null;

      _get(getPrototypeOf_getPrototypeOf(MapBrowserEventHandler.prototype), "disposeInternal", this).call(this);
    }
  }]);

  return MapBrowserEventHandler;
}(events_Target);

/* harmony default export */ var ol_MapBrowserEventHandler = (MapBrowserEventHandler);
;// CONCATENATED MODULE: ./node_modules/ol/MapEventType.js
/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ var MapEventType = ({
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend',

  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: 'loadstart',

  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: 'loadend'
});
/***
 * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
 */
;// CONCATENATED MODULE: ./node_modules/ol/MapProperty.js
/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ var MapProperty = ({
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
});
;// CONCATENATED MODULE: ./node_modules/ol/structs/PriorityQueue.js



/**
 * @module ol/structs/PriorityQueue
 */


/**
 * @type {number}
 */

var DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */

var PriorityQueue = /*#__PURE__*/function () {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  function PriorityQueue(priorityFunction, keyFunction) {
    _classCallCheck(this, PriorityQueue);

    /**
     * @type {function(T): number}
     * @private
     */
    this.priorityFunction_ = priorityFunction;
    /**
     * @type {function(T): string}
     * @private
     */

    this.keyFunction_ = keyFunction;
    /**
     * @type {Array<T>}
     * @private
     */

    this.elements_ = [];
    /**
     * @type {Array<number>}
     * @private
     */

    this.priorities_ = [];
    /**
     * @type {!Object<string, boolean>}
     * @private
     */

    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */


  _createClass(PriorityQueue, [{
    key: "clear",
    value: function clear() {
      this.elements_.length = 0;
      this.priorities_.length = 0;

      obj_clear(this.queuedElements_);
    }
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */

  }, {
    key: "dequeue",
    value: function dequeue() {
      var elements = this.elements_;
      var priorities = this.priorities_;
      var element = elements[0];

      if (elements.length == 1) {
        elements.length = 0;
        priorities.length = 0;
      } else {
        elements[0] = elements.pop();
        priorities[0] = priorities.pop();
        this.siftUp_(0);
      }

      var elementKey = this.keyFunction_(element);
      delete this.queuedElements_[elementKey];
      return element;
    }
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */

  }, {
    key: "enqueue",
    value: function enqueue(element) {
      asserts_assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue

      var priority = this.priorityFunction_(element);

      if (priority != DROP) {
        this.elements_.push(element);
        this.priorities_.push(priority);
        this.queuedElements_[this.keyFunction_(element)] = true;
        this.siftDown_(0, this.elements_.length - 1);
        return true;
      }

      return false;
    }
    /**
     * @return {number} Count.
     */

  }, {
    key: "getCount",
    value: function getCount() {
      return this.elements_.length;
    }
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */

  }, {
    key: "getLeftChildIndex_",
    value: function getLeftChildIndex_(index) {
      return index * 2 + 1;
    }
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */

  }, {
    key: "getRightChildIndex_",
    value: function getRightChildIndex_(index) {
      return index * 2 + 2;
    }
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */

  }, {
    key: "getParentIndex_",
    value: function getParentIndex_(index) {
      return index - 1 >> 1;
    }
    /**
     * Make this a heap. O(N).
     * @private
     */

  }, {
    key: "heapify_",
    value: function heapify_() {
      var i;

      for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
        this.siftUp_(i);
      }
    }
    /**
     * @return {boolean} Is empty.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.elements_.length === 0;
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */

  }, {
    key: "isKeyQueued",
    value: function isKeyQueued(key) {
      return key in this.queuedElements_;
    }
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */

  }, {
    key: "isQueued",
    value: function isQueued(element) {
      return this.isKeyQueued(this.keyFunction_(element));
    }
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */

  }, {
    key: "siftUp_",
    value: function siftUp_(index) {
      var elements = this.elements_;
      var priorities = this.priorities_;
      var count = elements.length;
      var element = elements[index];
      var priority = priorities[index];
      var startIndex = index;

      while (index < count >> 1) {
        var lIndex = this.getLeftChildIndex_(index);
        var rIndex = this.getRightChildIndex_(index);
        var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
        elements[index] = elements[smallerChildIndex];
        priorities[index] = priorities[smallerChildIndex];
        index = smallerChildIndex;
      }

      elements[index] = element;
      priorities[index] = priority;
      this.siftDown_(startIndex, index);
    }
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */

  }, {
    key: "siftDown_",
    value: function siftDown_(startIndex, index) {
      var elements = this.elements_;
      var priorities = this.priorities_;
      var element = elements[index];
      var priority = priorities[index];

      while (index > startIndex) {
        var parentIndex = this.getParentIndex_(index);

        if (priorities[parentIndex] > priority) {
          elements[index] = elements[parentIndex];
          priorities[index] = priorities[parentIndex];
          index = parentIndex;
        } else {
          break;
        }
      }

      elements[index] = element;
      priorities[index] = priority;
    }
    /**
     * FIXME empty description for jsdoc
     */

  }, {
    key: "reprioritize",
    value: function reprioritize() {
      var priorityFunction = this.priorityFunction_;
      var elements = this.elements_;
      var priorities = this.priorities_;
      var index = 0;
      var n = elements.length;
      var element, i, priority;

      for (i = 0; i < n; ++i) {
        element = elements[i];
        priority = priorityFunction(element);

        if (priority == DROP) {
          delete this.queuedElements_[this.keyFunction_(element)];
        } else {
          priorities[index] = priority;
          elements[index++] = element;
        }
      }

      elements.length = index;
      priorities.length = index;
      this.heapify_();
    }
  }]);

  return PriorityQueue;
}();

/* harmony default export */ var structs_PriorityQueue = (PriorityQueue);
;// CONCATENATED MODULE: ./node_modules/ol/TileState.js
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ var TileState = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,

  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
});
;// CONCATENATED MODULE: ./node_modules/ol/TileQueue.js








/**
 * @module ol/TileQueue
 */



/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */

var TileQueue = /*#__PURE__*/function (_PriorityQueue) {
  _inherits(TileQueue, _PriorityQueue);

  var _super = createSuper_createSuper(TileQueue);

  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  function TileQueue(tilePriorityFunction, tileChangeCallback) {
    var _this;

    _classCallCheck(this, TileQueue);

    _this = _super.call(this,
    /**
     * @param {Array} element Element.
     * @return {number} Priority.
     */
    function (element) {
      return tilePriorityFunction.apply(null, element);
    },
    /**
     * @param {Array} element Element.
     * @return {string} Key.
     */
    function (element) {
      return (
        /** @type {import("./Tile.js").default} */
        element[0].getKey()
      );
    });
    /** @private */

    _this.boundHandleTileChange_ = _this.handleTileChange.bind(assertThisInitialized_assertThisInitialized(_this));
    /**
     * @private
     * @type {function(): ?}
     */

    _this.tileChangeCallback_ = tileChangeCallback;
    /**
     * @private
     * @type {number}
     */

    _this.tilesLoading_ = 0;
    /**
     * @private
     * @type {!Object<string,boolean>}
     */

    _this.tilesLoadingKeys_ = {};
    return _this;
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */


  _createClass(TileQueue, [{
    key: "enqueue",
    value: function enqueue(element) {
      var added = _get(getPrototypeOf_getPrototypeOf(TileQueue.prototype), "enqueue", this).call(this, element);

      if (added) {
        var tile = element[0];
        tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
      }

      return added;
    }
    /**
     * @return {number} Number of tiles loading.
     */

  }, {
    key: "getTilesLoading",
    value: function getTilesLoading() {
      return this.tilesLoading_;
    }
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */

  }, {
    key: "handleTileChange",
    value: function handleTileChange(event) {
      var tile =
      /** @type {import("./Tile.js").default} */
      event.target;
      var state = tile.getState();

      if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {
        if (state !== TileState.ERROR) {
          tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
        }

        var tileKey = tile.getKey();

        if (tileKey in this.tilesLoadingKeys_) {
          delete this.tilesLoadingKeys_[tileKey];
          --this.tilesLoading_;
        }

        this.tileChangeCallback_();
      }
    }
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */

  }, {
    key: "loadMoreTiles",
    value: function loadMoreTiles(maxTotalLoading, maxNewLoads) {
      var newLoads = 0;
      var state, tile, tileKey;

      while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
        tile =
        /** @type {import("./Tile.js").default} */
        this.dequeue()[0];
        tileKey = tile.getKey();
        state = tile.getState();

        if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
          this.tilesLoadingKeys_[tileKey] = true;
          ++this.tilesLoading_;
          ++newLoads;
          tile.load();
        }
      }
    }
  }]);

  return TileQueue;
}(structs_PriorityQueue);

/* harmony default export */ var ol_TileQueue = (TileQueue);
/**
 * @param {import('./Map.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */

function TileQueue_getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }

  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  } // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels between
  // the center of the tile and the center of the viewport.  The factor of 65536
  // means that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.


  var center = frameState.viewState.center;
  var deltaX = tileCenter[0] - center[0];
  var deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
;// CONCATENATED MODULE: ./node_modules/ol/ViewHint.js
/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ var ViewHint = ({
  ANIMATING: 0,
  INTERACTING: 1
});
;// CONCATENATED MODULE: ./node_modules/ol/ViewProperty.js
/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ var ViewProperty = ({
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
});
;// CONCATENATED MODULE: ./node_modules/ol/tilegrid/common.js
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;
/**
 * Default tile size.
 * @type {number}
 */

var DEFAULT_TILE_SIZE = 256;
;// CONCATENATED MODULE: ./node_modules/ol/proj/Units.js
/**
 * @module ol/proj/Units
 */

/**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */

/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */
var unitByCode = {
  '9001': 'm',
  '9002': 'ft',
  '9003': 'us-ft',
  '9101': 'radians',
  '9102': 'degrees'
};
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */

function fromCode(code) {
  return unitByCode[code];
}
/**
 * @typedef {Object} MetersPerUnitLookup
 * @property {number} radians Radians
 * @property {number} degrees Degrees
 * @property {number} ft  Feet
 * @property {number} m Meters
 * @property {number} us-ft US feet
 */

/**
 * Meters per unit lookup table.
 * @const
 * @type {MetersPerUnitLookup}
 * @api
 */

var Units_METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  'radians': 6370997 / (2 * Math.PI),
  'degrees': 2 * Math.PI * 6370997 / 360,
  'ft': 0.3048,
  'm': 1,
  'us-ft': 1200 / 3937
};
;// CONCATENATED MODULE: ./node_modules/ol/proj/Projection.js



/**
 * @module ol/proj/Projection
 */

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */

var Projection = /*#__PURE__*/function () {
  /**
   * @param {Options} options Projection options.
   */
  function Projection(options) {
    _classCallCheck(this, Projection);

    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;
    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */

    this.units_ =
    /** @type {import("./Units.js").Units} */
    options.units;
    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = options.extent !== undefined ? options.extent : null;
    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
    /**
     * @private
     * @type {string}
     */

    this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
    /**
     * @private
     * @type {boolean}
     */

    this.global_ = options.global !== undefined ? options.global : false;
    /**
     * @private
     * @type {boolean}
     */

    this.canWrapX_ = !!(this.global_ && this.extent_);
    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */

    this.getPointResolutionFunc_ = options.getPointResolution;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    this.defaultTileGrid_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */


  _createClass(Projection, [{
    key: "canWrapX",
    value: function canWrapX() {
      return this.canWrapX_;
    }
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */

  }, {
    key: "getCode",
    value: function getCode() {
      return this.code_;
    }
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */

  }, {
    key: "getExtent",
    value: function getExtent() {
      return this.extent_;
    }
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").Units} Units.
     * @api
     */

  }, {
    key: "getUnits",
    value: function getUnits() {
      return this.units_;
    }
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */

  }, {
    key: "getMetersPerUnit",
    value: function getMetersPerUnit() {
      return this.metersPerUnit_ || Units_METERS_PER_UNIT[this.units_];
    }
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */

  }, {
    key: "getWorldExtent",
    value: function getWorldExtent() {
      return this.worldExtent_;
    }
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */

  }, {
    key: "getAxisOrientation",
    value: function getAxisOrientation() {
      return this.axisOrientation_;
    }
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */

  }, {
    key: "isGlobal",
    value: function isGlobal() {
      return this.global_;
    }
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */

  }, {
    key: "setGlobal",
    value: function setGlobal(global) {
      this.global_ = global;
      this.canWrapX_ = !!(global && this.extent_);
    }
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */

  }, {
    key: "getDefaultTileGrid",
    value: function getDefaultTileGrid() {
      return this.defaultTileGrid_;
    }
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */

  }, {
    key: "setDefaultTileGrid",
    value: function setDefaultTileGrid(tileGrid) {
      this.defaultTileGrid_ = tileGrid;
    }
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */

  }, {
    key: "setExtent",
    value: function setExtent(extent) {
      this.extent_ = extent;
      this.canWrapX_ = !!(this.global_ && extent);
    }
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */

  }, {
    key: "setWorldExtent",
    value: function setWorldExtent(worldExtent) {
      this.worldExtent_ = worldExtent;
    }
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */

  }, {
    key: "setGetPointResolution",
    value: function setGetPointResolution(func) {
      this.getPointResolutionFunc_ = func;
    }
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */

  }, {
    key: "getPointResolutionFunc",
    value: function getPointResolutionFunc() {
      return this.getPointResolutionFunc_;
    }
  }]);

  return Projection;
}();

/* harmony default export */ var proj_Projection = (Projection);
;// CONCATENATED MODULE: ./node_modules/ol/proj/epsg3857.js





/**
 * @module ol/proj/epsg3857
 */

/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */

var RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */

var HALF_SIZE = Math.PI * RADIUS;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

var WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */

var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */

var EPSG3857Projection = /*#__PURE__*/function (_Projection) {
  _inherits(EPSG3857Projection, _Projection);

  var _super = createSuper_createSuper(EPSG3857Projection);

  /**
   * @param {string} code Code.
   */
  function EPSG3857Projection(code) {
    _classCallCheck(this, EPSG3857Projection);

    return _super.call(this, {
      code: code,
      units: 'm',
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function getPointResolution(resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      }
    });
  }

  return _createClass(EPSG3857Projection);
}(proj_Projection);
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */

function fromEPSG4326(input, output, dimension) {
  var length = input.length;
  dimension = dimension > 1 ? dimension : 2;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));

    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }

    output[i + 1] = y;
  }

  return output;
}
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */

function toEPSG4326(input, output, dimension) {
  var length = input.length;
  dimension = dimension > 1 ? dimension : 2;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }

  return output;
}
;// CONCATENATED MODULE: ./node_modules/ol/proj/epsg4326.js





/**
 * @module ol/proj/epsg4326
 */

/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */

var epsg4326_RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */

var epsg4326_EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */

var epsg4326_METERS_PER_UNIT = Math.PI * epsg4326_RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */

var EPSG4326Projection = /*#__PURE__*/function (_Projection) {
  _inherits(EPSG4326Projection, _Projection);

  var _super = createSuper_createSuper(EPSG4326Projection);

  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  function EPSG4326Projection(code, axisOrientation) {
    _classCallCheck(this, EPSG4326Projection);

    return _super.call(this, {
      code: code,
      units: 'degrees',
      extent: epsg4326_EXTENT,
      axisOrientation: axisOrientation,
      global: true,
      metersPerUnit: epsg4326_METERS_PER_UNIT,
      worldExtent: epsg4326_EXTENT
    });
  }

  return _createClass(EPSG4326Projection);
}(proj_Projection);
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var epsg4326_PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu')];
;// CONCATENATED MODULE: ./node_modules/ol/proj/projections.js
/**
 * @module ol/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};
/**
 * Clear the projections cache.
 */

function clear() {
  cache = {};
}
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */

function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */

function projections_add(code, projection) {
  cache[code] = projection;
}
;// CONCATENATED MODULE: ./node_modules/ol/proj/transforms.js
/**
 * @module ol/proj/transforms
 */

/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */

var transforms = {};
/**
 * Clear the transform cache.
 */

function transforms_clear() {
  transforms = {};
}
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */

function transforms_add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();

  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }

  transforms[sourceCode][destinationCode] = transformFn;
}
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */

function transforms_remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];

  if (isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }

  return transform;
}
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */

function transforms_get(sourceCode, destinationCode) {
  var transform;

  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }

  return transform;
}
;// CONCATENATED MODULE: ./node_modules/ol/sphere.js
/**
 * @module ol/sphere
 */

/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */

var DEFAULT_RADIUS = 6371008.8;
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */

function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  var lat1 = math_toRadians(c1[1]);
  var lat2 = math_toRadians(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = math_toRadians(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */

function getLengthInternal(coordinates, radius) {
  var length = 0;

  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }

  return length;
}
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */


function getLength(geometry, options) {
  options = options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var length = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case 'Point':
    case 'MultiPoint':
      {
        break;
      }

    case 'LineString':
    case 'LinearRing':
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();
        length = getLengthInternal(coordinates, radius);
        break;
      }

    case 'MultiLineString':
    case 'Polygon':
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += getLengthInternal(coordinates[i], radius);
        }

        break;
      }

    case 'MultiPolygon':
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];

          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += getLengthInternal(coords[j], radius);
          }
        }

        break;
      }

    case 'GeometryCollection':
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += getLength(geometries[i], options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */

function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];

  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }

  return area * radius * radius / 2.0;
}
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */


function sphere_getArea(geometry, options) {
  options = options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var area = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'LinearRing':
      {
        break;
      }

    case 'Polygon':
      {
        coordinates =
        /** @type {import("./geom/Polygon.js").default} */
        geometry.getCoordinates();
        area = Math.abs(getAreaInternal(coordinates[0], radius));

        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(getAreaInternal(coordinates[i], radius));
        }

        break;
      }

    case 'MultiPolygon':
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(getAreaInternal(coords[0], radius));

          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }

        break;
      }

    case 'GeometryCollection':
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += sphere_getArea(geometries[i], options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return area;
}
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */

function offset(c1, distance, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  var lat1 = toRadians(c1[1]);
  var lon1 = toRadians(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [toDegrees(lon), toDegrees(lat)];
}
;// CONCATENATED MODULE: ./node_modules/ol/proj.js
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */










/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */



var showCoordinateWarning = true;
/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */

function disableCoordinateWarning(disable) {
  var hide = disable === undefined ? true : disable;
  showCoordinateWarning = !hide;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */

function cloneTransform(input, output, dimension) {
  if (output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }

    output = output;
  } else {
    output = input.slice();
  }

  return output;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */

function identityTransform(input, output, dimension) {
  if (output !== undefined && input !== output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }

    input = output;
  }

  return input;
}
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */

function addProjection(projection) {
  projections_add(projection.getCode(), projection);
  transforms_add(projection, projection, cloneTransform);
}
/**
 * @param {Array<Projection>} projections Projections.
 */

function addProjections(projections) {
  projections.forEach(addProjection);
}
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */

function proj_get(projectionLike) {
  return typeof projectionLike === 'string' ? get(
  /** @type {string} */
  projectionLike) :
  /** @type {Projection} */
  projectionLike || null;
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */

function getPointResolution(projection, resolution, point, units) {
  projection = proj_get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();

  if (getter) {
    pointResolution = getter(resolution, point);

    if (units && units !== projection.getUnits()) {
      var metersPerUnit = projection.getMetersPerUnit();

      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / Units_METERS_PER_UNIT[units];
      }
    }
  } else {
    var projUnits = projection.getUnits();

    if (projUnits == 'degrees' && !units || units == 'degrees') {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var _toEPSG = getTransformFromProjections(projection, proj_get('EPSG:4326'));

      if (_toEPSG === identityTransform && projUnits !== 'degrees') {
        // no transform is available
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
        vertices = _toEPSG(vertices, vertices, 2);
        var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }

      var _metersPerUnit = units ? Units_METERS_PER_UNIT[units] : projection.getMetersPerUnit();

      if (_metersPerUnit !== undefined) {
        pointResolution /= _metersPerUnit;
      }
    }
  }

  return pointResolution;
}
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */

function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        transforms_add(source, destination, cloneTransform);
      }
    });
  });
}
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */

function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      transforms_add(projection1, projection2, forwardTransform);
      transforms_add(projection2, projection1, inverseTransform);
    });
  });
}
/**
 * Clear all cached projections and transforms.
 */

function clearAllProjections() {
  clearProj();
  clearTransformFuncs();
}
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */

function createProjection(projection, defaultCode) {
  if (!projection) {
    return proj_get(defaultCode);
  } else if (typeof projection === 'string') {
    return proj_get(projection);
  } else {
    return (
      /** @type {Projection} */
      projection
    );
  }
}
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */

function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function (input, output, dimension) {
      var length = input.length;
      dimension = dimension !== undefined ? dimension : 2;
      output = output !== undefined ? output : new Array(length);

      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform(input.slice(i, i + dimension));
        var pointLength = point.length;

        for (var j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }

      return output;
    }
  );
}
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */

function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = proj_get(source);
  var destProj = proj_get(destination);
  transforms_add(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  transforms_add(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */

function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(coordinate, 'EPSG:4326', projection !== undefined ? projection : 'EPSG:3857');
}
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */

function toLonLat(coordinate, projection) {
  var lonLat = transform(coordinate, projection !== undefined ? projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];

  if (lon < -180 || lon > 180) {
    lonLat[0] = modulo(lon + 180, 360) - 180;
  }

  return lonLat;
}
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */

function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }

  var equalUnits = projection1.getUnits() === projection2.getUnits();

  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */

function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = transforms_get(sourceCode, destinationCode);

  if (!transformFunc) {
    transformFunc = identityTransform;
  }

  return transformFunc;
}
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */

function getTransform(source, destination) {
  var sourceProjection = proj_get(source);
  var destinationProjection = proj_get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */

function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */

function transformExtent(extent, source, destination, stops) {
  var transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, undefined, stops);
}
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */

function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}
/**
 * @type {Projection|null}
 */

var userProjection = null;
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */

function setUserProjection(projection) {
  userProjection = proj_get(projection);
}
/**
 * Clear the user projection if set.
 * @api
 */

function clearUserProjection() {
  userProjection = null;
}
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */

function getUserProjection() {
  return userProjection;
}
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API
 * methods except for those interacting with tile grids.
 * @api
 */

function useGeographic() {
  setUserProjection('EPSG:4326');
}
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */

function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }

  return transform(coordinate, sourceProjection, userProjection);
}
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */

function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !coordinate_equals(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false; // eslint-disable-next-line no-console

      console.warn('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');
    }

    return coordinate;
  }

  return transform(coordinate, userProjection, destProjection);
}
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */

function proj_toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, sourceProjection, userProjection);
}
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */

function proj_fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, userProjection, destProjection);
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */

function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }

  var sourceUnits = proj_get(sourceProjection).getUnits();
  var userUnits = userProjection.getUnits();
  return sourceUnits && userUnits ? resolution * Units_METERS_PER_UNIT[sourceUnits] / Units_METERS_PER_UNIT[userUnits] : resolution;
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */

function proj_fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }

  var sourceUnits = proj_get(destProjection).getUnits();
  var userUnits = userProjection.getUnits();
  return sourceUnits && userUnits ? resolution * METERS_PER_UNIT[userUnits] / METERS_PER_UNIT[sourceUnits] : resolution;
}
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
 */

function createSafeCoordinateTransform(sourceProj, destProj, transform) {
  return function (coord) {
    var transformed, worldsAway;

    if (sourceProj.canWrapX()) {
      var sourceExtent = sourceProj.getExtent();
      var sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);

      if (worldsAway) {
        // Move x to the real world
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }

      coord[0] = math_clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = math_clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform(coord);
    } else {
      transformed = transform(coord);
    }

    if (worldsAway && destProj.canWrapX()) {
      // Move transformed coordinate back to the offset world
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }

    return transformed;
  };
}
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */

function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(epsg4326_PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.

  addEquivalentTransforms(epsg4326_PROJECTIONS, PROJECTIONS, fromEPSG4326, toEPSG4326);
}
addCommon();
;// CONCATENATED MODULE: ./node_modules/ol/centerconstraint.js
/**
 * @module ol/centerconstraint
 */

/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */

function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return undefined;
      }

      if (!resolution && !onlyCenter) {
        return center;
      }

      var viewWidth = onlyCenter ? 0 : size[0] * resolution;
      var viewHeight = onlyCenter ? 0 : size[1] * resolution;
      var shiftX = centerShift ? centerShift[0] : 0;
      var shiftY = centerShift ? centerShift[1] : 0;
      var minX = extent[0] + viewWidth / 2 + shiftX;
      var maxX = extent[2] - viewWidth / 2 + shiftX;
      var minY = extent[1] + viewHeight / 2 + shiftY;
      var maxY = extent[3] - viewHeight / 2 + shiftY; // note: when zooming out of bounds, min and max values for x and y may
      // end up inverted (min > max); this has to be accounted for

      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }

      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }

      var x = math_clamp(center[0], minX, maxX);
      var y = math_clamp(center[1], minY, maxY); // during an interaction, allow some overscroll

      if (isMoving && smooth && resolution) {
        var ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }

      return [x, y];
    }
  );
}
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */

function none(center) {
  return center;
}
;// CONCATENATED MODULE: ./node_modules/ol/resolutionconstraint.js
/**
 * @module ol/resolutionconstraint
 */



/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */

/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */

function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = getWidth(maxExtent) / viewportSize[0];
  var yResolution = getHeight(maxExtent) / viewportSize[1];

  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }

  return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */


function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;

  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }

  return math_clamp(result, minResolution / 2, maxResolution * 2);
}
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== undefined ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        var maxResolution = resolutions[0];
        var minResolution = resolutions[resolutions.length - 1];
        var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values

        if (isMoving) {
          if (!smooth) {
            return math_clamp(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var capped = Math.min(cappedMaxRes, resolution);
        var z = Math.floor(linearFindNearest(resolutions, capped, direction));

        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }

        return resolutions[z];
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */

function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== undefined ? smooth : true;
  minResolution = minResolution !== undefined ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values

        if (isMoving) {
          if (!smooth) {
            return math_clamp(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var tolerance = 1e-9;
        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
        var offset = -direction * (0.5 - tolerance) + 0.5;
        var capped = Math.min(cappedMaxRes, resolution);
        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        var newResolution = maxResolution / Math.pow(power, zoomLevel);
        return math_clamp(newResolution, minResolution, cappedMaxRes);
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */

function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== undefined ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;

        if (!smooth || !isMoving) {
          return math_clamp(resolution, minResolution, cappedMaxRes);
        }

        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      } else {
        return undefined;
      }
    }
  );
}
;// CONCATENATED MODULE: ./node_modules/ol/rotationconstraint.js
/**
 * @module ol/rotationconstraint
 */

/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */

function disable(rotation) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
}
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */

function rotationconstraint_none(rotation) {
  if (rotation !== undefined) {
    return rotation;
  } else {
    return undefined;
  }
}
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */

function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */

function createSnapToZero(tolerance) {
  tolerance = tolerance || math_toRadians(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        if (Math.abs(rotation) <= tolerance) {
          return 0;
        } else {
          return rotation;
        }
      } else {
        return undefined;
      }
    }
  );
}
;// CONCATENATED MODULE: ./node_modules/ol/easing.js
/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function easeOut(t) {
  return 1 - easeIn(1 - t);
}
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function linear(t) {
  return t;
}
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/transform.js
/**
 * @module ol/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, dest) {
  dest = dest ? dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }

  if (dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */

function transform_rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */

function transform_scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */

function transform_translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/Geometry.js





/**
 * @module ol/geom/Geometry
 */







/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */

/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */

/**
 * @type {import("../transform.js").Transform}
 */

var tmpTransform = create();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */

var Geometry = /*#__PURE__*/function (_BaseObject) {
  _inherits(Geometry, _BaseObject);

  var _super = createSuper_createSuper(Geometry);

  function Geometry() {
    var _this;

    _classCallCheck(this, Geometry);

    _this = _super.call(this);
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.extent_ = createEmpty();
    /**
     * @private
     * @type {number}
     */

    _this.extentRevision_ = -1;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryRevision = 0;
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */

    _this.simplifyTransformedInternal = functions_memoizeOne(function (revision, squaredTolerance, transform) {
      if (!transform) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }

      var clone = this.clone();
      clone.applyTransform(transform);
      return clone.getSimplifiedGeometry(squaredTolerance);
    });
    return _this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */


  _createClass(Geometry, [{
    key: "simplifyTransformed",
    value: function simplifyTransformed(squaredTolerance, transform) {
      return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);
    }
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */

  }, {
    key: "clone",
    value: function clone() {
      return util_abstract();
    }
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */

  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      return util_abstract();
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */

  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      var coord = this.getClosestPoint([x, y]);
      return coord[0] === x && coord[1] === y;
    }
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */

  }, {
    key: "getClosestPoint",
    value: function getClosestPoint(point, closestPoint) {
      closestPoint = closestPoint ? closestPoint : [NaN, NaN];
      this.closestPointXY(point[0], point[1], closestPoint, Infinity);
      return closestPoint;
    }
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */

  }, {
    key: "intersectsCoordinate",
    value: function intersectsCoordinate(coordinate) {
      return this.containsXY(coordinate[0], coordinate[1]);
    }
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */

  }, {
    key: "computeExtent",
    value: function computeExtent(extent) {
      return util_abstract();
    }
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */

  }, {
    key: "getExtent",
    value: function getExtent(extent) {
      if (this.extentRevision_ != this.getRevision()) {
        var _extent = this.computeExtent(this.extent_);

        if (isNaN(_extent[0]) || isNaN(_extent[1])) {
          createOrUpdateEmpty(_extent);
        }

        this.extentRevision_ = this.getRevision();
      }

      return returnOrUpdate(this.extent_, extent);
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */

  }, {
    key: "rotate",
    value: function rotate(angle, anchor) {
      util_abstract();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */

  }, {
    key: "scale",
    value: function scale(sx, sy, anchor) {
      util_abstract();
    }
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */

  }, {
    key: "simplify",
    value: function simplify(tolerance) {
      return this.getSimplifiedGeometry(tolerance * tolerance);
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */

  }, {
    key: "getSimplifiedGeometry",
    value: function getSimplifiedGeometry(squaredTolerance) {
      return util_abstract();
    }
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {Type} Geometry type.
     */

  }, {
    key: "getType",
    value: function getType() {
      return util_abstract();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */

  }, {
    key: "applyTransform",
    value: function applyTransform(transformFn) {
      util_abstract();
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */

  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return util_abstract();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */

  }, {
    key: "translate",
    value: function translate(deltaX, deltaY) {
      util_abstract();
    }
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {Geometry} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */

  }, {
    key: "transform",
    value: function transform(source, destination) {
      /** @type {import("../proj/Projection.js").default} */
      var sourceProj = proj_get(source);
      var transformFn = sourceProj.getUnits() == 'tile-pixels' ? function (inCoordinates, outCoordinates, stride) {
        var pixelExtent = sourceProj.getExtent();
        var projectedExtent = sourceProj.getWorldExtent();
        var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
        compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
        transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
        return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
      } : getTransform(sourceProj, destination);
      this.applyTransform(transformFn);
      return this;
    }
  }]);

  return Geometry;
}(ol_Object);

/* harmony default export */ var geom_Geometry = (Geometry);
;// CONCATENATED MODULE: ./node_modules/ol/geom/SimpleGeometry.js





/**
 * @module ol/geom/SimpleGeometry
 */




/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */

var SimpleGeometry = /*#__PURE__*/function (_Geometry) {
  _inherits(SimpleGeometry, _Geometry);

  var _super = createSuper_createSuper(SimpleGeometry);

  function SimpleGeometry() {
    var _this;

    _classCallCheck(this, SimpleGeometry);

    _this = _super.call(this);
    /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */

    _this.layout = 'XY';
    /**
     * @protected
     * @type {number}
     */

    _this.stride = 2;
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.flatCoordinates = null;
    return _this;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  _createClass(SimpleGeometry, [{
    key: "computeExtent",
    value: function computeExtent(extent) {
      return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }
    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */

  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return util_abstract();
    }
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */

  }, {
    key: "getFirstCoordinate",
    value: function getFirstCoordinate() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */

  }, {
    key: "getFlatCoordinates",
    value: function getFlatCoordinates() {
      return this.flatCoordinates;
    }
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */

  }, {
    key: "getLastCoordinate",
    value: function getLastCoordinate() {
      return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
    }
    /**
     * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
     * @return {import("./Geometry.js").GeometryLayout} Layout.
     * @api
     */

  }, {
    key: "getLayout",
    value: function getLayout() {
      return this.layout;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     */

  }, {
    key: "getSimplifiedGeometry",
    value: function getSimplifiedGeometry(squaredTolerance) {
      if (this.simplifiedGeometryRevision !== this.getRevision()) {
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = this.getRevision();
      } // If squaredTolerance is negative or if we know that simplification will not
      // have any effect then just return this.


      if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
        return this;
      }

      var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();

      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
        return simplifiedGeometry;
      } else {
        // Simplification did not actually remove any coordinates.  We now know
        // that any calls to getSimplifiedGeometry with a squaredTolerance less
        // than or equal to the current squaredTolerance will also not have any
        // effect.  This allows us to short circuit simplification (saving CPU
        // cycles) and prevents the cache of simplified geometries from filling
        // up with useless identical copies of this geometry (saving memory).
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */

  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      return this;
    }
    /**
     * @return {number} Stride.
     */

  }, {
    key: "getStride",
    value: function getStride() {
      return this.stride;
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */

  }, {
    key: "setFlatCoordinates",
    value: function setFlatCoordinates(layout, flatCoordinates) {
      this.stride = getStrideForLayout(layout);
      this.layout = layout;
      this.flatCoordinates = flatCoordinates;
    }
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */

  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      util_abstract();
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */

  }, {
    key: "setLayout",
    value: function setLayout(layout, coordinates, nesting) {
      /** @type {number} */
      var stride;

      if (layout) {
        stride = getStrideForLayout(layout);
      } else {
        for (var i = 0; i < nesting; ++i) {
          if (coordinates.length === 0) {
            this.layout = 'XY';
            this.stride = 2;
            return;
          } else {
            coordinates =
            /** @type {Array} */
            coordinates[0];
          }
        }

        stride = coordinates.length;
        layout = getLayoutForStride(stride);
      }

      this.layout = layout;
      this.stride = stride;
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */

  }, {
    key: "applyTransform",
    value: function applyTransform(transformFn) {
      if (this.flatCoordinates) {
        transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
        this.changed();
      }
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */

  }, {
    key: "rotate",
    value: function rotate(angle, anchor) {
      var flatCoordinates = this.getFlatCoordinates();

      if (flatCoordinates) {
        var stride = this.getStride();

        transform_rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);

        this.changed();
      }
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */

  }, {
    key: "scale",
    value: function scale(sx, sy, anchor) {
      if (sy === undefined) {
        sy = sx;
      }

      if (!anchor) {
        anchor = getCenter(this.getExtent());
      }

      var flatCoordinates = this.getFlatCoordinates();

      if (flatCoordinates) {
        var stride = this.getStride();

        transform_scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);

        this.changed();
      }
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */

  }, {
    key: "translate",
    value: function translate(deltaX, deltaY) {
      var flatCoordinates = this.getFlatCoordinates();

      if (flatCoordinates) {
        var stride = this.getStride();

        transform_translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);

        this.changed();
      }
    }
  }]);

  return SimpleGeometry;
}(geom_Geometry);
/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */


function getLayoutForStride(stride) {
  var layout;

  if (stride == 2) {
    layout = 'XY';
  } else if (stride == 3) {
    layout = 'XYZ';
  } else if (stride == 4) {
    layout = 'XYZM';
  }

  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */


function getStrideForLayout(layout) {
  var stride;

  if (layout == 'XY') {
    stride = 2;
  } else if (layout == 'XYZ' || layout == 'XYM') {
    stride = 3;
  } else if (layout == 'XYZM') {
    stride = 4;
  }

  return (
    /** @type {number} */
    stride
  );
}
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */

function transformGeom2D(simpleGeometry, transform, dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();

  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);
  }
}
/* harmony default export */ var geom_SimpleGeometry = (SimpleGeometry);
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/closest.js
/**
 * @module ol/geom/flat/closest
 */

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */

function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;

  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }

      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }

  for (var _i = 0; _i < stride; ++_i) {
    closestPoint[_i] = flatCoordinates[offset + _i];
  }

  closestPoint.length = stride;
}
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];

  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = math_squaredDistance(x1, y1, x2, y2);

    if (squaredDelta > max) {
      max = squaredDelta;
    }

    x1 = x2;
    y1 = y2;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */

function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */

function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */

function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }

  var i, squaredDistance;

  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = math_squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);

    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }

  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  var index = offset + stride;

  while (index < end) {
    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = math_squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }

  if (isRing) {
    // Check the closing segment.
    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = math_squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
    }
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */

function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */

function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }

  return minSquaredDistance;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/deflate.js
/**
 * @module ol/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */

function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];

    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */

function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  var i = 0;

  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }

  ends.length = i;
  return ends;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */

function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  var i = 0;

  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);

    if (ends.length === 0) {
      ends[0] = offset;
    }

    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }

  endss.length = i;
  return endss;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/simplify.js
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */

function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
  simplifiedFlatCoordinates = simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];

  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }

  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */

function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;

  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }
  /** @type {Array<number>} */


  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */

  var stack = [offset, end - stride];
  var index = 0;

  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];

    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];

      var _squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);

      if (_squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = _squaredDistance;
      }
    }

    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;

      if (first + stride < index) {
        stack.push(first, index);
      }

      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }

  for (var _i = 0; _i < n; ++_i) {
    if (markers[_i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + _i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + _i * stride + 1];
    }
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */

function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */

function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */

function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1]; // copy first point

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;

  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];

    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }

  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }

  return simplifiedOffset;
}
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */

function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */

function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  } // snap the first coordinate (P1)


  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride; // add the first coordinate to the output

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)

  var x2, y2;

  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;

    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);

  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride; // skip P3 if it is equal to P2

    if (x3 == x2 && y3 == y2) {
      continue;
    } // calculate the delta between P1 and P2


    var dx1 = x2 - x1;
    var dy1 = y2 - y1; // calculate the delta between P3 and P1

    var dx2 = x3 - x1;
    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3

    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3


    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  } // add the last point (P2)


  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */

function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */

function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/inflate.js
/**
 * @module ol/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates) {
  coordinates = coordinates !== undefined ? coordinates : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }

  coordinates.length = i;
  return coordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */

function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== undefined ? coordinatess : [];
  var i = 0;

  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }

  coordinatess.length = i;
  return coordinatess;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */

function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
  var i = 0;

  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }

  coordinatesss.length = i;
  return coordinatesss;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/area.js
/**
 * @module ol/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }

  return twiceArea / 2;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */

function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }

  return area;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */

function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }

  return area;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/LinearRing.js





/**
 * @module ol/geom/LinearRing
 */







/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */

var LinearRing = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(LinearRing, _SimpleGeometry);

  var _super = createSuper_createSuper(LinearRing);

  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  function LinearRing(coordinates, layout) {
    var _this;

    _classCallCheck(this, LinearRing);

    _this = _super.call(this);
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, layout);
    }

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */


  _createClass(LinearRing, [{
    key: "clone",
    value: function clone() {
      return new LinearRing(this.flatCoordinates.slice(), this.layout);
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */

  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }

      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }

      return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */

  }, {
    key: "getArea",
    value: function getArea() {
      return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */

  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     */

  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      var simplifiedFlatCoordinates = [];
      simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
      return new LinearRing(simplifiedFlatCoordinates, 'XY');
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */

  }, {
    key: "getType",
    value: function getType() {
      return 'LinearRing';
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */

  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return false;
    }
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */

  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 1);

      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }

      this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
      this.changed();
    }
  }]);

  return LinearRing;
}(geom_SimpleGeometry);

/* harmony default export */ var geom_LinearRing = (LinearRing);
;// CONCATENATED MODULE: ./node_modules/ol/geom/Point.js





/**
 * @module ol/geom/Point
 */




/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */

var Point = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(Point, _SimpleGeometry);

  var _super = createSuper_createSuper(Point);

  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  function Point(coordinates, layout) {
    var _this;

    _classCallCheck(this, Point);

    _this = _super.call(this);

    _this.setCoordinates(coordinates, layout);

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */


  _createClass(Point, [{
    key: "clone",
    value: function clone() {
      var point = new Point(this.flatCoordinates.slice(), this.layout);
      point.applyProperties(this);
      return point;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */

  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      var flatCoordinates = this.flatCoordinates;
      var squaredDistance = math_squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);

      if (squaredDistance < minSquaredDistance) {
        var stride = this.stride;

        for (var i = 0; i < stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }

        closestPoint.length = stride;
        return squaredDistance;
      } else {
        return minSquaredDistance;
      }
    }
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     */

  }, {
    key: "getCoordinates",
    value: function getCoordinates() {
      return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */

  }, {
    key: "computeExtent",
    value: function computeExtent(extent) {
      return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */

  }, {
    key: "getType",
    value: function getType() {
      return 'Point';
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */

  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */

  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 0);

      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }

      this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
      this.changed();
    }
  }]);

  return Point;
}(geom_SimpleGeometry);

/* harmony default export */ var geom_Point = (Point);
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/contains.js
/**
 * @module ol/geom/flat/contains
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */

function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = forEachCorner(extent,
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */

function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // https://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }

    x1 = x2;
    y1 = y2;
  }

  return wn !== 0;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */

function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }

  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */

function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/interiorpoint.js
/**
 * @module ol/geom/flat/interiorpoint
 */


/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */

function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */

  var intersections = []; // Calculate intersections with the horizontal line

  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];

    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];

      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }

      x1 = x2;
      y1 = y2;
    }
  } // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.


  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(numberSafeCompareFunction);
  x1 = intersections[0];

  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);

    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;

      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }

    x1 = x2;
  }

  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }

  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */

function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }

  return interiorPoints;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/segments.js
/**
 * @module ol/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  var ret;
  offset += stride;

  for (; offset < end; offset += stride) {
    ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));

    if (ret) {
      return ret;
    }
  }

  return false;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/intersectsextent.js
/**
 * @module ol/geom/flat/intersectsextent
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);

  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }

  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }

  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }

  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }

  return forEach(flatCoordinates, offset, end, stride,
  /**
   * @param {import("../../coordinate.js").Coordinate} point1 Start point.
   * @param {import("../../coordinate.js").Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return intersectsSegment(extent, point1, point2);
  });
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }

    offset = ends[i];
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }

  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }

  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }

  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }

  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }

  if (ends.length === 1) {
    return true;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/reverse.js
/**
 * @module ol/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }

    offset += stride;
    end -= stride;
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/orient.js
/**
 * @module ol/geom/flat/orient
 */

/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */

function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // https://stackoverflow.com/q/1165647/clockwise-method#1165943
  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }

  return edge === 0 ? undefined : edge > 0;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */

function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== undefined ? right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);

    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }

    offset = end;
  }

  return true;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */

function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }

    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }

  return true;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */

function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== undefined ? right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;

    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }

    offset = end;
  }

  return offset;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */

function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);
  }

  return offset;
}
/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to contruct a MultiPolygon
 */

function inflateEnds(flatCoordinates, ends) {
  var endss = [];
  var offset = 0;
  var prevEndIndex = 0;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i]; // classifies an array of rings into polygons with outer rings and holes

    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }

      endss[endss.length - 1].push(ends[prevEndIndex]);
    }

    prevEndIndex = i + 1;
    offset = end;
  }

  return endss;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/Polygon.js





/**
 * @module ol/geom/Polygon
 */
















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */

var Polygon = /*#__PURE__*/function (_SimpleGeometry) {
  _inherits(Polygon, _SimpleGeometry);

  var _super = createSuper_createSuper(Polygon);

  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  function Polygon(coordinates, layout, ends) {
    var _this;

    _classCallCheck(this, Polygon);

    _this = _super.call(this);
    /**
     * @type {Array<number>}
     * @private
     */

    _this.ends_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.flatInteriorPointRevision_ = -1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.flatInteriorPoint_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.orientedRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.orientedFlatCoordinates_ = null;

    if (layout !== undefined && ends) {
      _this.setFlatCoordinates(layout,
      /** @type {Array<number>} */
      coordinates);

      _this.ends_ = ends;
    } else {
      _this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, layout);
    }

    return _this;
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */


  _createClass(Polygon, [{
    key: "appendLinearRing",
    value: function appendLinearRing(linearRing) {
      if (!this.flatCoordinates) {
        this.flatCoordinates = linearRing.getFlatCoordinates().slice();
      } else {
        array_extend(this.flatCoordinates, linearRing.getFlatCoordinates());
      }

      this.ends_.push(this.flatCoordinates.length);
      this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     */

  }, {
    key: "clone",
    value: function clone() {
      var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      polygon.applyProperties(this);
      return polygon;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */

  }, {
    key: "closestPointXY",
    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }

      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }

      return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */

  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    }
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */

  }, {
    key: "getArea",
    value: function getArea() {
      return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */

  }, {
    key: "getCoordinates",
    value: function getCoordinates(right) {
      var flatCoordinates;

      if (right !== undefined) {
        flatCoordinates = this.getOrientedFlatCoordinates().slice();
        orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
      } else {
        flatCoordinates = this.flatCoordinates;
      }

      return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
     * @return {Array<number>} Ends.
     */

  }, {
    key: "getEnds",
    value: function getEnds() {
      return this.ends_;
    }
    /**
     * @return {Array<number>} Interior point.
     */

  }, {
    key: "getFlatInteriorPoint",
    value: function getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        var flatCenter = getCenter(this.getExtent());
        this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
        this.flatInteriorPointRevision_ = this.getRevision();
      }

      return this.flatInteriorPoint_;
    }
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */

  }, {
    key: "getInteriorPoint",
    value: function getInteriorPoint() {
      return new geom_Point(this.getFlatInteriorPoint(), 'XYM');
    }
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */

  }, {
    key: "getLinearRingCount",
    value: function getLinearRingCount() {
      return this.ends_.length;
    }
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */

  }, {
    key: "getLinearRing",
    value: function getLinearRing(index) {
      if (index < 0 || this.ends_.length <= index) {
        return null;
      }

      return new geom_LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */

  }, {
    key: "getLinearRings",
    value: function getLinearRings() {
      var layout = this.layout;
      var flatCoordinates = this.flatCoordinates;
      var ends = this.ends_;
      var linearRings = [];
      var offset = 0;

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var linearRing = new geom_LinearRing(flatCoordinates.slice(offset, end), layout);
        linearRings.push(linearRing);
        offset = end;
      }

      return linearRings;
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */

  }, {
    key: "getOrientedFlatCoordinates",
    value: function getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        var flatCoordinates = this.flatCoordinates;

        if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
          this.orientedFlatCoordinates_ = flatCoordinates;
        } else {
          this.orientedFlatCoordinates_ = flatCoordinates.slice();
          this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
        }

        this.orientedRevision_ = this.getRevision();
      }

      return this.orientedFlatCoordinates_;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     */

  }, {
    key: "getSimplifiedGeometryInternal",
    value: function getSimplifiedGeometryInternal(squaredTolerance) {
      var simplifiedFlatCoordinates = [];
      var simplifiedEnds = [];
      simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
      return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */

  }, {
    key: "getType",
    value: function getType() {
      return 'Polygon';
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */

  }, {
    key: "intersectsExtent",
    value: function intersectsExtent(extent) {
      return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    }
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */

  }, {
    key: "setCoordinates",
    value: function setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 2);

      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }

      var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
      this.changed();
    }
  }]);

  return Polygon;
}(geom_SimpleGeometry);

/* harmony default export */ var geom_Polygon = (Polygon);
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */

function circular(center, radius, n, sphereRadius) {
  n = n ? n : 32;
  /** @type {Array<number>} */

  var flatCoordinates = [];

  for (var i = 0; i < n; ++i) {
    extend(flatCoordinates, sphereOffset(center, radius, 2 * Math.PI * i / n, sphereRadius));
  }

  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */

function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */

function fromCircle(circle, sides, angle) {
  sides = sides ? sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);

  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;

    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }

  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle);
  return polygon;
}
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */

function makeRegular(polygon, center, radius, angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = angle ? angle : 0;

  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;

    var _angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;

    flatCoordinates[offset] = center[0] + radius * Math.cos(_angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(_angle);
  }

  polygon.changed();
}
;// CONCATENATED MODULE: ./node_modules/ol/View.js





/**
 * @module ol/View
 */
















/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */

/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */

/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */

/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */

/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center.
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */

/**
 * Default min zoom level for the map view.
 * @type {number}
 */

var DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */

/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */

var View = /*#__PURE__*/function (_BaseObject) {
  _inherits(View, _BaseObject);

  var _super = createSuper_createSuper(View);

  /**
   * @param {ViewOptions} [options] View options.
   */
  function View(options) {
    var _this;

    _classCallCheck(this, View);

    _this = _super.call(this);
    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */

    _this.on;
    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {ViewOnSignature<void>}
     */

    _this.un;
    options = Object.assign({}, options);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.hints_ = [0, 0];
    /**
     * @private
     * @type {Array<Array<Animation>>}
     */

    _this.animations_ = [];
    /**
     * @private
     * @type {number|undefined}
     */

    _this.updateAnimationKey_;
    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */

    _this.projection_ = createProjection(options.projection, 'EPSG:3857');
    /**
     * @private
     * @type {import("./size.js").Size}
     */

    _this.viewportSize_ = [100, 100];
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.targetCenter_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetResolution_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */

    _this.nextCenter_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.nextResolution_;
    /**
     * @private
     * @type {number}
     */

    _this.nextRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.cancelAnchor_ = undefined;

    if (options.projection) {
      disableCoordinateWarning();
    }

    if (options.center) {
      options.center = fromUserCoordinate(options.center, _this.projection_);
    }

    if (options.extent) {
      options.extent = proj_fromUserExtent(options.extent, _this.projection_);
    }

    _this.applyOptions_(options);

    return _this;
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */


  _createClass(View, [{
    key: "applyOptions_",
    value: function applyOptions_(options) {
      var properties = Object.assign({}, options);

      for (var key in ViewProperty) {
        delete properties[key];
      }

      this.setProperties(properties, true);
      var resolutionConstraintInfo = createResolutionConstraint(options);
      /**
       * @private
       * @type {number}
       */

      this.maxResolution_ = resolutionConstraintInfo.maxResolution;
      /**
       * @private
       * @type {number}
       */

      this.minResolution_ = resolutionConstraintInfo.minResolution;
      /**
       * @private
       * @type {number}
       */

      this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
      /**
       * @private
       * @type {Array<number>|undefined}
       */

      this.resolutions_ = options.resolutions;
      /**
       * @type {Array<number>|undefined}
       * @private
       */

      this.padding_ = options.padding;
      /**
       * @private
       * @type {number}
       */

      this.minZoom_ = resolutionConstraintInfo.minZoom;
      var centerConstraint = createCenterConstraint(options);
      var resolutionConstraint = resolutionConstraintInfo.constraint;
      var rotationConstraint = createRotationConstraint(options);
      /**
       * @private
       * @type {Constraints}
       */

      this.constraints_ = {
        center: centerConstraint,
        resolution: resolutionConstraint,
        rotation: rotationConstraint
      };
      this.setRotation(options.rotation !== undefined ? options.rotation : 0);
      this.setCenterInternal(options.center !== undefined ? options.center : null);

      if (options.resolution !== undefined) {
        this.setResolution(options.resolution);
      } else if (options.zoom !== undefined) {
        this.setZoom(options.zoom);
      }
    }
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */

  }, {
    key: "padding",
    get: function get() {
      return this.padding_;
    },
    set: function set(padding) {
      var oldPadding = this.padding_;
      this.padding_ = padding;
      var center = this.getCenter();

      if (center) {
        var newPadding = padding || [0, 0, 0, 0];
        oldPadding = oldPadding || [0, 0, 0, 0];
        var resolution = this.getResolution();
        var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
        var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
        this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
      }
    }
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */

  }, {
    key: "getUpdatedOptions_",
    value: function getUpdatedOptions_(newOptions) {
      var options = this.getProperties(); // preserve resolution (or zoom)

      if (options.resolution !== undefined) {
        options.resolution = this.getResolution();
      } else {
        options.zoom = this.getZoom();
      } // preserve center


      options.center = this.getCenterInternal(); // preserve rotation

      options.rotation = this.getRotation();
      return Object.assign({}, options, newOptions);
    }
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */

  }, {
    key: "animate",
    value: function animate(var_args) {
      if (this.isDef() && !this.getAnimating()) {
        this.resolveConstraints(0);
      }

      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; ++i) {
        var options = arguments[i];

        if (options.center) {
          options = Object.assign({}, options);
          options.center = fromUserCoordinate(options.center, this.getProjection());
        }

        if (options.anchor) {
          options = Object.assign({}, options);
          options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
        }

        args[i] = options;
      }

      this.animateInternal.apply(this, args);
    }
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */

  }, {
    key: "animateInternal",
    value: function animateInternal(var_args) {
      var animationCount = arguments.length;
      var callback;

      if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
        callback = arguments[animationCount - 1];
        --animationCount;
      }

      var i = 0;

      for (; i < animationCount && !this.isDef(); ++i) {
        // if view properties are not yet set, shortcut to the final state
        var state = arguments[i];

        if (state.center) {
          this.setCenterInternal(state.center);
        }

        if (state.zoom !== undefined) {
          this.setZoom(state.zoom);
        } else if (state.resolution) {
          this.setResolution(state.resolution);
        }

        if (state.rotation !== undefined) {
          this.setRotation(state.rotation);
        }
      }

      if (i === animationCount) {
        if (callback) {
          animationCallback(callback, true);
        }

        return;
      }

      var start = Date.now();
      var center = this.targetCenter_.slice();
      var resolution = this.targetResolution_;
      var rotation = this.targetRotation_;
      var series = [];

      for (; i < animationCount; ++i) {
        var options =
        /** @type {AnimationOptions} */
        arguments[i];
        var animation = {
          start: start,
          complete: false,
          anchor: options.anchor,
          duration: options.duration !== undefined ? options.duration : 1000,
          easing: options.easing || inAndOut,
          callback: callback
        };

        if (options.center) {
          animation.sourceCenter = center;
          animation.targetCenter = options.center.slice();
          center = animation.targetCenter;
        }

        if (options.zoom !== undefined) {
          animation.sourceResolution = resolution;
          animation.targetResolution = this.getResolutionForZoom(options.zoom);
          resolution = animation.targetResolution;
        } else if (options.resolution) {
          animation.sourceResolution = resolution;
          animation.targetResolution = options.resolution;
          resolution = animation.targetResolution;
        }

        if (options.rotation !== undefined) {
          animation.sourceRotation = rotation;
          var delta = math_modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
          animation.targetRotation = rotation + delta;
          rotation = animation.targetRotation;
        } // check if animation is a no-op


        if (isNoopAnimation(animation)) {
          animation.complete = true; // we still push it onto the series for callback handling
        } else {
          start += animation.duration;
        }

        series.push(animation);
      }

      this.animations_.push(series);
      this.setHint(ViewHint.ANIMATING, 1);
      this.updateAnimations_();
    }
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */

  }, {
    key: "getAnimating",
    value: function getAnimating() {
      return this.hints_[ViewHint.ANIMATING] > 0;
    }
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */

  }, {
    key: "getInteracting",
    value: function getInteracting() {
      return this.hints_[ViewHint.INTERACTING] > 0;
    }
    /**
     * Cancel any ongoing animations.
     * @api
     */

  }, {
    key: "cancelAnimations",
    value: function cancelAnimations() {
      this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
      var anchor;

      for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
        var series = this.animations_[i];

        if (series[0].callback) {
          animationCallback(series[0].callback, false);
        }

        if (!anchor) {
          for (var j = 0, jj = series.length; j < jj; ++j) {
            var animation = series[j];

            if (!animation.complete) {
              anchor = animation.anchor;
              break;
            }
          }
        }
      }

      this.animations_.length = 0;
      this.cancelAnchor_ = anchor;
      this.nextCenter_ = null;
      this.nextResolution_ = NaN;
      this.nextRotation_ = NaN;
    }
    /**
     * Update all animations.
     */

  }, {
    key: "updateAnimations_",
    value: function updateAnimations_() {
      if (this.updateAnimationKey_ !== undefined) {
        cancelAnimationFrame(this.updateAnimationKey_);
        this.updateAnimationKey_ = undefined;
      }

      if (!this.getAnimating()) {
        return;
      }

      var now = Date.now();
      var more = false;

      for (var i = this.animations_.length - 1; i >= 0; --i) {
        var series = this.animations_[i];
        var seriesComplete = true;

        for (var j = 0, jj = series.length; j < jj; ++j) {
          var animation = series[j];

          if (animation.complete) {
            continue;
          }

          var elapsed = now - animation.start;
          var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;

          if (fraction >= 1) {
            animation.complete = true;
            fraction = 1;
          } else {
            seriesComplete = false;
          }

          var progress = animation.easing(fraction);

          if (animation.sourceCenter) {
            var x0 = animation.sourceCenter[0];
            var y0 = animation.sourceCenter[1];
            var x1 = animation.targetCenter[0];
            var y1 = animation.targetCenter[1];
            this.nextCenter_ = animation.targetCenter;
            var x = x0 + progress * (x1 - x0);
            var y = y0 + progress * (y1 - y0);
            this.targetCenter_ = [x, y];
          }

          if (animation.sourceResolution && animation.targetResolution) {
            var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);

            if (animation.anchor) {
              var size = this.getViewportSize_(this.getRotation());
              var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
              this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
            }

            this.nextResolution_ = animation.targetResolution;
            this.targetResolution_ = resolution;
            this.applyTargetState_(true);
          }

          if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
            var rotation = progress === 1 ? math_modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);

            if (animation.anchor) {
              var constrainedRotation = this.constraints_.rotation(rotation, true);
              this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
            }

            this.nextRotation_ = animation.targetRotation;
            this.targetRotation_ = rotation;
          }

          this.applyTargetState_(true);
          more = true;

          if (!animation.complete) {
            break;
          }
        }

        if (seriesComplete) {
          this.animations_[i] = null;
          this.setHint(ViewHint.ANIMATING, -1);
          this.nextCenter_ = null;
          this.nextResolution_ = NaN;
          this.nextRotation_ = NaN;
          var callback = series[0].callback;

          if (callback) {
            animationCallback(callback, true);
          }
        }
      } // prune completed series


      this.animations_ = this.animations_.filter(Boolean);

      if (more && this.updateAnimationKey_ === undefined) {
        this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
      }
    }
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */

  }, {
    key: "calculateCenterRotate",
    value: function calculateCenterRotate(rotation, anchor) {
      var center;
      var currentCenter = this.getCenterInternal();

      if (currentCenter !== undefined) {
        center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
        coordinate_rotate(center, rotation - this.getRotation());
        add(center, anchor);
      }

      return center;
    }
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */

  }, {
    key: "calculateCenterZoom",
    value: function calculateCenterZoom(resolution, anchor) {
      var center;
      var currentCenter = this.getCenterInternal();
      var currentResolution = this.getResolution();

      if (currentCenter !== undefined && currentResolution !== undefined) {
        var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
        var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
        center = [x, y];
      }

      return center;
    }
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */

  }, {
    key: "getViewportSize_",
    value: function getViewportSize_(rotation) {
      var size = this.viewportSize_;

      if (rotation) {
        var w = size[0];
        var h = size[1];
        return [Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)), Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))];
      } else {
        return size;
      }
    }
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
     */

  }, {
    key: "setViewportSize",
    value: function setViewportSize(size) {
      this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];

      if (!this.getAnimating()) {
        this.resolveConstraints(0);
      }
    }
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */

  }, {
    key: "getCenter",
    value: function getCenter() {
      var center = this.getCenterInternal();

      if (!center) {
        return center;
      }

      return toUserCoordinate(center, this.getProjection());
    }
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */

  }, {
    key: "getCenterInternal",
    value: function getCenterInternal() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(ViewProperty.CENTER)
      );
    }
    /**
     * @return {Constraints} Constraints.
     */

  }, {
    key: "getConstraints",
    value: function getConstraints() {
      return this.constraints_;
    }
    /**
     * @return {boolean} Resolution constraint is set
     */

  }, {
    key: "getConstrainResolution",
    value: function getConstrainResolution() {
      return this.get('constrainResolution');
    }
    /**
     * @param {Array<number>} [hints] Destination array.
     * @return {Array<number>} Hint.
     */

  }, {
    key: "getHints",
    value: function getHints(hints) {
      if (hints !== undefined) {
        hints[0] = this.hints_[0];
        hints[1] = this.hints_[1];
        return hints;
      } else {
        return this.hints_.slice();
      }
    }
    /**
     * Calculate the extent for the current view state and the passed size.
     * The size is the pixel dimensions of the box into which the calculated extent
     * should fit. In most cases you want to get the extent of the entire map,
     * that is `map.getSize()`.
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
     * of the map that uses this view will be used.
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */

  }, {
    key: "calculateExtent",
    value: function calculateExtent(size) {
      var extent = this.calculateExtentInternal(size);
      return proj_toUserExtent(extent, this.getProjection());
    }
    /**
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */

  }, {
    key: "calculateExtentInternal",
    value: function calculateExtentInternal(size) {
      size = size || this.getViewportSizeMinusPadding_();
      var center =
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal();
      asserts_assert(center, 1); // The view center is not defined

      var resolution =
      /** @type {!number} */
      this.getResolution();
      asserts_assert(resolution !== undefined, 2); // The view resolution is not defined

      var rotation =
      /** @type {!number} */
      this.getRotation();
      asserts_assert(rotation !== undefined, 3); // The view rotation is not defined

      return getForViewAndSize(center, resolution, rotation, size);
    }
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */

  }, {
    key: "getMaxResolution",
    value: function getMaxResolution() {
      return this.maxResolution_;
    }
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */

  }, {
    key: "getMinResolution",
    value: function getMinResolution() {
      return this.minResolution_;
    }
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */

  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.minResolution_)
      );
    }
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */

  }, {
    key: "setMaxZoom",
    value: function setMaxZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({
        maxZoom: zoom
      }));
    }
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */

  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.maxResolution_)
      );
    }
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */

  }, {
    key: "setMinZoom",
    value: function setMinZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({
        minZoom: zoom
      }));
    }
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */

  }, {
    key: "setConstrainResolution",
    value: function setConstrainResolution(enabled) {
      this.applyOptions_(this.getUpdatedOptions_({
        constrainResolution: enabled
      }));
    }
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */

  }, {
    key: "getProjection",
    value: function getProjection() {
      return this.projection_;
    }
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */

  }, {
    key: "getResolution",
    value: function getResolution() {
      return (
        /** @type {number|undefined} */
        this.get(ViewProperty.RESOLUTION)
      );
    }
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */

  }, {
    key: "getResolutions",
    value: function getResolutions() {
      return this.resolutions_;
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */

  }, {
    key: "getResolutionForExtent",
    value: function getResolutionForExtent(extent, size) {
      return this.getResolutionForExtentInternal(proj_fromUserExtent(extent, this.getProjection()), size);
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */

  }, {
    key: "getResolutionForExtentInternal",
    value: function getResolutionForExtentInternal(extent, size) {
      size = size || this.getViewportSizeMinusPadding_();
      var xResolution = getWidth(extent) / size[0];
      var yResolution = getHeight(extent) / size[1];
      return Math.max(xResolution, yResolution);
    }
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Resolution for value function.
     */

  }, {
    key: "getResolutionForValueFunction",
    value: function getResolutionForValueFunction(power) {
      power = power || 2;
      var maxResolution = this.getConstrainedResolution(this.maxResolution_);
      var minResolution = this.minResolution_;
      var max = Math.log(maxResolution / minResolution) / Math.log(power);
      return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function (value) {
          var resolution = maxResolution / Math.pow(power, value * max);
          return resolution;
        }
      );
    }
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */

  }, {
    key: "getRotation",
    value: function getRotation() {
      return (
        /** @type {number} */
        this.get(ViewProperty.ROTATION)
      );
    }
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Value for resolution function.
     */

  }, {
    key: "getValueForResolutionFunction",
    value: function getValueForResolutionFunction(power) {
      var logPower = Math.log(power || 2);
      var maxResolution = this.getConstrainedResolution(this.maxResolution_);
      var minResolution = this.minResolution_;
      var max = Math.log(maxResolution / minResolution) / logPower;
      return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function (resolution) {
          var value = Math.log(maxResolution / resolution) / logPower / max;
          return value;
        }
      );
    }
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */

  }, {
    key: "getViewportSizeMinusPadding_",
    value: function getViewportSizeMinusPadding_(rotation) {
      var size = this.getViewportSize_(rotation);
      var padding = this.padding_;

      if (padding) {
        size = [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]];
      }

      return size;
    }
    /**
     * @return {State} View state.
     */

  }, {
    key: "getState",
    value: function getState() {
      var projection = this.getProjection();
      var resolution = this.getResolution();
      var rotation = this.getRotation();
      var center =
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal();
      var padding = this.padding_;

      if (padding) {
        var reducedSize = this.getViewportSizeMinusPadding_();
        center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      }

      return {
        center: center.slice(0),
        projection: projection !== undefined ? projection : null,
        resolution: resolution,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation: rotation,
        zoom: this.getZoom()
      };
    }
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */

  }, {
    key: "getZoom",
    value: function getZoom() {
      var zoom;
      var resolution = this.getResolution();

      if (resolution !== undefined) {
        zoom = this.getZoomForResolution(resolution);
      }

      return zoom;
    }
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */

  }, {
    key: "getZoomForResolution",
    value: function getZoomForResolution(resolution) {
      var offset = this.minZoom_ || 0;
      var max, zoomFactor;

      if (this.resolutions_) {
        var nearest = linearFindNearest(this.resolutions_, resolution, 1);
        offset = nearest;
        max = this.resolutions_[nearest];

        if (nearest == this.resolutions_.length - 1) {
          zoomFactor = 2;
        } else {
          zoomFactor = max / this.resolutions_[nearest + 1];
        }
      } else {
        max = this.maxResolution_;
        zoomFactor = this.zoomFactor_;
      }

      return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    }
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */

  }, {
    key: "getResolutionForZoom",
    value: function getResolutionForZoom(zoom) {
      if (this.resolutions_) {
        if (this.resolutions_.length <= 1) {
          return 0;
        }

        var baseLevel = math_clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
        var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
        return this.resolutions_[baseLevel] / Math.pow(zoomFactor, math_clamp(zoom - baseLevel, 0, 1));
      } else {
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
    }
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [options] Options.
     * @api
     */

  }, {
    key: "fit",
    value: function fit(geometryOrExtent, options) {
      /** @type {import("./geom/SimpleGeometry.js").default} */
      var geometry;
      asserts_assert(Array.isArray(geometryOrExtent) || typeof
      /** @type {?} */
      geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`

      if (Array.isArray(geometryOrExtent)) {
        asserts_assert(!extent_isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`

        var extent = proj_fromUserExtent(geometryOrExtent, this.getProjection());
        geometry = fromExtent(extent);
      } else if (geometryOrExtent.getType() === 'Circle') {
        var _extent = proj_fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());

        geometry = fromExtent(_extent);
        geometry.rotate(this.getRotation(), getCenter(_extent));
      } else {
        var userProjection = getUserProjection();

        if (userProjection) {
          geometry =
          /** @type {import("./geom/SimpleGeometry.js").default} */
          geometryOrExtent.clone().transform(userProjection, this.getProjection());
        } else {
          geometry = geometryOrExtent;
        }
      }

      this.fitInternal(geometry, options);
    }
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */

  }, {
    key: "rotatedExtentForGeometry",
    value: function rotatedExtentForGeometry(geometry) {
      var rotation = this.getRotation();
      var cosAngle = Math.cos(rotation);
      var sinAngle = Math.sin(-rotation);
      var coords = geometry.getFlatCoordinates();
      var stride = geometry.getStride();
      var minRotX = +Infinity;
      var minRotY = +Infinity;
      var maxRotX = -Infinity;
      var maxRotY = -Infinity;

      for (var i = 0, ii = coords.length; i < ii; i += stride) {
        var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
        var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
        minRotX = Math.min(minRotX, rotX);
        minRotY = Math.min(minRotY, rotY);
        maxRotX = Math.max(maxRotX, rotX);
        maxRotY = Math.max(maxRotY, rotY);
      }

      return [minRotX, minRotY, maxRotX, maxRotY];
    }
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [options] Options.
     */

  }, {
    key: "fitInternal",
    value: function fitInternal(geometry, options) {
      options = options || {};
      var size = options.size;

      if (!size) {
        size = this.getViewportSizeMinusPadding_();
      }

      var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
      var nearest = options.nearest !== undefined ? options.nearest : false;
      var minResolution;

      if (options.minResolution !== undefined) {
        minResolution = options.minResolution;
      } else if (options.maxZoom !== undefined) {
        minResolution = this.getResolutionForZoom(options.maxZoom);
      } else {
        minResolution = 0;
      }

      var rotatedExtent = this.rotatedExtentForGeometry(geometry); // calculate resolution

      var resolution = this.getResolutionForExtentInternal(rotatedExtent, [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
      resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
      resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1); // calculate center

      var rotation = this.getRotation();
      var sinAngle = Math.sin(rotation);
      var cosAngle = Math.cos(rotation);
      var centerRot = getCenter(rotatedExtent);
      centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
      centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
      var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
      var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
      var center = this.getConstrainedCenter([centerX, centerY], resolution);
      var callback = options.callback ? options.callback : VOID;

      if (options.duration !== undefined) {
        this.animateInternal({
          resolution: resolution,
          center: center,
          duration: options.duration,
          easing: options.easing
        }, callback);
      } else {
        this.targetResolution_ = resolution;
        this.targetCenter_ = center;
        this.applyTargetState_(false, true);
        animationCallback(callback, true);
      }
    }
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */

  }, {
    key: "centerOn",
    value: function centerOn(coordinate, size, position) {
      this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
    }
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */

  }, {
    key: "centerOnInternal",
    value: function centerOnInternal(coordinate, size, position) {
      this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    }
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */

  }, {
    key: "calculateCenterShift",
    value: function calculateCenterShift(center, resolution, rotation, size) {
      var centerShift;
      var padding = this.padding_;

      if (padding && center) {
        var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
        var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
        centerShift = [center[0] - shiftedCenter[0], center[1] - shiftedCenter[1]];
      }

      return centerShift;
    }
    /**
     * @return {boolean} Is defined.
     */

  }, {
    key: "isDef",
    value: function isDef() {
      return !!this.getCenterInternal() && this.getResolution() !== undefined;
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */

  }, {
    key: "adjustCenter",
    value: function adjustCenter(deltaCoordinates) {
      var center = toUserCoordinate(this.targetCenter_, this.getProjection());
      this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */

  }, {
    key: "adjustCenterInternal",
    value: function adjustCenterInternal(deltaCoordinates) {
      var center = this.targetCenter_;
      this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */

  }, {
    key: "adjustResolution",
    value: function adjustResolution(ratio, anchor) {
      anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
      this.adjustResolutionInternal(ratio, anchor);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */

  }, {
    key: "adjustResolutionInternal",
    value: function adjustResolutionInternal(ratio, anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      var size = this.getViewportSize_(this.getRotation());
      var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);

      if (anchor) {
        this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
      }

      this.targetResolution_ *= ratio;
      this.applyTargetState_();
    }
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */

  }, {
    key: "adjustZoom",
    value: function adjustZoom(delta, anchor) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     * @api
     */

  }, {
    key: "adjustRotation",
    value: function adjustRotation(delta, anchor) {
      if (anchor) {
        anchor = fromUserCoordinate(anchor, this.getProjection());
      }

      this.adjustRotationInternal(delta, anchor);
    }
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     */

  }, {
    key: "adjustRotationInternal",
    value: function adjustRotationInternal(delta, anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);

      if (anchor) {
        this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
      }

      this.targetRotation_ += delta;
      this.applyTargetState_();
    }
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */

  }, {
    key: "setCenter",
    value: function setCenter(center) {
      this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);
    }
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */

  }, {
    key: "setCenterInternal",
    value: function setCenterInternal(center) {
      this.targetCenter_ = center;
      this.applyTargetState_();
    }
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */

  }, {
    key: "setHint",
    value: function setHint(hint, delta) {
      this.hints_[hint] += delta;
      this.changed();
      return this.hints_[hint];
    }
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */

  }, {
    key: "setResolution",
    value: function setResolution(resolution) {
      this.targetResolution_ = resolution;
      this.applyTargetState_();
    }
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */

  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.targetRotation_ = rotation;
      this.applyTargetState_();
    }
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */

  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.setResolution(this.getResolutionForZoom(zoom));
    }
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
     * @private
     */

  }, {
    key: "applyTargetState_",
    value: function applyTargetState_(doNotCancelAnims, forceMoving) {
      var isMoving = this.getAnimating() || this.getInteracting() || forceMoving; // compute rotation

      var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
      var size = this.getViewportSize_(newRotation);
      var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
      var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

      if (this.get(ViewProperty.ROTATION) !== newRotation) {
        this.set(ViewProperty.ROTATION, newRotation);
      }

      if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
        this.set(ViewProperty.RESOLUTION, newResolution);
        this.set('zoom', this.getZoom(), true);
      }

      if (!newCenter || !this.get(ViewProperty.CENTER) || !coordinate_equals(this.get(ViewProperty.CENTER), newCenter)) {
        this.set(ViewProperty.CENTER, newCenter);
      }

      if (this.getAnimating() && !doNotCancelAnims) {
        this.cancelAnimations();
      }

      this.cancelAnchor_ = undefined;
    }
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [duration] The animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */

  }, {
    key: "resolveConstraints",
    value: function resolveConstraints(duration, resolutionDirection, anchor) {
      duration = duration !== undefined ? duration : 200;
      var direction = resolutionDirection || 0;
      var newRotation = this.constraints_.rotation(this.targetRotation_);
      var size = this.getViewportSize_(newRotation);
      var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
      var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

      if (duration === 0 && !this.cancelAnchor_) {
        this.targetResolution_ = newResolution;
        this.targetRotation_ = newRotation;
        this.targetCenter_ = newCenter;
        this.applyTargetState_();
        return;
      }

      anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
      this.cancelAnchor_ = undefined;

      if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !coordinate_equals(this.getCenterInternal(), newCenter)) {
        if (this.getAnimating()) {
          this.cancelAnimations();
        }

        this.animateInternal({
          rotation: newRotation,
          center: newCenter,
          resolution: newResolution,
          duration: duration,
          easing: easeOut,
          anchor: anchor
        });
      }
    }
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */

  }, {
    key: "beginInteraction",
    value: function beginInteraction() {
      this.resolveConstraints(0);
      this.setHint(ViewHint.INTERACTING, 1);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */

  }, {
    key: "endInteraction",
    value: function endInteraction(duration, resolutionDirection, anchor) {
      anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
      this.endInteractionInternal(duration, resolutionDirection, anchor);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */

  }, {
    key: "endInteractionInternal",
    value: function endInteractionInternal(duration, resolutionDirection, anchor) {
      this.setHint(ViewHint.INTERACTING, -1);
      this.resolveConstraints(duration, resolutionDirection, anchor);
    }
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */

  }, {
    key: "getConstrainedCenter",
    value: function getConstrainedCenter(targetCenter, targetResolution) {
      var size = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
    }
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */

  }, {
    key: "getConstrainedZoom",
    value: function getConstrainedZoom(targetZoom, direction) {
      var targetRes = this.getResolutionForZoom(targetZoom);
      return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));
    }
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */

  }, {
    key: "getConstrainedResolution",
    value: function getConstrainedResolution(targetResolution, direction) {
      direction = direction || 0;
      var size = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(targetResolution, direction, size);
    }
  }]);

  return View;
}(ol_Object);
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */


function animationCallback(callback, returnValue) {
  setTimeout(function () {
    callback(returnValue);
  }, 0);
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */


function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    var smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }

  var projection = createProjection(options.projection, 'EPSG:3857');

  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }

  return none;
}
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */

function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution; // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076

  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
  var projection = createProjection(options.projection, 'EPSG:3857');
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent = options.extent;

  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];

    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  } else {
    // calculate the default min and max resolution
    var size = !projExtent ? // use an extent that can fit the whole world if need be
    360 * Units_METERS_PER_UNIT.degrees / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));
    var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence

    maxResolution = options.maxResolution;

    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    } // user provided minResolution takes precedence


    minResolution = options.minResolution;

    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    } // given discrete zoom levels, minResolution may be different than provided


    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  }

  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor
  };
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */

function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;

  if (enableRotation) {
    var constrainRotation = options.constrainRotation;

    if (constrainRotation === undefined || constrainRotation === true) {
      return createSnapToZero();
    } else if (constrainRotation === false) {
      return rotationconstraint_none;
    } else if (typeof constrainRotation === 'number') {
      return createSnapToN(constrainRotation);
    } else {
      return rotationconstraint_none;
    }
  } else {
    return disable;
  }
}
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */

function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!coordinate_equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }

  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }

  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }

  return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */

function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  // calculate rotated position
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle

  sinAngle = -sinAngle; // go back to original rotation

  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}

/* harmony default export */ var ol_View = (View);
;// CONCATENATED MODULE: ./node_modules/ol/control/Control.js







/**
 * @module ol/control/Control
 */





/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */

var Control_Control = /*#__PURE__*/function (_BaseObject) {
  _inherits(Control, _BaseObject);

  var _super = createSuper_createSuper(Control);

  /**
   * @param {Options} options Control options.
   */
  function Control(options) {
    var _this;

    _classCallCheck(this, Control);

    _this = _super.call(this);
    var element = options.element;

    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = 'auto';
    }
    /**
     * @protected
     * @type {HTMLElement}
     */


    _this.element = element ? element : null;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.target_ = null;
    /**
     * @private
     * @type {import("../Map.js").default|null}
     */

    _this.map_ = null;
    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */

    _this.listenerKeys = [];

    if (options.render) {
      _this.render = options.render;
    }

    if (options.target) {
      _this.setTarget(options.target);
    }

    return _this;
  }
  /**
   * Clean up.
   */


  _createClass(Control, [{
    key: "disposeInternal",
    value: function disposeInternal() {
      removeNode(this.element);

      _get(getPrototypeOf_getPrototypeOf(Control.prototype), "disposeInternal", this).call(this);
    }
    /**
     * Get the map associated with this control.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */

  }, {
    key: "getMap",
    value: function getMap() {
      return this.map_;
    }
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */

  }, {
    key: "setMap",
    value: function setMap(map) {
      if (this.map_) {
        removeNode(this.element);
      }

      for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
        unlistenByKey(this.listenerKeys[i]);
      }

      this.listenerKeys.length = 0;
      this.map_ = map;

      if (map) {
        var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
        target.appendChild(this.element);

        if (this.render !== VOID) {
          this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
        }

        map.render();
      }
    }
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */

  }, {
    key: "render",
    value: function render(mapEvent) {}
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */

  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
    }
  }]);

  return Control;
}(ol_Object);

/* harmony default export */ var control_Control = (Control_Control);
;// CONCATENATED MODULE: ./node_modules/ol/control/Attribution.js






/**
 * @module ol/control/Attribution
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */

var Attribution = /*#__PURE__*/function (_Control) {
  _inherits(Attribution, _Control);

  var _super = createSuper_createSuper(Attribution);

  /**
   * @param {Options} [options] Attribution options.
   */
  function Attribution(options) {
    var _this;

    _classCallCheck(this, Attribution);

    options = options ? options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    });
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.ulElement_ = document.createElement('ul');
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.userCollapsed_ = _this.collapsed_;
    /**
     * @private
     * @type {boolean}
     */

    _this.overrideCollapsible_ = options.collapsible !== undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }

    var className = options.className !== undefined ? options.className : 'ol-attribution';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
    var expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "\u203A";
    var collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collapse';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
      _this.collapseLabel_.className = collapseClassName;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
      _this.label_.className = expandClassName;
    } else {
      _this.label_ = label;
    }

    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.toggleButton_ = document.createElement('button');

    _this.toggleButton_.setAttribute('type', 'button');

    _this.toggleButton_.setAttribute('aria-expanded', String(!_this.collapsed_));

    _this.toggleButton_.title = tipLabel;

    _this.toggleButton_.appendChild(activeLabel);

    _this.toggleButton_.addEventListener(EventType.CLICK, _this.handleClick_.bind(assertThisInitialized_assertThisInitialized(_this)), false);

    var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.toggleButton_);
    element.appendChild(_this.ulElement_);
    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */

    _this.renderedAttributions_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */


  _createClass(Attribution, [{
    key: "collectSourceAttributions_",
    value: function collectSourceAttributions_(frameState) {
      /**
       * Used to determine if an attribution already exists.
       * @type {!Object<string, boolean>}
       */
      var lookup = {};
      /**
       * A list of visible attributions.
       * @type {Array<string>}
       */

      var visibleAttributions = [];
      var collapsible = true;
      var layerStatesArray = frameState.layerStatesArray;

      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        var layerState = layerStatesArray[i];

        if (!inView(layerState, frameState.viewState)) {
          continue;
        }

        var source =
        /** @type {import("../layer/Layer.js").default} */
        layerState.layer.getSource();

        if (!source) {
          continue;
        }

        var attributionGetter = source.getAttributions();

        if (!attributionGetter) {
          continue;
        }

        var attributions = attributionGetter(frameState);

        if (!attributions) {
          continue;
        }

        collapsible = collapsible && source.getAttributionsCollapsible() !== false;

        if (Array.isArray(attributions)) {
          for (var j = 0, jj = attributions.length; j < jj; ++j) {
            if (!(attributions[j] in lookup)) {
              visibleAttributions.push(attributions[j]);
              lookup[attributions[j]] = true;
            }
          }
        } else {
          if (!(attributions in lookup)) {
            visibleAttributions.push(attributions);
            lookup[attributions] = true;
          }
        }
      }

      if (!this.overrideCollapsible_) {
        this.setCollapsible(collapsible);
      }

      return visibleAttributions;
    }
    /**
     * @private
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */

  }, {
    key: "updateElement_",
    value: function updateElement_(frameState) {
      if (!frameState) {
        if (this.renderedVisible_) {
          this.element.style.display = 'none';
          this.renderedVisible_ = false;
        }

        return;
      }

      var attributions = this.collectSourceAttributions_(frameState);
      var visible = attributions.length > 0;

      if (this.renderedVisible_ != visible) {
        this.element.style.display = visible ? '' : 'none';
        this.renderedVisible_ = visible;
      }

      if (equals(attributions, this.renderedAttributions_)) {
        return;
      }

      removeChildren(this.ulElement_); // append the attributions

      for (var i = 0, ii = attributions.length; i < ii; ++i) {
        var element = document.createElement('li');
        element.innerHTML = attributions[i];
        this.ulElement_.appendChild(element);
      }

      this.renderedAttributions_ = attributions;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */

  }, {
    key: "handleClick_",
    value: function handleClick_(event) {
      event.preventDefault();
      this.handleToggle_();
      this.userCollapsed_ = this.collapsed_;
    }
    /**
     * @private
     */

  }, {
    key: "handleToggle_",
    value: function handleToggle_() {
      this.element.classList.toggle(CLASS_COLLAPSED);

      if (this.collapsed_) {
        replaceNode(this.collapseLabel_, this.label_);
      } else {
        replaceNode(this.label_, this.collapseLabel_);
      }

      this.collapsed_ = !this.collapsed_;
      this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    }
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */

  }, {
    key: "getCollapsible",
    value: function getCollapsible() {
      return this.collapsible_;
    }
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */

  }, {
    key: "setCollapsible",
    value: function setCollapsible(collapsible) {
      if (this.collapsible_ === collapsible) {
        return;
      }

      this.collapsible_ = collapsible;
      this.element.classList.toggle('ol-uncollapsible');

      if (this.userCollapsed_) {
        this.handleToggle_();
      }
    }
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */

  }, {
    key: "setCollapsed",
    value: function setCollapsed(collapsed) {
      this.userCollapsed_ = collapsed;

      if (!this.collapsible_ || this.collapsed_ === collapsed) {
        return;
      }

      this.handleToggle_();
    }
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */

  }, {
    key: "getCollapsed",
    value: function getCollapsed() {
      return this.collapsed_;
    }
    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */

  }, {
    key: "render",
    value: function render(mapEvent) {
      this.updateElement_(mapEvent.frameState);
    }
  }]);

  return Attribution;
}(control_Control);

/* harmony default export */ var control_Attribution = (Attribution);
;// CONCATENATED MODULE: ./node_modules/ol/control/Rotate.js






/**
 * @module ol/control/Rotate
 */




/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */

var Rotate = /*#__PURE__*/function (_Control) {
  _inherits(Rotate, _Control);

  var _super = createSuper_createSuper(Rotate);

  /**
   * @param {Options} [options] Rotate options.
   */
  function Rotate(options) {
    var _this;

    _classCallCheck(this, Rotate);

    options = options ? options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    });
    var className = options.className !== undefined ? options.className : 'ol-rotate';
    var label = options.label !== undefined ? options.label : "\u21E7";
    var compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';
    /**
     * @type {HTMLElement}
     * @private
     */

    _this.label_ = null;

    if (typeof label === 'string') {
      _this.label_ = document.createElement('span');
      _this.label_.className = compassClassName;
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;

      _this.label_.classList.add(compassClassName);
    }

    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(_this.label_);
    button.addEventListener(EventType.CLICK, _this.handleClick_.bind(assertThisInitialized_assertThisInitialized(_this)), false);
    var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @type {boolean}
     * @private
     */

    _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;

    if (_this.autoHide_) {
      _this.element.classList.add(CLASS_HIDDEN);
    }

    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  _createClass(Rotate, [{
    key: "handleClick_",
    value: function handleClick_(event) {
      event.preventDefault();

      if (this.callResetNorth_ !== undefined) {
        this.callResetNorth_();
      } else {
        this.resetNorth_();
      }
    }
    /**
     * @private
     */

  }, {
    key: "resetNorth_",
    value: function resetNorth_() {
      var map = this.getMap();
      var view = map.getView();

      if (!view) {
        // the map does not have a view, so we can't act
        // upon it
        return;
      }

      var rotation = view.getRotation();

      if (rotation !== undefined) {
        if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
          view.animate({
            rotation: 0,
            duration: this.duration_,
            easing: easeOut
          });
        } else {
          view.setRotation(0);
        }
      }
    }
    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */

  }, {
    key: "render",
    value: function render(mapEvent) {
      var frameState = mapEvent.frameState;

      if (!frameState) {
        return;
      }

      var rotation = frameState.viewState.rotation;

      if (rotation != this.rotation_) {
        var transform = 'rotate(' + rotation + 'rad)';

        if (this.autoHide_) {
          var contains = this.element.classList.contains(CLASS_HIDDEN);

          if (!contains && rotation === 0) {
            this.element.classList.add(CLASS_HIDDEN);
          } else if (contains && rotation !== 0) {
            this.element.classList.remove(CLASS_HIDDEN);
          }
        }

        this.label_.style.transform = transform;
      }

      this.rotation_ = rotation;
    }
  }]);

  return Rotate;
}(control_Control);

/* harmony default export */ var control_Rotate = (Rotate);
;// CONCATENATED MODULE: ./node_modules/ol/control/Zoom.js






/**
 * @module ol/control/Zoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */

var Zoom_Zoom = /*#__PURE__*/function (_Control) {
  _inherits(Zoom, _Control);

  var _super = createSuper_createSuper(Zoom);

  /**
   * @param {Options} [options] Zoom options.
   */
  function Zoom(options) {
    var _this;

    _classCallCheck(this, Zoom);

    options = options ? options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    });
    var className = options.className !== undefined ? options.className : 'ol-zoom';
    var delta = options.delta !== undefined ? options.delta : 1;
    var zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
    var zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : "\u2013";
    var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
    var inElement = document.createElement('button');
    inElement.className = zoomInClassName;
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(assertThisInitialized_assertThisInitialized(_this), delta), false);
    var outElement = document.createElement('button');
    outElement.className = zoomOutClassName;
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(assertThisInitialized_assertThisInitialized(_this), -delta), false);
    var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */


  _createClass(Zoom, [{
    key: "handleClick_",
    value: function handleClick_(delta, event) {
      event.preventDefault();
      this.zoomByDelta_(delta);
    }
    /**
     * @param {number} delta Zoom delta.
     * @private
     */

  }, {
    key: "zoomByDelta_",
    value: function zoomByDelta_(delta) {
      var map = this.getMap();
      var view = map.getView();

      if (!view) {
        // the map does not have a view, so we can't act
        // upon it
        return;
      }

      var currentZoom = view.getZoom();

      if (currentZoom !== undefined) {
        var newZoom = view.getConstrainedZoom(currentZoom + delta);

        if (this.duration_ > 0) {
          if (view.getAnimating()) {
            view.cancelAnimations();
          }

          view.animate({
            zoom: newZoom,
            duration: this.duration_,
            easing: easeOut
          });
        } else {
          view.setZoom(newZoom);
        }
      }
    }
  }]);

  return Zoom;
}(control_Control);

/* harmony default export */ var control_Zoom = (Zoom_Zoom);
;// CONCATENATED MODULE: ./node_modules/ol/control/defaults.js
/**
 * @module ol/control/defaults
 */




/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 */

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [options] Options for the default controls.
 * @return {Collection<import("./Control.js").default>} A collection of controls
 * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
 * @api
 */

function defaults(options) {
  options = options ? options : {};
  /** @type {Collection<import("./Control.js").default>} */

  var controls = new ol_Collection();
  var zoomControl = options.zoom !== undefined ? options.zoom : true;

  if (zoomControl) {
    controls.push(new control_Zoom(options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;

  if (rotateControl) {
    controls.push(new control_Rotate(options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;

  if (attributionControl) {
    controls.push(new control_Attribution(options.attributionOptions));
  }

  return controls;
}
;// CONCATENATED MODULE: ./node_modules/ol/interaction/Property.js
/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ var interaction_Property = ({
  ACTIVE: 'active'
});
;// CONCATENATED MODULE: ./node_modules/ol/interaction/Interaction.js





/**
 * @module ol/interaction/Interaction
 */



/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */

/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */

var Interaction_Interaction = /*#__PURE__*/function (_BaseObject) {
  _inherits(Interaction, _BaseObject);

  var _super = createSuper_createSuper(Interaction);

  /**
   * @param {InteractionOptions} [options] Options.
   */
  function Interaction(options) {
    var _this;

    _classCallCheck(this, Interaction);

    _this = _super.call(this);
    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {InteractionOnSignature<void>}
     */

    _this.un;

    if (options && options.handleEvent) {
      _this.handleEvent = options.handleEvent;
    }
    /**
     * @private
     * @type {import("../Map.js").default|null}
     */


    _this.map_ = null;

    _this.setActive(true);

    return _this;
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */


  _createClass(Interaction, [{
    key: "getActive",
    value: function getActive() {
      return (
        /** @type {boolean} */
        this.get(interaction_Property.ACTIVE)
      );
    }
    /**
     * Get the map associated with this interaction.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */

  }, {
    key: "getMap",
    value: function getMap() {
      return this.map_;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */

  }, {
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      return true;
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */

  }, {
    key: "setActive",
    value: function setActive(active) {
      this.set(interaction_Property.ACTIVE, active);
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     */

  }, {
    key: "setMap",
    value: function setMap(map) {
      this.map_ = map;
    }
  }]);

  return Interaction;
}(ol_Object);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [duration] Duration.
 */


function pan(view, delta, duration) {
  var currentCenter = view.getCenterInternal();

  if (currentCenter) {
    var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== undefined ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
 * @param {number} [duration] Duration.
 */

function zoomByDelta(view, delta, anchor, duration) {
  var currentZoom = view.getZoom();

  if (currentZoom === undefined) {
    return;
  }

  var newZoom = view.getConstrainedZoom(currentZoom + delta);
  var newResolution = view.getResolutionForZoom(newZoom);

  if (view.getAnimating()) {
    view.cancelAnimations();
  }

  view.animate({
    resolution: newResolution,
    anchor: anchor,
    duration: duration !== undefined ? duration : 250,
    easing: easeOut
  });
}
/* harmony default export */ var interaction_Interaction = (Interaction_Interaction);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/DoubleClickZoom.js





/**
 * @module ol/interaction/DoubleClickZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */

var DoubleClickZoom = /*#__PURE__*/function (_Interaction) {
  _inherits(DoubleClickZoom, _Interaction);

  var _super = createSuper_createSuper(DoubleClickZoom);

  /**
   * @param {Options} [options] Options.
   */
  function DoubleClickZoom(options) {
    var _this;

    _classCallCheck(this, DoubleClickZoom);

    _this = _super.call(this);
    options = options ? options : {};
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  _createClass(DoubleClickZoom, [{
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      var stopEvent = false;

      if (mapBrowserEvent.type == ol_MapBrowserEventType.DBLCLICK) {
        var browserEvent =
        /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent;
        var map = mapBrowserEvent.map;
        var anchor = mapBrowserEvent.coordinate;
        var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
        var view = map.getView();
        zoomByDelta(view, delta, anchor, this.duration_);
        browserEvent.preventDefault();
        stopEvent = true;
      }

      return !stopEvent;
    }
  }]);

  return DoubleClickZoom;
}(interaction_Interaction);

/* harmony default export */ var interaction_DoubleClickZoom = (DoubleClickZoom);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/Pointer.js





/**
 * @module ol/interaction/Pointer
 */


/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */

var PointerInteraction = /*#__PURE__*/function (_Interaction) {
  _inherits(PointerInteraction, _Interaction);

  var _super = createSuper_createSuper(PointerInteraction);

  /**
   * @param {Options} [options] Options.
   */
  function PointerInteraction(options) {
    var _this;

    _classCallCheck(this, PointerInteraction);

    options = options ? options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options);

    if (options.handleDownEvent) {
      _this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      _this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      _this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      _this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      _this.stopDown = options.stopDown;
    }
    /**
     * @type {boolean}
     * @protected
     */


    _this.handlingDownUpSequence = false;
    /**
     * @type {Array<PointerEvent>}
     * @protected
     */

    _this.targetPointers = [];
    return _this;
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */


  _createClass(PointerInteraction, [{
    key: "getPointerCount",
    value: function getPointerCount() {
      return this.targetPointers.length;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */

  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      return false;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */

  }, {
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {}
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */

  }, {
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      if (!mapBrowserEvent.originalEvent) {
        return true;
      }

      var stopEvent = false;
      this.updateTrackedPointers_(mapBrowserEvent);

      if (this.handlingDownUpSequence) {
        if (mapBrowserEvent.type == ol_MapBrowserEventType.POINTERDRAG) {
          this.handleDragEvent(mapBrowserEvent); // prevent page scrolling during dragging

          mapBrowserEvent.originalEvent.preventDefault();
        } else if (mapBrowserEvent.type == ol_MapBrowserEventType.POINTERUP) {
          var handledUp = this.handleUpEvent(mapBrowserEvent);
          this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
        }
      } else {
        if (mapBrowserEvent.type == ol_MapBrowserEventType.POINTERDOWN) {
          var handled = this.handleDownEvent(mapBrowserEvent);
          this.handlingDownUpSequence = handled;
          stopEvent = this.stopDown(handled);
        } else if (mapBrowserEvent.type == ol_MapBrowserEventType.POINTERMOVE) {
          this.handleMoveEvent(mapBrowserEvent);
        }
      }

      return !stopEvent;
    }
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */

  }, {
    key: "handleMoveEvent",
    value: function handleMoveEvent(mapBrowserEvent) {}
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */

  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      return false;
    }
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */

  }, {
    key: "stopDown",
    value: function stopDown(handled) {
      return handled;
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */

  }, {
    key: "updateTrackedPointers_",
    value: function updateTrackedPointers_(mapBrowserEvent) {
      if (mapBrowserEvent.activePointers) {
        this.targetPointers = mapBrowserEvent.activePointers;
      }
    }
  }]);

  return PointerInteraction;
}(interaction_Interaction);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */


function Pointer_centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;

  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }

  return [clientX / length, clientY / length];
}
/* harmony default export */ var Pointer = (PointerInteraction);
;// CONCATENATED MODULE: ./node_modules/ol/events/condition.js
/**
 * @module ol/events/condition
 */




/**
 * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */

/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */

function condition_all(var_args) {
  var conditions = arguments;
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */

  return function (event) {
    var pass = true;

    for (var i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);

      if (!pass) {
        break;
      }
    }

    return pass;
  };
}
/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */

var altKeyOnly = function altKeyOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */

var altShiftKeysOnly = function altShiftKeysOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */

var condition_focus = function focus(event) {
  var targetElement = event.map.getTargetElement();
  var activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
/**
 * Return `true` if the map has the focus or no 'tabindex' attribute set.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map container has the focus or no 'tabindex' attribute.
 */

var focusWithTabindex = function focusWithTabindex(event) {
  return event.map.getTargetElement().hasAttribute('tabindex') ? condition_focus(event) : true;
};
/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */

var always = TRUE;
/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */

var click = function click(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.CLICK;
};
/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */

var mouseActionButton = function mouseActionButton(mapBrowserEvent) {
  var originalEvent =
  /** @type {MouseEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(has_WEBKIT && has_MAC && originalEvent.ctrlKey);
};
/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */

var never = (/* unused pure expression or super */ null && (FALSE));
/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */

var pointerMove = function pointerMove(mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};
/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */

var singleClick = function singleClick(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
};
/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */

var doubleClick = function doubleClick(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;
};
/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */

var noModifierKeys = function noModifierKeys(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */

var platformModifierKeyOnly = function platformModifierKeyOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */

var shiftKeyOnly = function shiftKeyOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the target element is not editable, i.e. not an `input`,
 * `select`, or `textarea` element and no `contenteditable` attribute is
 * set or inherited, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */

var targetNotEditable = function targetNotEditable(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  var tagName =
  /** @type {Element} */
  originalEvent.target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA' && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};
/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */

var mouseOnly = function mouseOnly(mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  asserts_assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvent.pointerType == 'mouse';
};
/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */

var touchOnly = function touchOnly(mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'touch';
};
/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */

var penOnly = function penOnly(mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'pen';
};
/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See https://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */

var primaryAction = function primaryAction(mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  asserts_assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event

  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
;// CONCATENATED MODULE: ./node_modules/ol/interaction/DragPan.js





/**
 * @module ol/interaction/DragPan
 */





/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */

var DragPan = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(DragPan, _PointerInteraction);

  var _super = createSuper_createSuper(DragPan);

  /**
   * @param {Options} [options] Options.
   */
  function DragPan(options) {
    var _this;

    _classCallCheck(this, DragPan);

    _this = _super.call(this, {
      stopDown: functions_FALSE
    });
    options = options ? options : {};
    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */

    _this.kinetic_ = options.kinetic;
    /**
     * @type {import("../pixel.js").Pixel}
     */

    _this.lastCentroid = null;
    /**
     * @type {number}
     */

    _this.lastPointersCount_;
    /**
     * @type {boolean}
     */

    _this.panning_ = false;
    var condition = options.condition ? options.condition : condition_all(noModifierKeys, primaryAction);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.onFocusOnly ? condition_all(focusWithTabindex, condition) : condition;
    /**
     * @private
     * @type {boolean}
     */

    _this.noKinetic_ = false;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  _createClass(DragPan, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      if (!this.panning_) {
        this.panning_ = true;
        this.getMap().getView().beginInteraction();
      }

      var targetPointers = this.targetPointers;
      var centroid = Pointer_centroid(targetPointers);

      if (targetPointers.length == this.lastPointersCount_) {
        if (this.kinetic_) {
          this.kinetic_.update(centroid[0], centroid[1]);
        }

        if (this.lastCentroid) {
          var delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];
          var map = mapBrowserEvent.map;
          var view = map.getView();
          coordinate_scale(delta, view.getResolution());
          coordinate_rotate(delta, view.getRotation());
          view.adjustCenterInternal(delta);
        }
      } else if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger down, tiny drag, second finger down
        this.kinetic_.begin();
      }

      this.lastCentroid = centroid;
      this.lastPointersCount_ = targetPointers.length;
      mapBrowserEvent.originalEvent.preventDefault();
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      var map = mapBrowserEvent.map;
      var view = map.getView();

      if (this.targetPointers.length === 0) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          var distance = this.kinetic_.getDistance();
          var angle = this.kinetic_.getAngle();
          var center = view.getCenterInternal();
          var centerpx = map.getPixelFromCoordinateInternal(center);
          var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
          view.animateInternal({
            center: view.getConstrainedCenter(dest),
            duration: 500,
            easing: easeOut
          });
        }

        if (this.panning_) {
          this.panning_ = false;
          view.endInteraction();
        }

        return false;
      } else {
        if (this.kinetic_) {
          // reset so we don't overestimate the kinetic energy after
          // after one finger up, tiny drag, second finger up
          this.kinetic_.begin();
        }

        this.lastCentroid = null;
        return true;
      }
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        this.lastCentroid = null; // stop any current animation

        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        if (this.kinetic_) {
          this.kinetic_.begin();
        } // No kinetic as soon as more than one pointer on the screen is
        // detected. This is to prevent nasty pans after pinch.


        this.noKinetic_ = this.targetPointers.length > 1;
        return true;
      } else {
        return false;
      }
    }
  }]);

  return DragPan;
}(Pointer);

/* harmony default export */ var interaction_DragPan = (DragPan);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/DragRotate.js





/**
 * @module ol/interaction/DragRotate
 */




/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */

var DragRotate = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(DragRotate, _PointerInteraction);

  var _super = createSuper_createSuper(DragRotate);

  /**
   * @param {Options} [options] Options.
   */
  function DragRotate(options) {
    var _this;

    _classCallCheck(this, DragRotate);

    options = options ? options : {};
    _this = _super.call(this, {
      stopDown: functions_FALSE
    });
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  _createClass(DragRotate, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return;
      }

      var map = mapBrowserEvent.map;
      var view = map.getView();

      if (view.getConstraints().rotation === disable) {
        return;
      }

      var size = map.getSize();
      var offset = mapBrowserEvent.pixel;
      var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);

      if (this.lastAngle_ !== undefined) {
        var delta = theta - this.lastAngle_;
        view.adjustRotationInternal(-delta);
      }

      this.lastAngle_ = theta;
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return true;
      }

      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return false;
      }

      if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
        var map = mapBrowserEvent.map;
        map.getView().beginInteraction();
        this.lastAngle_ = undefined;
        return true;
      } else {
        return false;
      }
    }
  }]);

  return DragRotate;
}(Pointer);

/* harmony default export */ var interaction_DragRotate = (DragRotate);
;// CONCATENATED MODULE: ./node_modules/ol/render/Box.js





/**
 * @module ol/render/Box
 */



var RenderBox = /*#__PURE__*/function (_Disposable) {
  _inherits(RenderBox, _Disposable);

  var _super = createSuper_createSuper(RenderBox);

  /**
   * @param {string} className CSS class name.
   */
  function RenderBox(className) {
    var _this;

    _classCallCheck(this, RenderBox);

    _this = _super.call(this);
    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */

    _this.geometry_ = null;
    /**
     * @type {HTMLDivElement}
     * @private
     */

    _this.element_ = document.createElement('div');
    _this.element_.style.position = 'absolute';
    _this.element_.style.pointerEvents = 'auto';
    _this.element_.className = 'ol-box ' + className;
    /**
     * @private
     * @type {import("../Map.js").default|null}
     */

    _this.map_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.startPixel_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.endPixel_ = null;
    return _this;
  }
  /**
   * Clean up.
   */


  _createClass(RenderBox, [{
    key: "disposeInternal",
    value: function disposeInternal() {
      this.setMap(null);
    }
    /**
     * @private
     */

  }, {
    key: "render_",
    value: function render_() {
      var startPixel = this.startPixel_;
      var endPixel = this.endPixel_;
      var px = 'px';
      var style = this.element_.style;
      style.left = Math.min(startPixel[0], endPixel[0]) + px;
      style.top = Math.min(startPixel[1], endPixel[1]) + px;
      style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
      style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     */

  }, {
    key: "setMap",
    value: function setMap(map) {
      if (this.map_) {
        this.map_.getOverlayContainer().removeChild(this.element_);
        var style = this.element_.style;
        style.left = 'inherit';
        style.top = 'inherit';
        style.width = 'inherit';
        style.height = 'inherit';
      }

      this.map_ = map;

      if (this.map_) {
        this.map_.getOverlayContainer().appendChild(this.element_);
      }
    }
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */

  }, {
    key: "setPixels",
    value: function setPixels(startPixel, endPixel) {
      this.startPixel_ = startPixel;
      this.endPixel_ = endPixel;
      this.createOrUpdateGeometry();
      this.render_();
    }
    /**
     * Creates or updates the cached geometry.
     */

  }, {
    key: "createOrUpdateGeometry",
    value: function createOrUpdateGeometry() {
      var startPixel = this.startPixel_;
      var endPixel = this.endPixel_;
      var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
      var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_); // close the polygon

      coordinates[4] = coordinates[0].slice();

      if (!this.geometry_) {
        this.geometry_ = new geom_Polygon([coordinates]);
      } else {
        this.geometry_.setCoordinates([coordinates]);
      }
    }
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */

  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this.geometry_;
    }
  }]);

  return RenderBox;
}(ol_Disposable);

/* harmony default export */ var Box = (RenderBox);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/DragBox.js





/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box




/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */

/**
 * @enum {string}
 */

var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend',

  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: 'boxcancel'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */

var DragBoxEvent = /*#__PURE__*/function (_Event) {
  _inherits(DragBoxEvent, _Event);

  var _super = createSuper_createSuper(DragBoxEvent);

  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    var _this;

    _classCallCheck(this, DragBoxEvent);

    _this = _super.call(this, type);
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */

    _this.coordinate = coordinate;
    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return _createClass(DragBoxEvent);
}(events_Event);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */

var DragBox = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(DragBox, _PointerInteraction);

  var _super2 = createSuper_createSuper(DragBox);

  /**
   * @param {Options} [options] Options.
   */
  function DragBox(options) {
    var _this2;

    _classCallCheck(this, DragBox);

    _this2 = _super2.call(this);
    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */

    _this2.on;
    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */

    _this2.once;
    /***
     * @type {DragBoxOnSignature<void>}
     */

    _this2.un;
    options = options ? options : {};
    /**
     * @type {import("../render/Box.js").default}
     * @private
     */

    _this2.box_ = new Box(options.className || 'ol-dragbox');
    /**
     * @type {number}
     * @private
     */

    _this2.minArea_ = options.minArea !== undefined ? options.minArea : 64;

    if (options.onBoxEnd) {
      _this2.onBoxEnd = options.onBoxEnd;
    }
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */


    _this2.startPixel_ = null;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this2.condition_ = options.condition ? options.condition : mouseActionButton;
    /**
     * @private
     * @type {EndCondition}
     */

    _this2.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this2.defaultBoxEndCondition;
    return _this2;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */


  _createClass(DragBox, [{
    key: "defaultBoxEndCondition",
    value: function defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
      var width = endPixel[0] - startPixel[0];
      var height = endPixel[1] - startPixel[1];
      return width * width + height * height >= this.minArea_;
    }
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */

  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this.box_.getGeometry();
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */

  }, {
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      this.box_.setMap(null);
      var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);

      if (completeBox) {
        this.onBoxEnd(mapBrowserEvent);
      }

      this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
      return false;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.condition_(mapBrowserEvent)) {
        this.startPixel_ = mapBrowserEvent.pixel;
        this.box_.setMap(mapBrowserEvent.map);
        this.box_.setPixels(this.startPixel_, this.startPixel_);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
        return true;
      } else {
        return false;
      }
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */

  }, {
    key: "onBoxEnd",
    value: function onBoxEnd(event) {}
  }]);

  return DragBox;
}(Pointer);

/* harmony default export */ var interaction_DragBox = (DragBox);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/DragZoom.js





/**
 * @module ol/interaction/DragZoom
 */



/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */

var DragZoom = /*#__PURE__*/function (_DragBox) {
  _inherits(DragZoom, _DragBox);

  var _super = createSuper_createSuper(DragZoom);

  /**
   * @param {Options} [options] Options.
   */
  function DragZoom(options) {
    var _this;

    _classCallCheck(this, DragZoom);

    options = options ? options : {};
    var condition = options.condition ? options.condition : shiftKeyOnly;
    _this = _super.call(this, {
      condition: condition,
      className: options.className || 'ol-dragzoom',
      minArea: options.minArea
    });
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 200;
    /**
     * @private
     * @type {boolean}
     */

    _this.out_ = options.out !== undefined ? options.out : false;
    return _this;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  _createClass(DragZoom, [{
    key: "onBoxEnd",
    value: function onBoxEnd(event) {
      var map = this.getMap();
      var view =
      /** @type {!import("../View.js").default} */
      map.getView();
      var geometry = this.getGeometry();

      if (this.out_) {
        var rotatedExtent = view.rotatedExtentForGeometry(geometry);
        var resolution = view.getResolutionForExtentInternal(rotatedExtent);
        var factor = view.getResolution() / resolution;
        geometry = geometry.clone();
        geometry.scale(factor * factor);
      }

      view.fitInternal(geometry, {
        duration: this.duration_,
        easing: easeOut
      });
    }
  }]);

  return DragZoom;
}(interaction_DragBox);

/* harmony default export */ var interaction_DragZoom = (DragZoom);
;// CONCATENATED MODULE: ./node_modules/ol/events/KeyCode.js
/**
 * @module ol/events/KeyCode
 */

/**
 * @enum {number}
 * @const
 */
/* harmony default export */ var KeyCode = ({
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
});
;// CONCATENATED MODULE: ./node_modules/ol/interaction/KeyboardPan.js





/**
 * @module ol/interaction/KeyboardPan
 */





/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */

var KeyboardPan = /*#__PURE__*/function (_Interaction) {
  _inherits(KeyboardPan, _Interaction);

  var _super = createSuper_createSuper(KeyboardPan);

  /**
   * @param {Options} [options] Options.
   */
  function KeyboardPan(options) {
    var _this;

    _classCallCheck(this, KeyboardPan);

    _this = _super.call(this);
    options = options || {};
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */

    _this.defaultCondition_ = function (mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */


    _this.condition_ = options.condition !== undefined ? options.condition : _this.defaultCondition_;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    /**
     * @private
     * @type {number}
     */

    _this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    return _this;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardPan}
   */


  _createClass(KeyboardPan, [{
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      var stopEvent = false;

      if (mapBrowserEvent.type == EventType.KEYDOWN) {
        var keyEvent =
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent;
        var keyCode = keyEvent.keyCode;

        if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
          var deltaX = 0,
              deltaY = 0;

          if (keyCode == KeyCode.DOWN) {
            deltaY = -mapUnitsDelta;
          } else if (keyCode == KeyCode.LEFT) {
            deltaX = -mapUnitsDelta;
          } else if (keyCode == KeyCode.RIGHT) {
            deltaX = mapUnitsDelta;
          } else {
            deltaY = mapUnitsDelta;
          }

          var delta = [deltaX, deltaY];
          coordinate_rotate(delta, view.getRotation());
          pan(view, delta, this.duration_);
          keyEvent.preventDefault();
          stopEvent = true;
        }
      }

      return !stopEvent;
    }
  }]);

  return KeyboardPan;
}(interaction_Interaction);

/* harmony default export */ var interaction_KeyboardPan = (KeyboardPan);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/KeyboardZoom.js





/**
 * @module ol/interaction/KeyboardZoom
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */

var KeyboardZoom = /*#__PURE__*/function (_Interaction) {
  _inherits(KeyboardZoom, _Interaction);

  var _super = createSuper_createSuper(KeyboardZoom);

  /**
   * @param {Options} [options] Options.
   */
  function KeyboardZoom(options) {
    var _this;

    _classCallCheck(this, KeyboardZoom);

    _this = _super.call(this);
    options = options ? options : {};
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : targetNotEditable;
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    return _this;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardZoom}
   */


  _createClass(KeyboardZoom, [{
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      var stopEvent = false;

      if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {
        var keyEvent =
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent;
        var charCode = keyEvent.charCode;

        if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
          var map = mapBrowserEvent.map;
          var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
          var view = map.getView();
          zoomByDelta(view, delta, undefined, this.duration_);
          keyEvent.preventDefault();
          stopEvent = true;
        }
      }

      return !stopEvent;
    }
  }]);

  return KeyboardZoom;
}(interaction_Interaction);

/* harmony default export */ var interaction_KeyboardZoom = (KeyboardZoom);
;// CONCATENATED MODULE: ./node_modules/ol/Kinetic.js



/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic = /*#__PURE__*/function () {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  function Kinetic(decay, minVelocity, delay) {
    _classCallCheck(this, Kinetic);

    /**
     * @private
     * @type {number}
     */
    this.decay_ = decay;
    /**
     * @private
     * @type {number}
     */

    this.minVelocity_ = minVelocity;
    /**
     * @private
     * @type {number}
     */

    this.delay_ = delay;
    /**
     * @private
     * @type {Array<number>}
     */

    this.points_ = [];
    /**
     * @private
     * @type {number}
     */

    this.angle_ = 0;
    /**
     * @private
     * @type {number}
     */

    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */


  _createClass(Kinetic, [{
    key: "begin",
    value: function begin() {
      this.points_.length = 0;
      this.angle_ = 0;
      this.initialVelocity_ = 0;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */

  }, {
    key: "update",
    value: function update(x, y) {
      this.points_.push(x, y, Date.now());
    }
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */

  }, {
    key: "end",
    value: function end() {
      if (this.points_.length < 6) {
        // at least 2 points are required (i.e. there must be at least 6 elements
        // in the array)
        return false;
      }

      var delay = Date.now() - this.delay_;
      var lastIndex = this.points_.length - 3;

      if (this.points_[lastIndex + 2] < delay) {
        // the last tracked point is too old, which means that the user stopped
        // panning before releasing the map
        return false;
      } // get the first point which still falls into the delay time


      var firstIndex = lastIndex - 3;

      while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
        firstIndex -= 3;
      }

      var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)
      // we also make sure the user panned for a duration of at least one frame
      // (1/60s) to compute sane displacement values

      if (duration < 1000 / 60) {
        return false;
      }

      var dx = this.points_[lastIndex] - this.points_[firstIndex];
      var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
      this.angle_ = Math.atan2(dy, dx);
      this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
      return this.initialVelocity_ > this.minVelocity_;
    }
    /**
     * @return {number} Total distance travelled (pixels).
     */

  }, {
    key: "getDistance",
    value: function getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */

  }, {
    key: "getAngle",
    value: function getAngle() {
      return this.angle_;
    }
  }]);

  return Kinetic;
}();

/* harmony default export */ var ol_Kinetic = (Kinetic);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/MouseWheelZoom.js





/**
 * @module ol/interaction/MouseWheelZoom
 */





/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */

var MouseWheelZoom = /*#__PURE__*/function (_Interaction) {
  _inherits(MouseWheelZoom, _Interaction);

  var _super = createSuper_createSuper(MouseWheelZoom);

  /**
   * @param {Options} [options] Options.
   */
  function MouseWheelZoom(options) {
    var _this;

    _classCallCheck(this, MouseWheelZoom);

    options = options ? options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options);
    /**
     * @private
     * @type {number}
     */

    _this.totalDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.lastDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @private
     * @type {number}
     */

    _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
    /**
     * @private
     * @type {boolean}
     */

    _this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
    var condition = options.condition ? options.condition : always;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.onFocusOnly ? condition_all(focusWithTabindex, condition) : condition;
    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */

    _this.lastAnchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.startTime_ = undefined;
    /**
     * @private
     * @type {?}
     */

    _this.timeoutId_;
    /**
     * @private
     * @type {Mode|undefined}
     */

    _this.mode_ = undefined;
    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */

    _this.trackpadEventGap_ = 400;
    /**
     * @type {?}
     */

    _this.trackpadTimeoutId_;
    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */

    _this.deltaPerZoom_ = 300;
    return _this;
  }
  /**
   * @private
   */


  _createClass(MouseWheelZoom, [{
    key: "endInteraction_",
    value: function endInteraction_() {
      this.trackpadTimeoutId_ = undefined;
      var map = this.getMap();

      if (!map) {
        return;
      }

      var view = map.getView();
      view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */

  }, {
    key: "handleEvent",
    value: function handleEvent(mapBrowserEvent) {
      if (!this.condition_(mapBrowserEvent)) {
        return true;
      }

      var type = mapBrowserEvent.type;

      if (type !== EventType.WHEEL) {
        return true;
      }

      var map = mapBrowserEvent.map;
      var wheelEvent =
      /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent;
      wheelEvent.preventDefault();

      if (this.useAnchor_) {
        this.lastAnchor_ = mapBrowserEvent.coordinate;
      } // Delta normalisation inspired by
      // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js


      var delta;

      if (mapBrowserEvent.type == EventType.WHEEL) {
        delta = wheelEvent.deltaY;

        if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
          delta /= DEVICE_PIXEL_RATIO;
        }

        if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
          delta *= 40;
        }
      }

      if (delta === 0) {
        return false;
      } else {
        this.lastDelta_ = delta;
      }

      var now = Date.now();

      if (this.startTime_ === undefined) {
        this.startTime_ = now;
      }

      if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
        this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';
      }

      var view = map.getView();

      if (this.mode_ === 'trackpad' && !(view.getConstrainResolution() || this.constrainResolution_)) {
        if (this.trackpadTimeoutId_) {
          clearTimeout(this.trackpadTimeoutId_);
        } else {
          if (view.getAnimating()) {
            view.cancelAnimations();
          }

          view.beginInteraction();
        }

        this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
        view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
        this.startTime_ = now;
        return false;
      }

      this.totalDelta_ += delta;
      var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
      clearTimeout(this.timeoutId_);
      this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
      return false;
    }
    /**
     * @private
     * @param {import("../Map.js").default} map Map.
     */

  }, {
    key: "handleWheelZoom_",
    value: function handleWheelZoom_(map) {
      var view = map.getView();

      if (view.getAnimating()) {
        view.cancelAnimations();
      }

      var delta = -math_clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;

      if (view.getConstrainResolution() || this.constrainResolution_) {
        // view has a zoom constraint, zoom by 1
        delta = delta ? delta > 0 ? 1 : -1 : 0;
      }

      zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
      this.mode_ = undefined;
      this.totalDelta_ = 0;
      this.lastAnchor_ = null;
      this.startTime_ = undefined;
      this.timeoutId_ = undefined;
    }
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */

  }, {
    key: "setMouseAnchor",
    value: function setMouseAnchor(useAnchor) {
      this.useAnchor_ = useAnchor;

      if (!useAnchor) {
        this.lastAnchor_ = null;
      }
    }
  }]);

  return MouseWheelZoom;
}(interaction_Interaction);

/* harmony default export */ var interaction_MouseWheelZoom = (MouseWheelZoom);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/PinchRotate.js





/**
 * @module ol/interaction/PinchRotate
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */

var PinchRotate = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(PinchRotate, _PointerInteraction);

  var _super = createSuper_createSuper(PinchRotate);

  /**
   * @param {Options} [options] Options.
   */
  function PinchRotate(options) {
    var _this;

    _classCallCheck(this, PinchRotate);

    options = options ? options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = functions_FALSE;
    }

    _this = _super.call(this, pointerOptions);
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.rotating_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.rotationDelta_ = 0.0;
    /**
     * @private
     * @type {number}
     */

    _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  _createClass(PinchRotate, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      var rotationDelta = 0.0;
      var touch0 = this.targetPointers[0];
      var touch1 = this.targetPointers[1]; // angle between touches

      var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

      if (this.lastAngle_ !== undefined) {
        var delta = angle - this.lastAngle_;
        this.rotationDelta_ += delta;

        if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
          this.rotating_ = true;
        }

        rotationDelta = delta;
      }

      this.lastAngle_ = angle;
      var map = mapBrowserEvent.map;
      var view = map.getView();

      if (view.getConstraints().rotation === disable) {
        return;
      } // rotate anchor point.
      // FIXME: should be the intersection point between the lines:
      //     touch0,touch1 and previousTouch0,previousTouch1


      var viewportPosition = map.getViewport().getBoundingClientRect();
      var centroid = Pointer_centroid(this.targetPointers);
      centroid[0] -= viewportPosition.left;
      centroid[1] -= viewportPosition.top;
      this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // rotate

      if (this.rotating_) {
        map.render();
        view.adjustRotationInternal(rotationDelta, this.anchor_);
      }
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        view.endInteraction(this.duration_);
        return false;
      } else {
        return true;
      }
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        var map = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastAngle_ = undefined;
        this.rotating_ = false;
        this.rotationDelta_ = 0.0;

        if (!this.handlingDownUpSequence) {
          map.getView().beginInteraction();
        }

        return true;
      } else {
        return false;
      }
    }
  }]);

  return PinchRotate;
}(Pointer);

/* harmony default export */ var interaction_PinchRotate = (PinchRotate);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/PinchZoom.js





/**
 * @module ol/interaction/PinchZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */

var PinchZoom = /*#__PURE__*/function (_PointerInteraction) {
  _inherits(PinchZoom, _PointerInteraction);

  var _super = createSuper_createSuper(PinchZoom);

  /**
   * @param {Options} [options] Options.
   */
  function PinchZoom(options) {
    var _this;

    _classCallCheck(this, PinchZoom);

    options = options ? options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = functions_FALSE;
    }

    _this = _super.call(this, pointerOptions);
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 400;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastDistance_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.lastScaleDelta_ = 1;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  _createClass(PinchZoom, [{
    key: "handleDragEvent",
    value: function handleDragEvent(mapBrowserEvent) {
      var scaleDelta = 1.0;
      var touch0 = this.targetPointers[0];
      var touch1 = this.targetPointers[1];
      var dx = touch0.clientX - touch1.clientX;
      var dy = touch0.clientY - touch1.clientY; // distance between touches

      var distance = Math.sqrt(dx * dx + dy * dy);

      if (this.lastDistance_ !== undefined) {
        scaleDelta = this.lastDistance_ / distance;
      }

      this.lastDistance_ = distance;
      var map = mapBrowserEvent.map;
      var view = map.getView();

      if (scaleDelta != 1.0) {
        this.lastScaleDelta_ = scaleDelta;
      } // scale anchor point.


      var viewportPosition = map.getViewport().getBoundingClientRect();
      var centroid = Pointer_centroid(this.targetPointers);
      centroid[0] -= viewportPosition.left;
      centroid[1] -= viewportPosition.top;
      this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // scale, bypass the resolution constraint

      map.render();
      view.adjustResolutionInternal(scaleDelta, this.anchor_);
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleUpEvent",
    value: function handleUpEvent(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
        view.endInteraction(this.duration_, direction);
        return false;
      } else {
        return true;
      }
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */

  }, {
    key: "handleDownEvent",
    value: function handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        var map = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastDistance_ = undefined;
        this.lastScaleDelta_ = 1;

        if (!this.handlingDownUpSequence) {
          map.getView().beginInteraction();
        }

        return true;
      } else {
        return false;
      }
    }
  }]);

  return PinchZoom;
}(Pointer);

/* harmony default export */ var interaction_PinchZoom = (PinchZoom);
;// CONCATENATED MODULE: ./node_modules/ol/interaction/defaults.js
/**
 * @module ol/interaction/defaults
 */











/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [options] Defaults options.
 * @return {Collection<import("./Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */

function defaults_defaults(options) {
  options = options ? options : {};
  /** @type {Collection<import("./Interaction.js").default>} */

  var interactions = new ol_Collection();
  var kinetic = new ol_Kinetic(-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;

  if (altShiftDragRotate) {
    interactions.push(new interaction_DragRotate());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;

  if (doubleClickZoom) {
    interactions.push(new interaction_DoubleClickZoom({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;

  if (dragPan) {
    interactions.push(new interaction_DragPan({
      onFocusOnly: options.onFocusOnly,
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;

  if (pinchRotate) {
    interactions.push(new interaction_PinchRotate());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;

  if (pinchZoom) {
    interactions.push(new interaction_PinchZoom({
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;

  if (keyboard) {
    interactions.push(new interaction_KeyboardPan());
    interactions.push(new interaction_KeyboardZoom({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;

  if (mouseWheelZoom) {
    interactions.push(new interaction_MouseWheelZoom({
      onFocusOnly: options.onFocusOnly,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;

  if (shiftDragZoom) {
    interactions.push(new interaction_DragZoom({
      duration: options.zoomDuration
    }));
  }

  return interactions;
}
;// CONCATENATED MODULE: ./node_modules/ol/size.js
/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */
function size_buffer(size, num, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }

  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */

function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */

function size_scale(size, ratio, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }

  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */

function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (dest === undefined) {
      dest = [size, size];
    } else {
      dest[0] = size;
      dest[1] = size;
    }

    return dest;
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/Map.js








/**
 * @module ol/Map
 */































/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent.
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */

/**
 * @typedef {function(Map, ?FrameState): any} PostRenderFunction
 */

/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */

/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */

/**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
 */

/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/defaults.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction/defaults.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 */

function removeLayerMapProperty(layer) {
  if (layer instanceof layer_Layer) {
    layer.setMapInternal(null);
    return;
  }

  if (layer instanceof layer_Group) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {Map} map Map.
 */


function setLayerMapProperty(layer, map) {
  if (layer instanceof layer_Layer) {
    layer.setMapInternal(map);
    return;
  }

  if (layer instanceof layer_Group) {
    var layers = layer.getLayers().getArray();

    for (var i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */


var Map_Map = /*#__PURE__*/function (_BaseObject) {
  _inherits(Map, _BaseObject);

  var _super = createSuper_createSuper(Map);

  /**
   * @param {MapOptions} [options] Map options.
   */
  function Map(options) {
    var _this;

    _classCallCheck(this, Map);

    _this = _super.call(this);
    options = options || {};
    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */

    _this.on;
    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {MapEventHandler<void>}
     */

    _this.un;
    var optionsInternal = createOptionsInternal(options);
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.renderComplete_;
    /**
     * @private
     * @type {boolean}
     */

    _this.loaded_ = true;
    /** @private */

    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(assertThisInitialized_assertThisInitialized(_this));
    /**
     * @type {number}
     * @private
     */

    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    /**
     * @private
     * @type {*}
     */

    _this.postRenderTimeoutHandle_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.animationDelayKey_;
    /**
     * @private
     */

    _this.animationDelay_ = _this.animationDelay_.bind(assertThisInitialized_assertThisInitialized(_this));
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */

    _this.coordinateToPixelTransform_ = create();
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */

    _this.pixelToCoordinateTransform_ = create();
    /**
     * @private
     * @type {number}
     */

    _this.frameIndex_ = 0;
    /**
     * @private
     * @type {?FrameState}
     */

    _this.frameState_ = null;
    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */

    _this.previousExtent_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewPropertyListenerKey_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewChangeListenerKey_ = null;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.layerGroupPropertyListenerKeys_ = null;
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.viewport_ = document.createElement('div');
    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
    _this.viewport_.style.position = 'relative';
    _this.viewport_.style.overflow = 'hidden';
    _this.viewport_.style.width = '100%';
    _this.viewport_.style.height = '100%';
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.overlayContainer_ = document.createElement('div');
    _this.overlayContainer_.style.position = 'absolute';
    _this.overlayContainer_.style.zIndex = '0';
    _this.overlayContainer_.style.width = '100%';
    _this.overlayContainer_.style.height = '100%';
    _this.overlayContainer_.style.pointerEvents = 'none';
    _this.overlayContainer_.className = 'ol-overlaycontainer';

    _this.viewport_.appendChild(_this.overlayContainer_);
    /**
     * @private
     * @type {!HTMLElement}
     */


    _this.overlayContainerStopEvent_ = document.createElement('div');
    _this.overlayContainerStopEvent_.style.position = 'absolute';
    _this.overlayContainerStopEvent_.style.zIndex = '0';
    _this.overlayContainerStopEvent_.style.width = '100%';
    _this.overlayContainerStopEvent_.style.height = '100%';
    _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';

    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
    /**
     * @private
     * @type {MapBrowserEventHandler}
     */


    _this.mapBrowserEventHandler_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.moveTolerance_ = options.moveTolerance;
    /**
     * @private
     * @type {HTMLElement|Document}
     */

    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.targetChangeHandlerKeys_ = null;
    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */

    _this.controls = optionsInternal.controls || defaults();
    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */

    _this.interactions = optionsInternal.interactions || defaults_defaults({
      onFocusOnly: true
    });
    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */

    _this.overlays_ = optionsInternal.overlays;
    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */

    _this.overlayIdIndex_ = {};
    /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */

    _this.renderer_ = null;
    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */

    _this.postRenderFunctions_ = [];
    /**
     * @private
     * @type {TileQueue}
     */

    _this.tileQueue_ = new ol_TileQueue(_this.getTilePriority.bind(assertThisInitialized_assertThisInitialized(_this)), _this.handleTileChange_.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);

    _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);

    _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);

    _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map
    // is "defined" already.


    _this.setProperties(optionsInternal.values);

    var map = assertThisInitialized_assertThisInitialized(_this);

    if (options.view && !(options.view instanceof ol_View)) {
      options.view.then(function (viewOptions) {
        map.setView(new ol_View(viewOptions));
      });
    }

    _this.controls.addEventListener(CollectionEventType.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
     */
    function (event) {
      event.element.setMap(this);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.controls.addEventListener(CollectionEventType.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.interactions.addEventListener(CollectionEventType.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(this);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.interactions.addEventListener(CollectionEventType.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.overlays_.addEventListener(CollectionEventType.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
     */
    function (event) {
      this.addOverlayInternal_(event.element);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.overlays_.addEventListener(CollectionEventType.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
     */
    function (event) {
      var id = event.element.getId();

      if (id !== undefined) {
        delete this.overlayIdIndex_[id.toString()];
      }

      event.element.setMap(null);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.controls.forEach(
    /**
     * @param {import("./control/Control.js").default} control Control.
     * @this {Map}
     */
    function (control) {
      control.setMap(this);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.interactions.forEach(
    /**
     * @param {import("./interaction/Interaction.js").default} interaction Interaction.
     * @this {Map}
     */
    function (interaction) {
      interaction.setMap(this);
    }.bind(assertThisInitialized_assertThisInitialized(_this)));

    _this.overlays_.forEach(_this.addOverlayInternal_.bind(assertThisInitialized_assertThisInitialized(_this)));

    return _this;
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */


  _createClass(Map, [{
    key: "addControl",
    value: function addControl(control) {
      this.getControls().push(control);
    }
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteractions()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */

  }, {
    key: "addInteraction",
    value: function addInteraction(interaction) {
      this.getInteractions().push(interaction);
    }
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */

  }, {
    key: "addLayer",
    value: function addLayer(layer) {
      var layers = this.getLayerGroup().getLayers();
      layers.push(layer);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */

  }, {
    key: "handleLayerAdd_",
    value: function handleLayerAdd_(event) {
      setLayerMapProperty(event.layer, this);
    }
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */

  }, {
    key: "addOverlay",
    value: function addOverlay(overlay) {
      this.getOverlays().push(overlay);
    }
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */

  }, {
    key: "addOverlayInternal_",
    value: function addOverlayInternal_(overlay) {
      var id = overlay.getId();

      if (id !== undefined) {
        this.overlayIdIndex_[id.toString()] = overlay;
      }

      overlay.setMap(this);
    }
    /**
     *
     * Clean up.
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      this.controls.clear();
      this.interactions.clear();
      this.overlays_.clear();
      this.setTarget(null);

      _get(getPrototypeOf_getPrototypeOf(Map.prototype), "disposeInternal", this).call(this);
    }
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */

  }, {
    key: "forEachFeatureAtPixel",
    value: function forEachFeatureAtPixel(pixel, callback, options) {
      if (!this.frameState_ || !this.renderer_) {
        return;
      }

      var coordinate = this.getCoordinateFromPixelInternal(pixel);
      options = options !== undefined ? options : {};
      var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
      var layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;
      var checkWrapped = options.checkWrapped !== false;
      return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
    }
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */

  }, {
    key: "getFeaturesAtPixel",
    value: function getFeaturesAtPixel(pixel, options) {
      var features = [];
      this.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature);
      }, options);
      return features;
    }
    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */

  }, {
    key: "getAllLayers",
    value: function getAllLayers() {
      var layers = [];

      function addLayersFrom(layerGroup) {
        layerGroup.forEach(function (layer) {
          if (layer instanceof layer_Group) {
            addLayersFrom(layer.getLayers());
          } else {
            layers.push(layer);
          }
        });
      }

      addLayersFrom(this.getLayers());
      return layers;
    }
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through the `layerFilter` option.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */

  }, {
    key: "hasFeatureAtPixel",
    value: function hasFeatureAtPixel(pixel, options) {
      if (!this.frameState_ || !this.renderer_) {
        return false;
      }

      var coordinate = this.getCoordinateFromPixelInternal(pixel);
      options = options !== undefined ? options : {};
      var layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;
      var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
      var checkWrapped = options.checkWrapped !== false;
      return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
    }
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */

  }, {
    key: "getEventCoordinate",
    value: function getEventCoordinate(event) {
      return this.getCoordinateFromPixel(this.getEventPixel(event));
    }
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */

  }, {
    key: "getEventCoordinateInternal",
    value: function getEventCoordinateInternal(event) {
      return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    }
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */

  }, {
    key: "getEventPixel",
    value: function getEventPixel(event) {
      var viewportPosition = this.viewport_.getBoundingClientRect();
      var eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
      'changedTouches' in event ?
      /** @type {TouchEvent} */
      event.changedTouches[0] :
      /** @type {MouseEvent} */
      event;
      return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
    }
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */

  }, {
    key: "getTarget",
    value: function getTarget() {
      return (
        /** @type {HTMLElement|string|undefined} */
        this.get(MapProperty.TARGET)
      );
    }
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */

  }, {
    key: "getTargetElement",
    value: function getTargetElement() {
      var target = this.getTarget();

      if (target !== undefined) {
        return typeof target === 'string' ? document.getElementById(target) : target;
      } else {
        return null;
      }
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */

  }, {
    key: "getCoordinateFromPixel",
    value: function getCoordinateFromPixel(pixel) {
      return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */

  }, {
    key: "getCoordinateFromPixelInternal",
    value: function getCoordinateFromPixelInternal(pixel) {
      var frameState = this.frameState_;

      if (!frameState) {
        return null;
      } else {
        return apply(frameState.pixelToCoordinateTransform, pixel.slice());
      }
    }
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */

  }, {
    key: "getControls",
    value: function getControls() {
      return this.controls;
    }
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */

  }, {
    key: "getOverlays",
    value: function getOverlays() {
      return this.overlays_;
    }
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default} Overlay.
     * @api
     */

  }, {
    key: "getOverlayById",
    value: function getOverlayById(id) {
      var overlay = this.overlayIdIndex_[id.toString()];
      return overlay !== undefined ? overlay : null;
    }
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */

  }, {
    key: "getInteractions",
    value: function getInteractions() {
      return this.interactions;
    }
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */

  }, {
    key: "getLayerGroup",
    value: function getLayerGroup() {
      return (
        /** @type {LayerGroup} */
        this.get(MapProperty.LAYERGROUP)
      );
    }
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */

  }, {
    key: "setLayers",
    value: function setLayers(layers) {
      var group = this.getLayerGroup();

      if (layers instanceof ol_Collection) {
        group.setLayers(layers);
        return;
      }

      var collection = group.getLayers();
      collection.clear();
      collection.extend(layers);
    }
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */

  }, {
    key: "getLayers",
    value: function getLayers() {
      var layers = this.getLayerGroup().getLayers();
      return layers;
    }
    /**
     * @return {boolean} Layers have sources that are still loading.
     */

  }, {
    key: "getLoadingOrNotReady",
    value: function getLoadingOrNotReady() {
      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();

      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        var state = layerStatesArray[i];

        if (!state.visible) {
          continue;
        }

        var renderer = state.layer.getRenderer();

        if (renderer && !renderer.ready) {
          return true;
        }

        var source = state.layer.getSource();

        if (source && source.loading) {
          return true;
        }
      }

      return false;
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */

  }, {
    key: "getPixelFromCoordinate",
    value: function getPixelFromCoordinate(coordinate) {
      var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
      return this.getPixelFromCoordinateInternal(viewCoordinate);
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */

  }, {
    key: "getPixelFromCoordinateInternal",
    value: function getPixelFromCoordinateInternal(coordinate) {
      var frameState = this.frameState_;

      if (!frameState) {
        return null;
      } else {
        return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
      }
    }
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default|null} Renderer
     */

  }, {
    key: "getRenderer",
    value: function getRenderer() {
      return this.renderer_;
    }
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return (
        /** @type {import("./size.js").Size|undefined} */
        this.get(MapProperty.SIZE)
      );
    }
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */

  }, {
    key: "getView",
    value: function getView() {
      return (
        /** @type {View} */
        this.get(MapProperty.VIEW)
      );
    }
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */

  }, {
    key: "getViewport",
    value: function getViewport() {
      return this.viewport_;
    }
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */

  }, {
    key: "getOverlayContainer",
    value: function getOverlayContainer() {
      return this.overlayContainer_;
    }
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */

  }, {
    key: "getOverlayContainerStopEvent",
    value: function getOverlayContainerStopEvent() {
      return this.overlayContainerStopEvent_;
    }
    /**
     * @return {!Document} The document where the map is displayed.
     */

  }, {
    key: "getOwnerDocument",
    value: function getOwnerDocument() {
      var targetElement = this.getTargetElement();
      return targetElement ? targetElement.ownerDocument : document;
    }
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */

  }, {
    key: "getTilePriority",
    value: function getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
      return TileQueue_getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
    }
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [type] Type.
     */

  }, {
    key: "handleBrowserEvent",
    value: function handleBrowserEvent(browserEvent, type) {
      type = type || browserEvent.type;
      var mapBrowserEvent = new ol_MapBrowserEvent(type, this, browserEvent);
      this.handleMapBrowserEvent(mapBrowserEvent);
    }
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */

  }, {
    key: "handleMapBrowserEvent",
    value: function handleMapBrowserEvent(mapBrowserEvent) {
      if (!this.frameState_) {
        // With no view defined, we cannot translate pixels into geographical
        // coordinates so interactions cannot be used.
        return;
      }

      var originalEvent =
      /** @type {PointerEvent} */
      mapBrowserEvent.originalEvent;
      var eventType = originalEvent.type;

      if (eventType === pointer_EventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {
        var doc = this.getOwnerDocument();
        var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
        var target =
        /** @type {Node} */
        originalEvent.target;

        if ( // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
          return;
        }
      }

      mapBrowserEvent.frameState = this.frameState_;

      if (this.dispatchEvent(mapBrowserEvent) !== false) {
        var interactionsArray = this.getInteractions().getArray().slice();

        for (var i = interactionsArray.length - 1; i >= 0; i--) {
          var interaction = interactionsArray[i];

          if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
            continue;
          }

          var cont = interaction.handleEvent(mapBrowserEvent);

          if (!cont || mapBrowserEvent.propagationStopped) {
            break;
          }
        }
      }
    }
    /**
     * @protected
     */

  }, {
    key: "handlePostRender",
    value: function handlePostRender() {
      var frameState = this.frameState_; // Manage the tile queue
      // Image loads are expensive and a limited resource, so try to use them
      // efficiently:
      // * When the view is static we allow a large number of parallel tile loads
      //   to complete the frame as quickly as possible.
      // * When animating or interacting, image loads can cause janks, so we reduce
      //   the maximum number of loads per frame and limit the number of parallel
      //   tile loads to remain reactive to view changes and to reduce the chance of
      //   loading tiles that will quickly disappear from view.

      var tileQueue = this.tileQueue_;

      if (!tileQueue.isEmpty()) {
        var maxTotalLoading = this.maxTilesLoading_;
        var maxNewLoads = maxTotalLoading;

        if (frameState) {
          var hints = frameState.viewHints;

          if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
            var lowOnFrameBudget = Date.now() - frameState.time > 8;
            maxTotalLoading = lowOnFrameBudget ? 0 : 8;
            maxNewLoads = lowOnFrameBudget ? 0 : 2;
          }
        }

        if (tileQueue.getTilesLoading() < maxTotalLoading) {
          tileQueue.reprioritize(); // FIXME only call if view has changed

          tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
        }
      }

      if (frameState && this.renderer_ && !frameState.animate) {
        if (this.renderComplete_ === true) {
          if (this.hasListener(render_EventType.RENDERCOMPLETE)) {
            this.renderer_.dispatchRenderEvent(render_EventType.RENDERCOMPLETE, frameState);
          }

          if (this.loaded_ === false) {
            this.loaded_ = true;
            this.dispatchEvent(new ol_MapEvent(MapEventType.LOADEND, this, frameState));
          }
        } else if (this.loaded_ === true) {
          this.loaded_ = false;
          this.dispatchEvent(new ol_MapEvent(MapEventType.LOADSTART, this, frameState));
        }
      }

      var postRenderFunctions = this.postRenderFunctions_;

      for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
        postRenderFunctions[i](this, frameState);
      }

      postRenderFunctions.length = 0;
    }
    /**
     * @private
     */

  }, {
    key: "handleSizeChanged_",
    value: function handleSizeChanged_() {
      if (this.getView() && !this.getView().getAnimating()) {
        this.getView().resolveConstraints(0);
      }

      this.render();
    }
    /**
     * @private
     */

  }, {
    key: "handleTargetChanged_",
    value: function handleTargetChanged_() {
      if (this.mapBrowserEventHandler_) {
        for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
          unlistenByKey(this.targetChangeHandlerKeys_[i]);
        }

        this.targetChangeHandlerKeys_ = null;
        this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
        this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
        this.mapBrowserEventHandler_.dispose();
        this.mapBrowserEventHandler_ = null;
        removeNode(this.viewport_);
      } // target may be undefined, null, a string or an Element.
      // If it's a string we convert it to an Element before proceeding.
      // If it's not now an Element we remove the viewport from the DOM.
      // If it's an Element we append the viewport element to it.


      var targetElement = this.getTargetElement();

      if (!targetElement) {
        if (this.renderer_) {
          clearTimeout(this.postRenderTimeoutHandle_);
          this.postRenderTimeoutHandle_ = undefined;
          this.postRenderFunctions_.length = 0;
          this.renderer_.dispose();
          this.renderer_ = null;
        }

        if (this.animationDelayKey_) {
          cancelAnimationFrame(this.animationDelayKey_);
          this.animationDelayKey_ = undefined;
        }
      } else {
        targetElement.appendChild(this.viewport_);

        if (!this.renderer_) {
          this.renderer_ = new Composite(this);
        }

        this.mapBrowserEventHandler_ = new ol_MapBrowserEventHandler(this, this.moveTolerance_);

        for (var key in ol_MapBrowserEventType) {
          this.mapBrowserEventHandler_.addEventListener(ol_MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
        }

        this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
        this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? {
          passive: false
        } : false);
        var defaultView = this.getOwnerDocument().defaultView;
        var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
        this.targetChangeHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this), listen(defaultView, EventType.RESIZE, this.updateSize, this)];
      }

      this.updateSize(); // updateSize calls setSize, so no need to call this.render
      // ourselves here.
    }
    /**
     * @private
     */

  }, {
    key: "handleTileChange_",
    value: function handleTileChange_() {
      this.render();
    }
    /**
     * @private
     */

  }, {
    key: "handleViewPropertyChanged_",
    value: function handleViewPropertyChanged_() {
      this.render();
    }
    /**
     * @private
     */

  }, {
    key: "handleViewChanged_",
    value: function handleViewChanged_() {
      if (this.viewPropertyListenerKey_) {
        unlistenByKey(this.viewPropertyListenerKey_);
        this.viewPropertyListenerKey_ = null;
      }

      if (this.viewChangeListenerKey_) {
        unlistenByKey(this.viewChangeListenerKey_);
        this.viewChangeListenerKey_ = null;
      }

      var view = this.getView();

      if (view) {
        this.updateViewportSize_();
        this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
        this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
        view.resolveConstraints(0);
      }

      this.render();
    }
    /**
     * @private
     */

  }, {
    key: "handleLayerGroupChanged_",
    value: function handleLayerGroupChanged_() {
      if (this.layerGroupPropertyListenerKeys_) {
        this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
        this.layerGroupPropertyListenerKeys_ = null;
      }

      var layerGroup = this.getLayerGroup();

      if (layerGroup) {
        this.handleLayerAdd_(new GroupEvent('addlayer', layerGroup));
        this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this), listen(layerGroup, 'addlayer', this.handleLayerAdd_, this), listen(layerGroup, 'removelayer', this.handleLayerRemove_, this)];
      }

      this.render();
    }
    /**
     * @return {boolean} Is rendered.
     */

  }, {
    key: "isRendered",
    value: function isRendered() {
      return !!this.frameState_;
    }
    /**
     * @private
     */

  }, {
    key: "animationDelay_",
    value: function animationDelay_() {
      this.animationDelayKey_ = undefined;
      this.renderFrame_(Date.now());
    }
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */

  }, {
    key: "renderSync",
    value: function renderSync() {
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
      }

      this.animationDelay_();
    }
    /**
     * Redraws all text after new fonts have loaded
     */

  }, {
    key: "redrawText",
    value: function redrawText() {
      var layerStates = this.getLayerGroup().getLayerStatesArray();

      for (var i = 0, ii = layerStates.length; i < ii; ++i) {
        var layer = layerStates[i].layer;

        if (layer.hasRenderer()) {
          layer.getRenderer().handleFontsChanged();
        }
      }
    }
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */

  }, {
    key: "render",
    value: function render() {
      if (this.renderer_ && this.animationDelayKey_ === undefined) {
        this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
      }
    }
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */

  }, {
    key: "removeControl",
    value: function removeControl(control) {
      return this.getControls().remove(control);
    }
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */

  }, {
    key: "removeInteraction",
    value: function removeInteraction(interaction) {
      return this.getInteractions().remove(interaction);
    }
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */

  }, {
    key: "removeLayer",
    value: function removeLayer(layer) {
      var layers = this.getLayerGroup().getLayers();
      return layers.remove(layer);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */

  }, {
    key: "handleLayerRemove_",
    value: function handleLayerRemove_(event) {
      removeLayerMapProperty(event.layer);
    }
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */

  }, {
    key: "removeOverlay",
    value: function removeOverlay(overlay) {
      return this.getOverlays().remove(overlay);
    }
    /**
     * @param {number} time Time.
     * @private
     */

  }, {
    key: "renderFrame_",
    value: function renderFrame_(time) {
      var _this2 = this;

      var size = this.getSize();
      var view = this.getView();
      var previousFrameState = this.frameState_;
      /** @type {?FrameState} */

      var frameState = null;

      if (size !== undefined && hasArea(size) && view && view.isDef()) {
        var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
        var viewState = view.getState();
        frameState = {
          animate: false,
          coordinateToPixelTransform: this.coordinateToPixelTransform_,
          declutterTree: null,
          extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
          index: this.frameIndex_++,
          layerIndex: 0,
          layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
          pixelRatio: this.pixelRatio_,
          pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
          postRenderFunctions: [],
          size: size,
          tileQueue: this.tileQueue_,
          time: time,
          usedTiles: {},
          viewState: viewState,
          viewHints: viewHints,
          wantedTiles: {},
          mapId: getUid(this),
          renderTargets: {}
        };

        if (viewState.nextCenter && viewState.nextResolution) {
          var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
          frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);
        }
      }

      this.frameState_ = frameState;
      this.renderer_.renderFrame(frameState);

      if (frameState) {
        if (frameState.animate) {
          this.render();
        }

        Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

        if (previousFrameState) {
          var moveStart = !this.previousExtent_ || !extent_isEmpty(this.previousExtent_) && !extent_equals(frameState.extent, this.previousExtent_);

          if (moveStart) {
            this.dispatchEvent(new ol_MapEvent(MapEventType.MOVESTART, this, previousFrameState));
            this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
          }
        }

        var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !extent_equals(frameState.extent, this.previousExtent_);

        if (idle) {
          this.dispatchEvent(new ol_MapEvent(MapEventType.MOVEEND, this, frameState));
          clone(frameState.extent, this.previousExtent_);
        }
      }

      this.dispatchEvent(new ol_MapEvent(MapEventType.POSTRENDER, this, frameState));
      this.renderComplete_ = this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(render_EventType.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : undefined;

      if (!this.postRenderTimeoutHandle_) {
        this.postRenderTimeoutHandle_ = setTimeout(function () {
          _this2.postRenderTimeoutHandle_ = undefined;

          _this2.handlePostRender();
        }, 0);
      }
    }
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */

  }, {
    key: "setLayerGroup",
    value: function setLayerGroup(layerGroup) {
      var oldLayerGroup = this.getLayerGroup();

      if (oldLayerGroup) {
        this.handleLayerRemove_(new GroupEvent('removelayer', oldLayerGroup));
      }

      this.set(MapProperty.LAYERGROUP, layerGroup);
    }
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */

  }, {
    key: "setSize",
    value: function setSize(size) {
      this.set(MapProperty.SIZE, size);
    }
    /**
     * Set the target element to render this map into.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */

  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this.set(MapProperty.TARGET, target);
    }
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */

  }, {
    key: "setView",
    value: function setView(view) {
      if (!view || view instanceof ol_View) {
        this.set(MapProperty.VIEW, view);
        return;
      }

      this.set(MapProperty.VIEW, new ol_View());
      var map = this;
      view.then(function (viewOptions) {
        map.setView(new ol_View(viewOptions));
      });
    }
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */

  }, {
    key: "updateSize",
    value: function updateSize() {
      var targetElement = this.getTargetElement();
      var size = undefined;

      if (targetElement) {
        var computedStyle = getComputedStyle(targetElement);
        var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);
        var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);

        if (!isNaN(width) && !isNaN(height)) {
          size = [width, height];

          if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
            // eslint-disable-next-line
            console.warn("No map visible because the map container's width or height are 0.");
          }
        }
      }

      this.setSize(size);
      this.updateViewportSize_();
    }
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @private
     */

  }, {
    key: "updateViewportSize_",
    value: function updateViewportSize_() {
      var view = this.getView();

      if (view) {
        var size = undefined;
        var computedStyle = getComputedStyle(this.viewport_);

        if (computedStyle.width && computedStyle.height) {
          size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];
        }

        view.setViewportSize(size);
      }
    }
  }]);

  return Map;
}(ol_Object);
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */


function createOptionsInternal(options) {
  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;

  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  /**
   * @type {Object<string, *>}
   */


  var values = {};
  var layerGroup = options.layers && typeof
  /** @type {?} */
  options.layers.getLayers === 'function' ?
  /** @type {LayerGroup} */
  options.layers : new layer_Group({
    layers:
    /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
    options.layers
  });
  values[MapProperty.LAYERGROUP] = layerGroup;
  values[MapProperty.TARGET] = options.target;
  values[MapProperty.VIEW] = options.view instanceof ol_View ? options.view : new ol_View();
  /** @type {Collection<import("./control/Control.js").default>} */

  var controls;

  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new ol_Collection(options.controls.slice());
    } else {
      asserts_assert(typeof
      /** @type {?} */
      options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`

      controls = options.controls;
    }
  }
  /** @type {Collection<import("./interaction/Interaction").default>} */


  var interactions;

  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new ol_Collection(options.interactions.slice());
    } else {
      asserts_assert(typeof
      /** @type {?} */
      options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`

      interactions = options.interactions;
    }
  }
  /** @type {Collection<import("./Overlay.js").default>} */


  var overlays;

  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new ol_Collection(options.overlays.slice());
    } else {
      asserts_assert(typeof
      /** @type {?} */
      options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`

      overlays = options.overlays;
    }
  } else {
    overlays = new ol_Collection();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };
}

/* harmony default export */ var ol_Map = (Map_Map);
;// CONCATENATED MODULE: ./node_modules/ol/layer/TileProperty.js
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ var TileProperty = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
});
;// CONCATENATED MODULE: ./node_modules/ol/layer/BaseTile.js







/**
 * @module ol/layer/BaseTile
 */


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */

/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */

var BaseTileLayer = /*#__PURE__*/function (_Layer) {
  _inherits(BaseTileLayer, _Layer);

  var _super = createSuper_createSuper(BaseTileLayer);

  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  function BaseTileLayer(options) {
    var _this;

    _classCallCheck(this, BaseTileLayer);

    options = options ? options : {};
    var baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions);
    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {BaseTileLayerOnSignature<void>}
     */

    _this.un;

    _this.setPreload(options.preload !== undefined ? options.preload : 0);

    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

    return _this;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */


  _createClass(BaseTileLayer, [{
    key: "getPreload",
    value: function getPreload() {
      return (
        /** @type {number} */
        this.get(TileProperty.PRELOAD)
      );
    }
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */

  }, {
    key: "setPreload",
    value: function setPreload(preload) {
      this.set(TileProperty.PRELOAD, preload);
    }
    /**
     * Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */

  }, {
    key: "getUseInterimTilesOnError",
    value: function getUseInterimTilesOnError() {
      return (
        /** @type {boolean} */
        this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)
      );
    }
    /**
     * Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */

  }, {
    key: "setUseInterimTilesOnError",
    value: function setUseInterimTilesOnError(useInterimTilesOnError) {
      this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    }
    /**
     * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
     * a four element RGBA array will be returned.  For data tiles, the array length will match the
     * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
     * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     */

  }, {
    key: "getData",
    value: function getData(pixel) {
      return _get(getPrototypeOf_getPrototypeOf(BaseTileLayer.prototype), "getData", this).call(this, pixel);
    }
  }]);

  return BaseTileLayer;
}(layer_Layer);

/* harmony default export */ var BaseTile = (BaseTileLayer);
;// CONCATENATED MODULE: ./node_modules/ol/ImageState.js
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ var ImageState = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
});
;// CONCATENATED MODULE: ./node_modules/ol/renderer/Layer.js








/**
 * @module ol/renderer/Layer
 */




/**
 * @template {import("../layer/Layer.js").default} LayerType
 */

var LayerRenderer = /*#__PURE__*/function (_Observable) {
  _inherits(LayerRenderer, _Observable);

  var _super = createSuper_createSuper(LayerRenderer);

  /**
   * @param {LayerType} layer Layer.
   */
  function LayerRenderer(layer) {
    var _this;

    _classCallCheck(this, LayerRenderer);

    _this = _super.call(this);
    /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */

    _this.ready = true;
    /** @private */

    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(assertThisInitialized_assertThisInitialized(_this));
    /**
     * @protected
     * @type {LayerType}
     */

    _this.layer_ = layer;
    /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */

    _this.declutterExecutorGroup = null;
    return _this;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */


  _createClass(LayerRenderer, [{
    key: "getFeatures",
    value: function getFeatures(pixel) {
      return util_abstract();
    }
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */

  }, {
    key: "getData",
    value: function getData(pixel) {
      return null;
    }
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */

  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      return util_abstract();
    }
    /**
     * Render the layer.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */

  }, {
    key: "renderFrame",
    value: function renderFrame(frameState, target) {
      return util_abstract();
    }
    /**
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */

  }, {
    key: "loadedTileCallback",
    value: function loadedTileCallback(tiles, zoom, tile) {
      if (!tiles[zoom]) {
        tiles[zoom] = {};
      }

      tiles[zoom][tile.tileCoord.toString()] = tile;
      return undefined;
    }
    /**
     * Create a function that adds loaded tiles to the tile lookup.
     * @param {import("../source/Tile.js").default} source Tile source.
     * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
     *     called with a zoom level and a tile range to add loaded tiles to the lookup.
     * @protected
     */

  }, {
    key: "createLoadedTileFinder",
    value: function createLoadedTileFinder(source, projection, tiles) {
      return (
        /**
         * @param {number} zoom Zoom level.
         * @param {import("../TileRange.js").default} tileRange Tile range.
         * @return {boolean} The tile range is fully loaded.
         * @this {LayerRenderer}
         */
        function (zoom, tileRange) {
          var callback = this.loadedTileCallback.bind(this, tiles, zoom);
          return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        }.bind(this)
      );
    }
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */

  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      return undefined;
    }
    /**
     * @return {LayerType} Layer.
     */

  }, {
    key: "getLayer",
    value: function getLayer() {
      return this.layer_;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */

  }, {
    key: "handleFontsChanged",
    value: function handleFontsChanged() {}
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */

  }, {
    key: "handleImageChange_",
    value: function handleImageChange_(event) {
      var image =
      /** @type {import("../Image.js").default} */
      event.target;

      if (image.getState() === ImageState.LOADED) {
        this.renderIfReadyAndVisible();
      }
    }
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../ImageBase.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */

  }, {
    key: "loadImage",
    value: function loadImage(image) {
      var imageState = image.getState();

      if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
        image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
      }

      if (imageState == ImageState.IDLE) {
        image.load();
        imageState = image.getState();
      }

      return imageState == ImageState.LOADED;
    }
    /**
     * @protected
     */

  }, {
    key: "renderIfReadyAndVisible",
    value: function renderIfReadyAndVisible() {
      var layer = this.getLayer();

      if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {
        layer.changed();
      }
    }
    /**
     * Clean up.
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      delete this.layer_;

      _get(getPrototypeOf_getPrototypeOf(LayerRenderer.prototype), "disposeInternal", this).call(this);
    }
  }]);

  return LayerRenderer;
}(ol_Observable);

/* harmony default export */ var renderer_Layer = (LayerRenderer);
;// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/Layer.js







/**
 * @module ol/renderer/canvas/Layer
 */








/**
 * @type {Array<HTMLCanvasElement>}
 */

var canvasPool = [];
/**
 * @type {CanvasRenderingContext2D}
 */

var pixelContext = null;

function createPixelContext() {
  var canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  pixelContext = canvas.getContext('2d');
}
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */


var CanvasLayerRenderer = /*#__PURE__*/function (_LayerRenderer) {
  _inherits(CanvasLayerRenderer, _LayerRenderer);

  var _super = createSuper_createSuper(CanvasLayerRenderer);

  /**
   * @param {LayerType} layer Layer.
   */
  function CanvasLayerRenderer(layer) {
    var _this;

    _classCallCheck(this, CanvasLayerRenderer);

    _this = _super.call(this, layer);
    /**
     * @protected
     * @type {HTMLElement}
     */

    _this.container = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedResolution;
    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.tempTransform = create();
    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.pixelTransform = create();
    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.inversePixelTransform = create();
    /**
     * @type {CanvasRenderingContext2D}
     */

    _this.context = null;
    /**
     * @type {boolean}
     */

    _this.containerReused = false;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    _this.pixelContext_ = null;
    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */

    _this.frameState = null;
    return _this;
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */


  _createClass(CanvasLayerRenderer, [{
    key: "getImageData",
    value: function getImageData(image, col, row) {
      if (!pixelContext) {
        createPixelContext();
      }

      pixelContext.clearRect(0, 0, 1, 1);
      var data;

      try {
        pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
        data = pixelContext.getImageData(0, 0, 1, 1).data;
      } catch (err) {
        pixelContext = null;
        return null;
      }

      return data;
    }
    /**
     * @param {import('../../Map.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */

  }, {
    key: "getBackground",
    value: function getBackground(frameState) {
      var layer = this.getLayer();
      var background = layer.getBackground();

      if (typeof background === 'function') {
        background = background(frameState.viewState.resolution);
      }

      return background || undefined;
    }
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {string} [backgroundColor] Background color.
     */

  }, {
    key: "useContainer",
    value: function useContainer(target, transform, backgroundColor) {
      var layerClassName = this.getLayer().getClassName();
      var container, context;

      if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(asArray(target.style.backgroundColor), asArray(backgroundColor)))) {
        var canvas = target.firstElementChild;

        if (canvas instanceof HTMLCanvasElement) {
          context = canvas.getContext('2d');
        }
      }

      if (context && context.canvas.style.transform === transform) {
        // Container of the previous layer renderer can be used.
        this.container = target;
        this.context = context;
        this.containerReused = true;
      } else if (this.containerReused) {
        // Previously reused container cannot be used any more.
        this.container = null;
        this.context = null;
        this.containerReused = false;
      }

      if (!this.container) {
        container = document.createElement('div');
        container.className = layerClassName;
        var style = container.style;
        style.position = 'absolute';
        style.width = '100%';
        style.height = '100%';
        context = createCanvasContext2D();
        var _canvas = context.canvas;
        container.appendChild(_canvas);
        style = _canvas.style;
        style.position = 'absolute';
        style.left = '0';
        style.transformOrigin = 'top left';
        this.container = container;
        this.context = context;
      }

      if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
        this.container.style.backgroundColor = backgroundColor;
      }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */

  }, {
    key: "clipUnrotated",
    value: function clipUnrotated(context, frameState, extent) {
      var topLeft = getTopLeft(extent);
      var topRight = getTopRight(extent);
      var bottomRight = getBottomRight(extent);
      var bottomLeft = getBottomLeft(extent);
      apply(frameState.coordinateToPixelTransform, topLeft);
      apply(frameState.coordinateToPixelTransform, topRight);
      apply(frameState.coordinateToPixelTransform, bottomRight);
      apply(frameState.coordinateToPixelTransform, bottomLeft);
      var inverted = this.inversePixelTransform;
      apply(inverted, topLeft);
      apply(inverted, topRight);
      apply(inverted, bottomRight);
      apply(inverted, bottomLeft);
      context.save();
      context.beginPath();
      context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
      context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
      context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
      context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
      context.clip();
    }
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */

  }, {
    key: "dispatchRenderEvent_",
    value: function dispatchRenderEvent_(type, context, frameState) {
      var layer = this.getLayer();

      if (layer.hasListener(type)) {
        var event = new render_Event(type, this.inversePixelTransform, frameState, context);
        layer.dispatchEvent(event);
      }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */

  }, {
    key: "preRender",
    value: function preRender(context, frameState) {
      this.frameState = frameState;
      this.dispatchRenderEvent_(render_EventType.PRERENDER, context, frameState);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */

  }, {
    key: "postRender",
    value: function postRender(context, frameState) {
      this.dispatchRenderEvent_(render_EventType.POSTRENDER, context, frameState);
    }
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */

  }, {
    key: "getRenderTransform",
    value: function getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
      var dx1 = width / 2;
      var dy1 = height / 2;
      var sx = pixelRatio / resolution;
      var sy = -sx;
      var dx2 = -center[0] + offsetX;
      var dy2 = -center[1];
      return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    }
    /**
     * Clean up.
     */

  }, {
    key: "disposeInternal",
    value: function disposeInternal() {
      delete this.frameState;

      _get(getPrototypeOf_getPrototypeOf(CanvasLayerRenderer.prototype), "disposeInternal", this).call(this);
    }
  }]);

  return CanvasLayerRenderer;
}(renderer_Layer);

/* harmony default export */ var canvas_Layer = (CanvasLayerRenderer);
;// CONCATENATED MODULE: ./node_modules/ol/Tile.js





/**
 * @module ol/Tile
 */





/**
 * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */

var Tile = /*#__PURE__*/function (_EventTarget) {
  _inherits(Tile, _EventTarget);

  var _super = createSuper_createSuper(Tile);

  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  function Tile(tileCoord, state, options) {
    var _this;

    _classCallCheck(this, Tile);

    _this = _super.call(this);
    options = options ? options : {};
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */

    _this.tileCoord = tileCoord;
    /**
     * @protected
     * @type {import("./TileState.js").default}
     */

    _this.state = state;
    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */

    _this.interimTile = null;
    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */

    _this.key = '';
    /**
     * The duration for the opacity transition.
     * @type {number}
     */

    _this.transition_ = options.transition === undefined ? 250 : options.transition;
    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */

    _this.transitionStarts_ = {};
    /**
     * @type {boolean}
     */

    _this.interpolate = !!options.interpolate;
    return _this;
  }
  /**
   * @protected
   */


  _createClass(Tile, [{
    key: "changed",
    value: function changed() {
      this.dispatchEvent(EventType.CHANGE);
    }
    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */

  }, {
    key: "release",
    value: function release() {
      if (this.state === TileState.ERROR) {
        // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
        this.setState(TileState.EMPTY);
      }
    }
    /**
     * @return {string} Key.
     */

  }, {
    key: "getKey",
    value: function getKey() {
      return this.key + '/' + this.tileCoord;
    }
    /**
     * Get the interim tile most suitable for rendering using the chain of interim
     * tiles. This corresponds to the  most recent tile that has been loaded, if no
     * such tile exists, the original tile is returned.
     * @return {!Tile} Best tile for rendering.
     */

  }, {
    key: "getInterimTile",
    value: function getInterimTile() {
      if (!this.interimTile) {
        //empty chain
        return this;
      }

      var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in
      // decreasing order of creation time, there is no need to search the remainder
      // of the list (all those tiles correspond to older requests and will be
      // cleaned up by refreshInterimChain)

      do {
        if (tile.getState() == TileState.LOADED) {
          // Show tile immediately instead of fading it in after loading, because
          // the interim tile is in place already
          this.transition_ = 0;
          return tile;
        }

        tile = tile.interimTile;
      } while (tile); // we can not find a better tile


      return this;
    }
    /**
     * Goes through the chain of interim tiles and discards sections of the chain
     * that are no longer relevant.
     */

  }, {
    key: "refreshInterimChain",
    value: function refreshInterimChain() {
      if (!this.interimTile) {
        return;
      }

      var tile = this.interimTile;
      /**
       * @type {Tile}
       */

      var prev = this;

      do {
        if (tile.getState() == TileState.LOADED) {
          //we have a loaded tile, we can discard the rest of the list
          //we would could abort any LOADING tile request
          //older than this tile (i.e. any LOADING tile following this entry in the chain)
          tile.interimTile = null;
          break;
        } else if (tile.getState() == TileState.LOADING) {
          //keep this LOADING tile any loaded tiles later in the chain are
          //older than this tile, so we're still interested in the request
          prev = tile;
        } else if (tile.getState() == TileState.IDLE) {
          //the head of the list is the most current tile, we don't need
          //to start any other requests for this chain
          prev.interimTile = tile.interimTile;
        } else {
          prev = tile;
        }

        tile = prev.interimTile;
      } while (tile);
    }
    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */

  }, {
    key: "getTileCoord",
    value: function getTileCoord() {
      return this.tileCoord;
    }
    /**
     * @return {import("./TileState.js").default} State.
     */

  }, {
    key: "getState",
    value: function getState() {
      return this.state;
    }
    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */

  }, {
    key: "setState",
    value: function setState(state) {
      if (this.state !== TileState.ERROR && this.state > state) {
        throw new Error('Tile load sequence violation');
      }

      this.state = state;
      this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */

  }, {
    key: "load",
    value: function load() {
      util_abstract();
    }
    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */

  }, {
    key: "getAlpha",
    value: function getAlpha(id, time) {
      if (!this.transition_) {
        return 1;
      }

      var start = this.transitionStarts_[id];

      if (!start) {
        start = time;
        this.transitionStarts_[id] = start;
      } else if (start === -1) {
        return 1;
      }

      var delta = time - start + 1000 / 60; // avoid rendering at 0

      if (delta >= this.transition_) {
        return 1;
      }

      return easeIn(delta / this.transition_);
    }
    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */

  }, {
    key: "inTransition",
    value: function inTransition(id) {
      if (!this.transition_) {
        return false;
      }

      return this.transitionStarts_[id] !== -1;
    }
    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */

  }, {
    key: "endTransition",
    value: function endTransition(id) {
      if (this.transition_) {
        this.transitionStarts_[id] = -1;
      }
    }
  }]);

  return Tile;
}(events_Target);

/* harmony default export */ var ol_Tile = (Tile);
;// CONCATENATED MODULE: ./node_modules/ol/ImageBase.js





/**
 * @module ol/ImageBase
 */



/**
 * @abstract
 */

var ImageBase = /*#__PURE__*/function (_EventTarget) {
  _inherits(ImageBase, _EventTarget);

  var _super = createSuper_createSuper(ImageBase);

  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */
  function ImageBase(extent, resolution, pixelRatio, state) {
    var _this;

    _classCallCheck(this, ImageBase);

    _this = _super.call(this);
    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */

    _this.extent = extent;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @protected
     * @type {number|undefined}
     */

    _this.resolution = resolution;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */

    _this.state = state;
    return _this;
  }
  /**
   * @protected
   */


  _createClass(ImageBase, [{
    key: "changed",
    value: function changed() {
      this.dispatchEvent(EventType.CHANGE);
    }
    /**
     * @return {import("./extent.js").Extent} Extent.
     */

  }, {
    key: "getExtent",
    value: function getExtent() {
      return this.extent;
    }
    /**
     * @abstract
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     */

  }, {
    key: "getImage",
    value: function getImage() {
      return util_abstract();
    }
    /**
     * @return {number} PixelRatio.
     */

  }, {
    key: "getPixelRatio",
    value: function getPixelRatio() {
      return this.pixelRatio_;
    }
    /**
     * @return {number} Resolution.
     */

  }, {
    key: "getResolution",
    value: function getResolution() {
      return (
        /** @type {number} */
        this.resolution
      );
    }
    /**
     * @return {import("./ImageState.js").default} State.
     */

  }, {
    key: "getState",
    value: function getState() {
      return this.state;
    }
    /**
     * Load not yet loaded URI.
     * @abstract
     */

  }, {
    key: "load",
    value: function load() {
      util_abstract();
    }
  }]);

  return ImageBase;
}(events_Target);

/* harmony default export */ var ol_ImageBase = (ImageBase);
;// CONCATENATED MODULE: ./node_modules/ol/Image.js





/**
 * @module ol/Image
 */






/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */

var ImageWrapper = /*#__PURE__*/function (_ImageBase) {
  _inherits(ImageWrapper, _ImageBase);

  var _super = createSuper_createSuper(ImageWrapper);

  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   */
  function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
    var _this;

    _classCallCheck(this, ImageWrapper);

    _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE);
    /**
     * @private
     * @type {string}
     */

    _this.src_ = src;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */

    _this.state = ImageState.IDLE;
    /**
     * @private
     * @type {LoadFunction}
     */

    _this.imageLoadFunction_ = imageLoadFunction;
    return _this;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */


  _createClass(ImageWrapper, [{
    key: "getImage",
    value: function getImage() {
      return this.image_;
    }
    /**
     * Tracks loading or read errors.
     *
     * @private
     */

  }, {
    key: "handleImageError_",
    value: function handleImageError_() {
      this.state = ImageState.ERROR;
      this.unlistenImage_();
      this.changed();
    }
    /**
     * Tracks successful image load.
     *
     * @private
     */

  }, {
    key: "handleImageLoad_",
    value: function handleImageLoad_() {
      if (this.resolution === undefined) {
        this.resolution = getHeight(this.extent) / this.image_.height;
      }

      this.state = ImageState.LOADED;
      this.unlistenImage_();
      this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @api
     */

  }, {
    key: "load",
    value: function load() {
      if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
        this.state = ImageState.LOADING;
        this.changed();
        this.imageLoadFunction_(this, this.src_);
        this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
      }
    }
    /**
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
     */

  }, {
    key: "setImage",
    value: function setImage(image) {
      this.image_ = image;
      this.resolution = getHeight(this.extent) / this.image_.height;
    }
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */

  }, {
    key: "unlistenImage_",
    value: function unlistenImage_() {
      if (this.unlisten_) {
        this.unlisten_();
        this.unlisten_ = null;
      }
    }
  }]);

  return ImageWrapper;
}(ol_ImageBase);
/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */


function listenImage(image, loadHandler, errorHandler) {
  var img =
  /** @type {HTMLImageElement} */
  image;
  var listening = true;
  var decoding = false;
  var loaded = false;
  var listenerKeys = [listenOnce(img, EventType.LOAD, function () {
    loaded = true;

    if (!decoding) {
      loadHandler();
    }
  })];

  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function () {
      if (listening) {
        loadHandler();
      }
    }).catch(function (error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));
  }

  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
/* harmony default export */ var ol_Image = ((/* unused pure expression or super */ null && (ImageWrapper)));
;// CONCATENATED MODULE: ./node_modules/ol/ImageTile.js





/**
 * @module ol/ImageTile
 */





var ImageTile = /*#__PURE__*/function (_Tile) {
  _inherits(ImageTile, _Tile);

  var _super = createSuper_createSuper(ImageTile);

  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    var _this;

    _classCallCheck(this, ImageTile);

    _this = _super.call(this, tileCoord, state, options);
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = crossOrigin;
    /**
     * Image URI
     *
     * @private
     * @type {string}
     */

    _this.src_ = src;
    _this.key = src;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */

    _this.tileLoadFunction_ = tileLoadFunction;
    return _this;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */


  _createClass(ImageTile, [{
    key: "getImage",
    value: function getImage() {
      return this.image_;
    }
    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */

  }, {
    key: "setImage",
    value: function setImage(element) {
      this.image_ = element;
      this.state = TileState.LOADED;
      this.unlistenImage_();
      this.changed();
    }
    /**
     * Tracks loading or read errors.
     *
     * @private
     */

  }, {
    key: "handleImageError_",
    value: function handleImageError_() {
      this.state = TileState.ERROR;
      this.unlistenImage_();
      this.image_ = getBlankImage();
      this.changed();
    }
    /**
     * Tracks successful image load.
     *
     * @private
     */

  }, {
    key: "handleImageLoad_",
    value: function handleImageLoad_() {
      var image =
      /** @type {HTMLImageElement} */
      this.image_;

      if (image.naturalWidth && image.naturalHeight) {
        this.state = TileState.LOADED;
      } else {
        this.state = TileState.EMPTY;
      }

      this.unlistenImage_();
      this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     *
     * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
     * that checks for error status codes and reloads only when the status code is
     * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
     * made already:
     *
     * ```js
     * const retryCodes = [408, 429, 500, 502, 503, 504];
     * const retries = {};
     * source.setTileLoadFunction((tile, src) => {
     *   const image = tile.getImage();
     *   fetch(src)
     *     .then((response) => {
     *       if (retryCodes.includes(response.status)) {
     *         retries[src] = (retries[src] || 0) + 1;
     *         if (retries[src] <= 3) {
     *           setTimeout(() => tile.load(), retries[src] * 1000);
     *         }
     *         return Promise.reject();
     *       }
     *       return response.blob();
     *     })
     *     .then((blob) => {
     *       const imageUrl = URL.createObjectURL(blob);
     *       image.src = imageUrl;
     *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
     *     })
     *     .catch(() => tile.setState(3)); // error
     * });
     * ```
     *
     * @api
     */

  }, {
    key: "load",
    value: function load() {
      if (this.state == TileState.ERROR) {
        this.state = TileState.IDLE;
        this.image_ = new Image();

        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }

      if (this.state == TileState.IDLE) {
        this.state = TileState.LOADING;
        this.changed();
        this.tileLoadFunction_(this, this.src_);
        this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
      }
    }
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */

  }, {
    key: "unlistenImage_",
    value: function unlistenImage_() {
      if (this.unlisten_) {
        this.unlisten_();
        this.unlisten_ = null;
      }
    }
  }]);

  return ImageTile;
}(ol_Tile);
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */


function getBlankImage() {
  var ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ var ol_ImageTile = (ImageTile);
;// CONCATENATED MODULE: ./node_modules/ol/reproj/common.js
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;
;// CONCATENATED MODULE: ./node_modules/ol/reproj/Triangulation.js



/**
 * @module ol/reproj/Triangulation
 */



/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */

var MAX_SUBDIVISION = 10;
/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */

var MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */

var Triangulation = /*#__PURE__*/function () {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    _classCallCheck(this, Triangulation);

    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */

    this.targetProj_ = targetProj;
    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */

    var transformInvCache = {};
    var transformInv = getTransform(this.targetProj_, this.sourceProj_);
    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */

    this.transformInv_ = function (c) {
      var key = c[0] + '/' + c[1];

      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }

      return transformInvCache[key];
    };
    /**
     * @type {import("../extent.js").Extent}
     * @private
     */


    this.maxSourceExtent_ = maxSourceExtent;
    /**
     * @type {number}
     * @private
     */

    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    /**
     * @type {Array<Triangle>}
     * @private
     */

    this.triangles_ = [];
    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */

    this.wrapsXInSource_ = false;
    /**
     * @type {boolean}
     * @private
     */

    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
    /**
     * @type {?number}
     * @private
     */

    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    /**
     * @type {?number}
     * @private
     */

    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    var destinationTopLeft = getTopLeft(targetExtent);
    var destinationTopRight = getTopRight(targetExtent);
    var destinationBottomRight = getBottomRight(targetExtent);
    var destinationBottomLeft = getBottomLeft(targetExtent);
    var sourceTopLeft = this.transformInv_(destinationTopLeft);
    var sourceTopRight = this.transformInv_(destinationTopRight);
    var sourceBottomRight = this.transformInv_(destinationBottomRight);
    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overal reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */

    var maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);
    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);

    if (this.wrapsXInSource_) {
      var leftBound = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
      }); // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.

      this.triangles_.forEach(function (triangle) {
        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];

          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          } // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.


          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);

          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      }.bind(this));
    }

    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */


  _createClass(Triangulation, [{
    key: "addTriangle_",
    value: function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
      this.triangles_.push({
        source: [aSrc, bSrc, cSrc],
        target: [a, b, c]
      });
    }
    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */

  }, {
    key: "addQuad_",
    value: function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
      var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
      var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
      var sourceWorldWidth =
      /** @type {number} */
      this.sourceWorldWidth_; // when the quad is wrapped in the source projection
      // it covers most of the projection extent, but not fully

      var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
      var needsSubdivision = false;

      if (maxSubdivision > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          var targetQuadExtent = boundingExtent([a, b, c, d]);
          var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
          needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }

        if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
          needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }
      }

      if (!needsSubdivision && this.maxSourceExtent_) {
        if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
          if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
            // whole quad outside source projection extent -> ignore
            return;
          }
        }
      }

      var isNotFinite = 0;

      if (!needsSubdivision) {
        if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
          if (maxSubdivision > 0) {
            needsSubdivision = true;
          } else {
            // It might be the case that only 1 of the points is infinite. In this case
            // we can draw a single triangle with the other three points
            isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);

            if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
              return;
            }
          }
        }
      }

      if (maxSubdivision > 0) {
        if (!needsSubdivision) {
          var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
          var centerSrc = this.transformInv_(center);
          var dx;

          if (wrapsX) {
            var centerSrcEstimX = (math_modulo(aSrc[0], sourceWorldWidth) + math_modulo(cSrc[0], sourceWorldWidth)) / 2;
            dx = centerSrcEstimX - math_modulo(centerSrc[0], sourceWorldWidth);
          } else {
            dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
          }

          var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
          var centerSrcErrorSquared = dx * dx + dy * dy;
          needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
        }

        if (needsSubdivision) {
          if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
            // split horizontally (top & bottom)
            var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
            var bcSrc = this.transformInv_(bc);
            var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
            var daSrc = this.transformInv_(da);
            this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
            this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
          } else {
            // split vertically (left & right)
            var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
            var abSrc = this.transformInv_(ab);
            var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
            var cdSrc = this.transformInv_(cd);
            this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
            this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
          }

          return;
        }
      }

      if (wrapsX) {
        if (!this.canWrapXInSource_) {
          return;
        }

        this.wrapsXInSource_ = true;
      } // Exactly zero or one of *Src is not finite
      // The triangles must have the diagonal line as the first side
      // This is to allow easy code in reproj.s to make it straight for broken
      // browsers that can't handle diagonal clipping


      if ((isNotFinite & 0xb) == 0) {
        this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
      }

      if ((isNotFinite & 0xe) == 0) {
        this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
      }

      if (isNotFinite) {
        // Try the other two triangles
        if ((isNotFinite & 0xd) == 0) {
          this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
        }

        if ((isNotFinite & 0x7) == 0) {
          this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
        }
      }
    }
    /**
     * Calculates extent of the `source` coordinates from all the triangles.
     *
     * @return {import("../extent.js").Extent} Calculated extent.
     */

  }, {
    key: "calculateSourceExtent",
    value: function calculateSourceExtent() {
      var extent = createEmpty();
      this.triangles_.forEach(function (triangle, i, arr) {
        var src = triangle.source;
        extendCoordinate(extent, src[0]);
        extendCoordinate(extent, src[1]);
        extendCoordinate(extent, src[2]);
      });
      return extent;
    }
    /**
     * @return {Array<Triangle>} Array of the calculated triangles.
     */

  }, {
    key: "getTriangles",
    value: function getTriangles() {
      return this.triangles_;
    }
  }]);

  return Triangulation;
}();

/* harmony default export */ var reproj_Triangulation = (Triangulation);
;// CONCATENATED MODULE: ./node_modules/ol/reproj.js
/**
 * @module ol/reproj
 */




var brokenDiagonalRendering_;
/**
 * @type {Array<HTMLCanvasElement>}
 */

var reproj_canvasPool = [];
/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */

function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */


function verifyBrokenDiagonalRendering(data, offset) {
  // the values ought to be close to the rgba(210, 0, 0, 0.75)
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */


function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === undefined) {
    var ctx = document.createElement('canvas').getContext('2d');
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    var data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
  }

  return brokenDiagonalRendering_;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */


function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data

  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();

  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }

  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();

  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  } // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.


  var sourceExtent = sourceProj.getExtent();

  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */

function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  var targetCenter = getCenter(targetExtent);
  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function (corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }

  return sourceResolution;
}
/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 */

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */

function reproj_render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate) {
  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height), reproj_canvasPool);

  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }

  context.globalCompositeOperation = 'lighter';
  var sourceDataExtent = createEmpty();
  sources.forEach(function (src, i, arr) {
    extent_extend(sourceDataExtent, src.extent);
  });
  var canvasWidthInUnits = getWidth(sourceDataExtent);
  var canvasHeightInUnits = getHeight(sourceDataExtent);
  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  if (!interpolate) {
    stitchContext.imageSmoothingEnabled = false;
  }

  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = getWidth(src.extent);
    var srcHeight = getHeight(src.extent); // This test should never fail -- but it does. Need to find a fix the upstream condition

    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    }
  });
  var targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1];
    var x1 = source[1][0],
        y1 = source[1][1];
    var x2 = source[2][0],
        y2 = source[2][1]; // Make sure that everything is on pixel boundaries

    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution); // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.

    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = solveLinearSystem(augmentedMatrix);

    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();

    if (isBrokenDiagonalRendering() || !interpolate) {
      // Make sure that all lines are horizontal or vertical
      context.moveTo(u1, v1); // This is the diagonal line. Do it in 4 steps

      var steps = 4;
      var ud = u0 - u1;
      var vd = v0 - v1;

      for (var step = 0; step < steps; step++) {
        // Go horizontally
        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1))); // Go vertically

        if (step != steps - 1) {
          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
        }
      } // We are almost at u0r, v0r


      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }

    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = 'source-over';
    context.strokeStyle = 'black';
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }

  return context.canvas;
}
;// CONCATENATED MODULE: ./node_modules/ol/reproj/Tile.js








/**
 * @module ol/reproj/Tile
 */










/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */

var ReprojTile = /*#__PURE__*/function (_Tile) {
  _inherits(ReprojTile, _Tile);

  var _super = createSuper_createSuper(ReprojTile);

  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */
  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, interpolate) {
    var _this;

    _classCallCheck(this, ReprojTile);

    _this = _super.call(this, tileCoord, TileState.IDLE, {
      interpolate: !!interpolate
    });
    /**
     * @private
     * @type {boolean}
     */

    _this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = gutter;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.sourceTileGrid_ = sourceTileGrid;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.targetTileGrid_ = targetTileGrid;
    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */

    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */

    _this.sourceTiles_ = [];
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */

    _this.sourcesListenerKeys_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.sourceZ_ = 0;
    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);

    var maxTargetExtent = _this.targetTileGrid_.getExtent();

    var maxSourceExtent = _this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;

    if (getArea(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      _this.state = TileState.EMPTY;
      return possibleConstructorReturn_possibleConstructorReturn(_this);
    }

    var sourceProjExtent = sourceProj.getExtent();

    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      _this.state = TileState.EMPTY;
      return possibleConstructorReturn_possibleConstructorReturn(_this);
    }

    var errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */

    _this.triangulation_ = new reproj_Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);

    if (_this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      _this.state = TileState.EMPTY;
      return possibleConstructorReturn_possibleConstructorReturn(_this);
    }

    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);

    var sourceExtent = _this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = math_clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = math_clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }

    if (!getArea(sourceExtent)) {
      _this.state = TileState.EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);

          if (tile) {
            _this.sourceTiles_.push(tile);
          }
        }
      }

      if (_this.sourceTiles_.length === 0) {
        _this.state = TileState.EMPTY;
      }
    }

    return _this;
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */


  _createClass(ReprojTile, [{
    key: "getImage",
    value: function getImage() {
      return this.canvas_;
    }
    /**
     * @private
     */

  }, {
    key: "reproject_",
    value: function reproject_() {
      var sources = [];
      this.sourceTiles_.forEach(function (tile, i, arr) {
        if (tile && tile.getState() == TileState.LOADED) {
          sources.push({
            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
            image: tile.getImage()
          });
        }
      }.bind(this));
      this.sourceTiles_.length = 0;

      if (sources.length === 0) {
        this.state = TileState.ERROR;
      } else {
        var z = this.wrappedTileCoord_[0];
        var size = this.targetTileGrid_.getTileSize(z);
        var width = typeof size === 'number' ? size : size[0];
        var height = typeof size === 'number' ? size : size[1];
        var targetResolution = this.targetTileGrid_.getResolution(z);
        var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
        var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        this.canvas_ = reproj_render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
        this.state = TileState.LOADED;
      }

      this.changed();
    }
    /**
     * Load not yet loaded URI.
     */

  }, {
    key: "load",
    value: function load() {
      if (this.state == TileState.IDLE) {
        this.state = TileState.LOADING;
        this.changed();
        var leftToLoad = 0;
        this.sourcesListenerKeys_ = [];
        this.sourceTiles_.forEach(function (tile, i, arr) {
          var state = tile.getState();

          if (state == TileState.IDLE || state == TileState.LOADING) {
            leftToLoad++;
            var sourceListenKey = listen(tile, EventType.CHANGE, function (e) {
              var state = tile.getState();

              if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {
                unlistenByKey(sourceListenKey);
                leftToLoad--;

                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            }, this);
            this.sourcesListenerKeys_.push(sourceListenKey);
          }
        }.bind(this));

        if (leftToLoad === 0) {
          setTimeout(this.reproject_.bind(this), 0);
        } else {
          this.sourceTiles_.forEach(function (tile, i, arr) {
            var state = tile.getState();

            if (state == TileState.IDLE) {
              tile.load();
            }
          });
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "unlistenSources_",
    value: function unlistenSources_() {
      this.sourcesListenerKeys_.forEach(unlistenByKey);
      this.sourcesListenerKeys_ = null;
    }
    /**
     * Remove from the cache due to expiry
     */

  }, {
    key: "release",
    value: function release() {
      if (this.canvas_) {
        releaseCanvas(this.canvas_.getContext('2d'));
        reproj_canvasPool.push(this.canvas_);
        this.canvas_ = null;
      }

      _get(getPrototypeOf_getPrototypeOf(ReprojTile.prototype), "release", this).call(this);
    }
  }]);

  return ReprojTile;
}(ol_Tile);

/* harmony default export */ var reproj_Tile = (ReprojTile);
;// CONCATENATED MODULE: ./node_modules/ol/TileRange.js



/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange = /*#__PURE__*/function () {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  function TileRange(minX, maxX, minY, maxY) {
    _classCallCheck(this, TileRange);

    /**
     * @type {number}
     */
    this.minX = minX;
    /**
     * @type {number}
     */

    this.maxX = maxX;
    /**
     * @type {number}
     */

    this.minY = minY;
    /**
     * @type {number}
     */

    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */


  _createClass(TileRange, [{
    key: "contains",
    value: function contains(tileCoord) {
      return this.containsXY(tileCoord[1], tileCoord[2]);
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */

  }, {
    key: "containsTileRange",
    value: function containsTileRange(tileRange) {
      return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    }
    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */

  }, {
    key: "containsXY",
    value: function containsXY(x, y) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */

  }, {
    key: "equals",
    value: function equals(tileRange) {
      return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     */

  }, {
    key: "extend",
    value: function extend(tileRange) {
      if (tileRange.minX < this.minX) {
        this.minX = tileRange.minX;
      }

      if (tileRange.maxX > this.maxX) {
        this.maxX = tileRange.maxX;
      }

      if (tileRange.minY < this.minY) {
        this.minY = tileRange.minY;
      }

      if (tileRange.maxY > this.maxY) {
        this.maxY = tileRange.maxY;
      }
    }
    /**
     * @return {number} Height.
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.maxY - this.minY + 1;
    }
    /**
     * @return {import("./size.js").Size} Size.
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return [this.getWidth(), this.getHeight()];
    }
    /**
     * @return {number} Width.
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.maxX - this.minX + 1;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */

  }, {
    key: "intersects",
    value: function intersects(tileRange) {
      return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
    }
  }]);

  return TileRange;
}();
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */


function TileRange_createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}
/* harmony default export */ var ol_TileRange = (TileRange);
;// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/TileLayer.js







/**
 * @module ol/renderer/canvas/TileLayer
 */











/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */

var CanvasTileLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {
  _inherits(CanvasTileLayerRenderer, _CanvasLayerRenderer);

  var _super = createSuper_createSuper(CanvasTileLayerRenderer);

  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  function CanvasTileLayerRenderer(tileLayer) {
    var _this;

    _classCallCheck(this, CanvasTileLayerRenderer);

    _this = _super.call(this, tileLayer);
    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */

    _this.extentChanged = true;
    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedPixelRatio;
    /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */

    _this.renderedProjection = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedRevision;
    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */

    _this.renderedTiles = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.newTiles_ = false;
    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */

    _this.tmpExtent = createEmpty();
    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */

    _this.tmpTileRange_ = new ol_TileRange(0, 0, 0, 0);
    return _this;
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */


  _createClass(CanvasTileLayerRenderer, [{
    key: "isDrawableTile",
    value: function isDrawableTile(tile) {
      var tileLayer = this.getLayer();
      var tileState = tile.getState();
      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
      return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {!import("../../Tile.js").default} Tile.
     */

  }, {
    key: "getTile",
    value: function getTile(z, x, y, frameState) {
      var pixelRatio = frameState.pixelRatio;
      var projection = frameState.viewState.projection;
      var tileLayer = this.getLayer();
      var tileSource = tileLayer.getSource();
      var tile = tileSource.getTile(z, x, y, pixelRatio, projection);

      if (tile.getState() == TileState.ERROR) {
        if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
          // Preloaded tiles for lower resolutions might have finished loading.
          this.newTiles_ = true;
        }
      }

      if (!this.isDrawableTile(tile)) {
        tile = tile.getInterimTile();
      }

      return tile;
    }
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     */

  }, {
    key: "getData",
    value: function getData(pixel) {
      var frameState = this.frameState;

      if (!frameState) {
        return null;
      }

      var layer = this.getLayer();
      var coordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
      var layerExtent = layer.getExtent();

      if (layerExtent) {
        if (!containsCoordinate(layerExtent, coordinate)) {
          return null;
        }
      }

      var pixelRatio = frameState.pixelRatio;
      var projection = frameState.viewState.projection;
      var viewState = frameState.viewState;
      var source = layer.getRenderSource();
      var tileGrid = source.getTileGridForProjection(viewState.projection);
      var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);

      for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
        var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
        var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);

        if (!(tile instanceof ol_ImageTile || tile instanceof reproj_Tile) || tile instanceof reproj_Tile && tile.getState() === TileState.EMPTY) {
          return null;
        }

        if (tile.getState() !== TileState.LOADED) {
          continue;
        }

        var tileOrigin = tileGrid.getOrigin(z);
        var tileSize = toSize(tileGrid.getTileSize(z));
        var tileResolution = tileGrid.getResolution(z);
        var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
        var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
        var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));
        return this.getImageData(tile.getImage(), col + gutter, row + gutter);
      }

      return null;
    }
    /**
     * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */

  }, {
    key: "loadedTileCallback",
    value: function loadedTileCallback(tiles, zoom, tile) {
      if (this.isDrawableTile(tile)) {
        return _get(getPrototypeOf_getPrototypeOf(CanvasTileLayerRenderer.prototype), "loadedTileCallback", this).call(this, tiles, zoom, tile);
      }

      return false;
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */

  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      return !!this.getLayer().getSource();
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */

  }, {
    key: "renderFrame",
    value: function renderFrame(frameState, target) {
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      var viewState = frameState.viewState;
      var projection = viewState.projection;
      var viewResolution = viewState.resolution;
      var viewCenter = viewState.center;
      var rotation = viewState.rotation;
      var pixelRatio = frameState.pixelRatio;
      var tileLayer = this.getLayer();
      var tileSource = tileLayer.getSource();
      var sourceRevision = tileSource.getRevision();
      var tileGrid = tileSource.getTileGridForProjection(projection);
      var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
      var tileResolution = tileGrid.getResolution(z);
      var extent = frameState.extent;
      var resolution = frameState.viewState.resolution;
      var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels

      var width = Math.round(getWidth(extent) / resolution * pixelRatio);
      var height = Math.round(getHeight(extent) / resolution * pixelRatio);
      var layerExtent = layerState.extent && proj_fromUserExtent(layerState.extent, projection);

      if (layerExtent) {
        extent = getIntersection(extent, proj_fromUserExtent(layerState.extent, projection));
      }

      var dx = tileResolution * width / 2 / tilePixelRatio;
      var dy = tileResolution * height / 2 / tilePixelRatio;
      var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /**
       * @type {Object<number, Object<string, import("../../Tile.js").default>>}
       */

      var tilesToDrawByZ = {};
      tilesToDrawByZ[z] = {};
      var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
      var tmpExtent = this.tmpExtent;
      var tmpTileRange = this.tmpTileRange_;
      this.newTiles_ = false;
      var viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;

      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
            continue;
          }

          var tile = this.getTile(z, x, y, frameState);

          if (this.isDrawableTile(tile)) {
            var uid = getUid(this);

            if (tile.getState() == TileState.LOADED) {
              tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
              var inTransition = tile.inTransition(uid);

              if (inTransition && layerState.opacity !== 1) {
                // Skipping transition when layer is not fully opaque avoids visual artifacts.
                tile.endTransition(uid);
                inTransition = false;
              }

              if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {
                this.newTiles_ = true;
              }
            }

            if (tile.getAlpha(uid, frameState.time) === 1) {
              // don't look for alt tiles if alpha is 1
              continue;
            }
          }

          var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
          var covered = false;

          if (childTileRange) {
            covered = findLoadedTiles(z + 1, childTileRange);
          }

          if (!covered) {
            tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
          }
        }
      }

      var canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio; // set forward and inverse pixel transforms

      compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
      var canvasTransform = transform_toString(this.pixelTransform);
      this.useContainer(target, canvasTransform, this.getBackground(frameState));
      var context = this.context;
      var canvas = context.canvas;
      makeInverse(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas

      compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);

      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      } else if (!this.containerReused) {
        context.clearRect(0, 0, width, height);
      }

      if (layerExtent) {
        this.clipUnrotated(context, frameState, layerExtent);
      }

      if (!tileSource.getInterpolate()) {
        context.imageSmoothingEnabled = false;
      }

      this.preRender(context, frameState);
      this.renderedTiles.length = 0;
      /** @type {Array<number>} */

      var zs = Object.keys(tilesToDrawByZ).map(Number);
      zs.sort(numberSafeCompareFunction);
      var clips, clipZs, currentClip;

      if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
        zs = zs.reverse();
      } else {
        clips = [];
        clipZs = [];
      }

      for (var i = zs.length - 1; i >= 0; --i) {
        var currentZ = zs[i];
        var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
        var currentResolution = tileGrid.getResolution(currentZ);
        var currentScale = currentResolution / tileResolution;

        var _dx = currentTilePixelSize[0] * currentScale * canvasScale;

        var _dy = currentTilePixelSize[1] * currentScale * canvasScale;

        var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
        var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
        var origin = apply(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);
        var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
        var tilesToDraw = tilesToDrawByZ[currentZ];

        for (var tileCoordKey in tilesToDraw) {
          var _tile =
          /** @type {import("../../ImageTile.js").default} */
          tilesToDraw[tileCoordKey];
          var tileCoord = _tile.tileCoord; // Calculate integer positions and sizes so that tiles align

          var xIndex = originTileCoord[1] - tileCoord[1];
          var nextX = Math.round(origin[0] - (xIndex - 1) * _dx);
          var yIndex = originTileCoord[2] - tileCoord[2];
          var nextY = Math.round(origin[1] - (yIndex - 1) * _dy);

          var _x = Math.round(origin[0] - xIndex * _dx);

          var _y = Math.round(origin[1] - yIndex * _dy);

          var w = nextX - _x;
          var h = nextY - _y;
          var transition = z === currentZ;

          var _inTransition = transition && _tile.getAlpha(getUid(this), frameState.time) !== 1;

          var contextSaved = false;

          if (!_inTransition) {
            if (clips) {
              // Clip mask for regions in this tile that already filled by a higher z tile
              currentClip = [_x, _y, _x + w, _y, _x + w, _y + h, _x, _y + h];

              for (var _i = 0, ii = clips.length; _i < ii; ++_i) {
                if (z !== currentZ && currentZ < clipZs[_i]) {
                  var clip = clips[_i];

                  if (intersects([_x, _y, _x + w, _y + h], [clip[0], clip[3], clip[4], clip[7]])) {
                    if (!contextSaved) {
                      context.save();
                      contextSaved = true;
                    }

                    context.beginPath(); // counter-clockwise (outer ring) for current tile

                    context.moveTo(currentClip[0], currentClip[1]);
                    context.lineTo(currentClip[2], currentClip[3]);
                    context.lineTo(currentClip[4], currentClip[5]);
                    context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile

                    context.moveTo(clip[6], clip[7]);
                    context.lineTo(clip[4], clip[5]);
                    context.lineTo(clip[2], clip[3]);
                    context.lineTo(clip[0], clip[1]);
                    context.clip();
                  }
                }
              }

              clips.push(currentClip);
              clipZs.push(currentZ);
            } else {
              context.clearRect(_x, _y, w, h);
            }
          }

          this.drawTileImage(_tile, frameState, _x, _y, w, h, tileGutter, transition);

          if (clips && !_inTransition) {
            if (contextSaved) {
              context.restore();
            }

            this.renderedTiles.unshift(_tile);
          } else {
            this.renderedTiles.push(_tile);
          }

          this.updateUsedTiles(frameState.usedTiles, tileSource, _tile);
        }
      }

      this.renderedRevision = sourceRevision;
      this.renderedResolution = tileResolution;
      this.extentChanged = !this.renderedExtent_ || !extent_equals(this.renderedExtent_, canvasExtent);
      this.renderedExtent_ = canvasExtent;
      this.renderedPixelRatio = pixelRatio;
      this.renderedProjection = projection;
      this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
      this.scheduleExpireCache(frameState, tileSource);
      this.postRender(context, frameState);

      if (layerState.extent) {
        context.restore();
      }

      context.imageSmoothingEnabled = true;

      if (canvasTransform !== canvas.style.transform) {
        canvas.style.transform = canvasTransform;
      }

      return this.container;
    }
    /**
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     */

  }, {
    key: "drawTileImage",
    value: function drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
      var image = this.getTileImage(tile);

      if (!image) {
        return;
      }

      var uid = getUid(this);
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      var alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
      var alphaChanged = alpha !== this.context.globalAlpha;

      if (alphaChanged) {
        this.context.save();
        this.context.globalAlpha = alpha;
      }

      this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

      if (alphaChanged) {
        this.context.restore();
      }

      if (alpha !== layerState.opacity) {
        frameState.animate = true;
      } else if (transition) {
        tile.endTransition(uid);
      }
    }
    /**
     * @return {HTMLCanvasElement} Image
     */

  }, {
    key: "getImage",
    value: function getImage() {
      var context = this.context;
      return context ? context.canvas : null;
    }
    /**
     * Get the image from a tile.
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @protected
     */

  }, {
    key: "getTileImage",
    value: function getTileImage(tile) {
      return tile.getImage();
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @protected
     */

  }, {
    key: "scheduleExpireCache",
    value: function scheduleExpireCache(frameState, tileSource) {
      if (tileSource.canExpireCache()) {
        /**
         * @param {import("../../source/Tile.js").default} tileSource Tile source.
         * @param {import("../../Map.js").default} map Map.
         * @param {import("../../Map.js").FrameState} frameState Frame state.
         */
        var postRenderFunction = function (tileSource, map, frameState) {
          var tileSourceKey = getUid(tileSource);

          if (tileSourceKey in frameState.usedTiles) {
            tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
          }
        }.bind(null, tileSource);

        frameState.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        postRenderFunction);
      }
    }
    /**
     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import('../../Tile.js').default} tile Tile.
     * @protected
     */

  }, {
    key: "updateUsedTiles",
    value: function updateUsedTiles(usedTiles, tileSource, tile) {
      // FIXME should we use tilesToDrawByZ instead?
      var tileSourceKey = getUid(tileSource);

      if (!(tileSourceKey in usedTiles)) {
        usedTiles[tileSourceKey] = {};
      }

      usedTiles[tileSourceKey][tile.getKey()] = true;
    }
    /**
     * Manage tile pyramid.
     * This function performs a number of functions related to the tiles at the
     * current zoom and lower zoom levels:
     * - registers idle tiles in frameState.wantedTiles so that they are not
     *   discarded by the tile queue
     * - enqueues missing tiles
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../proj/Projection.js").default} projection Projection.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {number} currentZ Current Z.
     * @param {number} preload Load low resolution tiles up to `preload` levels.
     * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
     * @protected
     */

  }, {
    key: "manageTilePyramid",
    value: function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
      var tileSourceKey = getUid(tileSource);

      if (!(tileSourceKey in frameState.wantedTiles)) {
        frameState.wantedTiles[tileSourceKey] = {};
      }

      var wantedTiles = frameState.wantedTiles[tileSourceKey];
      var tileQueue = frameState.tileQueue;
      var minZoom = tileGrid.getMinZoom();
      var rotation = frameState.viewState.rotation;
      var viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;
      var tileCount = 0;
      var tile, tileRange, tileResolution, x, y, z;

      for (z = minZoom; z <= currentZ; ++z) {
        tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
        tileResolution = tileGrid.getResolution(z);

        for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
            if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
              continue;
            }

            if (currentZ - z <= preload) {
              ++tileCount;
              tile = tileSource.getTile(z, x, y, pixelRatio, projection);

              if (tile.getState() == TileState.IDLE) {
                wantedTiles[tile.getKey()] = true;

                if (!tileQueue.isKeyQueued(tile.getKey())) {
                  tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
                }
              }

              if (tileCallback !== undefined) {
                tileCallback(tile);
              }
            } else {
              tileSource.useTile(z, x, y, projection);
            }
          }
        }
      }

      tileSource.updateCacheSize(tileCount, projection);
    }
  }]);

  return CanvasTileLayerRenderer;
}(canvas_Layer);

/* harmony default export */ var canvas_TileLayer = (CanvasTileLayerRenderer);
;// CONCATENATED MODULE: ./node_modules/ol/layer/Tile.js





/**
 * @module ol/layer/Tile
 */


/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */

var TileLayer = /*#__PURE__*/function (_BaseTileLayer) {
  _inherits(TileLayer, _BaseTileLayer);

  var _super = createSuper_createSuper(TileLayer);

  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  function TileLayer(options) {
    _classCallCheck(this, TileLayer);

    return _super.call(this, options);
  }

  _createClass(TileLayer, [{
    key: "createRenderer",
    value: function createRenderer() {
      return new canvas_TileLayer(this);
    }
  }]);

  return TileLayer;
}(BaseTile);

/* harmony default export */ var layer_Tile = (TileLayer);
// EXTERNAL MODULE: ./node_modules/rbush/rbush.min.js
var rbush_min = __webpack_require__(5950);
;// CONCATENATED MODULE: ./node_modules/ol/style/Image.js



/**
 * @module ol/style/Image
 */


/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, 'none */

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */

var ImageStyle = /*#__PURE__*/function () {
  /**
   * @param {Options} options Options.
   */
  function ImageStyle(options) {
    _classCallCheck(this, ImageStyle);

    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;
    /**
     * @private
     * @type {boolean}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.scaleArray_ = toSize(options.scale);
    /**
     * @private
     * @type {Array<number>}
     */

    this.displacement_ = options.displacement;
    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */

    this.declutterMode_ = options.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */


  _createClass(ImageStyle, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      return new ImageStyle({
        opacity: this.getOpacity(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */

  }, {
    key: "getOpacity",
    value: function getOpacity() {
      return this.opacity_;
    }
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */

  }, {
    key: "getRotateWithView",
    value: function getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */

  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.rotation_;
    }
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */

  }, {
    key: "getScale",
    value: function getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */

  }, {
    key: "getScaleArray",
    value: function getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */

  }, {
    key: "getDisplacement",
    value: function getDisplacement() {
      return this.displacement_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
     * @api
     */

  }, {
    key: "getDeclutterMode",
    value: function getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */

  }, {
    key: "getAnchor",
    value: function getAnchor() {
      return util_abstract();
    }
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
     */

  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      return util_abstract();
    }
    /**
     * @abstract
     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
     */

  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      return util_abstract();
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */

  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      return 1;
    }
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */

  }, {
    key: "getImageState",
    value: function getImageState() {
      return util_abstract();
    }
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */

  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return util_abstract();
    }
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */

  }, {
    key: "getOrigin",
    value: function getOrigin() {
      return util_abstract();
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return util_abstract();
    }
    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */

  }, {
    key: "setDisplacement",
    value: function setDisplacement(displacement) {
      this.displacement_ = displacement;
    }
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      this.opacity_ = opacity;
    }
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */

  }, {
    key: "setRotateWithView",
    value: function setRotateWithView(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    }
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */

  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.rotation_ = rotation;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */

  }, {
    key: "setScale",
    value: function setScale(scale) {
      this.scale_ = scale;
      this.scaleArray_ = toSize(scale);
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */

  }, {
    key: "listenImageChange",
    value: function listenImageChange(listener) {
      util_abstract();
    }
    /**
     * Load not yet loaded URI.
     * @abstract
     */

  }, {
    key: "load",
    value: function load() {
      util_abstract();
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */

  }, {
    key: "unlistenImageChange",
    value: function unlistenImageChange(listener) {
      util_abstract();
    }
  }]);

  return ImageStyle;
}();

/* harmony default export */ var style_Image = (ImageStyle);
;// CONCATENATED MODULE: ./node_modules/ol/colorlike.js
/**
 * @module ol/colorlike
 */

/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */

function asColorLike(color) {
  if (Array.isArray(color)) {
    return color_toString(color);
  } else {
    return color;
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/style/RegularShape.js





/**
 * @module ol/style/RegularShape
 */






/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */

/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */

var RegularShape = /*#__PURE__*/function (_ImageStyle) {
  _inherits(RegularShape, _ImageStyle);

  var _super = createSuper_createSuper(RegularShape);

  /**
   * @param {Options} options Options.
   */
  function RegularShape(options) {
    var _this;

    _classCallCheck(this, RegularShape);

    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: options.scale !== undefined ? options.scale : 1,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */

    _this.canvas_ = undefined;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.hitDetectionCanvas_ = null;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    _this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.points_ = options.points;
    /**
     * @protected
     * @type {number}
     */

    _this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.radius2_ = options.radius2;
    /**
     * @private
     * @type {number}
     */

    _this.angle_ = options.angle !== undefined ? options.angle : 0;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = null;
    /**
     * @private
     * @type {RenderOptions}
     */

    _this.renderOptions_ = null;

    _this.render();

    return _this;
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */


  _createClass(RegularShape, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      var style = new RegularShape({
        fill: this.getFill() ? this.getFill().clone() : undefined,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style.setOpacity(this.getOpacity());
      return style;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */

  }, {
    key: "getAnchor",
    value: function getAnchor() {
      var size = this.size_;

      if (!size) {
        return null;
      }

      var displacement = this.getDisplacement();
      var scale = this.getScaleArray(); // anchor is scaled by renderer but displacement should not be scaled
      // so divide by scale here

      return [size[0] / 2 - displacement[0] / scale[0], size[1] / 2 + displacement[1] / scale[1]];
    }
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */

  }, {
    key: "getAngle",
    value: function getAngle() {
      return this.angle_;
    }
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */

  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */

  }, {
    key: "setFill",
    value: function setFill(fill) {
      this.fill_ = fill;
      this.render();
    }
    /**
     * @return {HTMLCanvasElement} Image element.
     */

  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      if (!this.hitDetectionCanvas_) {
        this.createHitDetectionCanvas_(this.renderOptions_);
      }

      return this.hitDetectionCanvas_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     */

  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      var image = this.canvas_[pixelRatio];

      if (!image) {
        var renderOptions = this.renderOptions_;
        var context = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
        this.draw_(renderOptions, context, pixelRatio);
        image = context.canvas;
        this.canvas_[pixelRatio] = image;
      }

      return image;
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */

  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      return pixelRatio;
    }
    /**
     * @return {import("../size.js").Size} Image size.
     */

  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return this.size_;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */

  }, {
    key: "getImageState",
    value: function getImageState() {
      return ImageState.LOADED;
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */

  }, {
    key: "getOrigin",
    value: function getOrigin() {
      return this.origin_;
    }
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */

  }, {
    key: "getPoints",
    value: function getPoints() {
      return this.points_;
    }
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */

  }, {
    key: "getRadius",
    value: function getRadius() {
      return this.radius_;
    }
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */

  }, {
    key: "getRadius2",
    value: function getRadius2() {
      return this.radius2_;
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return this.size_;
    }
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */

  }, {
    key: "getStroke",
    value: function getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */

  }, {
    key: "setStroke",
    value: function setStroke(stroke) {
      this.stroke_ = stroke;
      this.render();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */

  }, {
    key: "listenImageChange",
    value: function listenImageChange(listener) {}
    /**
     * Load not yet loaded URI.
     */

  }, {
    key: "load",
    value: function load() {}
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */

  }, {
    key: "unlistenImageChange",
    value: function unlistenImageChange(listener) {}
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */

  }, {
    key: "calculateLineJoinSize_",
    value: function calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
      if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') {
        return strokeWidth;
      } // m  | ^
      // i  | |\                  .
      // t >|  #\
      // e  | |\ \              .
      // r      \s\
      //      |  \t\          .                 .
      //          \r\                      .   .
      //      |    \o\      .          .  . . .
      //          e \k\            .  .    . .
      //      |      \e\  .    .  .       . .
      //       d      \ \  .  .          . .
      //      | _ _a_ _\#  .            . .
      //   r1          / `             . .
      //      |                       . .
      //       b     /               . .
      //      |                     . .
      //           / r2            . .
      //      |                        .   .
      //         /                           .   .
      //      |α                                   .   .
      //       /                                         .   .
      //      ° center


      var r1 = this.radius_;
      var r2 = this.radius2_ === undefined ? r1 : this.radius2_;

      if (r1 < r2) {
        var tmp = r1;
        r1 = r2;
        r2 = tmp;
      }

      var points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
      var alpha = 2 * Math.PI / points;
      var a = r2 * Math.sin(alpha);
      var b = Math.sqrt(r2 * r2 - a * a);
      var d = r1 - b;
      var e = Math.sqrt(a * a + d * d);
      var miterRatio = e / a;

      if (lineJoin === 'miter' && miterRatio <= miterLimit) {
        return miterRatio * strokeWidth;
      } // Calculate the distnce from center to the stroke corner where
      // it was cut short because of the miter limit.
      //              l
      //        ----+---- <= distance from center to here is maxr
      //       /####|k ##\
      //      /#####^#####\
      //     /#### /+\# s #\
      //    /### h/+++\# t #\
      //   /### t/+++++\# r #\
      //  /### a/+++++++\# o #\
      // /### p/++ fill +\# k #\
      ///#### /+++++^+++++\# e #\
      //#####/+++++/+\+++++\#####\


      var k = strokeWidth / 2 / miterRatio;
      var l = strokeWidth / 2 * (d / e);
      var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
      var bevelAdd = maxr - r1;

      if (this.radius2_ === undefined || lineJoin === 'bevel') {
        return bevelAdd * 2;
      } // If outer miter is over the miter limit the inner miter may reach through the
      // center and be longer than the bevel, same calculation as above but swap r1 / r2.


      var aa = r1 * Math.sin(alpha);
      var bb = Math.sqrt(r1 * r1 - aa * aa);
      var dd = r2 - bb;
      var ee = Math.sqrt(aa * aa + dd * dd);
      var innerMiterRatio = ee / aa;

      if (innerMiterRatio <= miterLimit) {
        var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
        return 2 * Math.max(bevelAdd, innerLength);
      }

      return bevelAdd * 2;
    }
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */

  }, {
    key: "createRenderOptions",
    value: function createRenderOptions() {
      var lineJoin = defaultLineJoin;
      var miterLimit = 0;
      var lineDash = null;
      var lineDashOffset = 0;
      var strokeStyle;
      var strokeWidth = 0;

      if (this.stroke_) {
        strokeStyle = this.stroke_.getColor();

        if (strokeStyle === null) {
          strokeStyle = defaultStrokeStyle;
        }

        strokeStyle = asColorLike(strokeStyle);
        strokeWidth = this.stroke_.getWidth();

        if (strokeWidth === undefined) {
          strokeWidth = defaultLineWidth;
        }

        lineDash = this.stroke_.getLineDash();
        lineDashOffset = this.stroke_.getLineDashOffset();
        lineJoin = this.stroke_.getLineJoin();

        if (lineJoin === undefined) {
          lineJoin = defaultLineJoin;
        }

        miterLimit = this.stroke_.getMiterLimit();

        if (miterLimit === undefined) {
          miterLimit = defaultMiterLimit;
        }
      }

      var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
      var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
      var size = Math.ceil(2 * maxRadius + add);
      return {
        strokeStyle: strokeStyle,
        strokeWidth: strokeWidth,
        size: size,
        lineDash: lineDash,
        lineDashOffset: lineDashOffset,
        lineJoin: lineJoin,
        miterLimit: miterLimit
      };
    }
    /**
     * @protected
     */

  }, {
    key: "render",
    value: function render() {
      this.renderOptions_ = this.createRenderOptions();
      var size = this.renderOptions_.size;
      this.canvas_ = {};
      this.size_ = [size, size];
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */

  }, {
    key: "draw_",
    value: function draw_(renderOptions, context, pixelRatio) {
      context.scale(pixelRatio, pixelRatio); // set origin to canvas center

      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);

      if (this.fill_) {
        var color = this.fill_.getColor();

        if (color === null) {
          color = defaultFillStyle;
        }

        context.fillStyle = asColorLike(color);
        context.fill();
      }

      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;

        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }

        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     */

  }, {
    key: "createHitDetectionCanvas_",
    value: function createHitDetectionCanvas_(renderOptions) {
      if (this.fill_) {
        var color = this.fill_.getColor(); // determine if fill is transparent (or pattern or gradient)

        var opacity = 0;

        if (typeof color === 'string') {
          color = asArray(color);
        }

        if (color === null) {
          opacity = 1;
        } else if (Array.isArray(color)) {
          opacity = color.length === 4 ? color[3] : 1;
        }

        if (opacity === 0) {
          // if a transparent fill style is set, create an extra hit-detection image
          // with a default fill style
          var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
          this.hitDetectionCanvas_ = context.canvas;
          this.drawHitDetectionCanvas_(renderOptions, context);
        }
      }

      if (!this.hitDetectionCanvas_) {
        this.hitDetectionCanvas_ = this.getImage(1);
      }
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */

  }, {
    key: "createPath_",
    value: function createPath_(context) {
      var points = this.points_;
      var radius = this.radius_;

      if (points === Infinity) {
        context.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        var radius2 = this.radius2_ === undefined ? radius : this.radius2_;

        if (this.radius2_ !== undefined) {
          points *= 2;
        }

        var startAngle = this.angle_ - Math.PI / 2;
        var step = 2 * Math.PI / points;

        for (var i = 0; i < points; i++) {
          var angle0 = startAngle + i * step;
          var radiusC = i % 2 === 0 ? radius : radius2;
          context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
        }

        context.closePath();
      }
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */

  }, {
    key: "drawHitDetectionCanvas_",
    value: function drawHitDetectionCanvas_(renderOptions, context) {
      // set origin to canvas center
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      context.fillStyle = defaultFillStyle;
      context.fill();

      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;

        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }

        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    }
  }]);

  return RegularShape;
}(style_Image);

/* harmony default export */ var style_RegularShape = (RegularShape);
;// CONCATENATED MODULE: ./node_modules/ol/style/Circle.js





/**
 * @module ol/style/Circle
 */

/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode
 */

/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */

var Circle_CircleStyle = /*#__PURE__*/function (_RegularShape) {
  _inherits(CircleStyle, _RegularShape);

  var _super = createSuper_createSuper(CircleStyle);

  /**
   * @param {Options} [options] Options.
   */
  function CircleStyle(options) {
    _classCallCheck(this, CircleStyle);

    options = options ? options : {
      radius: 5
    };
    return _super.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== undefined ? options.scale : 1,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */


  _createClass(CircleStyle, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      var style = new CircleStyle({
        fill: this.getFill() ? this.getFill().clone() : undefined,
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        radius: this.getRadius(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style.setOpacity(this.getOpacity());
      return style;
    }
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */

  }, {
    key: "setRadius",
    value: function setRadius(radius) {
      this.radius_ = radius;
      this.render();
    }
  }]);

  return CircleStyle;
}(style_RegularShape);

/* harmony default export */ var Circle = (Circle_CircleStyle);
;// CONCATENATED MODULE: ./node_modules/ol/style/Fill.js



/**
 * @module ol/style/Fill
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */

/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill_Fill = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Options.
   */
  function Fill(options) {
    _classCallCheck(this, Fill);

    options = options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */

    this.color_ = options.color !== undefined ? options.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */


  _createClass(Fill, [{
    key: "clone",
    value: function clone() {
      var color = this.getColor();
      return new Fill({
        color: Array.isArray(color) ? color.slice() : color || undefined
      });
    }
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
     * @api
     */

  }, {
    key: "getColor",
    value: function getColor() {
      return this.color_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
     * @api
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this.color_ = color;
    }
  }]);

  return Fill;
}();

/* harmony default export */ var style_Fill = (Fill_Fill);
;// CONCATENATED MODULE: ./node_modules/ol/style/Stroke.js



/**
 * @module ol/style/Stroke
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke_Stroke = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Options.
   */
  function Stroke(options) {
    _classCallCheck(this, Stroke);

    options = options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */

    this.color_ = options.color !== undefined ? options.color : null;
    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */

    this.lineCap_ = options.lineCap;
    /**
     * @private
     * @type {Array<number>|null}
     */

    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.lineDashOffset_ = options.lineDashOffset;
    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */

    this.lineJoin_ = options.lineJoin;
    /**
     * @private
     * @type {number|undefined}
     */

    this.miterLimit_ = options.miterLimit;
    /**
     * @private
     * @type {number|undefined}
     */

    this.width_ = options.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */


  _createClass(Stroke, [{
    key: "clone",
    value: function clone() {
      var color = this.getColor();
      return new Stroke({
        color: Array.isArray(color) ? color.slice() : color || undefined,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    }
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */

  }, {
    key: "getColor",
    value: function getColor() {
      return this.color_;
    }
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */

  }, {
    key: "getLineCap",
    value: function getLineCap() {
      return this.lineCap_;
    }
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>|null} Line dash.
     * @api
     */

  }, {
    key: "getLineDash",
    value: function getLineDash() {
      return this.lineDash_;
    }
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */

  }, {
    key: "getLineDashOffset",
    value: function getLineDashOffset() {
      return this.lineDashOffset_;
    }
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */

  }, {
    key: "getLineJoin",
    value: function getLineJoin() {
      return this.lineJoin_;
    }
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */

  }, {
    key: "getMiterLimit",
    value: function getMiterLimit() {
      return this.miterLimit_;
    }
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this.color_ = color;
    }
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */

  }, {
    key: "setLineCap",
    value: function setLineCap(lineCap) {
      this.lineCap_ = lineCap;
    }
    /**
     * Set the line dash.
     *
     * @param {Array<number>|null} lineDash Line dash.
     * @api
     */

  }, {
    key: "setLineDash",
    value: function setLineDash(lineDash) {
      this.lineDash_ = lineDash;
    }
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */

  }, {
    key: "setLineDashOffset",
    value: function setLineDashOffset(lineDashOffset) {
      this.lineDashOffset_ = lineDashOffset;
    }
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */

  }, {
    key: "setLineJoin",
    value: function setLineJoin(lineJoin) {
      this.lineJoin_ = lineJoin;
    }
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */

  }, {
    key: "setMiterLimit",
    value: function setMiterLimit(miterLimit) {
      this.miterLimit_ = miterLimit;
    }
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */

  }, {
    key: "setWidth",
    value: function setWidth(width) {
      this.width_ = width;
    }
  }]);

  return Stroke;
}();

/* harmony default export */ var style_Stroke = (Stroke_Stroke);
;// CONCATENATED MODULE: ./node_modules/ol/style/Style.js



/**
 * @module ol/style/Style
 */




/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */

/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void} RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */

var Style = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Style options.
   */
  function Style(options) {
    _classCallCheck(this, Style);

    options = options || {};
    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
     */

    this.geometry_ = null;
    /**
     * @private
     * @type {!GeometryFunction}
     */

    this.geometryFunction_ = defaultGeometryFunction;

    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }
    /**
     * @private
     * @type {import("./Fill.js").default}
     */


    this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
     * @private
     * @type {import("./Image.js").default}
     */

    this.image_ = options.image !== undefined ? options.image : null;
    /**
     * @private
     * @type {RenderFunction|null}
     */

    this.renderer_ = options.renderer !== undefined ? options.renderer : null;
    /**
     * @private
     * @type {RenderFunction|null}
     */

    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== undefined ? options.hitDetectionRenderer : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {import("./Text.js").default}
     */

    this.text_ = options.text !== undefined ? options.text : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.zIndex_ = options.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */


  _createClass(Style, [{
    key: "clone",
    value: function clone() {
      var geometry = this.getGeometry();

      if (geometry && typeof geometry === 'object') {
        geometry =
        /** @type {import("../geom/Geometry.js").default} */
        geometry.clone();
      }

      return new Style({
        geometry: geometry,
        fill: this.getFill() ? this.getFill().clone() : undefined,
        image: this.getImage() ? this.getImage().clone() : undefined,
        renderer: this.getRenderer(),
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        text: this.getText() ? this.getText().clone() : undefined,
        zIndex: this.getZIndex()
      });
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */

  }, {
    key: "getRenderer",
    value: function getRenderer() {
      return this.renderer_;
    }
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */

  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      this.renderer_ = renderer;
    }
    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */

  }, {
    key: "setHitDetectionRenderer",
    value: function setHitDetectionRenderer(renderer) {
      this.hitDetectionRenderer_ = renderer;
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */

  }, {
    key: "getHitDetectionRenderer",
    value: function getHitDetectionRenderer() {
      return this.hitDetectionRenderer_;
    }
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */

  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this.geometry_;
    }
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */

  }, {
    key: "getGeometryFunction",
    value: function getGeometryFunction() {
      return this.geometryFunction_;
    }
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */

  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */

  }, {
    key: "setFill",
    value: function setFill(fill) {
      this.fill_ = fill;
    }
    /**
     * Get the image style.
     * @return {import("./Image.js").default} Image style.
     * @api
     */

  }, {
    key: "getImage",
    value: function getImage() {
      return this.image_;
    }
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */

  }, {
    key: "setImage",
    value: function setImage(image) {
      this.image_ = image;
    }
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */

  }, {
    key: "getStroke",
    value: function getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */

  }, {
    key: "setStroke",
    value: function setStroke(stroke) {
      this.stroke_ = stroke;
    }
    /**
     * Get the text style.
     * @return {import("./Text.js").default} Text style.
     * @api
     */

  }, {
    key: "getText",
    value: function getText() {
      return this.text_;
    }
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */

  }, {
    key: "setText",
    value: function setText(text) {
      this.text_ = text;
    }
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */

  }, {
    key: "getZIndex",
    value: function getZIndex() {
      return this.zIndex_;
    }
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */

  }, {
    key: "setGeometry",
    value: function setGeometry(geometry) {
      if (typeof geometry === 'function') {
        this.geometryFunction_ = geometry;
      } else if (typeof geometry === 'string') {
        this.geometryFunction_ = function (feature) {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            feature.get(geometry)
          );
        };
      } else if (!geometry) {
        this.geometryFunction_ = defaultGeometryFunction;
      } else if (geometry !== undefined) {
        this.geometryFunction_ = function () {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            geometry
          );
        };
      }

      this.geometry_ = geometry;
    }
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */

  }, {
    key: "setZIndex",
    value: function setZIndex(zIndex) {
      this.zIndex_ = zIndex;
    }
  }]);

  return Style;
}();
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */


function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles;

    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      asserts_assert(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `Style` or an array of `Style`

      var style =
      /** @type {Style} */
      obj;
      styles = [style];
    }

    styleFunction = function styleFunction() {
      return styles;
    };
  }

  return styleFunction;
}
/**
 * @type {Array<Style>|null}
 */

var Style_defaultStyles = null;
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */

function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!Style_defaultStyles) {
    var fill = new style_Fill({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new style_Stroke({
      color: '#3399CC',
      width: 1.25
    });
    Style_defaultStyles = [new Style({
      image: new Circle({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }

  return Style_defaultStyles;
}
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */

function createEditingStyle() {
  /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles['Polygon'] = [new Style({
    fill: new Fill({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles['MultiPolygon'] = styles['Polygon'];
  styles['LineString'] = [new Style({
    stroke: new Stroke({
      color: white,
      width: width + 2
    })
  }), new Style({
    stroke: new Stroke({
      color: blue,
      width: width
    })
  })];
  styles['MultiLineString'] = styles['LineString'];
  styles['Circle'] = styles['Polygon'].concat(styles['LineString']);
  styles['Point'] = [new Style({
    image: new CircleStyle({
      radius: width * 2,
      fill: new Fill({
        color: blue
      }),
      stroke: new Stroke({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles['MultiPoint'] = styles['Point'];
  styles['GeometryCollection'] = styles['Polygon'].concat(styles['LineString'], styles['Point']);
  return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */

function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ var style_Style = (Style);
;// CONCATENATED MODULE: ./node_modules/ol/style/IconImage.js





/**
 * @module ol/style/IconImage
 */







/**
 * @type {CanvasRenderingContext2D}
 */

var taintedTestContext = null;

var IconImage = /*#__PURE__*/function (_EventTarget) {
  _inherits(IconImage, _EventTarget);

  var _super = createSuper_createSuper(IconImage);

  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  function IconImage(image, src, size, crossOrigin, imageState, color) {
    var _this;

    _classCallCheck(this, IconImage);

    _this = _super.call(this);
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = image;
    /**
     * @private
     * @type {string|null}
     */

    _this.crossOrigin_ = crossOrigin;
    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */

    _this.canvas_ = {};
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = color;
    /**
     * @private
     * @type {?function():void}
     */

    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("../ImageState.js").default}
     */

    _this.imageState_ = imageState;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = size;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.src_ = src;
    /**
     * @private
     */

    _this.tainted_;
    return _this;
  }
  /**
   * @private
   */


  _createClass(IconImage, [{
    key: "initializeImage_",
    value: function initializeImage_() {
      this.image_ = new Image();

      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */

  }, {
    key: "isTainted_",
    value: function isTainted_() {
      if (this.tainted_ === undefined && this.imageState_ === ImageState.LOADED) {
        if (!taintedTestContext) {
          taintedTestContext = createCanvasContext2D(1, 1);
        }

        taintedTestContext.drawImage(this.image_, 0, 0);

        try {
          taintedTestContext.getImageData(0, 0, 1, 1);
          this.tainted_ = false;
        } catch (e) {
          taintedTestContext = null;
          this.tainted_ = true;
        }
      }

      return this.tainted_ === true;
    }
    /**
     * @private
     */

  }, {
    key: "dispatchChangeEvent_",
    value: function dispatchChangeEvent_() {
      this.dispatchEvent(EventType.CHANGE);
    }
    /**
     * @private
     */

  }, {
    key: "handleImageError_",
    value: function handleImageError_() {
      this.imageState_ = ImageState.ERROR;
      this.unlistenImage_();
      this.dispatchChangeEvent_();
    }
    /**
     * @private
     */

  }, {
    key: "handleImageLoad_",
    value: function handleImageLoad_() {
      this.imageState_ = ImageState.LOADED;

      if (this.size_) {
        this.image_.width = this.size_[0];
        this.image_.height = this.size_[1];
      } else {
        this.size_ = [this.image_.width, this.image_.height];
      }

      this.unlistenImage_();
      this.dispatchChangeEvent_();
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
     */

  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      if (!this.image_) {
        this.initializeImage_();
      }

      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */

  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? pixelRatio : 1;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */

  }, {
    key: "getImageState",
    value: function getImageState() {
      return this.imageState_;
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement} Image element.
     */

  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      if (!this.image_) {
        this.initializeImage_();
      }

      if (!this.hitDetectionImage_) {
        if (this.isTainted_()) {
          var width = this.size_[0];
          var height = this.size_[1];
          var context = createCanvasContext2D(width, height);
          context.fillRect(0, 0, width, height);
          this.hitDetectionImage_ = context.canvas;
        } else {
          this.hitDetectionImage_ = this.image_;
        }
      }

      return this.hitDetectionImage_;
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return this.size_;
    }
    /**
     * @return {string|undefined} Image src.
     */

  }, {
    key: "getSrc",
    value: function getSrc() {
      return this.src_;
    }
    /**
     * Load not yet loaded URI.
     */

  }, {
    key: "load",
    value: function load() {
      if (this.imageState_ !== ImageState.IDLE) {
        return;
      }

      if (!this.image_) {
        this.initializeImage_();
      }

      this.imageState_ = ImageState.LOADING;

      try {
        /** @type {HTMLImageElement} */
        this.image_.src = this.src_;
      } catch (e) {
        this.handleImageError_();
      }

      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */

  }, {
    key: "replaceColor_",
    value: function replaceColor_(pixelRatio) {
      if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {
        return;
      }

      var image = this.image_;
      var canvas = document.createElement('canvas');
      canvas.width = Math.ceil(image.width * pixelRatio);
      canvas.height = Math.ceil(image.height * pixelRatio);
      var ctx = canvas.getContext('2d');
      ctx.scale(pixelRatio, pixelRatio);
      ctx.drawImage(image, 0, 0);
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = asString(this.color_);
      ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(image, 0, 0);
      this.canvas_[pixelRatio] = canvas;
    }
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */

  }, {
    key: "unlistenImage_",
    value: function unlistenImage_() {
      if (this.unlisten_) {
        this.unlisten_();
        this.unlisten_ = null;
      }
    }
  }]);

  return IconImage;
}(events_Target);
/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */


function IconImage_get(image, src, size, crossOrigin, imageState, color) {
  var iconImage = shared.get(src, crossOrigin, color);

  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
    shared.set(src, crossOrigin, color, iconImage);
  }

  return iconImage;
}
/* harmony default export */ var style_IconImage = ((/* unused pure expression or super */ null && (IconImage)));
;// CONCATENATED MODULE: ./node_modules/ol/style/Icon.js





/**
 * @module ol/style/Icon
 */







/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */

/**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */

/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not.
 * The provided `imgSize` needs to match the actual size of the image.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */

var Icon = /*#__PURE__*/function (_ImageStyle) {
  _inherits(Icon, _ImageStyle);

  var _super = createSuper_createSuper(Icon);

  /**
   * @param {Options} [options] Options.
   */
  function Icon(options) {
    var _this;

    _classCallCheck(this, Icon);

    options = options || {};
    /**
     * @type {number}
     */

    var opacity = options.opacity !== undefined ? options.opacity : 1;
    /**
     * @type {number}
     */

    var rotation = options.rotation !== undefined ? options.rotation : 0;
    /**
     * @type {number|import("../size.js").Size}
     */

    var scale = options.scale !== undefined ? options.scale : 1;
    /**
     * @type {boolean}
     */

    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView,
      declutterMode: options.declutterMode
    });
    /**
     * @private
     * @type {Array<number>}
     */

    _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
    /**
     * @private
     * @type {Array<number>}
     */

    _this.normalizedAnchor_ = null;
    /**
     * @private
     * @type {IconOrigin}
     */

    _this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';
    /**
     * @private
     * @type {IconAnchorUnits}
     */

    _this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';
    /**
     * @private
     * @type {IconAnchorUnits}
     */

    _this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    var image = options.img !== undefined ? options.img : null;
    /**
     * @private
     * @type {import("../size.js").Size|undefined}
     */

    _this.imgSize_ = options.imgSize;
    /**
     * @type {string|undefined}
     */

    var src = options.src;
    asserts_assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time

    asserts_assert(!image || image && _this.imgSize_, 5); // `imgSize` must be set when `image` is provided

    if ((src === undefined || src.length === 0) && image) {
      src =
      /** @type {HTMLImageElement} */
      image.src || getUid(image);
    }

    asserts_assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

    /**
     * @type {import("../ImageState.js").default}
     */

    var imageState = options.src !== undefined ? ImageState.IDLE : ImageState.LOADED;
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = options.color !== undefined ? asArray(options.color) : null;
    /**
     * @private
     * @type {import("./IconImage.js").default}
     */

    _this.iconImage_ = IconImage_get(image,
    /** @type {string} */
    src, _this.imgSize_ !== undefined ? _this.imgSize_ : null, _this.crossOrigin_, imageState, _this.color_);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {IconOrigin}
     */

    _this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = options.size !== undefined ? options.size : null;
    return _this;
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */


  _createClass(Icon, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      return new Icon({
        anchor: this.anchor_.slice(),
        anchorOrigin: this.anchorOrigin_,
        anchorXUnits: this.anchorXUnits_,
        anchorYUnits: this.anchorYUnits_,
        color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
        crossOrigin: this.crossOrigin_,
        imgSize: this.imgSize_,
        offset: this.offset_.slice(),
        offsetOrigin: this.offsetOrigin_,
        opacity: this.getOpacity(),
        rotateWithView: this.getRotateWithView(),
        rotation: this.getRotation(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        size: this.size_ !== null ? this.size_.slice() : undefined,
        src: this.getSrc(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */

  }, {
    key: "getAnchor",
    value: function getAnchor() {
      var anchor = this.normalizedAnchor_;

      if (!anchor) {
        anchor = this.anchor_;
        var size = this.getSize();

        if (this.anchorXUnits_ == 'fraction' || this.anchorYUnits_ == 'fraction') {
          if (!size) {
            return null;
          }

          anchor = this.anchor_.slice();

          if (this.anchorXUnits_ == 'fraction') {
            anchor[0] *= size[0];
          }

          if (this.anchorYUnits_ == 'fraction') {
            anchor[1] *= size[1];
          }
        }

        if (this.anchorOrigin_ != 'top-left') {
          if (!size) {
            return null;
          }

          if (anchor === this.anchor_) {
            anchor = this.anchor_.slice();
          }

          if (this.anchorOrigin_ == 'top-right' || this.anchorOrigin_ == 'bottom-right') {
            anchor[0] = -anchor[0] + size[0];
          }

          if (this.anchorOrigin_ == 'bottom-left' || this.anchorOrigin_ == 'bottom-right') {
            anchor[1] = -anchor[1] + size[1];
          }
        }

        this.normalizedAnchor_ = anchor;
      }

      var displacement = this.getDisplacement();
      var scale = this.getScaleArray(); // anchor is scaled by renderer but displacement should not be scaled
      // so divide by scale here

      return [anchor[0] - displacement[0] / scale[0], anchor[1] + displacement[1] / scale[1]];
    }
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */

  }, {
    key: "setAnchor",
    value: function setAnchor(anchor) {
      this.anchor_ = anchor;
      this.normalizedAnchor_ = null;
    }
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */

  }, {
    key: "getColor",
    value: function getColor() {
      return this.color_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
     * @api
     */

  }, {
    key: "getImage",
    value: function getImage(pixelRatio) {
      return this.iconImage_.getImage(pixelRatio);
    }
    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     */

  }, {
    key: "getPixelRatio",
    value: function getPixelRatio(pixelRatio) {
      return this.iconImage_.getPixelRatio(pixelRatio);
    }
    /**
     * @return {import("../size.js").Size} Image size.
     */

  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return this.iconImage_.getSize();
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */

  }, {
    key: "getImageState",
    value: function getImageState() {
      return this.iconImage_.getImageState();
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement} Image element.
     */

  }, {
    key: "getHitDetectionImage",
    value: function getHitDetectionImage() {
      return this.iconImage_.getHitDetectionImage();
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */

  }, {
    key: "getOrigin",
    value: function getOrigin() {
      if (this.origin_) {
        return this.origin_;
      }

      var offset = this.offset_;

      if (this.offsetOrigin_ != 'top-left') {
        var size = this.getSize();
        var iconImageSize = this.iconImage_.getSize();

        if (!size || !iconImageSize) {
          return null;
        }

        offset = offset.slice();

        if (this.offsetOrigin_ == 'top-right' || this.offsetOrigin_ == 'bottom-right') {
          offset[0] = iconImageSize[0] - size[0] - offset[0];
        }

        if (this.offsetOrigin_ == 'bottom-left' || this.offsetOrigin_ == 'bottom-right') {
          offset[1] = iconImageSize[1] - size[1] - offset[1];
        }
      }

      this.origin_ = offset;
      return this.origin_;
    }
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */

  }, {
    key: "getSrc",
    value: function getSrc() {
      return this.iconImage_.getSrc();
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return !this.size_ ? this.iconImage_.getSize() : this.size_;
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */

  }, {
    key: "listenImageChange",
    value: function listenImageChange(listener) {
      this.iconImage_.addEventListener(EventType.CHANGE, listener);
    }
    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     */

  }, {
    key: "load",
    value: function load() {
      this.iconImage_.load();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */

  }, {
    key: "unlistenImageChange",
    value: function unlistenImageChange(listener) {
      this.iconImage_.removeEventListener(EventType.CHANGE, listener);
    }
  }]);

  return Icon;
}(style_Image);

/* harmony default export */ var style_Icon = (Icon);
;// CONCATENATED MODULE: ./node_modules/ol/style/Text.js



/**
 * @module ol/style/Text
 */


/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */

/**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */

var DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */

var Text_Text = /*#__PURE__*/function () {
  /**
   * @param {Options} [options] Options.
   */
  function Text(options) {
    _classCallCheck(this, Text);

    options = options || {};
    /**
     * @private
     * @type {string|undefined}
     */

    this.font_ = options.font;
    /**
     * @private
     * @type {number|undefined}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {boolean|undefined}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.scaleArray_ = toSize(options.scale !== undefined ? options.scale : 1);
    /**
     * @private
     * @type {string|Array<string>|undefined}
     */

    this.text_ = options.text;
    /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */

    this.textAlign_ = options.textAlign;
    /**
     * @private
     * @type {TextJustify|undefined}
     */

    this.justify_ = options.justify;
    /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */

    this.textBaseline_ = options.textBaseline;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.fill_ = options.fill !== undefined ? options.fill : new style_Fill({
      color: DEFAULT_FILL_COLOR
    });
    /**
     * @private
     * @type {number}
     */

    this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
    /**
     * @private
     * @type {TextPlacement}
     */

    this.placement_ = options.placement !== undefined ? options.placement : 'point';
    /**
     * @private
     * @type {boolean}
     */

    this.overflow_ = !!options.overflow;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {number}
     */

    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
    /**
     * @private
     * @type {number}
     */

    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    /**
     * @private
     * @type {Array<number>|null}
     */

    this.padding_ = options.padding === undefined ? null : options.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */


  _createClass(Text, [{
    key: "clone",
    value: function clone() {
      var scale = this.getScale();
      return new Text({
        font: this.getFont(),
        placement: this.getPlacement(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : undefined,
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
        backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
        padding: this.getPadding() || undefined
      });
    }
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */

  }, {
    key: "getOverflow",
    value: function getOverflow() {
      return this.overflow_;
    }
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */

  }, {
    key: "getFont",
    value: function getFont() {
      return this.font_;
    }
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */

  }, {
    key: "getMaxAngle",
    value: function getMaxAngle() {
      return this.maxAngle_;
    }
    /**
     * Get the label placement.
     * @return {TextPlacement} Text placement.
     * @api
     */

  }, {
    key: "getPlacement",
    value: function getPlacement() {
      return this.placement_;
    }
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */

  }, {
    key: "getOffsetX",
    value: function getOffsetX() {
      return this.offsetX_;
    }
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */

  }, {
    key: "getOffsetY",
    value: function getOffsetY() {
      return this.offsetY_;
    }
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */

  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill_;
    }
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */

  }, {
    key: "getRotateWithView",
    value: function getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */

  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.rotation_;
    }
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */

  }, {
    key: "getScale",
    value: function getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */

  }, {
    key: "getScaleArray",
    value: function getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */

  }, {
    key: "getStroke",
    value: function getStroke() {
      return this.stroke_;
    }
    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */

  }, {
    key: "getText",
    value: function getText() {
      return this.text_;
    }
    /**
     * Get the text alignment.
     * @return {CanvasTextAlign|undefined} Text align.
     * @api
     */

  }, {
    key: "getTextAlign",
    value: function getTextAlign() {
      return this.textAlign_;
    }
    /**
     * Get the justification.
     * @return {TextJustify|undefined} Justification.
     * @api
     */

  }, {
    key: "getJustify",
    value: function getJustify() {
      return this.justify_;
    }
    /**
     * Get the text baseline.
     * @return {CanvasTextBaseline|undefined} Text baseline.
     * @api
     */

  }, {
    key: "getTextBaseline",
    value: function getTextBaseline() {
      return this.textBaseline_;
    }
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */

  }, {
    key: "getBackgroundFill",
    value: function getBackgroundFill() {
      return this.backgroundFill_;
    }
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */

  }, {
    key: "getBackgroundStroke",
    value: function getBackgroundStroke() {
      return this.backgroundStroke_;
    }
    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */

  }, {
    key: "getPadding",
    value: function getPadding() {
      return this.padding_;
    }
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */

  }, {
    key: "setOverflow",
    value: function setOverflow(overflow) {
      this.overflow_ = overflow;
    }
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */

  }, {
    key: "setFont",
    value: function setFont(font) {
      this.font_ = font;
    }
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */

  }, {
    key: "setMaxAngle",
    value: function setMaxAngle(maxAngle) {
      this.maxAngle_ = maxAngle;
    }
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */

  }, {
    key: "setOffsetX",
    value: function setOffsetX(offsetX) {
      this.offsetX_ = offsetX;
    }
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */

  }, {
    key: "setOffsetY",
    value: function setOffsetY(offsetY) {
      this.offsetY_ = offsetY;
    }
    /**
     * Set the text placement.
     *
     * @param {TextPlacement} placement Placement.
     * @api
     */

  }, {
    key: "setPlacement",
    value: function setPlacement(placement) {
      this.placement_ = placement;
    }
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */

  }, {
    key: "setRotateWithView",
    value: function setRotateWithView(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    }
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */

  }, {
    key: "setFill",
    value: function setFill(fill) {
      this.fill_ = fill;
    }
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */

  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.rotation_ = rotation;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */

  }, {
    key: "setScale",
    value: function setScale(scale) {
      this.scale_ = scale;
      this.scaleArray_ = toSize(scale !== undefined ? scale : 1);
    }
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */

  }, {
    key: "setStroke",
    value: function setStroke(stroke) {
      this.stroke_ = stroke;
    }
    /**
     * Set the text.
     *
     * @param {string|Array<string>|undefined} text Text.
     * @api
     */

  }, {
    key: "setText",
    value: function setText(text) {
      this.text_ = text;
    }
    /**
     * Set the text alignment.
     *
     * @param {CanvasTextAlign|undefined} textAlign Text align.
     * @api
     */

  }, {
    key: "setTextAlign",
    value: function setTextAlign(textAlign) {
      this.textAlign_ = textAlign;
    }
    /**
     * Set the justification.
     *
     * @param {TextJustify|undefined} justify Justification.
     * @api
     */

  }, {
    key: "setJustify",
    value: function setJustify(justify) {
      this.justify_ = justify;
    }
    /**
     * Set the text baseline.
     *
     * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
     * @api
     */

  }, {
    key: "setTextBaseline",
    value: function setTextBaseline(textBaseline) {
      this.textBaseline_ = textBaseline;
    }
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */

  }, {
    key: "setBackgroundFill",
    value: function setBackgroundFill(fill) {
      this.backgroundFill_ = fill;
    }
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */

  }, {
    key: "setBackgroundStroke",
    value: function setBackgroundStroke(stroke) {
      this.backgroundStroke_ = stroke;
    }
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */

  }, {
    key: "setPadding",
    value: function setPadding(padding) {
      this.padding_ = padding;
    }
  }]);

  return Text;
}();

/* harmony default export */ var style_Text = (Text_Text);
;// CONCATENATED MODULE: ./node_modules/ol/style/flat.js
/**
 * @module ol/style/flat
 */







/**
 * For static styling, the [layer.setStyle()]{@link module:ol/layer/Vector~VectorLayer#setStyle} method
 * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.
 * @api
 *
 * @typedef {FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle} FlatStyle
 */

/**
 * A flat style literal or an array of the same.
 *
 * @typedef {FlatStyle|Array<FlatStyle>} FlatStyleLike
 */

/**
 * Fill style properties applied to polygon features.
 *
 * @typedef {Object} FlatFill
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [fill-color] The fill color.
 */

/**
 * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of
 * `stroke-color` or `stroke-width` must be provided.
 *
 * @typedef {Object} FlatStroke
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [stroke-color] The stroke color.
 * @property {number} [stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [stroke-line-dash] Line dash pattern.
 * @property {number} [stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [stroke-miter-limit=10] Miter limit.
 */

/**
 * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.
 *
 * @typedef {Object} FlatText
 * @property {string|Array<string>} [text-value] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {string} [text-font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [text-max-angle=Math.PI/4] When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [text-offset-x=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [text-offset-y=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [text-overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./Text.js").TextPlacement} [text-placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [text-scale] Scale.
 * @property {boolean} [text-rotate-with-view=false] Whether to rotate the text with the view.
 * @property {number} [text-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {CanvasTextAlign} [text-align] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `text-placement: 'point'`. For `text-placement: 'line'`, the default is to let the renderer choose a
 * placement where `text-max-angle` is not exceeded.
 * @property {import('./Text.js').TextJustify} [text-justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `text-justify` is ignored for immediate rendering and also for `text-placement: 'line'`.
 * @property {CanvasTextBaseline} [text-baseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {Array<number>} [text-padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-background-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-stroke-color] The stroke color.
 * @property {CanvasLineCap} [text-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [text-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [text-stroke-line-dash] Line dash pattern.
 * @property {number} [text-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [text-stroke-miter-limit=10] Miter limit.
 * @property {number} [text-stroke-width] Stroke pixel width.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-background-stroke-color] The stroke color.
 * @property {CanvasLineCap} [text-background-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [text-background-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [text-background-stroke-line-dash] Line dash pattern.
 * @property {number} [text-background-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [text-background-stroke-miter-limit=10] Miter limit.
 * @property {number} [text-background-stroke-width] Stroke pixel width.
 */

/**
 * Icon style properties applied to point features.  One of `icon-src` or `icon-img` must be provided to render
 * points with an icon.
 *
 * @typedef {Object} FlatIcon
 * @property {string} [icon-src] Image source URI.
 * @property {HTMLImageElement|HTMLCanvasElement} [icon-img] Image object for the icon. If the `icon-src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `icon-img-size` option.
 * @property {import("../size.js").Size} [icon-img-size] Image size in pixels. Only required if `icon-img` is set and `icon-src` is not.
 * The provided size needs to match the actual size of the image.
 * @property {Array<number>} [icon-anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./Icon.js").IconOrigin} [icon-anchor-origin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-x-units='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-y-units='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [icon-color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [icon-cross-origin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Array<number>} [icon-offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [icon-displacement=[0,0]] Displacement of the icon.
 * @property {import("./Icon.js").IconOrigin} [icon-offset-origin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [icon-opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [icon-scale=1] Scale.
 * @property {number} [icon-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [icon-rotate-with-view=false] Whether to rotate the icon with the view.
 * @property {import("../size.js").Size} [icon-size] Icon size in pixel. Can be used together with `icon-offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {"declutter"|"obstacle"|"none"|undefined} [icon-declutter-mode] Declutter mode
 */

/**
 * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.
 *
 * @typedef {Object} FlatShape
 * @property {number} [shape-points] Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [shape-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [shape-stroke-color] The stroke color.
 * @property {number} [shape-stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [shape-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [shape-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [shape-stroke-line-dash] Line dash pattern.
 * @property {number} [shape-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [shape-stroke-miter-limit=10] Miter limit.
 * @property {number} [shape-radius] Radius of a regular polygon.
 * @property {number} [shape-radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [shape-radius2] Second radius of a star.
 * @property {number} [shape-angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [shape-displacement=[0,0]] Displacement of the shape
 * @property {number} [shape-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [shape-rotate-with-view=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [shape-scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `shape-radius`, `shape-radius1` and `shape-radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [shape-declutter-mode] Declutter mode.
 */

/**
 * Circle style properties for rendering point features.  At least `circle-radius` must be provided.
 *
 * @typedef {Object} FlatCircle
 * @property {number} [circle-radius] Circle radius.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [circle-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [circle-stroke-color] The stroke color.
 * @property {number} [circle-stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [circle-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [circle-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [circle-stroke-line-dash] Line dash pattern.
 * @property {number} [circle-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [circle-stroke-miter-limit=10] Miter limit.
 * @property {Array<number>} [circle-displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [circle-scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
 * @property {number} [circle-rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [circle-rotate-with-view=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [circle-declutter-mode] Declutter mode
 */

/**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @return {import("./Style.js").default} A style instance.
 */

function toStyle(flatStyle) {
  var style = new style_Style({
    fill: getFill(flatStyle, ''),
    stroke: getStroke(flatStyle, ''),
    text: getText(flatStyle),
    image: getImage(flatStyle)
  });
  return style;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @return {Fill|undefined} The fill (if any).
 */

function getFill(flatStyle, prefix) {
  var color = flatStyle[prefix + 'fill-color'];

  if (!color) {
    return;
  }

  return new style_Fill({
    color: color
  });
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @return {Stroke|undefined} The stroke (if any).
 */


function getStroke(flatStyle, prefix) {
  var width = flatStyle[prefix + 'stroke-width'];
  var color = flatStyle[prefix + 'stroke-color'];

  if (!width && !color) {
    return;
  }

  return new style_Stroke({
    width: width,
    color: color,
    lineCap: flatStyle[prefix + 'stroke-line-cap'],
    lineJoin: flatStyle[prefix + 'stroke-line-join'],
    lineDash: flatStyle[prefix + 'stroke-line-dash'],
    lineDashOffset: flatStyle[prefix + 'stroke-line-dash-offset'],
    miterLimit: flatStyle[prefix + 'stroke-miter-limit']
  });
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @return {Text|undefined} The text (if any).
 */


function getText(flatStyle) {
  var value = flatStyle['text-value'];

  if (!value) {
    return;
  }

  var text = new style_Text({
    text: value,
    font: flatStyle['text-font'],
    maxAngle: flatStyle['text-max-angle'],
    offsetX: flatStyle['text-offset-x'],
    offsetY: flatStyle['text-offset-y'],
    overflow: flatStyle['text-overflow'],
    placement: flatStyle['text-placement'],
    scale: flatStyle['text-scale'],
    rotateWithView: flatStyle['text-rotate-with-view'],
    rotation: flatStyle['text-rotation'],
    textAlign: flatStyle['text-align'],
    justify: flatStyle['text-justify'],
    textBaseline: flatStyle['text-baseline'],
    padding: flatStyle['text-padding'],
    fill: getFill(flatStyle, 'text-'),
    backgroundFill: getFill(flatStyle, 'text-background-'),
    stroke: getStroke(flatStyle, 'text-'),
    backgroundStroke: getStroke(flatStyle, 'text-background-')
  });
  return text;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @return {import("./Image.js").default|undefined} The image (if any).
 */


function getImage(flatStyle) {
  var iconSrc = flatStyle['icon-src'];
  var iconImg = flatStyle['icon-img'];

  if (iconSrc || iconImg) {
    var icon = new style_Icon({
      src: iconSrc,
      img: iconImg,
      imgSize: flatStyle['icon-img-size'],
      anchor: flatStyle['icon-anchor'],
      anchorOrigin: flatStyle['icon-anchor-origin'],
      anchorXUnits: flatStyle['icon-anchor-x-units'],
      anchorYUnits: flatStyle['icon-anchor-y-units'],
      color: flatStyle['icon-color'],
      crossOrigin: flatStyle['icon-cross-origin'],
      offset: flatStyle['icon-offset'],
      displacement: flatStyle['icon-displacement'],
      opacity: flatStyle['icon-opacity'],
      scale: flatStyle['icon-scale'],
      rotation: flatStyle['icon-rotation'],
      rotateWithView: flatStyle['icon-rotate-with-view'],
      size: flatStyle['icon-size'],
      declutterMode: flatStyle['icon-declutter-mode']
    });
    return icon;
  }

  var shapePoints = flatStyle['shape-points'];

  if (shapePoints) {
    var prefix = 'shape-';
    var shape = new style_RegularShape({
      points: shapePoints,
      fill: getFill(flatStyle, prefix),
      stroke: getStroke(flatStyle, prefix),
      radius: flatStyle['shape-radius'],
      radius1: flatStyle['shape-radius1'],
      radius2: flatStyle['shape-radius2'],
      angle: flatStyle['shape-angle'],
      displacement: flatStyle['shape-displacement'],
      rotation: flatStyle['shape-rotation'],
      rotateWithView: flatStyle['shape-rotate-with-view'],
      scale: flatStyle['shape-scale'],
      declutterMode: flatStyle['shape-declutter-mode']
    });
    return shape;
  }

  var circleRadius = flatStyle['circle-radius'];

  if (circleRadius) {
    var _prefix = 'circle-';
    var circle = new Circle({
      radius: circleRadius,
      fill: getFill(flatStyle, _prefix),
      stroke: getStroke(flatStyle, _prefix),
      displacement: flatStyle['circle-displacement'],
      scale: flatStyle['circle-scale'],
      rotation: flatStyle['circle-rotation'],
      rotateWithView: flatStyle['circle-rotate-with-view'],
      declutterMode: flatStyle['circle-declutter-mode']
    });
    return circle;
  }

  return;
}
;// CONCATENATED MODULE: ./node_modules/ol/layer/BaseVector.js







/**
 * @module ol/layer/BaseVector
 */




/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */

var BaseVector_Property = {
  RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */

var BaseVectorLayer = /*#__PURE__*/function (_Layer) {
  _inherits(BaseVectorLayer, _Layer);

  var _super = createSuper_createSuper(BaseVectorLayer);

  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  function BaseVectorLayer(options) {
    var _this;

    _classCallCheck(this, BaseVectorLayer);

    options = options ? options : {};
    var baseOptions = Object.assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    _this = _super.call(this, baseOptions);
    /**
     * @private
     * @type {boolean}
     */

    _this.declutter_ = options.declutter !== undefined ? options.declutter : false;
    /**
     * @type {number}
     * @private
     */

    _this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */

    _this.style_ = null;
    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */

    _this.styleFunction_ = undefined;

    _this.setStyle(options.style);
    /**
     * @type {boolean}
     * @private
     */


    _this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
    /**
     * @type {boolean}
     * @private
     */

    _this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    return _this;
  }
  /**
   * @return {boolean} Declutter.
   */


  _createClass(BaseVectorLayer, [{
    key: "getDeclutter",
    value: function getDeclutter() {
      return this.declutter_;
    }
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
     * @api
     */

  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      return _get(getPrototypeOf_getPrototypeOf(BaseVectorLayer.prototype), "getFeatures", this).call(this, pixel);
    }
    /**
     * @return {number|undefined} Render buffer.
     */

  }, {
    key: "getRenderBuffer",
    value: function getRenderBuffer() {
      return this.renderBuffer_;
    }
    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */

  }, {
    key: "getRenderOrder",
    value: function getRenderOrder() {
      return (
        /** @type {import("../render.js").OrderFunction|null|undefined} */
        this.get(BaseVector_Property.RENDER_ORDER)
      );
    }
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
     * @api
     */

  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.style_;
    }
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */

  }, {
    key: "getStyleFunction",
    value: function getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */

  }, {
    key: "getUpdateWhileAnimating",
    value: function getUpdateWhileAnimating() {
      return this.updateWhileAnimating_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */

  }, {
    key: "getUpdateWhileInteracting",
    value: function getUpdateWhileInteracting() {
      return this.updateWhileInteracting_;
    }
    /**
     * Render declutter items for this layer
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */

  }, {
    key: "renderDeclutter",
    value: function renderDeclutter(frameState) {
      if (!frameState.declutterTree) {
        frameState.declutterTree = new rbush_min(9);
      }
      /** @type {*} */


      this.getRenderer().renderDeclutter(frameState);
    }
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */

  }, {
    key: "setRenderOrder",
    value: function setRenderOrder(renderOrder) {
      this.set(BaseVector_Property.RENDER_ORDER, renderOrder);
    }
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
     *
     * If your layer has a static style, you can use "flat" style object literals instead of
     * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation
     * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.
     *
     * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
     * @api
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      /**
       * @type {import("../style/Style.js").StyleLike|null}
       */
      var styleLike;

      if (style === undefined) {
        styleLike = createDefaultStyle;
      } else if (style === null) {
        styleLike = null;
      } else if (typeof style === 'function') {
        styleLike = style;
      } else if (style instanceof style_Style) {
        styleLike = style;
      } else if (Array.isArray(style)) {
        var len = style.length;
        /**
         * @type {Array<Style>}
         */

        var styles = new Array(len);

        for (var i = 0; i < len; ++i) {
          var s = style[i];

          if (s instanceof style_Style) {
            styles[i] = s;
          } else {
            styles[i] = toStyle(s);
          }
        }

        styleLike = styles;
      } else {
        styleLike = toStyle(style);
      }

      this.style_ = styleLike;
      this.styleFunction_ = style === null ? undefined : toFunction(this.style_);
      this.changed();
    }
  }]);

  return BaseVectorLayer;
}(layer_Layer);

/* harmony default export */ var BaseVector = (BaseVectorLayer);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Instruction.js
/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
/**
 * @type {Array<Instruction>}
 */

var fillInstruction = [Instruction.FILL];
/**
 * @type {Array<Instruction>}
 */

var strokeInstruction = [Instruction.STROKE];
/**
 * @type {Array<Instruction>}
 */

var beginPathInstruction = [Instruction.BEGIN_PATH];
/**
 * @type {Array<Instruction>}
 */

var closePathInstruction = [Instruction.CLOSE_PATH];
/* harmony default export */ var canvas_Instruction = (Instruction);
;// CONCATENATED MODULE: ./node_modules/ol/render/VectorContext.js



/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext = /*#__PURE__*/function () {
  function VectorContext() {
    _classCallCheck(this, VectorContext);
  }

  _createClass(VectorContext, [{
    key: "drawCustom",
    value:
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */
    function drawCustom(geometry, feature, renderer, hitDetectionRenderer) {}
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */

  }, {
    key: "drawGeometry",
    value: function drawGeometry(geometry) {}
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {}
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     */

  }, {
    key: "drawCircle",
    value: function drawCircle(circleGeometry, feature) {}
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     */

  }, {
    key: "drawFeature",
    value: function drawFeature(feature, style) {}
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     */

  }, {
    key: "drawGeometryCollection",
    value: function drawGeometryCollection(geometryCollectionGeometry, feature) {}
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawLineString",
    value: function drawLineString(lineStringGeometry, feature) {}
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawMultiLineString",
    value: function drawMultiLineString(multiLineStringGeometry, feature) {}
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawMultiPoint",
    value: function drawMultiPoint(multiPointGeometry, feature) {}
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawMultiPolygon",
    value: function drawMultiPolygon(multiPolygonGeometry, feature) {}
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawPoint",
    value: function drawPoint(pointGeometry, feature) {}
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawPolygon",
    value: function drawPolygon(polygonGeometry, feature) {}
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawText",
    value: function drawText(geometry, feature) {}
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */

  }, {
    key: "setFillStrokeStyle",
    value: function setFillStrokeStyle(fillStyle, strokeStyle) {}
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
     */

  }, {
    key: "setImageStyle",
    value: function setImageStyle(imageStyle, declutterImageWithText) {}
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
     */

  }, {
    key: "setTextStyle",
    value: function setTextStyle(textStyle, declutterImageWithText) {}
  }]);

  return VectorContext;
}();

/* harmony default export */ var render_VectorContext = (VectorContext);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Builder.js





/**
 * @module ol/render/canvas/Builder
 */









var CanvasBuilder = /*#__PURE__*/function (_VectorContext) {
  _inherits(CanvasBuilder, _VectorContext);

  var _super = createSuper_createSuper(CanvasBuilder);

  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this;

    _classCallCheck(this, CanvasBuilder);

    _this = _super.call(this);
    /**
     * @protected
     * @type {number}
     */

    _this.tolerance = tolerance;
    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */

    _this.maxExtent = maxExtent;
    /**
     * @protected
     * @type {number}
     */

    _this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @type {number}
     */

    _this.maxLineWidth = 0;
    /**
     * @protected
     * @const
     * @type {number}
     */

    _this.resolution = resolution;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction1_ = null;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction2_ = null;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.bufferedMaxExtent_ = null;
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.instructions = [];
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.coordinates = [];
    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */

    _this.tmpCoordinate_ = [];
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.hitDetectionInstructions = [];
    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */

    _this.state =
    /** @type {import("../canvas.js").FillStrokeState} */
    {};
    return _this;
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */


  _createClass(CanvasBuilder, [{
    key: "applyPixelRatio",
    value: function applyPixelRatio(dashArray) {
      var pixelRatio = this.pixelRatio;
      return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
        return dash * pixelRatio;
      });
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */

  }, {
    key: "appendFlatPointCoordinates",
    value: function appendFlatPointCoordinates(flatCoordinates, stride) {
      var extent = this.getBufferedMaxExtent();
      var tmpCoord = this.tmpCoordinate_;
      var coordinates = this.coordinates;
      var myEnd = coordinates.length;

      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        tmpCoord[0] = flatCoordinates[i];
        tmpCoord[1] = flatCoordinates[i + 1];

        if (containsCoordinate(extent, tmpCoord)) {
          coordinates[myEnd++] = tmpCoord[0];
          coordinates[myEnd++] = tmpCoord[1];
        }
      }

      return myEnd;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */

  }, {
    key: "appendFlatLineCoordinates",
    value: function appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
      var coordinates = this.coordinates;
      var myEnd = coordinates.length;
      var extent = this.getBufferedMaxExtent();

      if (skipFirst) {
        offset += stride;
      }

      var lastXCoord = flatCoordinates[offset];
      var lastYCoord = flatCoordinates[offset + 1];
      var nextCoord = this.tmpCoordinate_;
      var skipped = true;
      var i, lastRel, nextRel;

      for (i = offset + stride; i < end; i += stride) {
        nextCoord[0] = flatCoordinates[i];
        nextCoord[1] = flatCoordinates[i + 1];
        nextRel = coordinateRelationship(extent, nextCoord);

        if (nextRel !== lastRel) {
          if (skipped) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
            skipped = false;
          }

          coordinates[myEnd++] = nextCoord[0];
          coordinates[myEnd++] = nextCoord[1];
        } else if (nextRel === Relationship.INTERSECTING) {
          coordinates[myEnd++] = nextCoord[0];
          coordinates[myEnd++] = nextCoord[1];
          skipped = false;
        } else {
          skipped = true;
        }

        lastXCoord = nextCoord[0];
        lastYCoord = nextCoord[1];
        lastRel = nextRel;
      } // Last coordinate equals first or only one point to append:


      if (closed && skipped || i === offset + stride) {
        coordinates[myEnd++] = lastXCoord;
        coordinates[myEnd++] = lastYCoord;
      }

      return myEnd;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */

  }, {
    key: "drawCustomCoordinates_",
    value: function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        builderEnds.push(builderEnd);
        offset = end;
      }

      return offset;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */

  }, {
    key: "drawCustom",
    value: function drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
      this.beginGeometry(geometry, feature);
      var type = geometry.getType();
      var stride = geometry.getStride();
      var builderBegin = this.coordinates.length;
      var flatCoordinates, builderEnd, builderEnds, builderEndss;
      var offset;

      switch (type) {
        case 'MultiPolygon':
          flatCoordinates =
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getOrientedFlatCoordinates();
          builderEndss = [];
          var endss =
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getEndss();
          offset = 0;

          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var myEnds = [];
            offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
            builderEndss.push(myEnds);
          }

          this.instructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);
          this.hitDetectionInstructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray]);
          break;

        case 'Polygon':
        case 'MultiLineString':
          builderEnds = [];
          flatCoordinates = type == 'Polygon' ?
          /** @type {import("../../geom/Polygon.js").default} */
          geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
          offset = this.drawCustomCoordinates_(flatCoordinates, 0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          geometry.getEnds(), stride, builderEnds);
          this.instructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);
          this.hitDetectionInstructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray]);
          break;

        case 'LineString':
        case 'Circle':
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
          this.instructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);
          this.hitDetectionInstructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);
          break;

        case 'MultiPoint':
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);

          if (builderEnd > builderBegin) {
            this.instructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);
            this.hitDetectionInstructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);
          }

          break;

        case 'Point':
          flatCoordinates = geometry.getFlatCoordinates();
          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
          builderEnd = this.coordinates.length;
          this.instructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);
          this.hitDetectionInstructions.push([canvas_Instruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);
          break;

        default:
      }

      this.endGeometry(feature);
    }
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "beginGeometry",
    value: function beginGeometry(geometry, feature) {
      this.beginGeometryInstruction1_ = [canvas_Instruction.BEGIN_GEOMETRY, feature, 0, geometry];
      this.instructions.push(this.beginGeometryInstruction1_);
      this.beginGeometryInstruction2_ = [canvas_Instruction.BEGIN_GEOMETRY, feature, 0, geometry];
      this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */

  }, {
    key: "finish",
    value: function finish() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates
      };
    }
    /**
     * Reverse the hit detection instructions.
     */

  }, {
    key: "reverseHitDetectionInstructions",
    value: function reverseHitDetectionInstructions() {
      var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array

      hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks

      var i;
      var n = hitDetectionInstructions.length;
      var instruction;
      var type;
      var begin = -1;

      for (i = 0; i < n; ++i) {
        instruction = hitDetectionInstructions[i];
        type =
        /** @type {import("./Instruction.js").default} */
        instruction[0];

        if (type == canvas_Instruction.END_GEOMETRY) {
          begin = i;
        } else if (type == canvas_Instruction.BEGIN_GEOMETRY) {
          instruction[2] = i;
          reverseSubArray(this.hitDetectionInstructions, begin, i);
          begin = -1;
        }
      }
    }
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */

  }, {
    key: "setFillStrokeStyle",
    value: function setFillStrokeStyle(fillStyle, strokeStyle) {
      var state = this.state;

      if (fillStyle) {
        var fillStyleColor = fillStyle.getColor();
        state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
      } else {
        state.fillStyle = undefined;
      }

      if (strokeStyle) {
        var strokeStyleColor = strokeStyle.getColor();
        state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
        var strokeStyleLineCap = strokeStyle.getLineCap();
        state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;
        var strokeStyleLineDash = strokeStyle.getLineDash();
        state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
        state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
        var strokeStyleLineJoin = strokeStyle.getLineJoin();
        state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;
        var strokeStyleWidth = strokeStyle.getWidth();
        state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;
        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;

        if (state.lineWidth > this.maxLineWidth) {
          this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache

          this.bufferedMaxExtent_ = null;
        }
      } else {
        state.strokeStyle = undefined;
        state.lineCap = undefined;
        state.lineDash = null;
        state.lineDashOffset = undefined;
        state.lineJoin = undefined;
        state.lineWidth = undefined;
        state.miterLimit = undefined;
      }
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */

  }, {
    key: "createFill",
    value: function createFill(state) {
      var fillStyle = state.fillStyle;
      /** @type {Array<*>} */

      var fillInstruction = [canvas_Instruction.SET_FILL_STYLE, fillStyle];

      if (typeof fillStyle !== 'string') {
        // Fill is a pattern or gradient - align it!
        fillInstruction.push(true);
      }

      return fillInstruction;
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */

  }, {
    key: "applyStroke",
    value: function applyStroke(state) {
      this.instructions.push(this.createStroke(state));
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */

  }, {
    key: "createStroke",
    value: function createStroke(state) {
      return [canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */

  }, {
    key: "updateFillStyle",
    value: function updateFillStyle(state, createFill) {
      var fillStyle = state.fillStyle;

      if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
        if (fillStyle !== undefined) {
          this.instructions.push(createFill.call(this, state));
        }

        state.currentFillStyle = fillStyle;
      }
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */

  }, {
    key: "updateStrokeStyle",
    value: function updateStrokeStyle(state, applyStroke) {
      var strokeStyle = state.strokeStyle;
      var lineCap = state.lineCap;
      var lineDash = state.lineDash;
      var lineDashOffset = state.lineDashOffset;
      var lineJoin = state.lineJoin;
      var lineWidth = state.lineWidth;
      var miterLimit = state.miterLimit;

      if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
        if (strokeStyle !== undefined) {
          applyStroke.call(this, state);
        }

        state.currentStrokeStyle = strokeStyle;
        state.currentLineCap = lineCap;
        state.currentLineDash = lineDash;
        state.currentLineDashOffset = lineDashOffset;
        state.currentLineJoin = lineJoin;
        state.currentLineWidth = lineWidth;
        state.currentMiterLimit = miterLimit;
      }
    }
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "endGeometry",
    value: function endGeometry(feature) {
      this.beginGeometryInstruction1_[2] = this.instructions.length;
      this.beginGeometryInstruction1_ = null;
      this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
      this.beginGeometryInstruction2_ = null;
      var endGeometryInstruction = [canvas_Instruction.END_GEOMETRY, feature];
      this.instructions.push(endGeometryInstruction);
      this.hitDetectionInstructions.push(endGeometryInstruction);
    }
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */

  }, {
    key: "getBufferedMaxExtent",
    value: function getBufferedMaxExtent() {
      if (!this.bufferedMaxExtent_) {
        this.bufferedMaxExtent_ = clone(this.maxExtent);

        if (this.maxLineWidth > 0) {
          var width = this.resolution * (this.maxLineWidth + 1) / 2;
          buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
        }
      }

      return this.bufferedMaxExtent_;
    }
  }]);

  return CanvasBuilder;
}(render_VectorContext);

/* harmony default export */ var Builder = (CanvasBuilder);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/ImageBuilder.js







/**
 * @module ol/render/canvas/ImageBuilder
 */



var CanvasImageBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasImageBuilder, _CanvasBuilder);

  var _super = createSuper_createSuper(CanvasImageBuilder);

  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this;

    _classCallCheck(this, CanvasImageBuilder);

    _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio);
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.imagePixelRatio_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorY_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.height_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.opacity_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originY_ = undefined;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.rotateWithView_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;
    /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */

    _this.scale_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.width_ = undefined;
    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */

    _this.declutterMode_ = undefined;
    /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */

    _this.declutterImageWithText_ = undefined;
    return _this;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  _createClass(CanvasImageBuilder, [{
    key: "drawPoint",
    value: function drawPoint(pointGeometry, feature) {
      if (!this.image_) {
        return;
      }

      this.beginGeometry(pointGeometry, feature);
      var flatCoordinates = pointGeometry.getFlatCoordinates();
      var stride = pointGeometry.getStride();
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]);
      this.hitDetectionInstructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]);
      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawMultiPoint",
    value: function drawMultiPoint(multiPointGeometry, feature) {
      if (!this.image_) {
        return;
      }

      this.beginGeometry(multiPointGeometry, feature);
      var flatCoordinates = multiPointGeometry.getFlatCoordinates();
      var stride = multiPointGeometry.getStride();
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]);
      this.hitDetectionInstructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]);
      this.endGeometry(feature);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */

  }, {
    key: "finish",
    value: function finish() {
      this.reverseHitDetectionInstructions(); // FIXME this doesn't really protect us against further calls to draw*Geometry

      this.anchorX_ = undefined;
      this.anchorY_ = undefined;
      this.hitDetectionImage_ = null;
      this.image_ = null;
      this.imagePixelRatio_ = undefined;
      this.height_ = undefined;
      this.scale_ = undefined;
      this.opacity_ = undefined;
      this.originX_ = undefined;
      this.originY_ = undefined;
      this.rotateWithView_ = undefined;
      this.rotation_ = undefined;
      this.width_ = undefined;
      return _get(getPrototypeOf_getPrototypeOf(CanvasImageBuilder.prototype), "finish", this).call(this);
    }
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [sharedData] Shared data.
     */

  }, {
    key: "setImageStyle",
    value: function setImageStyle(imageStyle, sharedData) {
      var anchor = imageStyle.getAnchor();
      var size = imageStyle.getSize();
      var origin = imageStyle.getOrigin();
      this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
      this.anchorX_ = anchor[0];
      this.anchorY_ = anchor[1];
      this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
      this.image_ = imageStyle.getImage(this.pixelRatio);
      this.height_ = size[1];
      this.opacity_ = imageStyle.getOpacity();
      this.originX_ = origin[0];
      this.originY_ = origin[1];
      this.rotateWithView_ = imageStyle.getRotateWithView();
      this.rotation_ = imageStyle.getRotation();
      this.scale_ = imageStyle.getScaleArray();
      this.width_ = size[0];
      this.declutterMode_ = imageStyle.getDeclutterMode();
      this.declutterImageWithText_ = sharedData;
    }
  }]);

  return CanvasImageBuilder;
}(Builder);

/* harmony default export */ var ImageBuilder = (CanvasImageBuilder);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/LineStringBuilder.js







/**
 * @module ol/render/canvas/LineStringBuilder
 */




var CanvasLineStringBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasLineStringBuilder, _CanvasBuilder);

  var _super = createSuper_createSuper(CanvasLineStringBuilder);

  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    _classCallCheck(this, CanvasLineStringBuilder);

    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */


  _createClass(CanvasLineStringBuilder, [{
    key: "drawFlatCoordinates_",
    value: function drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
      var moveToLineToInstruction = [canvas_Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      return end;
    }
    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawLineString",
    value: function drawLineString(lineStringGeometry, feature) {
      var state = this.state;
      var strokeStyle = state.strokeStyle;
      var lineWidth = state.lineWidth;

      if (strokeStyle === undefined || lineWidth === undefined) {
        return;
      }

      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(lineStringGeometry, feature);
      this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset], beginPathInstruction);
      var flatCoordinates = lineStringGeometry.getFlatCoordinates();
      var stride = lineStringGeometry.getStride();
      this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
      this.hitDetectionInstructions.push(strokeInstruction);
      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawMultiLineString",
    value: function drawMultiLineString(multiLineStringGeometry, feature) {
      var state = this.state;
      var strokeStyle = state.strokeStyle;
      var lineWidth = state.lineWidth;

      if (strokeStyle === undefined || lineWidth === undefined) {
        return;
      }

      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(multiLineStringGeometry, feature);
      this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);
      var ends = multiLineStringGeometry.getEnds();
      var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
      var stride = multiLineStringGeometry.getStride();
      var offset = 0;

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.drawFlatCoordinates_(flatCoordinates, offset,
        /** @type {number} */
        ends[i], stride);
      }

      this.hitDetectionInstructions.push(strokeInstruction);
      this.endGeometry(feature);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */

  }, {
    key: "finish",
    value: function finish() {
      var state = this.state;

      if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
        this.instructions.push(strokeInstruction);
      }

      this.reverseHitDetectionInstructions();
      this.state = null;
      return _get(getPrototypeOf_getPrototypeOf(CanvasLineStringBuilder.prototype), "finish", this).call(this);
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */

  }, {
    key: "applyStroke",
    value: function applyStroke(state) {
      if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
        this.instructions.push(strokeInstruction);
        state.lastStroke = this.coordinates.length;
      }

      state.lastStroke = 0;

      _get(getPrototypeOf_getPrototypeOf(CanvasLineStringBuilder.prototype), "applyStroke", this).call(this, state);

      this.instructions.push(beginPathInstruction);
    }
  }]);

  return CanvasLineStringBuilder;
}(Builder);

/* harmony default export */ var LineStringBuilder = (CanvasLineStringBuilder);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/PolygonBuilder.js







/**
 * @module ol/render/canvas/PolygonBuilder
 */





var CanvasPolygonBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasPolygonBuilder, _CanvasBuilder);

  var _super = createSuper_createSuper(CanvasPolygonBuilder);

  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    _classCallCheck(this, CanvasPolygonBuilder);

    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */


  _createClass(CanvasPolygonBuilder, [{
    key: "drawFlatCoordinatess_",
    value: function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
      var state = this.state;
      var fill = state.fillStyle !== undefined;
      var stroke = state.strokeStyle !== undefined;
      var numEnds = ends.length;
      this.instructions.push(beginPathInstruction);
      this.hitDetectionInstructions.push(beginPathInstruction);

      for (var i = 0; i < numEnds; ++i) {
        var end = ends[i];
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
        var moveToLineToInstruction = [canvas_Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);

        if (stroke) {
          // Performance optimization: only call closePath() when we have a stroke.
          // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
          this.instructions.push(closePathInstruction);
          this.hitDetectionInstructions.push(closePathInstruction);
        }

        offset = end;
      }

      if (fill) {
        this.instructions.push(fillInstruction);
        this.hitDetectionInstructions.push(fillInstruction);
      }

      if (stroke) {
        this.instructions.push(strokeInstruction);
        this.hitDetectionInstructions.push(strokeInstruction);
      }

      return offset;
    }
    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     */

  }, {
    key: "drawCircle",
    value: function drawCircle(circleGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;

      if (fillStyle === undefined && strokeStyle === undefined) {
        return;
      }

      this.setFillStrokeStyles_();
      this.beginGeometry(circleGeometry, feature);

      if (state.fillStyle !== undefined) {
        this.hitDetectionInstructions.push([canvas_Instruction.SET_FILL_STYLE, defaultFillStyle]);
      }

      if (state.strokeStyle !== undefined) {
        this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
      }

      var flatCoordinates = circleGeometry.getFlatCoordinates();
      var stride = circleGeometry.getStride();
      var myBegin = this.coordinates.length;
      this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      var circleInstruction = [canvas_Instruction.CIRCLE, myBegin];
      this.instructions.push(beginPathInstruction, circleInstruction);
      this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);

      if (state.fillStyle !== undefined) {
        this.instructions.push(fillInstruction);
        this.hitDetectionInstructions.push(fillInstruction);
      }

      if (state.strokeStyle !== undefined) {
        this.instructions.push(strokeInstruction);
        this.hitDetectionInstructions.push(strokeInstruction);
      }

      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawPolygon",
    value: function drawPolygon(polygonGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;

      if (fillStyle === undefined && strokeStyle === undefined) {
        return;
      }

      this.setFillStrokeStyles_();
      this.beginGeometry(polygonGeometry, feature);

      if (state.fillStyle !== undefined) {
        this.hitDetectionInstructions.push([canvas_Instruction.SET_FILL_STYLE, defaultFillStyle]);
      }

      if (state.strokeStyle !== undefined) {
        this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
      }

      var ends = polygonGeometry.getEnds();
      var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
      var stride = polygonGeometry.getStride();
      this.drawFlatCoordinatess_(flatCoordinates, 0,
      /** @type {Array<number>} */
      ends, stride);
      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawMultiPolygon",
    value: function drawMultiPolygon(multiPolygonGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;

      if (fillStyle === undefined && strokeStyle === undefined) {
        return;
      }

      this.setFillStrokeStyles_();
      this.beginGeometry(multiPolygonGeometry, feature);

      if (state.fillStyle !== undefined) {
        this.hitDetectionInstructions.push([canvas_Instruction.SET_FILL_STYLE, defaultFillStyle]);
      }

      if (state.strokeStyle !== undefined) {
        this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
      }

      var endss = multiPolygonGeometry.getEndss();
      var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
      var stride = multiPolygonGeometry.getStride();
      var offset = 0;

      for (var i = 0, ii = endss.length; i < ii; ++i) {
        offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
      }

      this.endGeometry(feature);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */

  }, {
    key: "finish",
    value: function finish() {
      this.reverseHitDetectionInstructions();
      this.state = null; // We want to preserve topology when drawing polygons.  Polygons are
      // simplified using quantization and point elimination. However, we might
      // have received a mix of quantized and non-quantized geometries, so ensure
      // that all are quantized by quantizing all coordinates in the batch.

      var tolerance = this.tolerance;

      if (tolerance !== 0) {
        var coordinates = this.coordinates;

        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          coordinates[i] = snap(coordinates[i], tolerance);
        }
      }

      return _get(getPrototypeOf_getPrototypeOf(CanvasPolygonBuilder.prototype), "finish", this).call(this);
    }
    /**
     * @private
     */

  }, {
    key: "setFillStrokeStyles_",
    value: function setFillStrokeStyles_() {
      var state = this.state;
      var fillStyle = state.fillStyle;

      if (fillStyle !== undefined) {
        this.updateFillStyle(state, this.createFill);
      }

      if (state.strokeStyle !== undefined) {
        this.updateStrokeStyle(state, this.applyStroke);
      }
    }
  }]);

  return CanvasPolygonBuilder;
}(Builder);

/* harmony default export */ var PolygonBuilder = (CanvasPolygonBuilder);
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/straightchunk.js
/**
 * @module ol/geom/flat/straightchunk
 */

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;

  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];

    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);

      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));

        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }

          m = 0;
          start = i - stride;
        }
      }

      m12 = m23;
      x12 = x23;
      y12 = y23;
    }

    x1 = x2;
    y1 = y2;
  }

  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/TextBuilder.js







/**
 * @module ol/render/canvas/TextBuilder
 */







/**
 * @const
 * @enum {number}
 */

var TEXT_ALIGN = {
  'left': 0,
  'end': 0,
  'center': 0.5,
  'right': 1,
  'start': 1,
  'top': 0,
  'middle': 0.5,
  'hanging': 0.2,
  'alphabetic': 0.8,
  'ideographic': 0.8,
  'bottom': 1
};

var CanvasTextBuilder = /*#__PURE__*/function (_CanvasBuilder) {
  _inherits(CanvasTextBuilder, _CanvasBuilder);

  var _super = createSuper_createSuper(CanvasTextBuilder);

  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this;

    _classCallCheck(this, CanvasTextBuilder);

    _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio);
    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */

    _this.labels_ = null;
    /**
     * @private
     * @type {string|Array<string>}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.textRotateWithView_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    _this.fillStates = {};
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    _this.strokeStates = {};
    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */

    _this.textState_ =
    /** @type {import("../canvas.js").TextState} */
    {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    _this.textStates = {};
    /**
     * @private
     * @type {string}
     */

    _this.textKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.fillKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.strokeKey_ = '';
    /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */

    _this.declutterImageWithText_ = undefined;
    return _this;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  _createClass(CanvasTextBuilder, [{
    key: "finish",
    value: function finish() {
      var instructions = _get(getPrototypeOf_getPrototypeOf(CanvasTextBuilder.prototype), "finish", this).call(this);

      instructions.textStates = this.textStates;
      instructions.fillStates = this.fillStates;
      instructions.strokeStates = this.strokeStates;
      return instructions;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */

  }, {
    key: "drawText",
    value: function drawText(geometry, feature) {
      var fillState = this.textFillState_;
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;

      if (this.text_ === '' || !textState || !fillState && !strokeState) {
        return;
      }

      var coordinates = this.coordinates;
      var begin = coordinates.length;
      var geometryType = geometry.getType();
      var flatCoordinates = null;
      var stride = geometry.getStride();

      if (textState.placement === 'line' && (geometryType == 'LineString' || geometryType == 'MultiLineString' || geometryType == 'Polygon' || geometryType == 'MultiPolygon')) {
        if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
          return;
        }

        var ends;
        flatCoordinates = geometry.getFlatCoordinates();

        if (geometryType == 'LineString') {
          ends = [flatCoordinates.length];
        } else if (geometryType == 'MultiLineString') {
          ends =
          /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.getEnds();
        } else if (geometryType == 'Polygon') {
          ends =
          /** @type {import("../../geom/Polygon.js").default} */
          geometry.getEnds().slice(0, 1);
        } else if (geometryType == 'MultiPolygon') {
          var endss =
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getEndss();
          ends = [];

          for (var i = 0, ii = endss.length; i < ii; ++i) {
            ends.push(endss[i][0]);
          }
        }

        this.beginGeometry(geometry, feature);
        var textAlign = textState.textAlign; // No `justify` support for line placement.

        var flatOffset = 0;
        var flatEnd;

        for (var o = 0, oo = ends.length; o < oo; ++o) {
          if (textAlign == undefined) {
            var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
            flatOffset = range[0];
            flatEnd = range[1];
          } else {
            flatEnd = ends[o];
          }

          for (var _i = flatOffset; _i < flatEnd; _i += stride) {
            coordinates.push(flatCoordinates[_i], flatCoordinates[_i + 1]);
          }

          var end = coordinates.length;
          flatOffset = ends[o];
          this.drawChars_(begin, end);
          begin = end;
        }

        this.endGeometry(feature);
      } else {
        var geometryWidths = textState.overflow ? null : [];

        switch (geometryType) {
          case 'Point':
          case 'MultiPoint':
            flatCoordinates =
            /** @type {import("../../geom/MultiPoint.js").default} */
            geometry.getFlatCoordinates();
            break;

          case 'LineString':
            flatCoordinates =
            /** @type {import("../../geom/LineString.js").default} */
            geometry.getFlatMidpoint();
            break;

          case 'Circle':
            flatCoordinates =
            /** @type {import("../../geom/Circle.js").default} */
            geometry.getCenter();
            break;

          case 'MultiLineString':
            flatCoordinates =
            /** @type {import("../../geom/MultiLineString.js").default} */
            geometry.getFlatMidpoints();
            stride = 2;
            break;

          case 'Polygon':
            flatCoordinates =
            /** @type {import("../../geom/Polygon.js").default} */
            geometry.getFlatInteriorPoint();

            if (!textState.overflow) {
              geometryWidths.push(flatCoordinates[2] / this.resolution);
            }

            stride = 3;
            break;

          case 'MultiPolygon':
            var interiorPoints =
            /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getFlatInteriorPoints();
            flatCoordinates = [];

            for (var _i2 = 0, _ii = interiorPoints.length; _i2 < _ii; _i2 += 3) {
              if (!textState.overflow) {
                geometryWidths.push(interiorPoints[_i2 + 2] / this.resolution);
              }

              flatCoordinates.push(interiorPoints[_i2], interiorPoints[_i2 + 1]);
            }

            if (flatCoordinates.length === 0) {
              return;
            }

            stride = 2;
            break;

          default:
        }

        var _end = this.appendFlatPointCoordinates(flatCoordinates, stride);

        if (_end === begin) {
          return;
        }

        if (geometryWidths && (_end - begin) / 2 !== flatCoordinates.length / stride) {
          var beg = begin / 2;
          geometryWidths = geometryWidths.filter(function (w, i) {
            var keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];

            if (!keep) {
              --beg;
            }

            return keep;
          });
        }

        this.saveTextStates_();

        if (textState.backgroundFill || textState.backgroundStroke) {
          this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);

          if (textState.backgroundFill) {
            this.updateFillStyle(this.state, this.createFill);
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }

          if (textState.backgroundStroke) {
            this.updateStrokeStyle(this.state, this.applyStroke);
            this.hitDetectionInstructions.push(this.createStroke(this.state));
          }
        }

        this.beginGeometry(geometry, feature); // adjust padding for negative scale

        var padding = textState.padding;

        if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
          var p0 = textState.padding[0];
          var p1 = textState.padding[1];
          var p2 = textState.padding[2];
          var p3 = textState.padding[3];

          if (textState.scale[0] < 0) {
            p1 = -p1;
            p3 = -p3;
          }

          if (textState.scale[1] < 0) {
            p0 = -p0;
            p2 = -p2;
          }

          padding = [p0, p1, p2, p3];
        } // The image is unknown at this stage so we pass null; it will be computed at render time.
        // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
        // render time.


        var pixelRatio = this.pixelRatio;
        this.instructions.push([canvas_Instruction.DRAW_IMAGE, begin, _end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, undefined, this.declutterImageWithText_, padding == defaultPadding ? defaultPadding : padding.map(function (p) {
          return p * pixelRatio;
        }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
        var scale = 1 / pixelRatio;
        this.hitDetectionInstructions.push([canvas_Instruction.DRAW_IMAGE, begin, _end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, undefined, this.declutterImageWithText_, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
        this.endGeometry(feature);
      }
    }
    /**
     * @private
     */

  }, {
    key: "saveTextStates_",
    value: function saveTextStates_() {
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      var fillState = this.textFillState_;
      var strokeKey = this.strokeKey_;

      if (strokeState) {
        if (!(strokeKey in this.strokeStates)) {
          this.strokeStates[strokeKey] = {
            strokeStyle: strokeState.strokeStyle,
            lineCap: strokeState.lineCap,
            lineDashOffset: strokeState.lineDashOffset,
            lineWidth: strokeState.lineWidth,
            lineJoin: strokeState.lineJoin,
            miterLimit: strokeState.miterLimit,
            lineDash: strokeState.lineDash
          };
        }
      }

      var textKey = this.textKey_;

      if (!(textKey in this.textStates)) {
        this.textStates[textKey] = {
          font: textState.font,
          textAlign: textState.textAlign || defaultTextAlign,
          justify: textState.justify,
          textBaseline: textState.textBaseline || defaultTextBaseline,
          scale: textState.scale
        };
      }

      var fillKey = this.fillKey_;

      if (fillState) {
        if (!(fillKey in this.fillStates)) {
          this.fillStates[fillKey] = {
            fillStyle: fillState.fillStyle
          };
        }
      }
    }
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */

  }, {
    key: "drawChars_",
    value: function drawChars_(begin, end) {
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      var strokeKey = this.strokeKey_;
      var textKey = this.textKey_;
      var fillKey = this.fillKey_;
      this.saveTextStates_();
      var pixelRatio = this.pixelRatio;
      var baseline = TEXT_ALIGN[textState.textBaseline];
      var offsetY = this.textOffsetY_ * pixelRatio;
      var text = this.text_;
      var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
      this.instructions.push([canvas_Instruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
      this.hitDetectionInstructions.push([canvas_Instruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, 1, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
    }
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [sharedData] Shared data.
     */

  }, {
    key: "setTextStyle",
    value: function setTextStyle(textStyle, sharedData) {
      var textState, fillState, strokeState;

      if (!textStyle) {
        this.text_ = '';
      } else {
        var textFillStyle = textStyle.getFill();

        if (!textFillStyle) {
          fillState = null;
          this.textFillState_ = fillState;
        } else {
          fillState = this.textFillState_;

          if (!fillState) {
            fillState =
            /** @type {import("../canvas.js").FillState} */
            {};
            this.textFillState_ = fillState;
          }

          fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
        }

        var textStrokeStyle = textStyle.getStroke();

        if (!textStrokeStyle) {
          strokeState = null;
          this.textStrokeState_ = strokeState;
        } else {
          strokeState = this.textStrokeState_;

          if (!strokeState) {
            strokeState =
            /** @type {import("../canvas.js").StrokeState} */
            {};
            this.textStrokeState_ = strokeState;
          }

          var lineDash = textStrokeStyle.getLineDash();
          var lineDashOffset = textStrokeStyle.getLineDashOffset();
          var lineWidth = textStrokeStyle.getWidth();
          var miterLimit = textStrokeStyle.getMiterLimit();
          strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
          strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
          strokeState.lineDashOffset = lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;
          strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
          strokeState.lineWidth = lineWidth === undefined ? defaultLineWidth : lineWidth;
          strokeState.miterLimit = miterLimit === undefined ? defaultMiterLimit : miterLimit;
          strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
        }

        textState = this.textState_;
        var font = textStyle.getFont() || defaultFont;
        registerFont(font);
        var textScale = textStyle.getScaleArray();
        textState.overflow = textStyle.getOverflow();
        textState.font = font;
        textState.maxAngle = textStyle.getMaxAngle();
        textState.placement = textStyle.getPlacement();
        textState.textAlign = textStyle.getTextAlign();
        textState.justify = textStyle.getJustify();
        textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
        textState.backgroundFill = textStyle.getBackgroundFill();
        textState.backgroundStroke = textStyle.getBackgroundStroke();
        textState.padding = textStyle.getPadding() || defaultPadding;
        textState.scale = textScale === undefined ? [1, 1] : textScale;
        var textOffsetX = textStyle.getOffsetX();
        var textOffsetY = textStyle.getOffsetY();
        var textRotateWithView = textStyle.getRotateWithView();
        var textRotation = textStyle.getRotation();
        this.text_ = textStyle.getText() || '';
        this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
        this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
        this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
        this.textRotation_ = textRotation === undefined ? 0 : textRotation;
        this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
        this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.justify || '?') + (textState.textBaseline || '?');
        this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + getUid(fillState.fillStyle) : '';
      }

      this.declutterImageWithText_ = sharedData;
    }
  }]);

  return CanvasTextBuilder;
}(Builder);

/* harmony default export */ var TextBuilder = (CanvasTextBuilder);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/BuilderGroup.js



/**
 * @module ol/render/canvas/BuilderGroup
 */





/**
 * @type {Object<import("../canvas.js").BuilderType, typeof Builder>}
 */

var BATCH_CONSTRUCTORS = {
  'Circle': PolygonBuilder,
  'Default': Builder,
  'Image': ImageBuilder,
  'LineString': LineStringBuilder,
  'Polygon': PolygonBuilder,
  'Text': TextBuilder
};

var BuilderGroup = /*#__PURE__*/function () {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio) {
    _classCallCheck(this, BuilderGroup);

    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */

    this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */


  _createClass(BuilderGroup, [{
    key: "finish",
    value: function finish() {
      var builderInstructions = {};

      for (var zKey in this.buildersByZIndex_) {
        builderInstructions[zKey] = builderInstructions[zKey] || {};
        var builders = this.buildersByZIndex_[zKey];

        for (var builderKey in builders) {
          var builderInstruction = builders[builderKey].finish();
          builderInstructions[zKey][builderKey] = builderInstruction;
        }
      }

      return builderInstructions;
    }
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("../canvas.js").BuilderType} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */

  }, {
    key: "getBuilder",
    value: function getBuilder(zIndex, builderType) {
      var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
      var replays = this.buildersByZIndex_[zIndexKey];

      if (replays === undefined) {
        replays = {};
        this.buildersByZIndex_[zIndexKey] = replays;
      }

      var replay = replays[builderType];

      if (replay === undefined) {
        var Constructor = BATCH_CONSTRUCTORS[builderType];
        replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
        replays[builderType] = replay;
      }

      return replay;
    }
  }]);

  return BuilderGroup;
}();

/* harmony default export */ var canvas_BuilderGroup = (BuilderGroup);
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/textpath.js
/**
 * @module ol/geom/flat/textpath
 */


/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */

function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var x1 = 0;
  var y1 = 0;
  var segmentLength = 0;
  var segmentM = 0;

  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }

  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);

  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  var beginX = lerp(x1, x2, interpolate);
  var beginY = lerp(y1, y2, interpolate);
  var startOffset = offset - stride;
  var startLength = segmentM;
  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);

  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }

  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  var endX = lerp(x1, x2, interpolate);
  var endY = lerp(y1, y2, interpolate); // Keep text upright

  var reverse;

  if (rotation) {
    var flat = [beginX, beginY, endX, endY];
    transform_rotate(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }

  var PI = Math.PI;
  var result = [];
  var singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];
  var previousAngle; // All on the same segment

  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }

    var x = (endX + beginX) / 2;
    var y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  } // rendering across line segments


  text = text.replace(/\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines

  for (var i = 0, ii = text.length; i < ii;) {
    advance();
    var angle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }

    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;

      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }

    previousAngle = angle;
    var iStart = i;
    var charLength = 0;

    for (; i < ii; ++i) {
      var index = reverse ? ii - i - 1 : i;
      var len = scale * measureAndCacheTextWidth(font, text[index], cache);

      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }

      charLength += len;
    }

    if (i === iStart) {
      continue;
    }

    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;

    var _x = lerp(x1, x2, interpolate);

    var _y = lerp(y1, y2, interpolate);

    result.push([_x, _y, charLength / 2, angle, chars]);
    startM += charLength;
  }

  return result;
}
;// CONCATENATED MODULE: ./node_modules/ol/geom/flat/length.js
/**
 * @module ol/geom/flat/length
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;

  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }

  return length;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */

function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Executor.js



/**
 * @module ol/render/canvas/Executor
 */









/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */

/**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */

/**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */

/**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * @type {import("../../extent.js").Extent}
 */

var tmpExtent = createEmpty();
/** @type {import("../../coordinate.js").Coordinate} */

var p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */

function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}

var rtlRegEx = new RegExp(
/* eslint-disable prettier/prettier */
'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'
/* eslint-enable prettier/prettier */
);
/**
 * @param {string} text Text.
 * @param {CanvasTextAlign} align Alignment.
 * @return {number} Text alignment.
 */

function horizontalTextAlign(text, align) {
  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {
    align = align === 'start' ? 'left' : 'right';
  }

  return TEXT_ALIGN[align];
}
/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */


function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push('\n', '');
  }

  acc.push(line, '');
  return acc;
}

var Executor = /*#__PURE__*/function () {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  function Executor(resolution, pixelRatio, overlaps, instructions) {
    _classCallCheck(this, Executor);

    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;
    /**
     * @protected
     * @type {number}
     */

    this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @const
     * @type {number}
     */

    this.resolution = resolution;
    /**
     * @private
     * @type {boolean}
     */

    this.alignFill_;
    /**
     * @protected
     * @type {Array<*>}
     */

    this.instructions = instructions.instructions;
    /**
     * @protected
     * @type {Array<number>}
     */

    this.coordinates = instructions.coordinates;
    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */

    this.coordinateCache_ = {};
    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */

    this.renderedTransform_ = create();
    /**
     * @protected
     * @type {Array<*>}
     */

    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    /**
     * @private
     * @type {Array<number>}
     */

    this.pixelCoordinates_ = null;
    /**
     * @private
     * @type {number}
     */

    this.viewRotation_ = 0;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    this.fillStates = instructions.fillStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    this.strokeStates = instructions.strokeStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    this.textStates = instructions.textStates || {};
    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */

    this.widths_ = {};
    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */

    this.labels_ = {};
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */


  _createClass(Executor, [{
    key: "createLabel",
    value: function createLabel(text, textKey, fillKey, strokeKey) {
      var key = text + textKey + fillKey + strokeKey;

      if (this.labels_[key]) {
        return this.labels_[key];
      }

      var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
      var fillState = fillKey ? this.fillStates[fillKey] : null;
      var textState = this.textStates[textKey];
      var pixelRatio = this.pixelRatio;
      var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];
      var textIsArray = Array.isArray(text);
      var align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);
      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
      var chunks = textIsArray ? text : text.split('\n').reduce(createTextChunks, []);

      var _getTextDimensions = getTextDimensions(textState, chunks),
          width = _getTextDimensions.width,
          height = _getTextDimensions.height,
          widths = _getTextDimensions.widths,
          heights = _getTextDimensions.heights,
          lineWidths = _getTextDimensions.lineWidths;

      var renderWidth = width + strokeWidth;
      var contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors

      var w = (renderWidth + 2) * scale[0];
      var h = (height + strokeWidth) * scale[1];
      /** @type {import("../canvas.js").Label} */

      var label = {
        width: w < 0 ? Math.floor(w) : Math.ceil(w),
        height: h < 0 ? Math.floor(h) : Math.ceil(h),
        contextInstructions: contextInstructions
      };

      if (scale[0] != 1 || scale[1] != 1) {
        contextInstructions.push('scale', scale);
      }

      if (strokeKey) {
        contextInstructions.push('strokeStyle', strokeState.strokeStyle);
        contextInstructions.push('lineWidth', strokeWidth);
        contextInstructions.push('lineCap', strokeState.lineCap);
        contextInstructions.push('lineJoin', strokeState.lineJoin);
        contextInstructions.push('miterLimit', strokeState.miterLimit);
        contextInstructions.push('setLineDash', [strokeState.lineDash]);
        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
      }

      if (fillKey) {
        contextInstructions.push('fillStyle', fillState.fillStyle);
      }

      contextInstructions.push('textBaseline', 'middle');
      contextInstructions.push('textAlign', 'center');
      var leftRight = 0.5 - align;
      var x = align * renderWidth + leftRight * strokeWidth;
      var strokeInstructions = [];
      var fillInstructions = [];
      var lineHeight = 0;
      var lineOffset = 0;
      var widthHeightIndex = 0;
      var lineWidthIndex = 0;
      var previousFont;

      for (var i = 0, ii = chunks.length; i < ii; i += 2) {
        var _text = chunks[i];

        if (_text === '\n') {
          lineOffset += lineHeight;
          lineHeight = 0;
          x = align * renderWidth + leftRight * strokeWidth;
          ++lineWidthIndex;
          continue;
        }

        var font = chunks[i + 1] || textState.font;

        if (font !== previousFont) {
          if (strokeKey) {
            strokeInstructions.push('font', font);
          }

          if (fillKey) {
            fillInstructions.push('font', font);
          }

          previousFont = font;
        }

        lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
        var fillStrokeArgs = [_text, x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];
        x += widths[widthHeightIndex];

        if (strokeKey) {
          strokeInstructions.push('strokeText', fillStrokeArgs);
        }

        if (fillKey) {
          fillInstructions.push('fillText', fillStrokeArgs);
        }

        ++widthHeightIndex;
      }

      Array.prototype.push.apply(contextInstructions, strokeInstructions);
      Array.prototype.push.apply(contextInstructions, fillInstructions);
      this.labels_[key] = label;
      return label;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */

  }, {
    key: "replayTextBackground_",
    value: function replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
      context.beginPath();
      context.moveTo.apply(context, p1);
      context.lineTo.apply(context, p2);
      context.lineTo.apply(context, p3);
      context.lineTo.apply(context, p4);
      context.lineTo.apply(context, p1);

      if (fillInstruction) {
        this.alignFill_ =
        /** @type {boolean} */
        fillInstruction[2];
        this.fill_(context);
      }

      if (strokeInstruction) {
        this.setStrokeStyle_(context,
        /** @type {Array<*>} */
        strokeInstruction);
        context.stroke();
      }
    }
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */

  }, {
    key: "calculateImageOrLabelDimensions_",
    value: function calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
      anchorX *= scale[0];
      anchorY *= scale[1];
      var x = centerX - anchorX;
      var y = centerY - anchorY;
      var w = width + originX > sheetWidth ? sheetWidth - originX : width;
      var h = height + originY > sheetHeight ? sheetHeight - originY : height;
      var boxW = padding[3] + w * scale[0] + padding[1];
      var boxH = padding[0] + h * scale[1] + padding[2];
      var boxX = x - padding[3];
      var boxY = y - padding[0];

      if (fillStroke || rotation !== 0) {
        p1[0] = boxX;
        p4[0] = boxX;
        p1[1] = boxY;
        p2[1] = boxY;
        p2[0] = boxX + boxW;
        p3[0] = p2[0];
        p3[1] = boxY + boxH;
        p4[1] = p3[1];
      }

      var transform;

      if (rotation !== 0) {
        transform = compose(create(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
        apply(transform, p1);
        apply(transform, p2);
        apply(transform, p3);
        apply(transform, p4);
        createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
      } else {
        createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
      }

      if (snapToPixel) {
        x = Math.round(x);
        y = Math.round(y);
      }

      return {
        drawImageX: x,
        drawImageY: y,
        drawImageW: w,
        drawImageH: h,
        originX: originX,
        originY: originY,
        declutterBox: {
          minX: tmpExtent[0],
          minY: tmpExtent[1],
          maxX: tmpExtent[2],
          maxY: tmpExtent[3],
          value: feature
        },
        canvasTransform: transform,
        scale: scale
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */

  }, {
    key: "replayImageOrLabel_",
    value: function replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
      var fillStroke = !!(fillInstruction || strokeInstruction);
      var box = dimensions.declutterBox;
      var canvas = context.canvas;
      var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
      var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;

      if (intersects) {
        if (fillStroke) {
          this.replayTextBackground_(context, p1, p2, p3, p4,
          /** @type {Array<*>} */
          fillInstruction,
          /** @type {Array<*>} */
          strokeInstruction);
        }

        drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
      }

      return true;
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */

  }, {
    key: "fill_",
    value: function fill_(context) {
      if (this.alignFill_) {
        var origin = apply(this.renderedTransform_, [0, 0]);
        var repeatSize = 512 * this.pixelRatio;
        context.save();
        context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
        context.rotate(this.viewRotation_);
      }

      context.fill();

      if (this.alignFill_) {
        context.restore();
      }
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */

  }, {
    key: "setStrokeStyle_",
    value: function setStrokeStyle_(context, instruction) {
      context['strokeStyle'] =
      /** @type {import("../../colorlike.js").ColorLike} */
      instruction[1];
      context.lineWidth =
      /** @type {number} */
      instruction[2];
      context.lineCap =
      /** @type {CanvasLineCap} */
      instruction[3];
      context.lineJoin =
      /** @type {CanvasLineJoin} */
      instruction[4];
      context.miterLimit =
      /** @type {number} */
      instruction[5];
      context.lineDashOffset =
      /** @type {number} */
      instruction[7];
      context.setLineDash(
      /** @type {Array<number>} */
      instruction[6]);
    }
    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */

  }, {
    key: "drawLabelWithPointPlacement_",
    value: function drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
      var textState = this.textStates[textKey];
      var label = this.createLabel(text, textKey, fillKey, strokeKey);
      var strokeState = this.strokeStates[strokeKey];
      var pixelRatio = this.pixelRatio;
      var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);
      var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
      var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor

      var width = label.width / pixelRatio - 2 * textState.scale[0];
      var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
      var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
      return {
        label: label,
        anchorX: anchorX,
        anchorY: anchorY
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */

  }, {
    key: "execute_",
    value: function execute_(context, contextScale, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
      /** @type {Array<number>} */
      var pixelCoordinates;

      if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {
        pixelCoordinates = this.pixelCoordinates_;
      } else {
        if (!this.pixelCoordinates_) {
          this.pixelCoordinates_ = [];
        }

        pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
        setFromArray(this.renderedTransform_, transform);
      }

      var i = 0; // instruction index

      var ii = instructions.length; // end of instructions

      var d = 0; // data index

      var dd; // end of per-instruction data

      var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
      var pendingFill = 0;
      var pendingStroke = 0;
      var lastFillInstruction = null;
      var lastStrokeInstruction = null;
      var coordinateCache = this.coordinateCache_;
      var viewRotation = this.viewRotation_;
      var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
      var state =
      /** @type {import("../../render.js").State} */
      {
        context: context,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: viewRotation
      }; // When the batch size gets too big, performance decreases. 200 is a good
      // balance between batch size and number of fill/stroke instructions.

      var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
      var
      /** @type {import("../../Feature.js").FeatureLike} */
      feature;
      var x, y, currentGeometry;

      while (i < ii) {
        var instruction = instructions[i];
        var type =
        /** @type {import("./Instruction.js").default} */
        instruction[0];

        switch (type) {
          case canvas_Instruction.BEGIN_GEOMETRY:
            feature =
            /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            currentGeometry = instruction[3];

            if (!feature.getGeometry()) {
              i =
              /** @type {number} */
              instruction[2];
            } else if (hitExtent !== undefined && !intersects(hitExtent, currentGeometry.getExtent())) {
              i =
              /** @type {number} */
              instruction[2] + 1;
            } else {
              ++i;
            }

            break;

          case canvas_Instruction.BEGIN_PATH:
            if (pendingFill > batchSize) {
              this.fill_(context);
              pendingFill = 0;
            }

            if (pendingStroke > batchSize) {
              context.stroke();
              pendingStroke = 0;
            }

            if (!pendingFill && !pendingStroke) {
              context.beginPath();
              prevX = NaN;
              prevY = NaN;
            }

            ++i;
            break;

          case canvas_Instruction.CIRCLE:
            d =
            /** @type {number} */
            instruction[1];
            var x1 = pixelCoordinates[d];
            var y1 = pixelCoordinates[d + 1];
            var x2 = pixelCoordinates[d + 2];
            var y2 = pixelCoordinates[d + 3];
            var dx = x2 - x1;
            var dy = y2 - y1;
            var r = Math.sqrt(dx * dx + dy * dy);
            context.moveTo(x1 + r, y1);
            context.arc(x1, y1, r, 0, 2 * Math.PI, true);
            ++i;
            break;

          case canvas_Instruction.CLOSE_PATH:
            context.closePath();
            ++i;
            break;

          case canvas_Instruction.CUSTOM:
            d =
            /** @type {number} */
            instruction[1];
            dd = instruction[2];
            var geometry =
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            instruction[3];
            var renderer = instruction[4];
            var fn = instruction.length == 6 ? instruction[5] : undefined;
            state.geometry = geometry;
            state.feature = feature;

            if (!(i in coordinateCache)) {
              coordinateCache[i] = [];
            }

            var coords = coordinateCache[i];

            if (fn) {
              fn(pixelCoordinates, d, dd, 2, coords);
            } else {
              coords[0] = pixelCoordinates[d];
              coords[1] = pixelCoordinates[d + 1];
              coords.length = 2;
            }

            renderer(coords, state);
            ++i;
            break;

          case canvas_Instruction.DRAW_IMAGE:
            d =
            /** @type {number} */
            instruction[1];
            dd =
            /** @type {number} */
            instruction[2];
            image =
            /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
            instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order

            anchorX =
            /** @type {number} */
            instruction[4];
            anchorY =
            /** @type {number} */
            instruction[5];
            var height =
            /** @type {number} */
            instruction[6];
            var opacity =
            /** @type {number} */
            instruction[7];
            var originX =
            /** @type {number} */
            instruction[8];
            var originY =
            /** @type {number} */
            instruction[9];
            var rotateWithView =
            /** @type {boolean} */
            instruction[10];
            var rotation =
            /** @type {number} */
            instruction[11];
            var scale =
            /** @type {import("../../size.js").Size} */
            instruction[12];
            var width =
            /** @type {number} */
            instruction[13];
            var declutterMode =
            /** @type {"declutter"|"obstacle"|"none"|undefined} */
            instruction[14];
            var declutterImageWithText =
            /** @type {import("../canvas.js").DeclutterImageWithText} */
            instruction[15];

            if (!image && instruction.length >= 20) {
              // create label images
              text =
              /** @type {string} */
              instruction[19];
              textKey =
              /** @type {string} */
              instruction[20];
              strokeKey =
              /** @type {string} */
              instruction[21];
              fillKey =
              /** @type {string} */
              instruction[22];
              var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
              image = labelWithAnchor.label;
              instruction[3] = image;
              var textOffsetX =
              /** @type {number} */
              instruction[23];
              anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
              instruction[4] = anchorX;
              var textOffsetY =
              /** @type {number} */
              instruction[24];
              anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
              instruction[5] = anchorY;
              height = image.height;
              instruction[6] = height;
              width = image.width;
              instruction[13] = width;
            }

            var geometryWidths = void 0;

            if (instruction.length > 25) {
              geometryWidths =
              /** @type {number} */
              instruction[25];
            }

            var padding = void 0,
                backgroundFill = void 0,
                backgroundStroke = void 0;

            if (instruction.length > 17) {
              padding =
              /** @type {Array<number>} */
              instruction[16];
              backgroundFill =
              /** @type {boolean} */
              instruction[17];
              backgroundStroke =
              /** @type {boolean} */
              instruction[18];
            } else {
              padding = defaultPadding;
              backgroundFill = false;
              backgroundStroke = false;
            }

            if (rotateWithView && viewRotationFromTransform) {
              // Canvas is expected to be rotated to reverse view rotation.
              rotation += viewRotation;
            } else if (!rotateWithView && !viewRotationFromTransform) {
              // Canvas is not rotated, images need to be rotated back to be north-up.
              rotation -= viewRotation;
            }

            var widthIndex = 0;

            for (; d < dd; d += 2) {
              if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                continue;
              }

              var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
              /** @type {ReplayImageOrLabelArgs} */

              var args = [context, contextScale, image, dimensions, opacity, backgroundFill ?
              /** @type {Array<*>} */
              lastFillInstruction : null, backgroundStroke ?
              /** @type {Array<*>} */
              lastStrokeInstruction : null];

              if (declutterTree) {
                if (declutterMode === 'none') {
                  // not rendered in declutter group
                  continue;
                } else if (declutterMode === 'obstacle') {
                  // will always be drawn, thus no collision detection, but insert as obstacle
                  declutterTree.insert(dimensions.declutterBox);
                  continue;
                } else {
                  var imageArgs = void 0;
                  var imageDeclutterBox = void 0;

                  if (declutterImageWithText) {
                    var index = dd - d;

                    if (!declutterImageWithText[index]) {
                      // We now have the image for an image+text combination.
                      declutterImageWithText[index] = args; // Don't render anything for now, wait for the text.

                      continue;
                    }

                    imageArgs = declutterImageWithText[index];
                    delete declutterImageWithText[index];
                    imageDeclutterBox = getDeclutterBox(imageArgs);

                    if (declutterTree.collides(imageDeclutterBox)) {
                      continue;
                    }
                  }

                  if (declutterTree.collides(dimensions.declutterBox)) {
                    continue;
                  }

                  if (imageArgs) {
                    // We now have image and text for an image+text combination.
                    declutterTree.insert(imageDeclutterBox); // Render the image before we render the text.

                    this.replayImageOrLabel_.apply(this, imageArgs);
                  }

                  declutterTree.insert(dimensions.declutterBox);
                }
              }

              this.replayImageOrLabel_.apply(this, args);
            }

            ++i;
            break;

          case canvas_Instruction.DRAW_CHARS:
            var begin =
            /** @type {number} */
            instruction[1];
            var end =
            /** @type {number} */
            instruction[2];
            var baseline =
            /** @type {number} */
            instruction[3];
            var overflow =
            /** @type {number} */
            instruction[4];
            fillKey =
            /** @type {string} */
            instruction[5];
            var maxAngle =
            /** @type {number} */
            instruction[6];
            var measurePixelRatio =
            /** @type {number} */
            instruction[7];
            var offsetY =
            /** @type {number} */
            instruction[8];
            strokeKey =
            /** @type {string} */
            instruction[9];
            var strokeWidth =
            /** @type {number} */
            instruction[10];
            text =
            /** @type {string} */
            instruction[11];
            textKey =
            /** @type {string} */
            instruction[12];
            var pixelRatioScale = [
            /** @type {number} */
            instruction[13],
            /** @type {number} */
            instruction[13]];
            var textState = this.textStates[textKey];
            var font = textState.font;
            var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];
            var cachedWidths = void 0;

            if (font in this.widths_) {
              cachedWidths = this.widths_[font];
            } else {
              cachedWidths = {};
              this.widths_[font] = cachedWidths;
            }

            var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
            var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);

            if (overflow || textLength <= pathLength) {
              var textAlign = this.textStates[textKey].textAlign;
              var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
              var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);

              drawChars: if (parts) {
                /** @type {Array<ReplayImageOrLabelArgs>} */
                var replayImageOrLabelArgs = [];
                var c = void 0,
                    cc = void 0,
                    chars = void 0,
                    label = void 0,
                    part = void 0;

                if (strokeKey) {
                  for (c = 0, cc = parts.length; c < cc; ++c) {
                    part = parts[c]; // x, y, anchorX, rotation, chunk

                    chars =
                    /** @type {string} */
                    part[4];
                    label = this.createLabel(chars, textKey, '', strokeKey);
                    anchorX =
                    /** @type {number} */
                    part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                    anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;

                    var _dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);

                    if (declutterTree && declutterTree.collides(_dimensions.declutterBox)) {
                      break drawChars;
                    }

                    replayImageOrLabelArgs.push([context, contextScale, label, _dimensions, 1, null, null]);
                  }
                }

                if (fillKey) {
                  for (c = 0, cc = parts.length; c < cc; ++c) {
                    part = parts[c]; // x, y, anchorX, rotation, chunk

                    chars =
                    /** @type {string} */
                    part[4];
                    label = this.createLabel(chars, textKey, fillKey, '');
                    anchorX =
                    /** @type {number} */
                    part[2];
                    anchorY = baseline * label.height - offsetY;

                    var _dimensions2 = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);

                    if (declutterTree && declutterTree.collides(_dimensions2.declutterBox)) {
                      break drawChars;
                    }

                    replayImageOrLabelArgs.push([context, contextScale, label, _dimensions2, 1, null, null]);
                  }
                }

                if (declutterTree) {
                  declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                }

                for (var _i = 0, _ii = replayImageOrLabelArgs.length; _i < _ii; ++_i) {
                  this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[_i]);
                }
              }
            }

            ++i;
            break;

          case canvas_Instruction.END_GEOMETRY:
            if (featureCallback !== undefined) {
              feature =
              /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              var result = featureCallback(feature, currentGeometry);

              if (result) {
                return result;
              }
            }

            ++i;
            break;

          case canvas_Instruction.FILL:
            if (batchSize) {
              pendingFill++;
            } else {
              this.fill_(context);
            }

            ++i;
            break;

          case canvas_Instruction.MOVE_TO_LINE_TO:
            d =
            /** @type {number} */
            instruction[1];
            dd =
            /** @type {number} */
            instruction[2];
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;

            if (roundX !== prevX || roundY !== prevY) {
              context.moveTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }

            for (d += 2; d < dd; d += 2) {
              x = pixelCoordinates[d];
              y = pixelCoordinates[d + 1];
              roundX = x + 0.5 | 0;
              roundY = y + 0.5 | 0;

              if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                context.lineTo(x, y);
                prevX = roundX;
                prevY = roundY;
              }
            }

            ++i;
            break;

          case canvas_Instruction.SET_FILL_STYLE:
            lastFillInstruction = instruction;
            this.alignFill_ = instruction[2];

            if (pendingFill) {
              this.fill_(context);
              pendingFill = 0;

              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
            }

            context.fillStyle =
            /** @type {import("../../colorlike.js").ColorLike} */
            instruction[1];
            ++i;
            break;

          case canvas_Instruction.SET_STROKE_STYLE:
            lastStrokeInstruction = instruction;

            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }

            this.setStrokeStyle_(context,
            /** @type {Array<*>} */
            instruction);
            ++i;
            break;

          case canvas_Instruction.STROKE:
            if (batchSize) {
              pendingStroke++;
            } else {
              context.stroke();
            }

            ++i;
            break;

          default:
            // consume the instruction anyway, to avoid an infinite loop
            ++i;
            break;
        }
      }

      if (pendingFill) {
        this.fill_(context);
      }

      if (pendingStroke) {
        context.stroke();
      }

      return undefined;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     */

  }, {
    key: "execute",
    value: function execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree) {
      this.viewRotation_ = viewRotation;
      this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */

  }, {
    key: "executeHitDetection",
    value: function executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {
      this.viewRotation_ = viewRotation;
      return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);
    }
  }]);

  return Executor;
}();

/* harmony default export */ var canvas_Executor = (Executor);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/ExecutorGroup.js




/**
 * @module ol/render/canvas/ExecutorGroup
 */







/**
 * @const
 * @type {Array<import("../canvas.js").BuilderType>}
 */

var ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];

var ExecutorGroup = /*#__PURE__*/function () {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {
    _classCallCheck(this, ExecutorGroup);

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {boolean}
     */

    this.overlaps_ = overlaps;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {number|undefined}
     */

    this.renderBuffer_ = renderBuffer;
    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Executor").default>>}
     */

    this.executorsByZIndex_ = {};
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    this.hitDetectionContext_ = null;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    this.hitDetectionTransform_ = create();
    this.createExecutors_(allInstructions);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */


  _createClass(ExecutorGroup, [{
    key: "clip",
    value: function clip(context, transform) {
      var flatClipCoords = this.getClipCoords(transform);
      context.beginPath();
      context.moveTo(flatClipCoords[0], flatClipCoords[1]);
      context.lineTo(flatClipCoords[2], flatClipCoords[3]);
      context.lineTo(flatClipCoords[4], flatClipCoords[5]);
      context.lineTo(flatClipCoords[6], flatClipCoords[7]);
      context.clip();
    }
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     */

  }, {
    key: "createExecutors_",
    value: function createExecutors_(allInstructions) {
      for (var zIndex in allInstructions) {
        var executors = this.executorsByZIndex_[zIndex];

        if (executors === undefined) {
          executors = {};
          this.executorsByZIndex_[zIndex] = executors;
        }

        var instructionByZindex = allInstructions[zIndex];

        for (var builderType in instructionByZindex) {
          var instructions = instructionByZindex[builderType];
          executors[builderType] = new canvas_Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
        }
      }
    }
    /**
     * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */

  }, {
    key: "hasExecutors",
    value: function hasExecutors(executors) {
      for (var zIndex in this.executorsByZIndex_) {
        var candidates = this.executorsByZIndex_[zIndex];

        for (var i = 0, ii = executors.length; i < ii; ++i) {
          if (executors[i] in candidates) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */

  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
      hitTolerance = Math.round(hitTolerance);
      var contextSize = hitTolerance * 2 + 1;
      var transform = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
      var newContext = !this.hitDetectionContext_;

      if (newContext) {
        this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
      }

      var context = this.hitDetectionContext_;

      if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
        context.canvas.width = contextSize;
        context.canvas.height = contextSize;
      } else if (!newContext) {
        context.clearRect(0, 0, contextSize, contextSize);
      }
      /**
       * @type {import("../../extent.js").Extent}
       */


      var hitExtent;

      if (this.renderBuffer_ !== undefined) {
        hitExtent = createEmpty();
        extendCoordinate(hitExtent, coordinate);
        buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
      }

      var indexes = getPixelIndexArray(hitTolerance);
      var builderType;
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @return {T|undefined} Callback result.
       */

      function featureCallback(feature, geometry) {
        var imageData = context.getImageData(0, 0, contextSize, contextSize).data;

        for (var _i = 0, ii = indexes.length; _i < ii; _i++) {
          if (imageData[indexes[_i]] > 0) {
            if (!declutteredFeatures || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {
              var idx = (indexes[_i] - 3) / 4;
              var x = hitTolerance - idx % contextSize;
              var y = hitTolerance - (idx / contextSize | 0);

              var _result = callback(feature, geometry, x * x + y * y);

              if (_result) {
                return _result;
              }
            }

            context.clearRect(0, 0, contextSize, contextSize);
            break;
          }
        }

        return undefined;
      }
      /** @type {Array<number>} */


      var zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(numberSafeCompareFunction);
      var i, j, executors, executor, result;

      for (i = zs.length - 1; i >= 0; --i) {
        var zIndexKey = zs[i].toString();
        executors = this.executorsByZIndex_[zIndexKey];

        for (j = ORDER.length - 1; j >= 0; --j) {
          builderType = ORDER[j];
          executor = executors[builderType];

          if (executor !== undefined) {
            result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);

            if (result) {
              return result;
            }
          }
        }
      }

      return undefined;
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>|null} Clip coordinates.
     */

  }, {
    key: "getClipCoords",
    value: function getClipCoords(transform) {
      var maxExtent = this.maxExtent_;

      if (!maxExtent) {
        return null;
      }

      var minX = maxExtent[0];
      var minY = maxExtent[1];
      var maxX = maxExtent[2];
      var maxY = maxExtent[3];
      var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
      transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
      return flatClipCoords;
    }
    /**
     * @return {boolean} Is empty.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return obj_isEmpty(this.executorsByZIndex_);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ORDER}
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     */

  }, {
    key: "execute",
    value: function execute(context, contextScale, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {
      /** @type {Array<number>} */
      var zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not
      // visible outside the current extent when panning

      if (this.maxExtent_) {
        context.save();
        this.clip(context, transform);
      }

      builderTypes = builderTypes ? builderTypes : ORDER;
      var i, ii, j, jj, replays, replay;

      if (declutterTree) {
        zs.reverse();
      }

      for (i = 0, ii = zs.length; i < ii; ++i) {
        var zIndexKey = zs[i].toString();
        replays = this.executorsByZIndex_[zIndexKey];

        for (j = 0, jj = builderTypes.length; j < jj; ++j) {
          var builderType = builderTypes[j];
          replay = replays[builderType];

          if (replay !== undefined) {
            replay.execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree);
          }
        }
      }

      if (this.maxExtent_) {
        context.restore();
      }
    }
  }]);

  return ExecutorGroup;
}();
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */


var circlePixelIndexArrayCache = {};
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */

function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== undefined) {
    return circlePixelIndexArrayCache[radius];
  }

  var size = radius * 2 + 1;
  var maxDistanceSq = radius * radius;
  var distances = new Array(maxDistanceSq + 1);

  for (var i = 0; i <= radius; ++i) {
    for (var j = 0; j <= radius; ++j) {
      var distanceSq = i * i + j * j;

      if (distanceSq > maxDistanceSq) {
        break;
      }

      var distance = distances[distanceSq];

      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }

      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);

      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }

      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);

        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }

  var pixelIndex = [];

  for (var _i2 = 0, ii = distances.length; _i2 < ii; ++_i2) {
    if (distances[_i2]) {
      pixelIndex.push.apply(pixelIndex, _toConsumableArray(distances[_i2]));
    }
  }

  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
/* harmony default export */ var canvas_ExecutorGroup = (ExecutorGroup);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Immediate.js





/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?








/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */

var CanvasImmediateRenderer = /*#__PURE__*/function (_VectorContext) {
  _inherits(CanvasImmediateRenderer, _VectorContext);

  var _super = createSuper_createSuper(CanvasImmediateRenderer);

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, squaredTolerance, userTransform) {
    var _this;

    _classCallCheck(this, CanvasImmediateRenderer);

    _this = _super.call(this);
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    _this.context_ = context;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.extent_ = extent;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.transform_ = transform;
    /**
     * @private
     * @type {number}
     */

    _this.viewRotation_ = viewRotation;
    /**
     * @private
     * @type {number}
     */

    _this.squaredTolerance_ = squaredTolerance;
    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */

    _this.userTransform_ = userTransform;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.contextFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.contextStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.contextTextState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.fillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.strokeState_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorY_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageHeight_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOpacity_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.imageRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.imageRotation_ = 0;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */

    _this.imageScale_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.imageWidth_ = 0;
    /**
     * @private
     * @type {string}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.textRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */

    _this.textScale_ = [0, 0];
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.textState_ = null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.pixelCoordinates_ = [];
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tmpLocalTransform_ = create();
    return _this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */


  _createClass(CanvasImmediateRenderer, [{
    key: "drawImages_",
    value: function drawImages_(flatCoordinates, offset, end, stride) {
      if (!this.image_) {
        return;
      }

      var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
      var context = this.context_;
      var localTransform = this.tmpLocalTransform_;
      var alpha = context.globalAlpha;

      if (this.imageOpacity_ != 1) {
        context.globalAlpha = alpha * this.imageOpacity_;
      }

      var rotation = this.imageRotation_;

      if (this.imageRotateWithView_) {
        rotation += this.viewRotation_;
      }

      for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
        var x = pixelCoordinates[i] - this.imageAnchorX_;
        var y = pixelCoordinates[i + 1] - this.imageAnchorY_;

        if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
          var centerX = x + this.imageAnchorX_;
          var centerY = y + this.imageAnchorY_;
          compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
          context.setTransform.apply(context, localTransform);
          context.translate(centerX, centerY);
          context.scale(this.imageScale_[0], this.imageScale_[1]);
          context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
          context.setTransform(1, 0, 0, 1, 0, 0);
        } else {
          context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
        }
      }

      if (this.imageOpacity_ != 1) {
        context.globalAlpha = alpha;
      }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */

  }, {
    key: "drawText_",
    value: function drawText_(flatCoordinates, offset, end, stride) {
      if (!this.textState_ || this.text_ === '') {
        return;
      }

      if (this.textFillState_) {
        this.setContextFillState_(this.textFillState_);
      }

      if (this.textStrokeState_) {
        this.setContextStrokeState_(this.textStrokeState_);
      }

      this.setContextTextState_(this.textState_);
      var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
      var context = this.context_;
      var rotation = this.textRotation_;

      if (this.textRotateWithView_) {
        rotation += this.viewRotation_;
      }

      for (; offset < end; offset += stride) {
        var x = pixelCoordinates[offset] + this.textOffsetX_;
        var y = pixelCoordinates[offset + 1] + this.textOffsetY_;

        if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
          context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
          context.rotate(rotation);
          context.translate(this.textOffsetX_, this.textOffsetY_);
          context.scale(this.textScale_[0], this.textScale_[1]);

          if (this.textStrokeState_) {
            context.strokeText(this.text_, 0, 0);
          }

          if (this.textFillState_) {
            context.fillText(this.text_, 0, 0);
          }

          context.setTransform(1, 0, 0, 1, 0, 0);
        } else {
          if (this.textStrokeState_) {
            context.strokeText(this.text_, x, y);
          }

          if (this.textFillState_) {
            context.fillText(this.text_, x, y);
          }
        }
      }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */

  }, {
    key: "moveToLineTo_",
    value: function moveToLineTo_(flatCoordinates, offset, end, stride, close) {
      var context = this.context_;
      var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
      context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
      var length = pixelCoordinates.length;

      if (close) {
        length -= 2;
      }

      for (var i = 2; i < length; i += 2) {
        context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
      }

      if (close) {
        context.closePath();
      }

      return end;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */

  }, {
    key: "drawRings_",
    value: function drawRings_(flatCoordinates, offset, ends, stride) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
      }

      return offset;
    }
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     */

  }, {
    key: "drawCircle",
    value: function drawCircle(geometry) {
      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }

      if (this.fillState_ || this.strokeState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }

        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }

        var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
        var dx = pixelCoordinates[2] - pixelCoordinates[0];
        var dy = pixelCoordinates[3] - pixelCoordinates[1];
        var radius = Math.sqrt(dx * dx + dy * dy);
        var context = this.context_;
        context.beginPath();
        context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);

        if (this.fillState_) {
          context.fill();
        }

        if (this.strokeState_) {
          context.stroke();
        }
      }

      if (this.text_ !== '') {
        this.drawText_(geometry.getCenter(), 0, 2, 2);
      }
    }
    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.setFillStrokeStyle(style.getFill(), style.getStroke());
      this.setImageStyle(style.getImage());
      this.setTextStyle(style.getText());
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */

  }, {
    key: "setTransform",
    value: function setTransform(transform) {
      this.transform_ = transform;
    }
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     */

  }, {
    key: "drawGeometry",
    value: function drawGeometry(geometry) {
      var type = geometry.getType();

      switch (type) {
        case 'Point':
          this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          geometry);
          break;

        case 'LineString':
          this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          geometry);
          break;

        case 'Polygon':
          this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          geometry);
          break;

        case 'MultiPoint':
          this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          geometry);
          break;

        case 'MultiLineString':
          this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          geometry);
          break;

        case 'MultiPolygon':
          this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry);
          break;

        case 'GeometryCollection':
          this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry);
          break;

        case 'Circle':
          this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          geometry);
          break;

        default:
      }
    }
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     */

  }, {
    key: "drawFeature",
    value: function drawFeature(feature, style) {
      var geometry = style.getGeometryFunction()(feature);

      if (!geometry || !intersects(this.extent_, geometry.getExtent())) {
        return;
      }

      this.setStyle(style);
      this.drawGeometry(geometry);
    }
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     */

  }, {
    key: "drawGeometryCollection",
    value: function drawGeometryCollection(geometry) {
      var geometries = geometry.getGeometriesArray();

      for (var i = 0, ii = geometries.length; i < ii; ++i) {
        this.drawGeometry(geometries[i]);
      }
    }
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     */

  }, {
    key: "drawPoint",
    value: function drawPoint(geometry) {
      if (this.squaredTolerance_) {
        geometry =
        /** @type {import("../../geom/Point.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }

      var flatCoordinates = geometry.getFlatCoordinates();
      var stride = geometry.getStride();

      if (this.image_) {
        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
      }

      if (this.text_ !== '') {
        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
    }
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     */

  }, {
    key: "drawMultiPoint",
    value: function drawMultiPoint(geometry) {
      if (this.squaredTolerance_) {
        geometry =
        /** @type {import("../../geom/MultiPoint.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }

      var flatCoordinates = geometry.getFlatCoordinates();
      var stride = geometry.getStride();

      if (this.image_) {
        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
      }

      if (this.text_ !== '') {
        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
    }
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     */

  }, {
    key: "drawLineString",
    value: function drawLineString(geometry) {
      if (this.squaredTolerance_) {
        geometry =
        /** @type {import("../../geom/LineString.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }

      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        var context = this.context_;
        var flatCoordinates = geometry.getFlatCoordinates();
        context.beginPath();
        this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
        context.stroke();
      }

      if (this.text_ !== '') {
        var flatMidpoint = geometry.getFlatMidpoint();
        this.drawText_(flatMidpoint, 0, 2, 2);
      }
    }
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     */

  }, {
    key: "drawMultiLineString",
    value: function drawMultiLineString(geometry) {
      if (this.squaredTolerance_) {
        geometry =
        /** @type {import("../../geom/MultiLineString.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }

      var geometryExtent = geometry.getExtent();

      if (!intersects(this.extent_, geometryExtent)) {
        return;
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        var context = this.context_;
        var flatCoordinates = geometry.getFlatCoordinates();
        var offset = 0;
        var ends =
        /** @type {Array<number>} */
        geometry.getEnds();
        var stride = geometry.getStride();
        context.beginPath();

        for (var i = 0, ii = ends.length; i < ii; ++i) {
          offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
        }

        context.stroke();
      }

      if (this.text_ !== '') {
        var flatMidpoints = geometry.getFlatMidpoints();
        this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
      }
    }
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     */

  }, {
    key: "drawPolygon",
    value: function drawPolygon(geometry) {
      if (this.squaredTolerance_) {
        geometry =
        /** @type {import("../../geom/Polygon.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }

      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }

      if (this.strokeState_ || this.fillState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }

        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }

        var context = this.context_;
        context.beginPath();
        this.drawRings_(geometry.getOrientedFlatCoordinates(), 0,
        /** @type {Array<number>} */
        geometry.getEnds(), geometry.getStride());

        if (this.fillState_) {
          context.fill();
        }

        if (this.strokeState_) {
          context.stroke();
        }
      }

      if (this.text_ !== '') {
        var flatInteriorPoint = geometry.getFlatInteriorPoint();
        this.drawText_(flatInteriorPoint, 0, 2, 2);
      }
    }
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     */

  }, {
    key: "drawMultiPolygon",
    value: function drawMultiPolygon(geometry) {
      if (this.squaredTolerance_) {
        geometry =
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
      }

      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }

      if (this.strokeState_ || this.fillState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }

        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }

        var context = this.context_;
        var flatCoordinates = geometry.getOrientedFlatCoordinates();
        var offset = 0;
        var endss = geometry.getEndss();
        var stride = geometry.getStride();
        context.beginPath();

        for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          offset = this.drawRings_(flatCoordinates, offset, ends, stride);
        }

        if (this.fillState_) {
          context.fill();
        }

        if (this.strokeState_) {
          context.stroke();
        }
      }

      if (this.text_ !== '') {
        var flatInteriorPoints = geometry.getFlatInteriorPoints();
        this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
      }
    }
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */

  }, {
    key: "setContextFillState_",
    value: function setContextFillState_(fillState) {
      var context = this.context_;
      var contextFillState = this.contextFillState_;

      if (!contextFillState) {
        context.fillStyle = fillState.fillStyle;
        this.contextFillState_ = {
          fillStyle: fillState.fillStyle
        };
      } else {
        if (contextFillState.fillStyle != fillState.fillStyle) {
          contextFillState.fillStyle = fillState.fillStyle;
          context.fillStyle = fillState.fillStyle;
        }
      }
    }
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */

  }, {
    key: "setContextStrokeState_",
    value: function setContextStrokeState_(strokeState) {
      var context = this.context_;
      var contextStrokeState = this.contextStrokeState_;

      if (!contextStrokeState) {
        context.lineCap = strokeState.lineCap;
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
        context.lineJoin = strokeState.lineJoin;
        context.lineWidth = strokeState.lineWidth;
        context.miterLimit = strokeState.miterLimit;
        context.strokeStyle = strokeState.strokeStyle;
        this.contextStrokeState_ = {
          lineCap: strokeState.lineCap,
          lineDash: strokeState.lineDash,
          lineDashOffset: strokeState.lineDashOffset,
          lineJoin: strokeState.lineJoin,
          lineWidth: strokeState.lineWidth,
          miterLimit: strokeState.miterLimit,
          strokeStyle: strokeState.strokeStyle
        };
      } else {
        if (contextStrokeState.lineCap != strokeState.lineCap) {
          contextStrokeState.lineCap = strokeState.lineCap;
          context.lineCap = strokeState.lineCap;
        }

        if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }

        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
          context.lineDashOffset = strokeState.lineDashOffset;
        }

        if (contextStrokeState.lineJoin != strokeState.lineJoin) {
          contextStrokeState.lineJoin = strokeState.lineJoin;
          context.lineJoin = strokeState.lineJoin;
        }

        if (contextStrokeState.lineWidth != strokeState.lineWidth) {
          contextStrokeState.lineWidth = strokeState.lineWidth;
          context.lineWidth = strokeState.lineWidth;
        }

        if (contextStrokeState.miterLimit != strokeState.miterLimit) {
          contextStrokeState.miterLimit = strokeState.miterLimit;
          context.miterLimit = strokeState.miterLimit;
        }

        if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
          contextStrokeState.strokeStyle = strokeState.strokeStyle;
          context.strokeStyle = strokeState.strokeStyle;
        }
      }
    }
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */

  }, {
    key: "setContextTextState_",
    value: function setContextTextState_(textState) {
      var context = this.context_;
      var contextTextState = this.contextTextState_;
      var textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;

      if (!contextTextState) {
        context.font = textState.font;
        context.textAlign = textAlign;
        context.textBaseline = textState.textBaseline;
        this.contextTextState_ = {
          font: textState.font,
          textAlign: textAlign,
          textBaseline: textState.textBaseline
        };
      } else {
        if (contextTextState.font != textState.font) {
          contextTextState.font = textState.font;
          context.font = textState.font;
        }

        if (contextTextState.textAlign != textAlign) {
          contextTextState.textAlign = textAlign;
          context.textAlign = textAlign;
        }

        if (contextTextState.textBaseline != textState.textBaseline) {
          contextTextState.textBaseline = textState.textBaseline;
          context.textBaseline = textState.textBaseline;
        }
      }
    }
    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */

  }, {
    key: "setFillStrokeStyle",
    value: function setFillStrokeStyle(fillStyle, strokeStyle) {
      var _this2 = this;

      if (!fillStyle) {
        this.fillState_ = null;
      } else {
        var fillStyleColor = fillStyle.getColor();
        this.fillState_ = {
          fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)
        };
      }

      if (!strokeStyle) {
        this.strokeState_ = null;
      } else {
        var strokeStyleColor = strokeStyle.getColor();
        var strokeStyleLineCap = strokeStyle.getLineCap();
        var strokeStyleLineDash = strokeStyle.getLineDash();
        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
        var strokeStyleLineJoin = strokeStyle.getLineJoin();
        var strokeStyleWidth = strokeStyle.getWidth();
        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        var lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
        this.strokeState_ = {
          lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap,
          lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function (n) {
            return n * _this2.pixelRatio_;
          }),
          lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
          lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin,
          lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
          miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit,
          strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)
        };
      }
    }
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     */

  }, {
    key: "setImageStyle",
    value: function setImageStyle(imageStyle) {
      var imageSize;

      if (!imageStyle || !(imageSize = imageStyle.getSize())) {
        this.image_ = null;
        return;
      }

      var imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
      var imageAnchor = imageStyle.getAnchor();
      var imageOrigin = imageStyle.getOrigin();
      this.image_ = imageStyle.getImage(this.pixelRatio_);
      this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
      this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
      this.imageHeight_ = imageSize[1] * imagePixelRatio;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      var imageScale = imageStyle.getScaleArray();
      this.imageScale_ = [imageScale[0] * this.pixelRatio_ / imagePixelRatio, imageScale[1] * this.pixelRatio_ / imagePixelRatio];
      this.imageWidth_ = imageSize[0] * imagePixelRatio;
    }
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     */

  }, {
    key: "setTextStyle",
    value: function setTextStyle(textStyle) {
      if (!textStyle) {
        this.text_ = '';
      } else {
        var textFillStyle = textStyle.getFill();

        if (!textFillStyle) {
          this.textFillState_ = null;
        } else {
          var textFillStyleColor = textFillStyle.getColor();
          this.textFillState_ = {
            fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)
          };
        }

        var textStrokeStyle = textStyle.getStroke();

        if (!textStrokeStyle) {
          this.textStrokeState_ = null;
        } else {
          var textStrokeStyleColor = textStrokeStyle.getColor();
          var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
          var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
          var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
          var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
          var textStrokeStyleWidth = textStrokeStyle.getWidth();
          var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
          this.textStrokeState_ = {
            lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : defaultLineCap,
            lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
            lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
            lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : defaultLineJoin,
            lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : defaultLineWidth,
            miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : defaultMiterLimit,
            strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)
          };
        }

        var textFont = textStyle.getFont();
        var textOffsetX = textStyle.getOffsetX();
        var textOffsetY = textStyle.getOffsetY();
        var textRotateWithView = textStyle.getRotateWithView();
        var textRotation = textStyle.getRotation();
        var textScale = textStyle.getScaleArray();
        var textText = textStyle.getText();
        var textTextAlign = textStyle.getTextAlign();
        var textTextBaseline = textStyle.getTextBaseline();
        this.textState_ = {
          font: textFont !== undefined ? textFont : defaultFont,
          textAlign: textTextAlign !== undefined ? textTextAlign : defaultTextAlign,
          textBaseline: textTextBaseline !== undefined ? textTextBaseline : defaultTextBaseline
        };
        this.text_ = textText !== undefined ? Array.isArray(textText) ? textText.reduce(function (acc, t, i) {
          return acc += i % 2 ? ' ' : t;
        }, '') : textText : '';
        this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
        this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
        this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
        this.textRotation_ = textRotation !== undefined ? textRotation : 0;
        this.textScale_ = [this.pixelRatio_ * textScale[0], this.pixelRatio_ * textScale[1]];
      }
    }
  }]);

  return CanvasImmediateRenderer;
}(render_VectorContext);

/* harmony default export */ var Immediate = (CanvasImmediateRenderer);
;// CONCATENATED MODULE: ./node_modules/ol/render/canvas/hitdetect.js
/**
 * @module ol/render/canvas/hitdetect
 */






var HIT_DETECT_RESOLUTION = 0.5;
/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */

function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
  var width = size[0] * HIT_DETECT_RESOLUTION;
  var height = size[1] * HIT_DETECT_RESOLUTION;
  var context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  var canvas = context.canvas;
  var renderer = new Immediate(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
  var featureCount = features.length; // Stretch hit detection index to use the whole available color range

  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  var featuresByZIndex = {};

  for (var i = 1; i <= featureCount; ++i) {
    var feature = features[i - 1];
    var featureStyleFunction = feature.getStyleFunction() || styleFunction;

    if (!styleFunction) {
      continue;
    }

    var styles = featureStyleFunction(feature, resolution);

    if (!styles) {
      continue;
    }

    if (!Array.isArray(styles)) {
      styles = [styles];
    }

    var index = i * indexFactor;
    var color = '#' + ('000000' + index.toString(16)).slice(-6);

    for (var j = 0, jj = styles.length; j < jj; ++j) {
      var originalStyle = styles[j];
      var geometry = originalStyle.getGeometryFunction()(feature);

      if (!geometry || !intersects(extent, geometry.getExtent())) {
        continue;
      }

      var style = originalStyle.clone();
      var fill = style.getFill();

      if (fill) {
        fill.setColor(color);
      }

      var stroke = style.getStroke();

      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }

      style.setText(undefined);
      var image = originalStyle.getImage();

      if (image && image.getOpacity() !== 0) {
        var imgSize = image.getImageSize();

        if (!imgSize) {
          continue;
        }

        var imgContext = createCanvasContext2D(imgSize[0], imgSize[1], undefined, {
          alpha: false
        });
        var img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(new style_Icon({
          img: img,
          imgSize: imgSize,
          anchor: image.getAnchor(),
          anchorXUnits: 'pixels',
          anchorYUnits: 'pixels',
          offset: image.getOrigin(),
          opacity: 1,
          size: image.getSize(),
          scale: image.getScale(),
          rotation: image.getRotation(),
          rotateWithView: image.getRotateWithView()
        }));
      }

      var zIndex = style.getZIndex() || 0;
      var byGeometryType = featuresByZIndex[zIndex];

      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType['Polygon'] = [];
        byGeometryType['Circle'] = [];
        byGeometryType['LineString'] = [];
        byGeometryType['Point'] = [];
      }

      byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
    }
  }

  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(numberSafeCompareFunction);

  for (var _i = 0, ii = zIndexKeys.length; _i < ii; ++_i) {
    var _byGeometryType = featuresByZIndex[zIndexKeys[_i]];

    for (var type in _byGeometryType) {
      var geomAndStyle = _byGeometryType[type];

      for (var _j = 0, _jj = geomAndStyle.length; _j < _jj; _j += 2) {
        renderer.setStyle(geomAndStyle[_j + 1]);

        for (var k = 0, kk = transforms.length; k < kk; ++k) {
          renderer.setTransform(transforms[k]);
          renderer.drawGeometry(geomAndStyle[_j]);
        }
      }
    }
  }

  return context.getImageData(0, 0, canvas.width, canvas.height);
}
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<import("../../Feature").FeatureLike>} features Features.
 */

function hitDetect(pixel, features, imageData) {
  var resultFeatures = [];

  if (imageData) {
    var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION); // The pixel coordinate is clamped down to the hit-detect canvas' size to account
    // for browsers returning coordinates slightly larger than the actual canvas size
    // due to a non-integer pixel ratio.

    var index = (math_clamp(x, 0, imageData.width - 1) + math_clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
    var r = imageData.data[index];
    var g = imageData.data[index + 1];
    var b = imageData.data[index + 2];
    var i = b + 256 * (g + 256 * r);
    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);

    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }

  return resultFeatures;
}
;// CONCATENATED MODULE: ./node_modules/ol/renderer/vector.js
/**
 * @module ol/renderer/vector
 */


/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */

var SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */

var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */

function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */

function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */

function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */

function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */


function vector_renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform, declutterBuilderGroup) {
  var loading = false;
  var imageStyle = style.getImage();

  if (imageStyle) {
    var imageState = imageStyle.getImageState();

    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == ImageState.IDLE) {
        imageStyle.load();
      }

      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }

  renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup);
  return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */

function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry) {
    return;
  }

  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, transform);
  var renderer = style.getRenderer();

  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature, declutterBuilderGroup);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == 'GeometryCollection') {
    var geometries =
    /** @type {import("../geom/GeometryCollection.js").default} */
    geometry.getGeometries();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }

    return;
  }

  var replay = replayGroup.getBuilder(style.getZIndex(), 'Default');
  replay.drawCustom(
  /** @type {import("../geom/SimpleGeometry.js").default} */
  geometry, feature, style.getRenderer(), style.getHitDetectionRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */


function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature, declutterBuilderGroup);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */


function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */


function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */


function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (strokeStyle || fillStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */


function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */

  var declutterImageWithText;

  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }

    var imageBuilderGroup = builderGroup;

    if (declutterBuilderGroup) {
      var declutterMode = imageStyle.getDeclutterMode();

      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;

        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          var _imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');

          _imageReplay.setImageStyle(imageStyle, declutterImageWithText);

          _imageReplay.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }

    var imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }

  if (textStyle && textStyle.getText()) {
    var textBuilderGroup = builderGroup;

    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }

    var textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */


function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */

  var declutterImageWithText;

  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }

    var imageBuilderGroup = builderGroup;

    if (declutterBuilderGroup) {
      var declutterMode = imageStyle.getDeclutterMode();

      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;

        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          var _imageReplay2 = builderGroup.getBuilder(style.getZIndex(), 'Image');

          _imageReplay2.setImageStyle(imageStyle, declutterImageWithText);

          _imageReplay2.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }

    var imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }

  if (textStyle && textStyle.getText()) {
    var textBuilderGroup = builderGroup;

    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }

    var textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */


function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/VectorLayer.js






/**
 * @module ol/renderer/canvas/VectorLayer
 */













/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */

var CanvasVectorLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {
  _inherits(CanvasVectorLayerRenderer, _CanvasLayerRenderer);

  var _super = createSuper_createSuper(CanvasVectorLayerRenderer);

  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  function CanvasVectorLayerRenderer(vectorLayer) {
    var _this;

    _classCallCheck(this, CanvasVectorLayerRenderer);

    _this = _super.call(this, vectorLayer);
    /** @private */

    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(assertThisInitialized_assertThisInitialized(_this));
    /**
     * @type {boolean}
     */

    _this.animatingOrInteracting_;
    /**
     * @type {ImageData}
     */

    _this.hitDetectionImageData_ = null;
    /**
     * @type {Array<import("../../Feature.js").default>}
     */

    _this.renderedFeatures_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.renderedResolution_ = NaN;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = createEmpty();
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.wrappedRenderedExtent_ = createEmpty();
    /**
     * @private
     * @type {number}
     */

    _this.renderedRotation_;
    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */

    _this.renderedCenter_ = null;
    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */

    _this.renderedProjection_ = null;
    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */

    _this.renderedRenderOrder_ = null;
    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */

    _this.replayGroup_ = null;
    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */

    _this.replayGroupChanged = true;
    /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */

    _this.declutterExecutorGroup = null;
    /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */

    _this.clipping = true;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    _this.compositionContext_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.opacity_ = 1;
    return _this;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */


  _createClass(CanvasVectorLayerRenderer, [{
    key: "renderWorlds",
    value: function renderWorlds(executorGroup, frameState, declutterTree) {
      var extent = frameState.extent;
      var viewState = frameState.viewState;
      var center = viewState.center;
      var resolution = viewState.resolution;
      var projection = viewState.projection;
      var rotation = viewState.rotation;
      var projectionExtent = projection.getExtent();
      var vectorSource = this.getLayer().getSource();
      var pixelRatio = frameState.pixelRatio;
      var viewHints = frameState.viewHints;
      var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
      var context = this.compositionContext_;
      var width = Math.round(frameState.size[0] * pixelRatio);
      var height = Math.round(frameState.size[1] * pixelRatio);
      var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
      var worldWidth = multiWorld ? getWidth(projectionExtent) : null;
      var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
      var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;

      do {
        var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
        executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, declutterTree);
      } while (++world < endWorld);
    }
  }, {
    key: "setupCompositionContext_",
    value: function setupCompositionContext_() {
      if (this.opacity_ !== 1) {
        var compositionContext = createCanvasContext2D(this.context.canvas.width, this.context.canvas.height, canvasPool);
        this.compositionContext_ = compositionContext;
      } else {
        this.compositionContext_ = this.context;
      }
    }
  }, {
    key: "releaseCompositionContext_",
    value: function releaseCompositionContext_() {
      if (this.opacity_ !== 1) {
        var alpha = this.context.globalAlpha;
        this.context.globalAlpha = this.opacity_;
        this.context.drawImage(this.compositionContext_.canvas, 0, 0);
        this.context.globalAlpha = alpha;
        releaseCanvas(this.compositionContext_);
        canvasPool.push(this.compositionContext_.canvas);
        this.compositionContext_ = null;
      }
    }
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */

  }, {
    key: "renderDeclutter",
    value: function renderDeclutter(frameState) {
      if (this.declutterExecutorGroup) {
        this.setupCompositionContext_();
        this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
        this.releaseCompositionContext_();
      }
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */

  }, {
    key: "renderFrame",
    value: function renderFrame(frameState, target) {
      var pixelRatio = frameState.pixelRatio;
      var layerState = frameState.layerStatesArray[frameState.layerIndex]; // set forward and inverse pixel transforms

      makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
      makeInverse(this.inversePixelTransform, this.pixelTransform);
      var canvasTransform = transform_toString(this.pixelTransform);
      this.useContainer(target, canvasTransform, this.getBackground(frameState));
      var context = this.context;
      var canvas = context.canvas;
      var replayGroup = this.replayGroup_;
      var declutterExecutorGroup = this.declutterExecutorGroup;

      if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
        return null;
      } // resize and clear


      var width = Math.round(frameState.size[0] * pixelRatio);
      var height = Math.round(frameState.size[1] * pixelRatio);

      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;

        if (canvas.style.transform !== canvasTransform) {
          canvas.style.transform = canvasTransform;
        }
      } else if (!this.containerReused) {
        context.clearRect(0, 0, width, height);
      }

      this.preRender(context, frameState);
      var viewState = frameState.viewState;
      var projection = viewState.projection;
      this.opacity_ = layerState.opacity;
      this.setupCompositionContext_(); // clipped rendering if layer extent is set

      var clipped = false;
      var render = true;

      if (layerState.extent && this.clipping) {
        var layerExtent = proj_fromUserExtent(layerState.extent, projection);
        render = intersects(layerExtent, frameState.extent);
        clipped = render && !containsExtent(layerExtent, frameState.extent);

        if (clipped) {
          this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
        }
      }

      if (render) {
        this.renderWorlds(replayGroup, frameState);
      }

      if (clipped) {
        this.compositionContext_.restore();
      }

      this.releaseCompositionContext_();
      this.postRender(context, frameState);

      if (this.renderedRotation_ !== viewState.rotation) {
        this.renderedRotation_ = viewState.rotation;
        this.hitDetectionImageData_ = null;
      }

      return this.container;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
     */

  }, {
    key: "getFeatures",
    value: function getFeatures(pixel) {
      return new Promise(
      /**
       * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
       * @this {CanvasVectorLayerRenderer}
       */
      function (resolve) {
        if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          var size = [this.context.canvas.width, this.context.canvas.height];
          apply(this.pixelTransform, size);
          var center = this.renderedCenter_;
          var resolution = this.renderedResolution_;
          var rotation = this.renderedRotation_;
          var projection = this.renderedProjection_;
          var extent = this.wrappedRenderedExtent_;
          var layer = this.getLayer();
          var transforms = [];
          var width = size[0] * HIT_DETECT_RESOLUTION;
          var height = size[1] * HIT_DETECT_RESOLUTION;
          transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());
          var source = layer.getSource();
          var projectionExtent = projection.getExtent();

          if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
            var startX = extent[0];
            var worldWidth = getWidth(projectionExtent);
            var world = 0;
            var offsetX;

            while (startX < projectionExtent[0]) {
              --world;
              offsetX = worldWidth * world;
              transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
              startX += worldWidth;
            }

            world = 0;
            startX = extent[2];

            while (startX > projectionExtent[2]) {
              ++world;
              offsetX = worldWidth * world;
              transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
              startX -= worldWidth;
            }
          }

          this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
        }

        resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
      }.bind(this));
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */

  }, {
    key: "forEachFeatureAtCoordinate",
    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      var _this2 = this;

      if (!this.replayGroup_) {
        return undefined;
      }

      var resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      var layer = this.getLayer();
      /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */

      var features = {};
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {number} distanceSq The squared distance to the click position
       * @return {T|undefined} Callback result.
       */

      var featureCallback = function featureCallback(feature, geometry, distanceSq) {
        var key = getUid(feature);
        var match = features[key];

        if (!match) {
          if (distanceSq === 0) {
            features[key] = true;
            return callback(feature, layer, geometry);
          }

          matches.push(features[key] = {
            feature: feature,
            layer: layer,
            geometry: geometry,
            distanceSq: distanceSq,
            callback: callback
          });
        } else if (match !== true && distanceSq < match.distanceSq) {
          if (distanceSq === 0) {
            features[key] = true;
            matches.splice(matches.lastIndexOf(match), 1);
            return callback(feature, layer, geometry);
          }

          match.geometry = geometry;
          match.distanceSq = distanceSq;
        }

        return undefined;
      };

      var result;
      var executorGroups = [this.replayGroup_];

      if (this.declutterExecutorGroup) {
        executorGroups.push(this.declutterExecutorGroup);
      }

      executorGroups.some(function (executorGroup) {
        return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this2.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map(function (item) {
          return item.value;
        }) : null);
      });
      return result;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     */

  }, {
    key: "handleFontsChanged",
    value: function handleFontsChanged() {
      var layer = this.getLayer();

      if (layer.getVisible() && this.replayGroup_) {
        layer.changed();
      }
    }
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */

  }, {
    key: "handleStyleImageChange_",
    value: function handleStyleImageChange_(event) {
      this.renderIfReadyAndVisible();
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */

  }, {
    key: "prepareFrame",
    value: function prepareFrame(frameState) {
      var vectorLayer = this.getLayer();
      var vectorSource = vectorLayer.getSource();

      if (!vectorSource) {
        return false;
      }

      var animating = frameState.viewHints[ViewHint.ANIMATING];
      var interacting = frameState.viewHints[ViewHint.INTERACTING];
      var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
      var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

      if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
        this.animatingOrInteracting_ = true;
        return true;
      }

      this.animatingOrInteracting_ = false;
      var frameStateExtent = frameState.extent;
      var viewState = frameState.viewState;
      var projection = viewState.projection;
      var resolution = viewState.resolution;
      var pixelRatio = frameState.pixelRatio;
      var vectorLayerRevision = vectorLayer.getRevision();
      var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
      var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

      if (vectorLayerRenderOrder === undefined) {
        vectorLayerRenderOrder = defaultOrder;
      }

      var center = viewState.center.slice();
      var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
      var renderedExtent = extent.slice();
      var loadExtents = [extent.slice()];
      var projectionExtent = projection.getExtent();

      if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
        // For the replay group, we need an extent that intersects the real world
        // (-180° to +180°). To support geometries in a coordinate range from -540°
        // to +540°, we add at least 1 world width on each side of the projection
        // extent. If the viewport is wider than the world, we need to add half of
        // the viewport width to make sure we cover the whole viewport.
        var worldWidth = getWidth(projectionExtent);
        var gutter = Math.max(getWidth(extent) / 2, worldWidth);
        extent[0] = projectionExtent[0] - gutter;
        extent[2] = projectionExtent[2] + gutter;
        coordinate_wrapX(center, projection);
        var loadExtent = wrapX(loadExtents[0], projection); // If the extent crosses the date line, we load data for both edges of the worlds

        if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
          loadExtents.push([loadExtent[0] + worldWidth, loadExtent[1], loadExtent[2] + worldWidth, loadExtent[3]]);
        } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
          loadExtents.push([loadExtent[0] - worldWidth, loadExtent[1], loadExtent[2] - worldWidth, loadExtent[3]]);
        }
      }

      if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
        if (!equals(this.renderedExtent_, renderedExtent)) {
          this.hitDetectionImageData_ = null;
          this.renderedExtent_ = renderedExtent;
        }

        this.renderedCenter_ = center;
        this.replayGroupChanged = false;
        return true;
      }

      this.replayGroup_ = null;
      var replayGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
      var declutterBuilderGroup;

      if (this.getLayer().getDeclutter()) {
        declutterBuilderGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
      }

      var userProjection = getUserProjection();
      var userTransform;

      if (userProjection) {
        for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
          var _extent = loadExtents[i];

          var _userExtent = proj_toUserExtent(_extent, projection);

          vectorSource.loadFeatures(_userExtent, toUserResolution(resolution, projection), userProjection);
        }

        userTransform = getTransformFromProjections(userProjection, projection);
      } else {
        for (var _i = 0, _ii = loadExtents.length; _i < _ii; ++_i) {
          vectorSource.loadFeatures(loadExtents[_i], resolution, projection);
        }
      }

      var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
      var ready = true;

      var render =
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @this {CanvasVectorLayerRenderer}
       */
      function (feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();

        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }

        if (styles) {
          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
          ready = ready && !dirty;
        }
      }.bind(this);

      var userExtent = proj_toUserExtent(extent, projection);
      /** @type {Array<import("../../Feature.js").default>} */

      var features = vectorSource.getFeaturesInExtent(userExtent);

      if (vectorLayerRenderOrder) {
        features.sort(vectorLayerRenderOrder);
      }

      for (var _i2 = 0, _ii2 = features.length; _i2 < _ii2; ++_i2) {
        render(features[_i2]);
      }

      this.renderedFeatures_ = features;
      this.ready = ready;
      var replayGroupInstructions = replayGroup.finish();
      var executorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());

      if (declutterBuilderGroup) {
        this.declutterExecutorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
      }

      this.renderedResolution_ = resolution;
      this.renderedRevision_ = vectorLayerRevision;
      this.renderedRenderOrder_ = vectorLayerRenderOrder;
      this.renderedExtent_ = renderedExtent;
      this.wrappedRenderedExtent_ = extent;
      this.renderedCenter_ = center;
      this.renderedProjection_ = projection;
      this.replayGroup_ = executorGroup;
      this.hitDetectionImageData_ = null;
      this.replayGroupChanged = true;
      return true;
    }
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
     * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
     * @return {boolean} `true` if an image is loading.
     */

  }, {
    key: "renderFeature",
    value: function renderFeature(feature, squaredTolerance, styles, builderGroup, transform, declutterBuilderGroup) {
      if (!styles) {
        return false;
      }

      var loading = false;

      if (Array.isArray(styles)) {
        for (var i = 0, ii = styles.length; i < ii; ++i) {
          loading = vector_renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup) || loading;
        }
      } else {
        loading = vector_renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup);
      }

      return loading;
    }
  }]);

  return CanvasVectorLayerRenderer;
}(canvas_Layer);

/* harmony default export */ var canvas_VectorLayer = (CanvasVectorLayerRenderer);
;// CONCATENATED MODULE: ./node_modules/ol/layer/Vector.js





/**
 * @module ol/layer/Vector
 */


/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */

var VectorLayer = /*#__PURE__*/function (_BaseVectorLayer) {
  _inherits(VectorLayer, _BaseVectorLayer);

  var _super = createSuper_createSuper(VectorLayer);

  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  function VectorLayer(options) {
    _classCallCheck(this, VectorLayer);

    return _super.call(this, options);
  }

  _createClass(VectorLayer, [{
    key: "createRenderer",
    value: function createRenderer() {
      return new canvas_VectorLayer(this);
    }
  }]);

  return VectorLayer;
}(BaseVector);

/* harmony default export */ var Vector = (VectorLayer);
;// CONCATENATED MODULE: ./node_modules/ol/Feature.js





/**
 * @module ol/Feature
 */




/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */

/***
 * @template Geometry
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */

var Feature = /*#__PURE__*/function (_BaseObject) {
  _inherits(Feature, _BaseObject);

  var _super = createSuper_createSuper(Feature);

  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  function Feature(geometryOrProperties) {
    var _this;

    _classCallCheck(this, Feature);

    _this = _super.call(this);
    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */

    _this.on;
    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {FeatureOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {number|string|undefined}
     */

    _this.id_ = undefined;
    /**
     * @type {string}
     * @private
     */

    _this.geometryName_ = 'geometry';
    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */

    _this.style_ = null;
    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */

    _this.styleFunction_ = undefined;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.geometryChangeKey_ = null;

    _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);

    if (geometryOrProperties) {
      if (typeof
      /** @type {?} */
      geometryOrProperties.getSimplifiedGeometry === 'function') {
        var geometry =
        /** @type {Geometry} */
        geometryOrProperties;

        _this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = geometryOrProperties;

        _this.setProperties(properties);
      }
    }

    return _this;
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */


  _createClass(Feature, [{
    key: "clone",
    value: function clone() {
      var clone =
      /** @type {Feature<Geometry>} */
      new Feature(this.hasProperties() ? this.getProperties() : null);
      clone.setGeometryName(this.getGeometryName());
      var geometry = this.getGeometry();

      if (geometry) {
        clone.setGeometry(
        /** @type {Geometry} */
        geometry.clone());
      }

      var style = this.getStyle();

      if (style) {
        clone.setStyle(style);
      }

      return clone;
    }
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */

  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return (
        /** @type {Geometry|undefined} */
        this.get(this.geometryName_)
      );
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */

  }, {
    key: "getId",
    value: function getId() {
      return this.id_;
    }
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */

  }, {
    key: "getGeometryName",
    value: function getGeometryName() {
      return this.geometryName_;
    }
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */

  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.style_;
    }
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */

  }, {
    key: "getStyleFunction",
    value: function getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @private
     */

  }, {
    key: "handleGeometryChange_",
    value: function handleGeometryChange_() {
      this.changed();
    }
    /**
     * @private
     */

  }, {
    key: "handleGeometryChanged_",
    value: function handleGeometryChanged_() {
      if (this.geometryChangeKey_) {
        unlistenByKey(this.geometryChangeKey_);
        this.geometryChangeKey_ = null;
      }

      var geometry = this.getGeometry();

      if (geometry) {
        this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
      }

      this.changed();
    }
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */

  }, {
    key: "setGeometry",
    value: function setGeometry(geometry) {
      this.set(this.geometryName_, geometry);
    }
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.style_ = style;
      this.styleFunction_ = !style ? undefined : createStyleFunction(style);
      this.changed();
    }
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */

  }, {
    key: "setId",
    value: function setId(id) {
      this.id_ = id;
      this.changed();
    }
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */

  }, {
    key: "setGeometryName",
    value: function setGeometryName(name) {
      this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
      this.geometryName_ = name;
      this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
      this.handleGeometryChanged_();
    }
  }]);

  return Feature;
}(ol_Object);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */


function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array<import("./style/Style.js").default>}
     */
    var styles;

    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      asserts_assert(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`

      var style =
      /** @type {import("./style/Style.js").default} */
      obj;
      styles = [style];
    }

    return function () {
      return styles;
    };
  }
}
/* harmony default export */ var ol_Feature = (Feature);
;// CONCATENATED MODULE: ./node_modules/ol/Overlay.js





/**
 * @module ol/Overlay
 */






/**
 * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning
 * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, or `'top-right'`.
 */

/**
 * @typedef {Object} Options
 * @property {number|string} [id] Set the overlay id. The overlay id can be used
 * with the {@link module:ol/Map~Map#getOverlayById} method.
 * @property {HTMLElement} [element] The overlay element.
 * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
 * the overlay. The first element in the
 * array is the horizontal offset. A positive value shifts the overlay right.
 * The second element in the array is the vertical offset. A positive value
 * shifts the overlay down.
 * @property {import("./coordinate.js").Coordinate} [position] The overlay position
 * in map projection.
 * @property {Positioning} [positioning='top-left'] Defines how
 * the overlay is actually positioned with respect to its `position` property.
 * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, and `'top-right'`.
 * @property {boolean} [stopEvent=true] Whether event propagation to the map
 * viewport should be stopped. If `true` the overlay is placed in the same
 * container as that of the controls (CSS class name
 * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
 * with CSS class name specified by the `className` property.
 * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
 * in the overlay container, or appended. If the overlay is placed in the same
 * container as that of the controls (see the `stopEvent` option) you will
 * probably set `insertFirst` to `true` so the overlay is displayed below the
 * controls.
 * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
 * `setPosition`, so that the overlay is entirely visible in the current viewport.
 * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
 * name.
 */

/**
 * @typedef {Object} PanOptions
 * @property {number} [duration=1000] The duration of the animation in
 * milliseconds.
 * @property {function(number):number} [easing] The easing function to use. Can
 * be one from {@link module:ol/easing} or a custom function.
 * Default is {@link module:ol/easing.inAndOut}.
 */

/**
 * @typedef {Object} PanIntoViewOptions
 * @property {PanOptions} [animation={}] The animation parameters for the pan
 * @property {number} [margin=20] The margin (in pixels) between the
 * overlay and the borders of the map when panning into view.
 */

/**
 * @enum {string}
 * @protected
 */

var Overlay_Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};
/**
 * @typedef {import("./ObjectEventType").Types|'change:element'|'change:map'|'change:offset'|'change:position'|
 *   'change:positioning'} OverlayObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<OverlayObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature
 */

/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:ol/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'ol/Overlay';
 *
 *     // ...
 *     const popup = new Overlay({
 *       element: document.getElementById('popup'),
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */

var Overlay = /*#__PURE__*/function (_BaseObject) {
  _inherits(Overlay, _BaseObject);

  var _super = createSuper_createSuper(Overlay);

  /**
   * @param {Options} options Overlay options.
   */
  function Overlay(options) {
    var _this;

    _classCallCheck(this, Overlay);

    _this = _super.call(this);
    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */

    _this.on;
    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {OverlayOnSignature<void>}
     */

    _this.un;
    /**
     * @protected
     * @type {Options}
     */

    _this.options = options;
    /**
     * @protected
     * @type {number|string|undefined}
     */

    _this.id = options.id;
    /**
     * @protected
     * @type {boolean}
     */

    _this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
    /**
     * @protected
     * @type {boolean}
     */

    _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
    /**
     * @protected
     * @type {HTMLElement}
     */

    _this.element = document.createElement('div');
    _this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + CLASS_SELECTABLE;
    _this.element.style.position = 'absolute';
    _this.element.style.pointerEvents = 'auto';
    /**
     * @protected
     * @type {PanIntoViewOptions|undefined}
     */

    _this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;
    /**
     * @protected
     * @type {{transform_: string,
     *         visible: boolean}}
     */

    _this.rendered = {
      transform_: '',
      visible: true
    };
    /**
     * @protected
     * @type {?import("./events.js").EventsKey}
     */

    _this.mapPostrenderListenerKey = null;

    _this.addChangeListener(Overlay_Property.ELEMENT, _this.handleElementChanged);

    _this.addChangeListener(Overlay_Property.MAP, _this.handleMapChanged);

    _this.addChangeListener(Overlay_Property.OFFSET, _this.handleOffsetChanged);

    _this.addChangeListener(Overlay_Property.POSITION, _this.handlePositionChanged);

    _this.addChangeListener(Overlay_Property.POSITIONING, _this.handlePositioningChanged);

    if (options.element !== undefined) {
      _this.setElement(options.element);
    }

    _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);

    _this.setPositioning(options.positioning || 'top-left');

    if (options.position !== undefined) {
      _this.setPosition(options.position);
    }

    return _this;
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */


  _createClass(Overlay, [{
    key: "getElement",
    value: function getElement() {
      return (
        /** @type {HTMLElement|undefined} */
        this.get(Overlay_Property.ELEMENT)
      );
    }
    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */

  }, {
    key: "getId",
    value: function getId() {
      return this.id;
    }
    /**
     * Get the map associated with this overlay.
     * @return {import("./Map.js").default|null} The map that the
     * overlay is part of.
     * @observable
     * @api
     */

  }, {
    key: "getMap",
    value: function getMap() {
      return (
        /** @type {import("./Map.js").default|null} */
        this.get(Overlay_Property.MAP) || null
      );
    }
    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */

  }, {
    key: "getOffset",
    value: function getOffset() {
      return (
        /** @type {Array<number>} */
        this.get(Overlay_Property.OFFSET)
      );
    }
    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(Overlay_Property.POSITION)
      );
    }
    /**
     * Get the current positioning of this overlay.
     * @return {Positioning} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */

  }, {
    key: "getPositioning",
    value: function getPositioning() {
      return (
        /** @type {Positioning} */
        this.get(Overlay_Property.POSITIONING)
      );
    }
    /**
     * @protected
     */

  }, {
    key: "handleElementChanged",
    value: function handleElementChanged() {
      removeChildren(this.element);
      var element = this.getElement();

      if (element) {
        this.element.appendChild(element);
      }
    }
    /**
     * @protected
     */

  }, {
    key: "handleMapChanged",
    value: function handleMapChanged() {
      if (this.mapPostrenderListenerKey) {
        removeNode(this.element);
        unlistenByKey(this.mapPostrenderListenerKey);
        this.mapPostrenderListenerKey = null;
      }

      var map = this.getMap();

      if (map) {
        this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);
        this.updatePixelPosition();
        var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();

        if (this.insertFirst) {
          container.insertBefore(this.element, container.childNodes[0] || null);
        } else {
          container.appendChild(this.element);
        }

        this.performAutoPan();
      }
    }
    /**
     * @protected
     */

  }, {
    key: "render",
    value: function render() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */

  }, {
    key: "handleOffsetChanged",
    value: function handleOffsetChanged() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */

  }, {
    key: "handlePositionChanged",
    value: function handlePositionChanged() {
      this.updatePixelPosition();
      this.performAutoPan();
    }
    /**
     * @protected
     */

  }, {
    key: "handlePositioningChanged",
    value: function handlePositioningChanged() {
      this.updatePixelPosition();
    }
    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */

  }, {
    key: "setElement",
    value: function setElement(element) {
      this.set(Overlay_Property.ELEMENT, element);
    }
    /**
     * Set the map to be associated with this overlay.
     * @param {import("./Map.js").default|null} map The map that the
     * overlay is part of. Pass `null` to just remove the overlay from the current map.
     * @observable
     * @api
     */

  }, {
    key: "setMap",
    value: function setMap(map) {
      this.set(Overlay_Property.MAP, map);
    }
    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */

  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      this.set(Overlay_Property.OFFSET, offset);
    }
    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this.set(Overlay_Property.POSITION, position);
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */

  }, {
    key: "performAutoPan",
    value: function performAutoPan() {
      if (this.autoPan) {
        this.panIntoView(this.autoPan);
      }
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
     * @api
     */

  }, {
    key: "panIntoView",
    value: function panIntoView(panIntoViewOptions) {
      var map = this.getMap();

      if (!map || !map.getTargetElement() || !this.get(Overlay_Property.POSITION)) {
        return;
      }

      var mapRect = this.getRect(map.getTargetElement(), map.getSize());
      var element = this.getElement();
      var overlayRect = this.getRect(element, [dom_outerWidth(element), dom_outerHeight(element)]);
      panIntoViewOptions = panIntoViewOptions || {};
      var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;

      if (!containsExtent(mapRect, overlayRect)) {
        // the overlay is not completely inside the viewport, so pan the map
        var offsetLeft = overlayRect[0] - mapRect[0];
        var offsetRight = mapRect[2] - overlayRect[2];
        var offsetTop = overlayRect[1] - mapRect[1];
        var offsetBottom = mapRect[3] - overlayRect[3];
        var delta = [0, 0];

        if (offsetLeft < 0) {
          // move map to the left
          delta[0] = offsetLeft - myMargin;
        } else if (offsetRight < 0) {
          // move map to the right
          delta[0] = Math.abs(offsetRight) + myMargin;
        }

        if (offsetTop < 0) {
          // move map up
          delta[1] = offsetTop - myMargin;
        } else if (offsetBottom < 0) {
          // move map down
          delta[1] = Math.abs(offsetBottom) + myMargin;
        }

        if (delta[0] !== 0 || delta[1] !== 0) {
          var center =
          /** @type {import("./coordinate.js").Coordinate} */
          map.getView().getCenterInternal();
          var centerPx = map.getPixelFromCoordinateInternal(center);

          if (!centerPx) {
            return;
          }

          var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
          var panOptions = panIntoViewOptions.animation || {};
          map.getView().animateInternal({
            center: map.getCoordinateFromPixelInternal(newCenterPx),
            duration: panOptions.duration,
            easing: panOptions.easing
          });
        }
      }
    }
    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */

  }, {
    key: "getRect",
    value: function getRect(element, size) {
      var box = element.getBoundingClientRect();
      var offsetX = box.left + window.pageXOffset;
      var offsetY = box.top + window.pageYOffset;
      return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
    }
    /**
     * Set the positioning for this overlay.
     * @param {Positioning} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */

  }, {
    key: "setPositioning",
    value: function setPositioning(positioning) {
      this.set(Overlay_Property.POSITIONING, positioning);
    }
    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */

  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      if (this.rendered.visible !== visible) {
        this.element.style.display = visible ? '' : 'none';
        this.rendered.visible = visible;
      }
    }
    /**
     * Update pixel position.
     * @protected
     */

  }, {
    key: "updatePixelPosition",
    value: function updatePixelPosition() {
      var map = this.getMap();
      var position = this.getPosition();

      if (!map || !map.isRendered() || !position) {
        this.setVisible(false);
        return;
      }

      var pixel = map.getPixelFromCoordinate(position);
      var mapSize = map.getSize();
      this.updateRenderedPosition(pixel, mapSize);
    }
    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */

  }, {
    key: "updateRenderedPosition",
    value: function updateRenderedPosition(pixel, mapSize) {
      var style = this.element.style;
      var offset = this.getOffset();
      var positioning = this.getPositioning();
      this.setVisible(true);
      var x = Math.round(pixel[0] + offset[0]) + 'px';
      var y = Math.round(pixel[1] + offset[1]) + 'px';
      var posX = '0%';
      var posY = '0%';

      if (positioning == 'bottom-right' || positioning == 'center-right' || positioning == 'top-right') {
        posX = '-100%';
      } else if (positioning == 'bottom-center' || positioning == 'center-center' || positioning == 'top-center') {
        posX = '-50%';
      }

      if (positioning == 'bottom-left' || positioning == 'bottom-center' || positioning == 'bottom-right') {
        posY = '-100%';
      } else if (positioning == 'center-left' || positioning == 'center-center' || positioning == 'center-right') {
        posY = '-50%';
      }

      var transform = "translate(".concat(posX, ", ").concat(posY, ") translate(").concat(x, ", ").concat(y, ")");

      if (this.rendered.transform_ != transform) {
        this.rendered.transform_ = transform;
        style.transform = transform;
      }
    }
    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      return this.options;
    }
  }]);

  return Overlay;
}(ol_Object);

/* harmony default export */ var ol_Overlay = (Overlay);
;// CONCATENATED MODULE: ./node_modules/ol/structs/RBush.js



/**
 * @module ol/structs/RBush
 */




/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */

var RBush = /*#__PURE__*/function () {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  function RBush(maxEntries) {
    _classCallCheck(this, RBush);

    /**
     * @private
     */
    this.rbush_ = new rbush_min(maxEntries);
    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */

    this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */


  _createClass(RBush, [{
    key: "insert",
    value: function insert(extent, value) {
      /** @type {Entry} */
      var item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value
      };
      this.rbush_.insert(item);
      this.items_[getUid(value)] = item;
    }
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */

  }, {
    key: "load",
    value: function load(extents, values) {
      var items = new Array(values.length);

      for (var i = 0, l = values.length; i < l; i++) {
        var extent = extents[i];
        var value = values[i];
        /** @type {Entry} */

        var item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value: value
        };
        items[i] = item;
        this.items_[getUid(value)] = item;
      }

      this.rbush_.load(items);
    }
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */

  }, {
    key: "remove",
    value: function remove(value) {
      var uid = getUid(value); // get the object in which the value was wrapped when adding to the
      // internal rbush. then use that object to do the removal.

      var item = this.items_[uid];
      delete this.items_[uid];
      return this.rbush_.remove(item) !== null;
    }
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */

  }, {
    key: "update",
    value: function update(extent, value) {
      var item = this.items_[getUid(value)];
      var bbox = [item.minX, item.minY, item.maxX, item.maxY];

      if (!extent_equals(bbox, extent)) {
        this.remove(value);
        this.insert(extent, value);
      }
    }
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */

  }, {
    key: "getAll",
    value: function getAll() {
      var items = this.rbush_.all();
      return items.map(function (item) {
        return item.value;
      });
    }
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */

  }, {
    key: "getInExtent",
    value: function getInExtent(extent) {
      /** @type {Entry} */
      var bbox = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3]
      };
      var items = this.rbush_.search(bbox);
      return items.map(function (item) {
        return item.value;
      });
    }
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */

  }, {
    key: "forEach",
    value: function forEach(callback) {
      return this.forEach_(this.getAll(), callback);
    }
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */

  }, {
    key: "forEachInExtent",
    value: function forEachInExtent(extent, callback) {
      return this.forEach_(this.getInExtent(extent), callback);
    }
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): *} callback Callback.
     * @private
     * @return {*} Callback return value.
     */

  }, {
    key: "forEach_",
    value: function forEach_(values, callback) {
      var result;

      for (var i = 0, l = values.length; i < l; i++) {
        result = callback(values[i]);

        if (result) {
          return result;
        }
      }

      return result;
    }
    /**
     * @return {boolean} Is empty.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return obj_isEmpty(this.items_);
    }
    /**
     * Remove all values from the RBush.
     */

  }, {
    key: "clear",
    value: function clear() {
      this.rbush_.clear();
      this.items_ = {};
    }
    /**
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */

  }, {
    key: "getExtent",
    value: function getExtent(extent) {
      var data = this.rbush_.toJSON();
      return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
    }
    /**
     * @param {RBush} rbush R-Tree.
     */

  }, {
    key: "concat",
    value: function concat(rbush) {
      this.rbush_.load(rbush.rbush_.all());

      for (var i in rbush.items_) {
        this.items_[i] = rbush.items_[i];
      }
    }
  }]);

  return RBush;
}();

/* harmony default export */ var structs_RBush = (RBush);
;// CONCATENATED MODULE: ./node_modules/ol/source/Source.js






/**
 * @module ol/source/Source
 */



/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */

/**
 * A function that takes a {@link module:ol/Map~FrameState} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../Map.js").FrameState): (string|Array<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */

var Source = /*#__PURE__*/function (_BaseObject) {
  _inherits(Source, _BaseObject);

  var _super = createSuper_createSuper(Source);

  /**
   * @param {Options} options Source options.
   */
  function Source(options) {
    var _this;

    _classCallCheck(this, Source);

    _this = _super.call(this);
    /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */

    _this.projection = proj_get(options.projection);
    /**
     * @private
     * @type {?Attribution}
     */

    _this.attributions_ = adaptAttributions(options.attributions);
    /**
     * @private
     * @type {boolean}
     */

    _this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */

    _this.loading = false;
    /**
     * @private
     * @type {import("./Source.js").State}
     */

    _this.state_ = options.state !== undefined ? options.state : 'ready';
    /**
     * @private
     * @type {boolean}
     */

    _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
    /**
     * @private
     * @type {boolean}
     */

    _this.interpolate_ = !!options.interpolate;
    /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */

    _this.viewResolver = null;
    /**
     * @protected
     * @type {function(Error):void}
     */

    _this.viewRejector = null;

    var self = assertThisInitialized_assertThisInitialized(_this);
    /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */


    _this.viewPromise_ = new Promise(function (resolve, reject) {
      self.viewResolver = resolve;
      self.viewRejector = reject;
    });
    return _this;
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */


  _createClass(Source, [{
    key: "getAttributions",
    value: function getAttributions() {
      return this.attributions_;
    }
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */

  }, {
    key: "getAttributionsCollapsible",
    value: function getAttributionsCollapsible() {
      return this.attributionsCollapsible_;
    }
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default|null} Projection.
     * @api
     */

  }, {
    key: "getProjection",
    value: function getProjection() {
      return this.projection;
    }
    /**
     * @abstract
     * @return {Array<number>|null} Resolutions.
     */

  }, {
    key: "getResolutions",
    value: function getResolutions() {
      return util_abstract();
    }
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */

  }, {
    key: "getView",
    value: function getView() {
      return this.viewPromise_;
    }
    /**
     * Get the state of the source, see {@link import("./Source.js").State} for possible states.
     * @return {import("./Source.js").State} State.
     * @api
     */

  }, {
    key: "getState",
    value: function getState() {
      return this.state_;
    }
    /**
     * @return {boolean|undefined} Wrap X.
     */

  }, {
    key: "getWrapX",
    value: function getWrapX() {
      return this.wrapX_;
    }
    /**
     * @return {boolean} Use linear interpolation when resampling.
     */

  }, {
    key: "getInterpolate",
    value: function getInterpolate() {
      return this.interpolate_;
    }
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */

  }, {
    key: "refresh",
    value: function refresh() {
      this.changed();
    }
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */

  }, {
    key: "setAttributions",
    value: function setAttributions(attributions) {
      this.attributions_ = adaptAttributions(attributions);
      this.changed();
    }
    /**
     * Set the state of the source.
     * @param {import("./Source.js").State} state State.
     */

  }, {
    key: "setState",
    value: function setState(state) {
      this.state_ = state;
      this.changed();
    }
  }]);

  return Source;
}(ol_Object);
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */


function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }

  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
}

/* harmony default export */ var source_Source = (Source);
;// CONCATENATED MODULE: ./node_modules/ol/source/VectorEventType.js
/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ var VectorEventType = ({
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature',

  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: 'featuresloadstart',

  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: 'featuresloadend',

  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: 'featuresloaderror'
});
/**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */
;// CONCATENATED MODULE: ./node_modules/ol/loadingstrategy.js
/**
 * @module ol/loadingstrategy
 */

/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */

function loadingstrategy_all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */

function bbox(extent, resolution) {
  return [extent];
}
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */

function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution, projection) {
      var z = tileGrid.getZForResolution(fromUserResolution(resolution, projection));
      var tileRange = tileGrid.getTileRangeForExtentAndZ(fromUserExtent(extent, projection), z);
      /** @type {Array<import("./extent.js").Extent>} */

      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */

      var tileCoord = [z, 0, 0];

      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection));
        }
      }

      return extents;
    }
  );
}
;// CONCATENATED MODULE: ./node_modules/ol/featureloader.js
/**
 * @module ol/featureloader
 */

/**
 *
 * @type {boolean}
 * @private
 */

var withCredentials = false;
/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */

/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */

function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);

  if (format.getType() == 'arraybuffer') {
    xhr.responseType = 'arraybuffer';
  }

  xhr.withCredentials = withCredentials;
  /**
   * @param {Event} event Event.
   * @private
   */

  xhr.onload = function (event) {
    // status will be 0 for file:// urls
    if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
      var type = format.getType();
      /** @type {Document|Node|Object|string|undefined} */

      var source;

      if (type == 'json' || type == 'text') {
        source = xhr.responseText;
      } else if (type == 'xml') {
        source = xhr.responseXML;

        if (!source) {
          source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
        }
      } else if (type == 'arraybuffer') {
        source =
        /** @type {ArrayBuffer} */
        xhr.response;
      }

      if (source) {
        success(
        /** @type {Array<import("./Feature.js").default>} */
        format.readFeatures(source, {
          extent: extent,
          featureProjection: projection
        }), format.readProjection(source));
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  /**
   * @private
   */


  xhr.onerror = failure;
  xhr.send();
}
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */

function xhr(url, format) {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   * @this {import("./source/Vector").default}
   */
  return function (extent, resolution, projection, success, failure) {
    var source =
    /** @type {import("./source/Vector").default} */
    this;
    loadFeaturesXhr(url, format, extent, resolution, projection,
    /**
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data
     * projection.
     */
    function (features, dataProjection) {
      source.addFeatures(features);

      if (success !== undefined) {
        success(features);
      }
    },
    /* FIXME handle error */
    failure ? failure : VOID);
  };
}
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */

function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}
;// CONCATENATED MODULE: ./node_modules/ol/source/Vector.js








/**
 * @module ol/source/Vector
 */

















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */

var VectorSourceEvent = /*#__PURE__*/function (_Event) {
  _inherits(VectorSourceEvent, _Event);

  var _super = createSuper_createSuper(VectorSourceEvent);

  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */
  function VectorSourceEvent(type, feature, features) {
    var _this;

    _classCallCheck(this, VectorSourceEvent);

    _this = _super.call(this, type);
    /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {import("../Feature.js").default<Geometry>|undefined}
     * @api
     */

    _this.feature = feature;
    /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
     * @api
     */

    _this.features = features;
    return _this;
  }

  return _createClass(VectorSourceEvent);
}(events_Event);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default<Geometry>>|Collection<import("../Feature.js").default<Geometry>>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */

var VectorSource = /*#__PURE__*/function (_Source) {
  _inherits(VectorSource, _Source);

  var _super2 = createSuper_createSuper(VectorSource);

  /**
   * @param {Options<Geometry>} [options] Vector source options.
   */
  function VectorSource(options) {
    var _this2;

    _classCallCheck(this, VectorSource);

    options = options || {};
    _this2 = _super2.call(this, {
      attributions: options.attributions,
      interpolate: true,
      projection: undefined,
      state: 'ready',
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    });
    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */

    _this2.on;
    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */

    _this2.once;
    /***
     * @type {VectorSourceOnSignature<void>}
     */

    _this2.un;
    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */

    _this2.loader_ = VOID;
    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */

    _this2.format_ = options.format;
    /**
     * @private
     * @type {boolean}
     */

    _this2.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */

    _this2.url_ = options.url;

    if (options.loader !== undefined) {
      _this2.loader_ = options.loader;
    } else if (_this2.url_ !== undefined) {
      asserts_assert(_this2.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"

      _this2.loader_ = xhr(_this2.url_,
      /** @type {import("../format/Feature.js").default} */
      _this2.format_);
    }
    /**
     * @private
     * @type {LoadingStrategy}
     */


    _this2.strategy_ = options.strategy !== undefined ? options.strategy : loadingstrategy_all;
    var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
    /**
     * @private
     * @type {RBush<import("../Feature.js").default<Geometry>>}
     */

    _this2.featuresRtree_ = useSpatialIndex ? new structs_RBush() : null;
    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */

    _this2.loadedExtentsRtree_ = new structs_RBush();
    /**
     * @type {number}
     * @private
     */

    _this2.loadingExtentsCount_ = 0;
    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this2.nullGeometryFeatures_ = {};
    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this2.idIndex_ = {};
    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this2.uidIndex_ = {};
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this2.featureChangeKeys_ = {};
    /**
     * @private
     * @type {Collection<import("../Feature.js").default<Geometry>>|null}
     */

    _this2.featuresCollection_ = null;
    /** @type {Collection<import("../Feature.js").default<Geometry>>} */

    var collection;
    /** @type {Array<import("../Feature.js").default<Geometry>>} */

    var features;

    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }

    if (!useSpatialIndex && collection === undefined) {
      collection = new ol_Collection(features);
    }

    if (features !== undefined) {
      _this2.addFeaturesInternal(features);
    }

    if (collection !== undefined) {
      _this2.bindFeaturesCollection_(collection);
    }

    return _this2;
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */


  _createClass(VectorSource, [{
    key: "addFeature",
    value: function addFeature(feature) {
      this.addFeatureInternal(feature);
      this.changed();
    }
    /**
     * Add a feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @protected
     */

  }, {
    key: "addFeatureInternal",
    value: function addFeatureInternal(feature) {
      var featureKey = getUid(feature);

      if (!this.addToIndex_(featureKey, feature)) {
        if (this.featuresCollection_) {
          this.featuresCollection_.remove(feature);
        }

        return;
      }

      this.setupChangeEvents_(featureKey, feature);
      var geometry = feature.getGeometry();

      if (geometry) {
        var extent = geometry.getExtent();

        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }

      this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @private
     */

  }, {
    key: "setupChangeEvents_",
    value: function setupChangeEvents_(featureKey, feature) {
      this.featureChangeKeys_[featureKey] = [listen(feature, EventType.CHANGE, this.handleFeatureChange_, this), listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)];
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */

  }, {
    key: "addToIndex_",
    value: function addToIndex_(featureKey, feature) {
      var valid = true;
      var id = feature.getId();

      if (id !== undefined) {
        if (!(id.toString() in this.idIndex_)) {
          this.idIndex_[id.toString()] = feature;
        } else {
          valid = false;
        }
      }

      if (valid) {
        asserts_assert(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source

        this.uidIndex_[featureKey] = feature;
      }

      return valid;
    }
    /**
     * Add a batch of features to the source.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
     * @api
     */

  }, {
    key: "addFeatures",
    value: function addFeatures(features) {
      this.addFeaturesInternal(features);
      this.changed();
    }
    /**
     * Add features without firing a `change` event.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
     * @protected
     */

  }, {
    key: "addFeaturesInternal",
    value: function addFeaturesInternal(features) {
      var extents = [];
      var newFeatures = [];
      var geometryFeatures = [];

      for (var i = 0, length = features.length; i < length; i++) {
        var feature = features[i];
        var featureKey = getUid(feature);

        if (this.addToIndex_(featureKey, feature)) {
          newFeatures.push(feature);
        }
      }

      for (var _i = 0, _length = newFeatures.length; _i < _length; _i++) {
        var _feature = newFeatures[_i];

        var _featureKey = getUid(_feature);

        this.setupChangeEvents_(_featureKey, _feature);

        var geometry = _feature.getGeometry();

        if (geometry) {
          var extent = geometry.getExtent();
          extents.push(extent);
          geometryFeatures.push(_feature);
        } else {
          this.nullGeometryFeatures_[_featureKey] = _feature;
        }
      }

      if (this.featuresRtree_) {
        this.featuresRtree_.load(extents, geometryFeatures);
      }

      if (this.hasListener(VectorEventType.ADDFEATURE)) {
        for (var _i2 = 0, _length2 = newFeatures.length; _i2 < _length2; _i2++) {
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[_i2]));
        }
      }
    }
    /**
     * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
     * @private
     */

  }, {
    key: "bindFeaturesCollection_",
    value: function bindFeaturesCollection_(collection) {
      var modifyingCollection = false;
      this.addEventListener(VectorEventType.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      });
      this.addEventListener(VectorEventType.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      });
      collection.addEventListener(CollectionEventType.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(evt.element);
          modifyingCollection = false;
        }
      }.bind(this));
      collection.addEventListener(CollectionEventType.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(evt.element);
          modifyingCollection = false;
        }
      }.bind(this));
      this.featuresCollection_ = collection;
    }
    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
     * @api
     */

  }, {
    key: "clear",
    value: function clear(fast) {
      if (fast) {
        for (var featureId in this.featureChangeKeys_) {
          var keys = this.featureChangeKeys_[featureId];
          keys.forEach(unlistenByKey);
        }

        if (!this.featuresCollection_) {
          this.featureChangeKeys_ = {};
          this.idIndex_ = {};
          this.uidIndex_ = {};
        }
      } else {
        if (this.featuresRtree_) {
          var removeAndIgnoreReturn = function (feature) {
            this.removeFeatureInternal(feature);
          }.bind(this);

          this.featuresRtree_.forEach(removeAndIgnoreReturn);

          for (var id in this.nullGeometryFeatures_) {
            this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
          }
        }
      }

      if (this.featuresCollection_) {
        this.featuresCollection_.clear();
      }

      if (this.featuresRtree_) {
        this.featuresRtree_.clear();
      }

      this.nullGeometryFeatures_ = {};
      var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
      this.dispatchEvent(clearEvent);
      this.changed();
    }
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */

  }, {
    key: "forEachFeature",
    value: function forEachFeature(callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEach(callback);
      } else if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    }
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */

  }, {
    key: "forEachFeatureAtCoordinateDirect",
    value: function forEachFeatureAtCoordinateDirect(coordinate, callback) {
      var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
      return this.forEachFeatureInExtent(extent, function (feature) {
        var geometry = feature.getGeometry();

        if (geometry.intersectsCoordinate(coordinate)) {
          return callback(feature);
        } else {
          return undefined;
        }
      });
    }
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */

  }, {
    key: "forEachFeatureInExtent",
    value: function forEachFeatureInExtent(extent, callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEachInExtent(extent, callback);
      } else if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    }
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */

  }, {
    key: "forEachFeatureIntersectingExtent",
    value: function forEachFeatureIntersectingExtent(extent, callback) {
      return this.forEachFeatureInExtent(extent,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function (feature) {
        var geometry = feature.getGeometry();

        if (geometry.intersectsExtent(extent)) {
          var result = callback(feature);

          if (result) {
            return result;
          }
        }
      });
    }
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with an {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
     * @api
     */

  }, {
    key: "getFeaturesCollection",
    value: function getFeaturesCollection() {
      return this.featuresCollection_;
    }
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */

  }, {
    key: "getFeatures",
    value: function getFeatures() {
      var features;

      if (this.featuresCollection_) {
        features = this.featuresCollection_.getArray().slice(0);
      } else if (this.featuresRtree_) {
        features = this.featuresRtree_.getAll();

        if (!obj_isEmpty(this.nullGeometryFeatures_)) {
          array_extend(features, Object.values(this.nullGeometryFeatures_));
        }
      }

      return (
        /** @type {Array<import("../Feature.js").default<Geometry>>} */
        features
      );
    }
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */

  }, {
    key: "getFeaturesAtCoordinate",
    value: function getFeaturesAtCoordinate(coordinate) {
      var features = [];
      this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
        features.push(feature);
      });
      return features;
    }
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../proj/Projection.js").default} [projection] Include features
     * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */

  }, {
    key: "getFeaturesInExtent",
    value: function getFeaturesInExtent(extent, projection) {
      var _this3 = this;

      if (this.featuresRtree_) {
        var _ref;

        var multiWorld = projection && projection.canWrapX() && this.getWrapX();

        if (!multiWorld) {
          return this.featuresRtree_.getInExtent(extent);
        }

        var extents = wrapAndSliceX(extent, projection);
        return (_ref = []).concat.apply(_ref, _toConsumableArray(extents.map(function (anExtent) {
          return _this3.featuresRtree_.getInExtent(anExtent);
        })));
      } else if (this.featuresCollection_) {
        return this.featuresCollection_.getArray().slice(0);
      } else {
        return [];
      }
    }
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {import("../Feature.js").default<Geometry>} Closest feature.
     * @api
     */

  }, {
    key: "getClosestFeatureToCoordinate",
    value: function getClosestFeatureToCoordinate(coordinate, filter) {
      // Find the closest feature using branch and bound.  We start searching an
      // infinite extent, and find the distance from the first feature found.  This
      // becomes the closest feature.  We then compute a smaller extent which any
      // closer feature must intersect.  We continue searching with this smaller
      // extent, trying to find a closer feature.  Every time we find a closer
      // feature, we update the extent being searched so that any even closer
      // feature must intersect it.  We continue until we run out of features.
      var x = coordinate[0];
      var y = coordinate[1];
      var closestFeature = null;
      var closestPoint = [NaN, NaN];
      var minSquaredDistance = Infinity;
      var extent = [-Infinity, -Infinity, Infinity, Infinity];
      filter = filter ? filter : TRUE;
      this.featuresRtree_.forEachInExtent(extent,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */
      function (feature) {
        if (filter(feature)) {
          var geometry = feature.getGeometry();
          var previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);

          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being
            // searched while the R-Tree traversal using this same extent object
            // is still in progress.  This is safe because the new extent is
            // strictly contained by the old extent.

            var minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      });
      return closestFeature;
    }
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */

  }, {
    key: "getExtent",
    value: function getExtent(extent) {
      return this.featuresRtree_.getExtent(extent);
    }
    /**
     * Get a feature by its identifier (the value returned by feature.getId()).
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
     * @api
     */

  }, {
    key: "getFeatureById",
    value: function getFeatureById(id) {
      var feature = this.idIndex_[id.toString()];
      return feature !== undefined ? feature : null;
    }
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
     */

  }, {
    key: "getFeatureByUid",
    value: function getFeatureByUid(uid) {
      var feature = this.uidIndex_[uid];
      return feature !== undefined ? feature : null;
    }
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default|undefined} The feature format.
     * @api
     */

  }, {
    key: "getFormat",
    value: function getFormat() {
      return this.format_;
    }
    /**
     * @return {boolean} The source can have overlapping geometries.
     */

  }, {
    key: "getOverlaps",
    value: function getOverlaps() {
      return this.overlaps_;
    }
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */

  }, {
    key: "getUrl",
    value: function getUrl() {
      return this.url_;
    }
    /**
     * @param {Event} event Event.
     * @private
     */

  }, {
    key: "handleFeatureChange_",
    value: function handleFeatureChange_(event) {
      var feature =
      /** @type {import("../Feature.js").default<Geometry>} */
      event.target;
      var featureKey = getUid(feature);
      var geometry = feature.getGeometry();

      if (!geometry) {
        if (!(featureKey in this.nullGeometryFeatures_)) {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }

          this.nullGeometryFeatures_[featureKey] = feature;
        }
      } else {
        var extent = geometry.getExtent();

        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];

          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.update(extent, feature);
          }
        }
      }

      var id = feature.getId();

      if (id !== undefined) {
        var sid = id.toString();

        if (this.idIndex_[sid] !== feature) {
          this.removeFromIdIndex_(feature);
          this.idIndex_[sid] = feature;
        }
      } else {
        this.removeFromIdIndex_(feature);
        this.uidIndex_[featureKey] = feature;
      }

      this.changed();
      this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
    }
    /**
     * Returns true if the feature is contained within the source.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */

  }, {
    key: "hasFeature",
    value: function hasFeature(feature) {
      var id = feature.getId();

      if (id !== undefined) {
        return id in this.idIndex_;
      } else {
        return getUid(feature) in this.uidIndex_;
      }
    }
    /**
     * @return {boolean} Is empty.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      if (this.featuresRtree_) {
        return this.featuresRtree_.isEmpty() && obj_isEmpty(this.nullGeometryFeatures_);
      }

      if (this.featuresCollection_) {
        return this.featuresCollection_.getLength() === 0;
      }

      return true;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */

  }, {
    key: "loadFeatures",
    value: function loadFeatures(extent, resolution, projection) {
      var _this4 = this;

      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var extentsToLoad = this.strategy_(extent, resolution, projection);

      var _loop = function _loop(i, ii) {
        var extentToLoad = extentsToLoad[i];
        var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function (object) {
          return containsExtent(object.extent, extentToLoad);
        });

        if (!alreadyLoaded) {
          ++_this4.loadingExtentsCount_;

          _this4.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));

          _this4.loader_.call(_this4, extentToLoad, resolution, projection, function (features) {
            --this.loadingExtentsCount_;
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, undefined, features));
          }.bind(_this4), function () {
            --this.loadingExtentsCount_;
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
          }.bind(_this4));

          loadedExtentsRtree.insert(extentToLoad, {
            extent: extentToLoad.slice()
          });
        }
      };

      for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
        _loop(i, ii);
      }

      this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    }
  }, {
    key: "refresh",
    value: function refresh() {
      this.clear(true);
      this.loadedExtentsRtree_.clear();

      _get(getPrototypeOf_getPrototypeOf(VectorSource.prototype), "refresh", this).call(this);
    }
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */

  }, {
    key: "removeLoadedExtent",
    value: function removeLoadedExtent(extent) {
      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var obj;
      loadedExtentsRtree.forEachInExtent(extent, function (object) {
        if (extent_equals(object.extent, extent)) {
          obj = object;
          return true;
        }
      });

      if (obj) {
        loadedExtentsRtree.remove(obj);
      }
    }
    /**
     * Remove a single feature from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
     * @api
     */

  }, {
    key: "removeFeature",
    value: function removeFeature(feature) {
      if (!feature) {
        return;
      }

      var featureKey = getUid(feature);

      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
      }

      var result = this.removeFeatureInternal(feature);

      if (result) {
        this.changed();
      }
    }
    /**
     * Remove feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
     *     (or undefined if the feature was not found).
     * @protected
     */

  }, {
    key: "removeFeatureInternal",
    value: function removeFeatureInternal(feature) {
      var featureKey = getUid(feature);
      var featureChangeKeys = this.featureChangeKeys_[featureKey];

      if (!featureChangeKeys) {
        return;
      }

      featureChangeKeys.forEach(unlistenByKey);
      delete this.featureChangeKeys_[featureKey];
      var id = feature.getId();

      if (id !== undefined) {
        delete this.idIndex_[id.toString()];
      }

      delete this.uidIndex_[featureKey];
      this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
      return feature;
    }
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} Removed the feature from the index.
     * @private
     */

  }, {
    key: "removeFromIdIndex_",
    value: function removeFromIdIndex_(feature) {
      var removed = false;

      for (var id in this.idIndex_) {
        if (this.idIndex_[id] === feature) {
          delete this.idIndex_[id];
          removed = true;
          break;
        }
      }

      return removed;
    }
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
     * @api
     */

  }, {
    key: "setLoader",
    value: function setLoader(loader) {
      this.loader_ = loader;
    }
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */

  }, {
    key: "setUrl",
    value: function setUrl(url) {
      asserts_assert(this.format_, 7); // `format` must be set when `url` is set

      this.url_ = url;
      this.setLoader(xhr(url, this.format_));
    }
  }]);

  return VectorSource;
}(source_Source);

/* harmony default export */ var source_Vector = (VectorSource);
;// CONCATENATED MODULE: ./node_modules/ol/source/Cluster.js








/**
 * @module ol/source/Cluster
 */








/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [distance=20] Distance in pixels within which features will
 * be clustered together.
 * @property {number} [minDistance=0] Minimum distance in pixels between clusters.
 * Will be capped at the configured distance.
 * By default no minimum distance is guaranteed. This config can be used to avoid
 * overlapping icons. As a tradoff, the cluster feature's position will no longer be
 * the center of all its features.
 * @property {function(Feature):Point} [geometryFunction]
 * Function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Point~Point} as cluster calculation point for the feature. When a
 * feature should not be considered for clustering, the function should return
 * `null`. The default, which works when the underlying source contains point
 * features only, is
 * ```js
 * function(feature) {
 *   return feature.getGeometry();
 * }
 * ```
 * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
 * calculation point for polygons.
 * @property {function(Point, Array<Feature>):Feature} [createCluster]
 * Function that takes the cluster's center {@link module:ol/geom/Point~Point} and an array
 * of {@link module:ol/Feature~Feature} included in this cluster. Must return a
 * {@link module:ol/Feature~Feature} that will be used to render. Default implementation is:
 * ```js
 * function(point, features) {
 *   return new Feature({
 *     geometry: point,
 *     features: features
 *   });
 * }
 * ```
 * @property {VectorSource} [source=null] Source.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */

/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 *
 * If the instance is disposed without also disposing the underlying
 * source `setSource(null)` has to be called to remove the listener reference
 * from the wrapped source.
 * @api
 */

var Cluster = /*#__PURE__*/function (_VectorSource) {
  _inherits(Cluster, _VectorSource);

  var _super = createSuper_createSuper(Cluster);

  /**
   * @param {Options} options Cluster options.
   */
  function Cluster(options) {
    var _this;

    _classCallCheck(this, Cluster);

    _this = _super.call(this, {
      attributions: options.attributions,
      wrapX: options.wrapX
    });
    /**
     * @type {number|undefined}
     * @protected
     */

    _this.resolution = undefined;
    /**
     * @type {number}
     * @protected
     */

    _this.distance = options.distance !== undefined ? options.distance : 20;
    /**
     * @type {number}
     * @protected
     */

    _this.minDistance = options.minDistance || 0;
    /**
     * @type {number}
     * @protected
     */

    _this.interpolationRatio = 0;
    /**
     * @type {Array<Feature>}
     * @protected
     */

    _this.features = [];
    /**
     * @param {Feature} feature Feature.
     * @return {Point} Cluster calculation point.
     * @protected
     */

    _this.geometryFunction = options.geometryFunction || function (feature) {
      var geometry =
      /** @type {Point} */
      feature.getGeometry();
      asserts_assert(geometry.getType() == 'Point', 10); // The default `geometryFunction` can only handle `Point` geometries

      return geometry;
    };
    /**
     * @type {function(Point, Array<Feature>):Feature}
     * @private
     */


    _this.createCustomCluster_ = options.createCluster;
    /**
     * @type {VectorSource|null}
     * @protected
     */

    _this.source = null;
    /**
     * @private
     */

    _this.boundRefresh_ = _this.refresh.bind(assertThisInitialized_assertThisInitialized(_this));

    _this.updateDistance(_this.distance, _this.minDistance);

    _this.setSource(options.source || null);

    return _this;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */


  _createClass(Cluster, [{
    key: "clear",
    value: function clear(fast) {
      this.features.length = 0;

      _get(getPrototypeOf_getPrototypeOf(Cluster.prototype), "clear", this).call(this, fast);
    }
    /**
     * Get the distance in pixels between clusters.
     * @return {number} Distance.
     * @api
     */

  }, {
    key: "getDistance",
    value: function getDistance() {
      return this.distance;
    }
    /**
     * Get a reference to the wrapped source.
     * @return {VectorSource|null} Source.
     * @api
     */

  }, {
    key: "getSource",
    value: function getSource() {
      return this.source;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */

  }, {
    key: "loadFeatures",
    value: function loadFeatures(extent, resolution, projection) {
      this.source.loadFeatures(extent, resolution, projection);

      if (resolution !== this.resolution) {
        this.resolution = resolution;
        this.refresh();
      }
    }
    /**
     * Set the distance within which features will be clusterd together.
     * @param {number} distance The distance in pixels.
     * @api
     */

  }, {
    key: "setDistance",
    value: function setDistance(distance) {
      this.updateDistance(distance, this.minDistance);
    }
    /**
     * Set the minimum distance between clusters. Will be capped at the
     * configured distance.
     * @param {number} minDistance The minimum distance in pixels.
     * @api
     */

  }, {
    key: "setMinDistance",
    value: function setMinDistance(minDistance) {
      this.updateDistance(this.distance, minDistance);
    }
    /**
     * The configured minimum distance between clusters.
     * @return {number} The minimum distance in pixels.
     * @api
     */

  }, {
    key: "getMinDistance",
    value: function getMinDistance() {
      return this.minDistance;
    }
    /**
     * Replace the wrapped source.
     * @param {VectorSource|null} source The new source for this instance.
     * @api
     */

  }, {
    key: "setSource",
    value: function setSource(source) {
      if (this.source) {
        this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);
      }

      this.source = source;

      if (source) {
        source.addEventListener(EventType.CHANGE, this.boundRefresh_);
      }

      this.refresh();
    }
    /**
     * Handle the source changing.
     */

  }, {
    key: "refresh",
    value: function refresh() {
      this.clear();
      this.cluster();
      this.addFeatures(this.features);
    }
    /**
     * Update the distances and refresh the source if necessary.
     * @param {number} distance The new distance.
     * @param {number} minDistance The new minimum distance.
     */

  }, {
    key: "updateDistance",
    value: function updateDistance(distance, minDistance) {
      var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
      var changed = distance !== this.distance || this.interpolationRatio !== ratio;
      this.distance = distance;
      this.minDistance = minDistance;
      this.interpolationRatio = ratio;

      if (changed) {
        this.refresh();
      }
    }
    /**
     * @protected
     */

  }, {
    key: "cluster",
    value: function cluster() {
      if (this.resolution === undefined || !this.source) {
        return;
      }

      var extent = createEmpty();
      var mapDistance = this.distance * this.resolution;
      var features = this.source.getFeatures();
      /** @type {Object<string, true>} */

      var clustered = {};

      for (var i = 0, ii = features.length; i < ii; i++) {
        var feature = features[i];

        if (!(getUid(feature) in clustered)) {
          var geometry = this.geometryFunction(feature);

          if (geometry) {
            var coordinates = geometry.getCoordinates();
            createOrUpdateFromCoordinate(coordinates, extent);
            buffer(extent, mapDistance, extent);
            var neighbors = this.source.getFeaturesInExtent(extent).filter(function (neighbor) {
              var uid = getUid(neighbor);

              if (uid in clustered) {
                return false;
              }

              clustered[uid] = true;
              return true;
            });
            this.features.push(this.createCluster(neighbors, extent));
          }
        }
      }
    }
    /**
     * @param {Array<Feature>} features Features
     * @param {import("../extent.js").Extent} extent The searched extent for these features.
     * @return {Feature} The cluster feature.
     * @protected
     */

  }, {
    key: "createCluster",
    value: function createCluster(features, extent) {
      var centroid = [0, 0];

      for (var i = features.length - 1; i >= 0; --i) {
        var _geometry = this.geometryFunction(features[i]);

        if (_geometry) {
          add(centroid, _geometry.getCoordinates());
        } else {
          features.splice(i, 1);
        }
      }

      coordinate_scale(centroid, 1 / features.length);
      var searchCenter = getCenter(extent);
      var ratio = this.interpolationRatio;
      var geometry = new geom_Point([centroid[0] * (1 - ratio) + searchCenter[0] * ratio, centroid[1] * (1 - ratio) + searchCenter[1] * ratio]);

      if (this.createCustomCluster_) {
        return this.createCustomCluster_(geometry, features);
      } else {
        return new ol_Feature({
          geometry: geometry,
          features: features
        });
      }
    }
  }]);

  return Cluster;
}(source_Vector);

/* harmony default export */ var source_Cluster = (Cluster);
;// CONCATENATED MODULE: ./node_modules/ol/structs/LRUCache.js



/**
 * @module ol/structs/LRUCache
 */

/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Object} newer Newer.
 * @property {Object} older Older.
 * @property {*} value_ Value.
 */

/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */

var LRUCache = /*#__PURE__*/function () {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  function LRUCache(highWaterMark) {
    _classCallCheck(this, LRUCache);

    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;
    /**
     * @private
     * @type {number}
     */

    this.count_ = 0;
    /**
     * @private
     * @type {!Object<string, Entry>}
     */

    this.entries_ = {};
    /**
     * @private
     * @type {?Entry}
     */

    this.oldest_ = null;
    /**
     * @private
     * @type {?Entry}
     */

    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  _createClass(LRUCache, [{
    key: "canExpireCache",
    value: function canExpireCache() {
      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }
    /**
     * Expire the cache.
     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
     */

  }, {
    key: "expireCache",
    value: function expireCache(keep) {
      while (this.canExpireCache()) {
        this.pop();
      }
    }
    /**
     * FIXME empty description for jsdoc
     */

  }, {
    key: "clear",
    value: function clear() {
      this.count_ = 0;
      this.entries_ = {};
      this.oldest_ = null;
      this.newest_ = null;
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */

  }, {
    key: "containsKey",
    value: function containsKey(key) {
      return this.entries_.hasOwnProperty(key);
    }
    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */

  }, {
    key: "forEach",
    value: function forEach(f) {
      var entry = this.oldest_;

      while (entry) {
        f(entry.value_, entry.key_, this);
        entry = entry.newer;
      }
    }
    /**
     * @param {string} key Key.
     * @param {*} [options] Options (reserved for subclasses).
     * @return {T} Value.
     */

  }, {
    key: "get",
    value: function get(key, options) {
      var entry = this.entries_[key];
      asserts_assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

      if (entry === this.newest_) {
        return entry.value_;
      } else if (entry === this.oldest_) {
        this.oldest_ =
        /** @type {Entry} */
        this.oldest_.newer;
        this.oldest_.older = null;
      } else {
        entry.newer.older = entry.older;
        entry.older.newer = entry.newer;
      }

      entry.newer = null;
      entry.older = this.newest_;
      this.newest_.newer = entry;
      this.newest_ = entry;
      return entry.value_;
    }
    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */

  }, {
    key: "remove",
    value: function remove(key) {
      var entry = this.entries_[key];
      asserts_assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

      if (entry === this.newest_) {
        this.newest_ =
        /** @type {Entry} */
        entry.older;

        if (this.newest_) {
          this.newest_.newer = null;
        }
      } else if (entry === this.oldest_) {
        this.oldest_ =
        /** @type {Entry} */
        entry.newer;

        if (this.oldest_) {
          this.oldest_.older = null;
        }
      } else {
        entry.newer.older = entry.older;
        entry.older.newer = entry.newer;
      }

      delete this.entries_[key];
      --this.count_;
      return entry.value_;
    }
    /**
     * @return {number} Count.
     */

  }, {
    key: "getCount",
    value: function getCount() {
      return this.count_;
    }
    /**
     * @return {Array<string>} Keys.
     */

  }, {
    key: "getKeys",
    value: function getKeys() {
      var keys = new Array(this.count_);
      var i = 0;
      var entry;

      for (entry = this.newest_; entry; entry = entry.older) {
        keys[i++] = entry.key_;
      }

      return keys;
    }
    /**
     * @return {Array<T>} Values.
     */

  }, {
    key: "getValues",
    value: function getValues() {
      var values = new Array(this.count_);
      var i = 0;
      var entry;

      for (entry = this.newest_; entry; entry = entry.older) {
        values[i++] = entry.value_;
      }

      return values;
    }
    /**
     * @return {T} Last value.
     */

  }, {
    key: "peekLast",
    value: function peekLast() {
      return this.oldest_.value_;
    }
    /**
     * @return {string} Last key.
     */

  }, {
    key: "peekLastKey",
    value: function peekLastKey() {
      return this.oldest_.key_;
    }
    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */

  }, {
    key: "peekFirstKey",
    value: function peekFirstKey() {
      return this.newest_.key_;
    }
    /**
     * Return an entry without updating least recently used time.
     * @param {string} key Key.
     * @return {T} Value.
     */

  }, {
    key: "peek",
    value: function peek(key) {
      if (!this.containsKey(key)) {
        return undefined;
      }

      return this.entries_[key].value_;
    }
    /**
     * @return {T} value Value.
     */

  }, {
    key: "pop",
    value: function pop() {
      var entry = this.oldest_;
      delete this.entries_[entry.key_];

      if (entry.newer) {
        entry.newer.older = null;
      }

      this.oldest_ =
      /** @type {Entry} */
      entry.newer;

      if (!this.oldest_) {
        this.newest_ = null;
      }

      --this.count_;
      return entry.value_;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */

  }, {
    key: "replace",
    value: function replace(key, value) {
      this.get(key); // update `newest_`

      this.entries_[key].value_ = value;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */

  }, {
    key: "set",
    value: function set(key, value) {
      asserts_assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already

      var entry = {
        key_: key,
        newer: null,
        older: this.newest_,
        value_: value
      };

      if (!this.newest_) {
        this.oldest_ = entry;
      } else {
        this.newest_.newer = entry;
      }

      this.newest_ = entry;
      this.entries_[key] = entry;
      ++this.count_;
    }
    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */

  }, {
    key: "setSize",
    value: function setSize(size) {
      this.highWaterMark = size;
    }
  }]);

  return LRUCache;
}();

/* harmony default export */ var structs_LRUCache = (LRUCache);
;// CONCATENATED MODULE: ./node_modules/ol/tilecoord.js


/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function tilecoord_createOrUpdate(z, x, y, tileCoord) {
  if (tileCoord !== undefined) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  } else {
    return [z, x, y];
  }
}
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */

function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */

function tilecoord_getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */

function getCacheKeyForTileKey(tileKey) {
  var _tileKey$substring$sp = tileKey.substring(tileKey.lastIndexOf('/') + 1, tileKey.length).split(',').map(Number),
      _tileKey$substring$sp2 = _slicedToArray(_tileKey$substring$sp, 3),
      z = _tileKey$substring$sp2[0],
      x = _tileKey$substring$sp2[1],
      y = _tileKey$substring$sp2[2];

  return getKeyZXY(z, x, y);
}
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */

function fromKey(key) {
  return key.split('/').map(Number);
}
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */

function tilecoord_hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */

function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }

  var tileRange = tileGrid.getFullTileRange(z);

  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}
;// CONCATENATED MODULE: ./node_modules/ol/TileCache.js







/**
 * @module ol/TileCache
 */



var TileCache = /*#__PURE__*/function (_LRUCache) {
  _inherits(TileCache, _LRUCache);

  var _super = createSuper_createSuper(TileCache);

  function TileCache() {
    _classCallCheck(this, TileCache);

    return _super.apply(this, arguments);
  }

  _createClass(TileCache, [{
    key: "clear",
    value: function clear() {
      while (this.getCount() > 0) {
        this.pop().release();
      }

      _get(getPrototypeOf_getPrototypeOf(TileCache.prototype), "clear", this).call(this);
    }
    /**
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */

  }, {
    key: "expireCache",
    value: function expireCache(usedTiles) {
      while (this.canExpireCache()) {
        var tile = this.peekLast();

        if (tile.getKey() in usedTiles) {
          break;
        } else {
          this.pop().release();
        }
      }
    }
    /**
     * Prune all tiles from the cache that don't have the same z as the newest tile.
     */

  }, {
    key: "pruneExceptNewestZ",
    value: function pruneExceptNewestZ() {
      if (this.getCount() === 0) {
        return;
      }

      var key = this.peekFirstKey();
      var tileCoord = fromKey(key);
      var z = tileCoord[0];
      this.forEach(function (tile) {
        if (tile.tileCoord[0] !== z) {
          this.remove(tilecoord_getKey(tile.tileCoord));
          tile.release();
        }
      }.bind(this));
    }
  }]);

  return TileCache;
}(structs_LRUCache);

/* harmony default export */ var ol_TileCache = (TileCache);
;// CONCATENATED MODULE: ./node_modules/ol/source/TileEventType.js
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ var TileEventType = ({
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'
});
/**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */
;// CONCATENATED MODULE: ./node_modules/ol/tilegrid/TileGrid.js



/**
 * @module ol/tilegrid/TileGrid
 */









/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */

var tmpTileCoord = [0, 0, 0];
/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */

var DECIMALS = 5;
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */

var TileGrid_TileGrid = /*#__PURE__*/function () {
  /**
   * @param {Options} options Tile grid options.
   */
  function TileGrid(options) {
    _classCallCheck(this, TileGrid);

    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
    /**
     * @private
     * @type {!Array<number>}
     */

    this.resolutions_ = options.resolutions;
    asserts_assert(isSorted(this.resolutions_, function (a, b) {
      return b - a;
    }, true), 17); // `resolutions` must be sorted in descending order
    // check if we've got a consistent zoom factor and origin

    var zoomFactor;

    if (!options.origins) {
      for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }
    /**
     * @private
     * @type {number|undefined}
     */


    this.zoomFactor_ = zoomFactor;
    /**
     * @protected
     * @type {number}
     */

    this.maxZoom = this.resolutions_.length - 1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */

    this.origin_ = options.origin !== undefined ? options.origin : null;
    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */

    this.origins_ = null;

    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      asserts_assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
    }

    var extent = options.extent;

    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }

    asserts_assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */

    this.tileSizes_ = null;

    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      asserts_assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
    }
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */


    this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    asserts_assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = extent !== undefined ? extent : null;
    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */

    this.fullTileRanges_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.tmpSize_ = [0, 0];
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.tmpExtent_ = [0, 0, 0, 0];

    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map(function (size, z) {
        var tileRange = new ol_TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));

        if (extent) {
          var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }

        return tileRange;
      }, this);
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */


  _createClass(TileGrid, [{
    key: "forEachTileCoord",
    value: function forEachTileCoord(extent, zoom, callback) {
      var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);

      for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
        for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
          callback([zoom, i, j]);
        }
      }
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */

  }, {
    key: "forEachTileCoordParentTileRange",
    value: function forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
      var tileRange, x, y;
      var tileCoordExtent = null;
      var z = tileCoord[0] - 1;

      if (this.zoomFactor_ === 2) {
        x = tileCoord[1];
        y = tileCoord[2];
      } else {
        tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
      }

      while (z >= this.minZoom) {
        if (this.zoomFactor_ === 2) {
          x = Math.floor(x / 2);
          y = Math.floor(y / 2);
          tileRange = TileRange_createOrUpdate(x, x, y, y, tempTileRange);
        } else {
          tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
        }

        if (callback(z, tileRange)) {
          return true;
        }

        --z;
      }

      return false;
    }
    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */

  }, {
    key: "getExtent",
    value: function getExtent() {
      return this.extent_;
    }
    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */

  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return this.maxZoom;
    }
    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */

  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return this.minZoom;
    }
    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */

  }, {
    key: "getOrigin",
    value: function getOrigin(z) {
      if (this.origin_) {
        return this.origin_;
      } else {
        return this.origins_[z];
      }
    }
    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */

  }, {
    key: "getResolution",
    value: function getResolution(z) {
      return this.resolutions_[z];
    }
    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */

  }, {
    key: "getResolutions",
    value: function getResolutions() {
      return this.resolutions_;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */

  }, {
    key: "getTileCoordChildTileRange",
    value: function getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
      if (tileCoord[0] < this.maxZoom) {
        if (this.zoomFactor_ === 2) {
          var minX = tileCoord[1] * 2;
          var minY = tileCoord[2] * 2;
          return TileRange_createOrUpdate(minX, minX + 1, minY, minY + 1, tempTileRange);
        }

        var tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent || this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, tempTileRange);
      }

      return null;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */

  }, {
    key: "getTileRangeForTileCoordAndZ",
    value: function getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
      if (z > this.maxZoom || z < this.minZoom) {
        return null;
      }

      var tileCoordZ = tileCoord[0];
      var tileCoordX = tileCoord[1];
      var tileCoordY = tileCoord[2];

      if (z === tileCoordZ) {
        return TileRange_createOrUpdate(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);
      }

      if (this.zoomFactor_) {
        var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
        var minX = Math.floor(tileCoordX * factor);
        var minY = Math.floor(tileCoordY * factor);

        if (z < tileCoordZ) {
          return TileRange_createOrUpdate(minX, minX, minY, minY, tempTileRange);
        }

        var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
        var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
        return TileRange_createOrUpdate(minX, maxX, minY, maxY, tempTileRange);
      }

      var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
    }
    /**
     * Get the extent for a tile range.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} tileRange Tile range.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {import("../extent.js").Extent} Extent.
     */

  }, {
    key: "getTileRangeExtent",
    value: function getTileRangeExtent(z, tileRange, tempExtent) {
      var origin = this.getOrigin(z);
      var resolution = this.getResolution(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
      var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
      var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
      var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
      var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
      return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
    }
    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */

  }, {
    key: "getTileRangeForExtentAndZ",
    value: function getTileRangeForExtentAndZ(extent, z, tempTileRange) {
      var tileCoord = tmpTileCoord;
      this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
      var minX = tileCoord[1];
      var minY = tileCoord[2];
      this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
      return TileRange_createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], tempTileRange);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */

  }, {
    key: "getTileCoordCenter",
    value: function getTileCoordCenter(tileCoord) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
      return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];
    }
    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */

  }, {
    key: "getTileCoordExtent",
    value: function getTileCoordExtent(tileCoord, tempExtent) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
      var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
      var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
      var maxX = minX + tileSize[0] * resolution;
      var maxY = minY + tileSize[1] * resolution;
      return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
    }
    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */

  }, {
    key: "getTileCoordForCoordAndResolution",
    value: function getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
      return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    }
    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */

  }, {
    key: "getTileCoordForXYAndResolution_",
    value: function getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
      var z = this.getZForResolution(resolution);
      var scale = resolution / this.getResolution(z);
      var origin = this.getOrigin(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
      var tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];
      var tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];

      if (reverseIntersectionPolicy) {
        tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
        tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
      } else {
        tileCoordX = floor(tileCoordX, DECIMALS);
        tileCoordY = floor(tileCoordY, DECIMALS);
      }

      return tilecoord_createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
    }
    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */

  }, {
    key: "getTileCoordForXYAndZ_",
    value: function getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
      var origin = this.getOrigin(z);
      var resolution = this.getResolution(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
      var tileCoordX = (x - origin[0]) / resolution / tileSize[0];
      var tileCoordY = (origin[1] - y) / resolution / tileSize[1];

      if (reverseIntersectionPolicy) {
        tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
        tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
      } else {
        tileCoordX = floor(tileCoordX, DECIMALS);
        tileCoordY = floor(tileCoordY, DECIMALS);
      }

      return tilecoord_createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
    }
    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Zoom level.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */

  }, {
    key: "getTileCoordForCoordAndZ",
    value: function getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
      return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */

  }, {
    key: "getTileCoordResolution",
    value: function getTileCoordResolution(tileCoord) {
      return this.resolutions_[tileCoord[0]];
    }
    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */

  }, {
    key: "getTileSize",
    value: function getTileSize(z) {
      if (this.tileSize_) {
        return this.tileSize_;
      } else {
        return this.tileSizes_[z];
      }
    }
    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
     */

  }, {
    key: "getFullTileRange",
    value: function getFullTileRange(z) {
      if (!this.fullTileRanges_) {
        return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
      } else {
        return this.fullTileRanges_[z];
      }
    }
    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */

  }, {
    key: "getZForResolution",
    value: function getZForResolution(resolution, opt_direction) {
      var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
      return math_clamp(z, this.minZoom, this.maxZoom);
    }
    /**
     * The tile with the provided tile coordinate intersects the given viewport.
     * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
     * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
     * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
     */

  }, {
    key: "tileCoordIntersectsViewport",
    value: function tileCoordIntersectsViewport(tileCoord, viewport) {
      return intersectsLinearRing(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
    }
    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */

  }, {
    key: "calculateTileRanges_",
    value: function calculateTileRanges_(extent) {
      var length = this.resolutions_.length;
      var fullTileRanges = new Array(length);

      for (var z = this.minZoom; z < length; ++z) {
        fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
      }

      this.fullTileRanges_ = fullTileRanges;
    }
  }]);

  return TileGrid;
}();

/* harmony default export */ var tilegrid_TileGrid = (TileGrid_TileGrid);
;// CONCATENATED MODULE: ./node_modules/ol/tilegrid.js
/**
 * @module ol/tilegrid
 */





/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */

function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();

  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }

  return tileGrid;
}
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */

function tilegrid_wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);

  if (!containsCoordinate(projectionExtent, center)) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */

function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== undefined ? corner : 'top-left';
  var resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new tilegrid_TileGrid({
    extent: extent,
    origin: getCorner(extent, corner),
    resolutions: resolutions,
    tileSize: tileSize
  });
}
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */

function createXYZ(options) {
  var xyzOptions = options || {};
  var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new TileGrid(gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */

function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);
  var height = getHeight(extent);
  var width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);

  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
}
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */


function createForProjection(projection, maxZoom, tileSize, corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */

function extentFromProjection(projection) {
  projection = proj_get(projection);
  var extent = projection.getExtent();

  if (!extent) {
    var half = 180 * Units_METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }

  return extent;
}
;// CONCATENATED MODULE: ./node_modules/ol/source/Tile.js







/**
 * @module ol/source/Tile
 */










/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */

var TileSource = /*#__PURE__*/function (_Source) {
  _inherits(TileSource, _Source);

  var _super = createSuper_createSuper(TileSource);

  /**
   * @param {Options} options SourceTile source options.
   */
  function TileSource(options) {
    var _this;

    _classCallCheck(this, TileSource);

    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {TileSourceOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {boolean}
     */

    _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
    /**
     * @private
     * @type {number}
     */

    _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
    /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     */

    _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
    var tileSize = [256, 256];

    if (_this.tileGrid) {
      toSize(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);
    }
    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */


    _this.tileCache = new ol_TileCache(options.cacheSize || 0);
    /**
     * @protected
     * @type {import("../size.js").Size}
     */

    _this.tmpSize = [0, 0];
    /**
     * @private
     * @type {string}
     */

    _this.key_ = options.key || '';
    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */

    _this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */

    _this.zDirection = options.zDirection ? options.zDirection : 0;
    return _this;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  _createClass(TileSource, [{
    key: "canExpireCache",
    value: function canExpireCache() {
      return this.tileCache.canExpireCache();
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */

  }, {
    key: "expireCache",
    value: function expireCache(projection, usedTiles) {
      var tileCache = this.getTileCacheForProjection(projection);

      if (tileCache) {
        tileCache.expireCache(usedTiles);
      }
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {number} z Zoom level.
     * @param {import("../TileRange.js").default} tileRange Tile range.
     * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
     *     loaded tile.  If the callback returns `false`, the tile will not be
     *     considered loaded.
     * @return {boolean} The tile range is fully covered with loaded tiles.
     */

  }, {
    key: "forEachLoadedTile",
    value: function forEachLoadedTile(projection, z, tileRange, callback) {
      var tileCache = this.getTileCacheForProjection(projection);

      if (!tileCache) {
        return false;
      }

      var covered = true;
      var tile, tileCoordKey, loaded;

      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          tileCoordKey = getKeyZXY(z, x, y);
          loaded = false;

          if (tileCache.containsKey(tileCoordKey)) {
            tile =
            /** @type {!import("../Tile.js").default} */
            tileCache.get(tileCoordKey);
            loaded = tile.getState() === TileState.LOADED;

            if (loaded) {
              loaded = callback(tile) !== false;
            }
          }

          if (!loaded) {
            covered = false;
          }
        }
      }

      return covered;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */

  }, {
    key: "getGutterForProjection",
    value: function getGutterForProjection(projection) {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */

  }, {
    key: "getKey",
    value: function getKey() {
      return this.key_;
    }
    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */

  }, {
    key: "setKey",
    value: function setKey(key) {
      if (this.key_ !== key) {
        this.key_ = key;
        this.changed();
      }
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {boolean} Opaque.
     */

  }, {
    key: "getOpaque",
    value: function getOpaque(projection) {
      return this.opaque_;
    }
    /**
     * @return {Array<number>|null} Resolutions.
     */

  }, {
    key: "getResolutions",
    value: function getResolutions() {
      if (!this.tileGrid) {
        return null;
      }

      return this.tileGrid.getResolutions();
    }
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../Tile.js").default} Tile.
     */

  }, {
    key: "getTile",
    value: function getTile(z, x, y, pixelRatio, projection) {
      return util_abstract();
    }
    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
     * @api
     */

  }, {
    key: "getTileGrid",
    value: function getTileGrid() {
      return this.tileGrid;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */

  }, {
    key: "getTileGridForProjection",
    value: function getTileGridForProjection(projection) {
      if (!this.tileGrid) {
        return getForProjection(projection);
      } else {
        return this.tileGrid;
      }
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     * @protected
     */

  }, {
    key: "getTileCacheForProjection",
    value: function getTileCacheForProjection(projection) {
      var sourceProjection = this.getProjection();
      asserts_assert(sourceProjection === null || equivalent(sourceProjection, projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
      );
      return this.tileCache;
    }
    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */

  }, {
    key: "getTilePixelRatio",
    value: function getTilePixelRatio(pixelRatio) {
      return this.tilePixelRatio_;
    }
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */

  }, {
    key: "getTilePixelSize",
    value: function getTilePixelSize(z, pixelRatio, projection) {
      var tileGrid = this.getTileGridForProjection(projection);
      var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
      var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);

      if (tilePixelRatio == 1) {
        return tileSize;
      } else {
        return size_scale(tileSize, tilePixelRatio, this.tmpSize);
      }
    }
    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */

  }, {
    key: "getTileCoordForTileUrlFunction",
    value: function getTileCoordForTileUrlFunction(tileCoord, projection) {
      projection = projection !== undefined ? projection : this.getProjection();
      var tileGrid = this.getTileGridForProjection(projection);

      if (this.getWrapX() && projection.isGlobal()) {
        tileCoord = tilegrid_wrapX(tileGrid, tileCoord, projection);
      }

      return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
    }
    /**
     * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
     * @api
     */

  }, {
    key: "clear",
    value: function clear() {
      this.tileCache.clear();
    }
  }, {
    key: "refresh",
    value: function refresh() {
      this.clear();

      _get(getPrototypeOf_getPrototypeOf(TileSource.prototype), "refresh", this).call(this);
    }
    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */

  }, {
    key: "updateCacheSize",
    value: function updateCacheSize(tileCount, projection) {
      var tileCache = this.getTileCacheForProjection(projection);

      if (tileCount > tileCache.highWaterMark) {
        tileCache.highWaterMark = tileCount;
      }
    }
    /**
     * Marks a tile coord as being used, without triggering a load.
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */

  }, {
    key: "useTile",
    value: function useTile(z, x, y, projection) {}
  }]);

  return TileSource;
}(source_Source);
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */


var TileSourceEvent = /*#__PURE__*/function (_Event) {
  _inherits(TileSourceEvent, _Event);

  var _super2 = createSuper_createSuper(TileSourceEvent);

  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  function TileSourceEvent(type, tile) {
    var _this2;

    _classCallCheck(this, TileSourceEvent);

    _this2 = _super2.call(this, type);
    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */

    _this2.tile = tile;
    return _this2;
  }

  return _createClass(TileSourceEvent);
}(events_Event);
/* harmony default export */ var source_Tile = (TileSource);
;// CONCATENATED MODULE: ./node_modules/ol/tileurlfunction.js
/**
 * @module ol/tileurlfunction
 */



/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */

function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          asserts_assert(range, 55); // The {-y} placeholder requires a tile grid with extent

          var y = range.getHeight() - tileCoord[2] - 1;
          return y.toString();
        });
      }
    }
  );
}
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */

function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);

  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }

  return createFromTileUrlFunctions(tileUrlFunctions);
}
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */

function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }

  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = tilecoord_hash(tileCoord);
        var index = math_modulo(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */

function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */

function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);

  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;

    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }

    return urls;
  }

  match = /\{(\d+)-(\d+)\}/.exec(url);

  if (match) {
    // number range
    var stop = parseInt(match[2], 10);

    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }

    return urls;
  }

  urls.push(url);
  return urls;
}
;// CONCATENATED MODULE: ./node_modules/ol/source/UrlTile.js





/**
 * @module ol/source/UrlTile
 */






/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */

var UrlTile = /*#__PURE__*/function (_TileSource) {
  _inherits(UrlTile, _TileSource);

  var _super = createSuper_createSuper(UrlTile);

  /**
   * @param {Options} options Image tile options.
   */
  function UrlTile(options) {
    var _this;

    _classCallCheck(this, UrlTile);

    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    /**
     * @private
     * @type {boolean}
     */

    _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */

    _this.tileLoadFunction = options.tileLoadFunction;

    if (options.tileUrlFunction) {
      _this.tileUrlFunction = options.tileUrlFunction;
    }
    /**
     * @protected
     * @type {!Array<string>|null}
     */


    _this.urls = null;

    if (options.urls) {
      _this.setUrls(options.urls);
    } else if (options.url) {
      _this.setUrl(options.url);
    }
    /**
     * @private
     * @type {!Object<string, boolean>}
     */


    _this.tileLoadingKeys_ = {};
    return _this;
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */


  _createClass(UrlTile, [{
    key: "getTileLoadFunction",
    value: function getTileLoadFunction() {
      return this.tileLoadFunction;
    }
    /**
     * Return the tile URL function of the source.
     * @return {import("../Tile.js").UrlFunction} TileUrlFunction
     * @api
     */

  }, {
    key: "getTileUrlFunction",
    value: function getTileUrlFunction() {
      return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    }
    /**
     * Return the URLs used for this source.
     * When a tileUrlFunction is used instead of url or urls,
     * null will be returned.
     * @return {!Array<string>|null} URLs.
     * @api
     */

  }, {
    key: "getUrls",
    value: function getUrls() {
      return this.urls;
    }
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */

  }, {
    key: "handleTileChange",
    value: function handleTileChange(event) {
      var tile =
      /** @type {import("../Tile.js").default} */
      event.target;
      var uid = getUid(tile);
      var tileState = tile.getState();
      var type;

      if (tileState == TileState.LOADING) {
        this.tileLoadingKeys_[uid] = true;
        type = TileEventType.TILELOADSTART;
      } else if (uid in this.tileLoadingKeys_) {
        delete this.tileLoadingKeys_[uid];
        type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;
      }

      if (type != undefined) {
        this.dispatchEvent(new TileSourceEvent(type, tile));
      }
    }
    /**
     * Set the tile load function of the source.
     * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @api
     */

  }, {
    key: "setTileLoadFunction",
    value: function setTileLoadFunction(tileLoadFunction) {
      this.tileCache.clear();
      this.tileLoadFunction = tileLoadFunction;
      this.changed();
    }
    /**
     * Set the tile URL function of the source.
     * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
     * @param {string} [key] Optional new tile key for the source.
     * @api
     */

  }, {
    key: "setTileUrlFunction",
    value: function setTileUrlFunction(tileUrlFunction, key) {
      this.tileUrlFunction = tileUrlFunction;
      this.tileCache.pruneExceptNewestZ();

      if (typeof key !== 'undefined') {
        this.setKey(key);
      } else {
        this.changed();
      }
    }
    /**
     * Set the URL to use for requests.
     * @param {string} url URL.
     * @api
     */

  }, {
    key: "setUrl",
    value: function setUrl(url) {
      var urls = expandUrl(url);
      this.urls = urls;
      this.setUrls(urls);
    }
    /**
     * Set the URLs to use for requests.
     * @param {Array<string>} urls URLs.
     * @api
     */

  }, {
    key: "setUrls",
    value: function setUrls(urls) {
      this.urls = urls;
      var key = urls.join('\n');

      if (this.generateTileUrlFunction_) {
        this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
      } else {
        this.setKey(key);
      }
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */

  }, {
    key: "tileUrlFunction",
    value: function tileUrlFunction(tileCoord, pixelRatio, projection) {
      return undefined;
    }
    /**
     * Marks a tile coord as being used, without triggering a load.
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     */

  }, {
    key: "useTile",
    value: function useTile(z, x, y) {
      var tileCoordKey = getKeyZXY(z, x, y);

      if (this.tileCache.containsKey(tileCoordKey)) {
        this.tileCache.get(tileCoordKey);
      }
    }
  }]);

  return UrlTile;
}(source_Tile);

/* harmony default export */ var source_UrlTile = (UrlTile);
;// CONCATENATED MODULE: ./node_modules/ol/source/TileImage.js







/**
 * @module ol/source/TileImage
 */










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */

var TileImage = /*#__PURE__*/function (_UrlTile) {
  _inherits(TileImage, _UrlTile);

  var _super = createSuper_createSuper(TileImage);

  /**
   * @param {!Options} options Image tile options.
   */
  function TileImage(options) {
    var _this;

    _classCallCheck(this, TileImage);

    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== undefined ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    /**
     * @protected
     * @type {?string}
     */

    _this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @protected
     * @type {typeof ImageTile}
     */

    _this.tileClass = options.tileClass !== undefined ? options.tileClass : ol_ImageTile;
    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */

    _this.tileCacheForProjection = {};
    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */

    _this.tileGridForProjection = {};
    /**
     * @private
     * @type {number|undefined}
     */

    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderReprojectionEdges_ = false;
    return _this;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  _createClass(TileImage, [{
    key: "canExpireCache",
    value: function canExpireCache() {
      if (this.tileCache.canExpireCache()) {
        return true;
      } else {
        for (var key in this.tileCacheForProjection) {
          if (this.tileCacheForProjection[key].canExpireCache()) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */

  }, {
    key: "expireCache",
    value: function expireCache(projection, usedTiles) {
      var usedTileCache = this.getTileCacheForProjection(projection);
      this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});

      for (var id in this.tileCacheForProjection) {
        var tileCache = this.tileCacheForProjection[id];
        tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
      }
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */

  }, {
    key: "getGutterForProjection",
    value: function getGutterForProjection(projection) {
      if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
        return 0;
      } else {
        return this.getGutter();
      }
    }
    /**
     * @return {number} Gutter.
     */

  }, {
    key: "getGutter",
    value: function getGutter() {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */

  }, {
    key: "getKey",
    value: function getKey() {
      var key = _get(getPrototypeOf_getPrototypeOf(TileImage.prototype), "getKey", this).call(this);

      if (!this.getInterpolate()) {
        key += ':disable-interpolation';
      }

      return key;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {boolean} Opaque.
     */

  }, {
    key: "getOpaque",
    value: function getOpaque(projection) {
      if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
        return false;
      } else {
        return _get(getPrototypeOf_getPrototypeOf(TileImage.prototype), "getOpaque", this).call(this, projection);
      }
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */

  }, {
    key: "getTileGridForProjection",
    value: function getTileGridForProjection(projection) {
      var thisProj = this.getProjection();

      if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
        return this.tileGrid;
      } else {
        var projKey = getUid(projection);

        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = getForProjection(projection);
        }

        return this.tileGridForProjection[projKey];
      }
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     */

  }, {
    key: "getTileCacheForProjection",
    value: function getTileCacheForProjection(projection) {
      var thisProj = this.getProjection();

      if (!thisProj || equivalent(thisProj, projection)) {
        return this.tileCache;
      } else {
        var projKey = getUid(projection);

        if (!(projKey in this.tileCacheForProjection)) {
          this.tileCacheForProjection[projKey] = new ol_TileCache(this.tileCache.highWaterMark);
        }

        return this.tileCacheForProjection[projKey];
      }
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {string} key The key set on the tile.
     * @return {!ImageTile} Tile.
     * @private
     */

  }, {
    key: "createTile_",
    value: function createTile_(z, x, y, pixelRatio, projection, key) {
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
      var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
      tile.key = key;
      tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
      return tile;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     */

  }, {
    key: "getTile",
    value: function getTile(z, x, y, pixelRatio, projection) {
      var sourceProjection = this.getProjection();

      if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
      } else {
        var cache = this.getTileCacheForProjection(projection);
        var tileCoord = [z, x, y];
        var tile;
        var tileCoordKey = tilecoord_getKey(tileCoord);

        if (cache.containsKey(tileCoordKey)) {
          tile = cache.get(tileCoordKey);
        }

        var key = this.getKey();

        if (tile && tile.key == key) {
          return tile;
        } else {
          var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
          var targetTileGrid = this.getTileGridForProjection(projection);
          var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
          var newTile = new reproj_Tile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
          }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
          newTile.key = key;

          if (tile) {
            newTile.interimTile = tile;
            newTile.refreshInterimChain();
            cache.replace(tileCoordKey, newTile);
          } else {
            cache.set(tileCoordKey, newTile);
          }

          return newTile;
        }
      }
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {!import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     * @protected
     */

  }, {
    key: "getTileInternal",
    value: function getTileInternal(z, x, y, pixelRatio, projection) {
      var tile = null;
      var tileCoordKey = getKeyZXY(z, x, y);
      var key = this.getKey();

      if (!this.tileCache.containsKey(tileCoordKey)) {
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);
        this.tileCache.set(tileCoordKey, tile);
      } else {
        tile = this.tileCache.get(tileCoordKey);

        if (tile.key != key) {
          // The source's params changed. If the tile has an interim tile and if we
          // can use it then we use it. Otherwise we create a new tile.  In both
          // cases we attempt to assign an interim tile to the new tile.
          var interimTile = tile;
          tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,

          if (interimTile.getState() == TileState.IDLE) {
            //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
            tile.interimTile = interimTile.interimTile;
          } else {
            tile.interimTile = interimTile;
          }

          tile.refreshInterimChain();
          this.tileCache.replace(tileCoordKey, tile);
        }
      }

      return tile;
    }
    /**
     * Sets whether to render reprojection edges or not (usually for debugging).
     * @param {boolean} render Render the edges.
     * @api
     */

  }, {
    key: "setRenderReprojectionEdges",
    value: function setRenderReprojectionEdges(render) {
      if (this.renderReprojectionEdges_ == render) {
        return;
      }

      this.renderReprojectionEdges_ = render;

      for (var id in this.tileCacheForProjection) {
        this.tileCacheForProjection[id].clear();
      }

      this.changed();
    }
    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */

  }, {
    key: "setTileGridForProjection",
    value: function setTileGridForProjection(projection, tilegrid) {
      var proj = proj_get(projection);

      if (proj) {
        var projKey = getUid(proj);

        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      _get(getPrototypeOf_getPrototypeOf(TileImage.prototype), "clear", this).call(this);

      for (var id in this.tileCacheForProjection) {
        this.tileCacheForProjection[id].clear();
      }
    }
  }]);

  return TileImage;
}(source_UrlTile);
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */


function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */
  imageTile.getImage().src = src;
}

/* harmony default export */ var source_TileImage = (TileImage);
;// CONCATENATED MODULE: ./node_modules/ol/source/wms.js
/**
 * @module ol/source/wms
 */

/**
 * Default WMS version.
 * @type {string}
 */
var DEFAULT_VERSION = '1.3.0';
/**
 * @api
 * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType
 * Set the server type to use implementation-specific parameters beyond the WMS specification.
 *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
 *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)
 *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)
 *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)
 */
;// CONCATENATED MODULE: ./node_modules/ol/uri.js
/**
 * @module ol/uri
 */

/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
function appendParams(uri, params) {
  var keyParams = []; // Skip any null or undefined parameter values

  Object.keys(params).forEach(function (k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join('&'); // remove any trailing ? or &

  uri = uri.replace(/[?&]$/, ''); // append ? or & depending on whether uri has existing parameters

  uri += uri.includes('?') ? '&' : '?';
  return uri + qs;
}
;// CONCATENATED MODULE: ./node_modules/ol/string.js
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function string_padNumber(number, width, precision) {
  var numberString = precision !== undefined ? number.toFixed(precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */

function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }

    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}
;// CONCATENATED MODULE: ./node_modules/ol/source/TileWMS.js





/**
 * @module ol/source/TileWMS
 */











/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See https://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */

var TileWMS = /*#__PURE__*/function (_TileImage) {
  _inherits(TileWMS, _TileImage);

  var _super = createSuper_createSuper(TileWMS);

  /**
   * @param {Options} [options] Tile WMS options.
   */
  function TileWMS(options) {
    var _this;

    _classCallCheck(this, TileWMS);

    options = options ? options :
    /** @type {Options} */
    {};
    var params = Object.assign({}, options.params);
    var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = params;
    /**
     * @private
     * @type {boolean}
     */

    _this.v13_ = true;
    /**
     * @private
     * @type {import("./wms.js").ServerType}
     */

    _this.serverType_ = options.serverType;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.tmpExtent_ = createEmpty();

    _this.updateV13_();

    _this.setKey(_this.getKeyForParams_());

    return _this;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */


  _createClass(TileWMS, [{
    key: "getFeatureInfoUrl",
    value: function getFeatureInfoUrl(coordinate, resolution, projection, params) {
      var projectionObj = proj_get(projection);
      var sourceProjectionObj = this.getProjection();
      var tileGrid = this.getTileGrid();

      if (!tileGrid) {
        tileGrid = this.getTileGridForProjection(projectionObj);
      }

      var z = tileGrid.getZForResolution(resolution, this.zDirection);
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);

      if (tileGrid.getResolutions().length <= tileCoord[0]) {
        return undefined;
      }

      var tileResolution = tileGrid.getResolution(tileCoord[0]);
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
      var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
      var gutter = this.gutter_;

      if (gutter !== 0) {
        tileSize = size_buffer(tileSize, gutter, this.tmpSize);
        tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
      }

      if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
        tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
        tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);
        coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
      }

      var baseParams = {
        'SERVICE': 'WMS',
        'VERSION': DEFAULT_VERSION,
        'REQUEST': 'GetFeatureInfo',
        'FORMAT': 'image/png',
        'TRANSPARENT': true,
        'QUERY_LAYERS': this.params_['LAYERS']
      };
      Object.assign(baseParams, this.params_, params);
      var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
      var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
      baseParams[this.v13_ ? 'I' : 'X'] = x;
      baseParams[this.v13_ ? 'J' : 'Y'] = y;
      return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
    }
    /**
     * Return the GetLegendGraphic URL, optionally optimized for the passed
     * resolution and possibly including any passed specific parameters. Returns
     * `undefined` if the GetLegendGraphic URL cannot be constructed.
     *
     * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
     *     will not be calculated and included in URL.
     * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
     *     request is generated for this wms layer, else it will try to use the
     *     configured wms layer. Default `FORMAT` is `image/png`.
     *     `VERSION` should not be specified here.
     * @return {string|undefined} GetLegendGraphic URL.
     * @api
     */

  }, {
    key: "getLegendUrl",
    value: function getLegendUrl(resolution, params) {
      if (this.urls[0] === undefined) {
        return undefined;
      }

      var baseParams = {
        'SERVICE': 'WMS',
        'VERSION': DEFAULT_VERSION,
        'REQUEST': 'GetLegendGraphic',
        'FORMAT': 'image/png'
      };

      if (params === undefined || params['LAYER'] === undefined) {
        var layers = this.params_.LAYERS;
        var isSingleLayer = !Array.isArray(layers) || layers.length === 1;

        if (!isSingleLayer) {
          return undefined;
        }

        baseParams['LAYER'] = layers;
      }

      if (resolution !== undefined) {
        var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
        var pixelSize = 0.00028;
        baseParams['SCALE'] = resolution * mpu / pixelSize;
      }

      Object.assign(baseParams, params);
      return appendParams(
      /** @type {string} */
      this.urls[0], baseParams);
    }
    /**
     * @return {number} Gutter.
     */

  }, {
    key: "getGutter",
    value: function getGutter() {
      return this.gutter_;
    }
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */

  }, {
    key: "getParams",
    value: function getParams() {
      return this.params_;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../size.js").Size} tileSize Tile size.
     * @param {import("../extent.js").Extent} tileExtent Tile extent.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {Object} params Params.
     * @return {string|undefined} Request URL.
     * @private
     */

  }, {
    key: "getRequestUrl_",
    value: function getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
      var urls = this.urls;

      if (!urls) {
        return undefined;
      }

      params['WIDTH'] = tileSize[0];
      params['HEIGHT'] = tileSize[1];
      params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

      if (!('STYLES' in this.params_)) {
        params['STYLES'] = '';
      }

      if (pixelRatio != 1) {
        switch (this.serverType_) {
          case 'geoserver':
            var dpi = 90 * pixelRatio + 0.5 | 0;

            if ('FORMAT_OPTIONS' in params) {
              params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
            } else {
              params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
            }

            break;

          case 'mapserver':
            params['MAP_RESOLUTION'] = 90 * pixelRatio;
            break;

          case 'carmentaserver':
          case 'qgis':
            params['DPI'] = 90 * pixelRatio;
            break;

          default:
            // Unknown `serverType` configured
            asserts_assert(false, 52);
            break;
        }
      }

      var axisOrientation = projection.getAxisOrientation();
      var bbox = tileExtent;

      if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
        var tmp;
        tmp = tileExtent[0];
        bbox[0] = tileExtent[1];
        bbox[1] = tmp;
        tmp = tileExtent[2];
        bbox[2] = tileExtent[3];
        bbox[3] = tmp;
      }

      params['BBOX'] = bbox.join(',');
      var url;

      if (urls.length == 1) {
        url = urls[0];
      } else {
        var index = math_modulo(tilecoord_hash(tileCoord), urls.length);
        url = urls[index];
      }

      return appendParams(url, params);
    }
    /**
     * Get the tile pixel ratio for this source.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */

  }, {
    key: "getTilePixelRatio",
    value: function getTilePixelRatio(pixelRatio) {
      return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;
    }
    /**
     * @private
     * @return {string} The key for the current params.
     */

  }, {
    key: "getKeyForParams_",
    value: function getKeyForParams_() {
      var i = 0;
      var res = [];

      for (var key in this.params_) {
        res[i++] = key + '-' + this.params_[key];
      }

      return res.join('/');
    }
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */

  }, {
    key: "updateParams",
    value: function updateParams(params) {
      Object.assign(this.params_, params);
      this.updateV13_();
      this.setKey(this.getKeyForParams_());
    }
    /**
     * @private
     */

  }, {
    key: "updateV13_",
    value: function updateV13_() {
      var version = this.params_['VERSION'] || DEFAULT_VERSION;
      this.v13_ = compareVersions(version, '1.3') >= 0;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
     * @param {number} pixelRatio The pixel ratio
     * @param {import("../proj/Projection.js").default} projection The projection
     * @return {string|undefined} The tile URL
     * @override
     */

  }, {
    key: "tileUrlFunction",
    value: function tileUrlFunction(tileCoord, pixelRatio, projection) {
      var tileGrid = this.getTileGrid();

      if (!tileGrid) {
        tileGrid = this.getTileGridForProjection(projection);
      }

      if (tileGrid.getResolutions().length <= tileCoord[0]) {
        return undefined;
      }

      if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
        pixelRatio = 1;
      }

      var tileResolution = tileGrid.getResolution(tileCoord[0]);
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
      var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
      var gutter = this.gutter_;

      if (gutter !== 0) {
        tileSize = size_buffer(tileSize, gutter, this.tmpSize);
        tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
      }

      if (pixelRatio != 1) {
        tileSize = size_scale(tileSize, pixelRatio, this.tmpSize);
      }

      var baseParams = {
        'SERVICE': 'WMS',
        'VERSION': DEFAULT_VERSION,
        'REQUEST': 'GetMap',
        'FORMAT': 'image/png',
        'TRANSPARENT': true
      };
      Object.assign(baseParams, this.params_);
      return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
    }
  }]);

  return TileWMS;
}(source_TileImage);

/* harmony default export */ var source_TileWMS = (TileWMS);
;// CONCATENATED MODULE: ./node_modules/proj4/lib/global.js
/* harmony default export */ function global(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857

  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent

var PJD_NODATUM = 5; // WGS84 or equivalent

var SRS_WGS84_SEMIMAJOR = 6378137.0; // only used in grid shift transforms

var SRS_WGS84_SEMIMINOR = 6356752.314; // only used in grid shift transforms

var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms

var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI / 2; // ellipoid pj_set_ell.c

var SIXTH = 0.1666666666666666667;
/* 1/6 */

var RA4 = 0.04722222222222222222;
/* 17/360 */

var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10; // you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2; // SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.

var SPI = 3.14159265359;
;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/PrimeMeridian.js
var PrimeMeridian_exports = {};

PrimeMeridian_exports.greenwich = 0.0; //"0dE",

PrimeMeridian_exports.lisbon = -9.131906111111; //"9d07'54.862\"W",

PrimeMeridian_exports.paris = 2.337229166667; //"2d20'14.025\"E",

PrimeMeridian_exports.bogota = -74.080916666667; //"74d04'51.3\"W",

PrimeMeridian_exports.madrid = -3.687938888889; //"3d41'16.58\"W",

PrimeMeridian_exports.rome = 12.452333333333; //"12d27'8.4\"E",

PrimeMeridian_exports.bern = 7.439583333333; //"7d26'22.5\"E",

PrimeMeridian_exports.jakarta = 106.807719444444; //"106d48'27.79\"E",

PrimeMeridian_exports.ferro = -17.666666666667; //"17d40'W",

PrimeMeridian_exports.brussels = 4.367975; //"4d22'4.71\"E",

PrimeMeridian_exports.stockholm = 18.058277777778; //"18d3'29.8\"E",

PrimeMeridian_exports.athens = 23.7163375; //"23d42'58.815\"E",

PrimeMeridian_exports.oslo = 10.722916666667; //"10d43'22.5\"E"
;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/units.js
/* harmony default export */ var constants_units = ({
  ft: {
    to_meter: 0.3048
  },
  'us-ft': {
    to_meter: 1200 / 3937
  }
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match_match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }

  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;

  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');

    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projString.js




/* harmony default export */ function projString(defData) {
  var self = {};
  var paramObj = defData.split('+').map(function (v) {
    return v.trim();
  }).filter(function (a) {
    return a;
  }).reduce(function (p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function rf(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function lat_0(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function lat_1(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function lat_2(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function lat_ts(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function lon_0(v) {
      self.long0 = v * D2R;
    },
    lon_1: function lon_1(v) {
      self.long1 = v * D2R;
    },
    lon_2: function lon_2(v) {
      self.long2 = v * D2R;
    },
    alpha: function alpha(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    gamma: function gamma(v) {
      self.rectified_grid_angle = parseFloat(v);
    },
    lonc: function lonc(v) {
      self.longc = v * D2R;
    },
    x_0: function x_0(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function y_0(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function k_0(v) {
      self.k0 = parseFloat(v);
    },
    k: function k(v) {
      self.k0 = parseFloat(v);
    },
    a: function a(v) {
      self.a = parseFloat(v);
    },
    b: function b(v) {
      self.b = parseFloat(v);
    },
    r_a: function r_a() {
      self.R_A = true;
    },
    zone: function zone(v) {
      self.zone = parseInt(v, 10);
    },
    south: function south() {
      self.utmSouth = true;
    },
    towgs84: function towgs84(v) {
      self.datum_params = v.split(",").map(function (a) {
        return parseFloat(a);
      });
    },
    to_meter: function to_meter(v) {
      self.to_meter = parseFloat(v);
    },
    units: function units(v) {
      self.units = v;
      var unit = match_match(constants_units, v);

      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function from_greenwich(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function pm(v) {
      var pm = match_match(PrimeMeridian_exports, v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
    },
    nadgrids: function nadgrids(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      } else {
        self.nadgrids = v;
      }
    },
    axis: function axis(v) {
      var legalAxis = "ewnsud";

      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    },
    approx: function approx() {
      self.approx = true;
    }
  };

  for (paramName in paramObj) {
    paramVal = paramObj[paramName];

    if (paramName in params) {
      paramOutname = params[paramName];

      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      } else {
        self[paramOutname] = paramVal;
      }
    } else {
      self[paramName] = paramVal;
    }
  }

  if (typeof self.datumCode === 'string' && self.datumCode !== "WGS84") {
    self.datumCode = self.datumCode.toLowerCase();
  }

  return self;
}
;// CONCATENATED MODULE: ./node_modules/wkt-parser/parser.js
/* harmony default export */ var parser = (parser_parseString);
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var parser_whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/; // const ignoredChar = /[\s_\-\/\(\)]/g;

function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }

  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}

Parser.prototype.readCharicter = function () {
  var char = this.text[this.place++];

  if (this.state !== QUOTED) {
    while (parser_whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }

      char = this.text[this.place++];
    }
  }

  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);

    case KEYWORD:
      return this.keyword(char);

    case QUOTED:
      return this.quoted(char);

    case AFTERQUOTE:
      return this.afterquote(char);

    case NUMBER:
      return this.number(char);

    case ENDED:
      return;
  }
};

Parser.prototype.afterquote = function (char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }

  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in afterquote yet, index ' + this.place);
};

Parser.prototype.afterItem = function (char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }

    this.word = null;
    this.state = NEUTRAL;
    return;
  }

  if (char === ']') {
    this.level--;

    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }

    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();

    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};

Parser.prototype.number = function (char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }

  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in number yet, index ' + this.place);
};

Parser.prototype.quoted = function (char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }

  this.word += char;
  return;
};

Parser.prototype.keyword = function (char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }

  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;

    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }

    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }

  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in keyword yet, index ' + this.place);
};

Parser.prototype.neutral = function (char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }

  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }

  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }

  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in neutral yet, index ' + this.place);
};

Parser.prototype.output = function () {
  while (this.place < this.text.length) {
    this.readCharicter();
  }

  if (this.state === ENDED) {
    return this.root;
  }

  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};

function parser_parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
;// CONCATENATED MODULE: ./node_modules/wkt-parser/process.js
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }

  var thing = key ? {} : obj;
  var out = value.reduce(function (newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);

  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }

  var key = v.shift();

  if (key === 'PARAMETER') {
    key = v.shift();
  }

  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }

    obj[key] = v[0];
    return;
  }

  if (!v.length) {
    obj[key] = true;
    return;
  }

  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }

  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }

    obj[key].push(v);
    return;
  }

  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;

  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };

      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }

      return;

    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };

      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }

      return;

    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;

    default:
      i = -1;

      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }

      return mapit(obj, key, v);
  }
}
;// CONCATENATED MODULE: ./node_modules/wkt-parser/index.js
var wkt_parser_D2R = 0.01745329251994329577;



function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];

  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];

    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * wkt_parser_D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }

  if (wkt.AXIS) {
    var axisOrder = '';

    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];

      if (axis[0].indexOf('north') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north') {
        axisOrder += 'n';
      } else if (axis[0].indexOf('south') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south') {
        axisOrder += 's';
      } else if (axis[0].indexOf('east') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east') {
        axisOrder += 'e';
      } else if (axis[0].indexOf('west') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west') {
        axisOrder += 'w';
      }
    }

    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }

    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }

  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();

    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }

    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }

  var geogcs = wkt.GEOGCS;

  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }

  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }

    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }

    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }

    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }

      wkt.datumCode = 'wgs84';
    }

    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, -6);
    }

    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, -8);
    }

    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }

    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');

      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }

    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }

    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }

    if (~wkt.datumCode.indexOf('tm65') || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }

    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }

    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }

  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }

  var renamer = function renamer(a) {
    return rename(wkt, a);
  };

  var list = [['standard_parallel_1', 'Standard_Parallel_1'], ['standard_parallel_1', 'Latitude of 1st standard parallel'], ['standard_parallel_2', 'Standard_Parallel_2'], ['standard_parallel_2', 'Latitude of 2nd standard parallel'], ['false_easting', 'False_Easting'], ['false_easting', 'False easting'], ['false-easting', 'Easting at false origin'], ['false_northing', 'False_Northing'], ['false_northing', 'False northing'], ['false_northing', 'Northing at false origin'], ['central_meridian', 'Central_Meridian'], ['central_meridian', 'Longitude of natural origin'], ['central_meridian', 'Longitude of false origin'], ['latitude_of_origin', 'Latitude_Of_Origin'], ['latitude_of_origin', 'Central_Parallel'], ['latitude_of_origin', 'Latitude of natural origin'], ['latitude_of_origin', 'Latitude of false origin'], ['scale_factor', 'Scale_Factor'], ['k0', 'scale_factor'], ['latitude_of_center', 'Latitude_Of_Center'], ['latitude_of_center', 'Latitude_of_center'], ['lat0', 'latitude_of_center', d2r], ['longitude_of_center', 'Longitude_Of_Center'], ['longitude_of_center', 'Longitude_of_center'], ['longc', 'longitude_of_center', d2r], ['x0', 'false_easting', toMeter], ['y0', 'false_northing', toMeter], ['long0', 'central_meridian', d2r], ['lat0', 'latitude_of_origin', d2r], ['lat0', 'standard_parallel_1', d2r], ['lat1', 'standard_parallel_1', d2r], ['lat2', 'standard_parallel_2', d2r], ['azimuth', 'Azimuth'], ['alpha', 'azimuth', d2r], ['srsCode', 'name']];
  list.forEach(renamer);

  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }

  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}

/* harmony default export */ function wkt_parser(wkt) {
  var lisp = parser(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/defs.js




function defs_defs(name) {
  /*global console*/
  var that = this;

  if (arguments.length === 2) {
    var def = arguments[1];

    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs_defs[name] = projString(arguments[1]);
      } else {
        defs_defs[name] = wkt_parser(arguments[1]);
      }
    } else {
      defs_defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function (v) {
        if (Array.isArray(v)) {
          defs_defs.apply(that, v);
        } else {
          defs_defs(v);
        }
      });
    } else if (typeof name === 'string') {
      if (name in defs_defs) {
        return defs_defs[name];
      }
    } else if ('EPSG' in name) {
      defs_defs['EPSG:' + name.EPSG] = name;
    } else if ('ESRI' in name) {
      defs_defs['ESRI:' + name.ESRI] = name;
    } else if ('IAU2000' in name) {
      defs_defs['IAU2000:' + name.IAU2000] = name;
    } else {
      console.log(name);
    }

    return;
  }
}

global(defs_defs);
/* harmony default export */ var lib_defs = (defs_defs);
;// CONCATENATED MODULE: ./node_modules/proj4/lib/parseCode.js





function testObj(code) {
  return typeof code === 'string';
}

function testDef(code) {
  return code in lib_defs;
}

var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];

function testWKT(code) {
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}

var codes = ['3857', '900913', '3785', '102113'];

function checkMercator(item) {
  var auth = match_match(item, 'authority');

  if (!auth) {
    return;
  }

  var code = match_match(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}

function checkProjStr(item) {
  var ext = match_match(item, 'extension');

  if (!ext) {
    return;
  }

  return match_match(ext, 'proj4');
}

function testProj(code) {
  return code[0] === '+';
}

function parseCode_parse(code) {
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return lib_defs[code];
    }

    if (testWKT(code)) {
      var out = wkt_parser(code); // test of spetial case, due to this being a very common and often malformed

      if (checkMercator(out)) {
        return lib_defs["EPSG:3857"];
      }

      var maybeProjStr = checkProjStr(out);

      if (maybeProjStr) {
        return projString(maybeProjStr);
      }

      return out;
    }

    if (testProj(code)) {
      return projString(code);
    }
  } else {
    return code;
  }
}

/* harmony default export */ var parseCode = (parseCode_parse);
;// CONCATENATED MODULE: ./node_modules/proj4/lib/extend.js
/* harmony default export */ function lib_extend(destination, source) {
  destination = destination || {};
  var value, property;

  if (!source) {
    return destination;
  }

  for (property in source) {
    value = source[property];

    if (value !== undefined) {
      destination[property] = value;
    }
  }

  return destination;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/msfnz.js
/* harmony default export */ function msfnz(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sign.js
/* harmony default export */ function sign(x) {
  return x < 0 ? -1 : 1;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lon.js


/* harmony default export */ function adjust_lon(x) {
  return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/tsfnz.js

/* harmony default export */ function tsfnz(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/phi2z.js

/* harmony default export */ function phi2z(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);

  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //console.log("phi2z has NoConvergence");


  return -9999;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/merc.js





function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;

  if (!('x0' in this)) {
    this.x0 = 0;
  }

  if (!('y0' in this)) {
    this.y0 = 0;
  }

  this.e = Math.sqrt(this.es);

  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y; // convert to radians

  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;

  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }

    p.x = x;
    p.y = y;
    return p;
  }
}
/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/

function inverse(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);

    if (lat === -9999) {
      return null;
    }
  }

  lon = adjust_lon(this.long0 + x / (this.a * this.k0));
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ var merc = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/longlat.js
function longlat_init() {//no-op for longlat
}

function longlat_identity(pt) {
  return pt;
}



var longlat_names = ["longlat", "identity"];
/* harmony default export */ var longlat = ({
  init: longlat_init,
  forward: longlat_identity,
  inverse: longlat_identity,
  names: longlat_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections.js


var projs = [merc, longlat];
var projections_names = {};
var projStore = [];

function lib_projections_add(proj, i) {
  var len = projStore.length;

  if (!proj.names) {
    console.log(i);
    return true;
  }

  projStore[len] = proj;
  proj.names.forEach(function (n) {
    projections_names[n.toLowerCase()] = len;
  });
  return this;
}


function projections_get(name) {
  if (!name) {
    return false;
  }

  var n = name.toLowerCase();

  if (typeof projections_names[n] !== 'undefined' && projStore[projections_names[n]]) {
    return projStore[projections_names[n]];
  }
}
function start() {
  projs.forEach(lib_projections_add);
}
/* harmony default export */ var projections = ({
  start: start,
  add: lib_projections_add,
  get: projections_get
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Ellipsoid.js
var Ellipsoid_exports = {};

Ellipsoid_exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
Ellipsoid_exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
Ellipsoid_exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
Ellipsoid_exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
Ellipsoid_exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};
Ellipsoid_exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
Ellipsoid_exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
Ellipsoid_exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};
Ellipsoid_exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
Ellipsoid_exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
Ellipsoid_exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};
Ellipsoid_exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
Ellipsoid_exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
Ellipsoid_exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};
Ellipsoid_exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
Ellipsoid_exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
Ellipsoid_exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
Ellipsoid_exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
Ellipsoid_exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
Ellipsoid_exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
Ellipsoid_exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
Ellipsoid_exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
Ellipsoid_exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
Ellipsoid_exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
Ellipsoid_exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
Ellipsoid_exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
Ellipsoid_exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
Ellipsoid_exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
Ellipsoid_exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};
Ellipsoid_exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};
Ellipsoid_exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
Ellipsoid_exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
Ellipsoid_exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};
Ellipsoid_exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};
Ellipsoid_exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};
Ellipsoid_exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
Ellipsoid_exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};
Ellipsoid_exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};
Ellipsoid_exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};
Ellipsoid_exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};
Ellipsoid_exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = Ellipsoid_exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
Ellipsoid_exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};
;// CONCATENATED MODULE: ./node_modules/proj4/lib/deriveConstants.js



function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric

  var b2 = b * b; // used in geocentric

  var es = (a2 - b2) / a2; // e ^ 2

  var e = 0;

  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }

  var ep2 = (a2 - b2) / b2; // used in geocentric

  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function sphere(a, b, rf, ellps, sphere) {
  if (!a) {
    // do we have an ellipsoid?
    var ellipse = match_match(Ellipsoid_exports, ellps);

    if (!ellipse) {
      ellipse = WGS84;
    }

    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }

  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere = true;
    b = a;
  }

  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Datum.js
var Datum_exports = {};

Datum_exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
Datum_exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
Datum_exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
Datum_exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
Datum_exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
Datum_exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
Datum_exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
Datum_exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
Datum_exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
Datum_exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
Datum_exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
Datum_exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
Datum_exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
Datum_exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};
Datum_exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};
Datum_exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};
Datum_exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
;// CONCATENATED MODULE: ./node_modules/proj4/lib/datum.js


function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);

    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }

    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1000000.0 + 1.0;
      }
    }
  }

  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }

  out.a = a; //datum object also uses these values

  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ var lib_datum = (datum);
;// CONCATENATED MODULE: ./node_modules/proj4/lib/nadgrid.js
/**
 * Resources for details of NTv2 file formats:
 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
 */
var loadedNadgrids = {};
/**
 * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
 * as an ArrayBuffer.
 */

function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);

  if (header.nSubgrids > 1) {
    console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
  }

  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid = {
    header: header,
    subgrids: subgrids
  };
  loadedNadgrids[key] = nadgrid;
  return nadgrid;
}
/**
 * Given a proj4 value for nadgrids, return an array of loaded grids
 */

function getNadgrids(nadgrids) {
  // Format details: http://proj.maptools.org/gen_parms.html
  if (nadgrids === undefined) {
    return null;
  }

  var grids = nadgrids.split(',');
  return grids.map(parseNadgridString);
}

function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }

  var optional = value[0] === '@';

  if (optional) {
    value = value.slice(1);
  }

  if (value === 'null') {
    return {
      name: 'null',
      mandatory: !optional,
      grid: null,
      isNull: true
    };
  }

  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}

function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}

function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);

  if (nFields === 11) {
    return false;
  }

  nFields = view.getInt32(8, true);

  if (nFields !== 11) {
    console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
  }

  return true;
}

function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}

function decodeString(view, start, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
}

function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];

  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
    var latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval); // Proj4 operates on radians whereas the coordinates are in seconds in the grid

    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }

  return grids;
}

function mapNodes(nodes) {
  return nodes.map(function (r) {
    return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
  });
}

function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}

function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];

  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
    };
    gridShiftRecords.push(record);
  }

  return gridShiftRecords;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/Proj.js









function Proj_Projection(srsCode, callback) {
  if (!(this instanceof Proj_Projection)) {
    return new Proj_Projection(srsCode);
  }

  callback = callback || function (error) {
    if (error) {
      throw error;
    }
  };

  var json = parseCode(srsCode);

  if (typeof json !== 'object') {
    callback(srsCode);
    return;
  }

  var ourProj = Proj_Projection.projections.get(json.projName);

  if (!ourProj) {
    callback(srsCode);
    return;
  }

  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = match_match(Datum_exports, json.datumCode);

    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }

  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);
  lib_extend(this, json); // transfer everything over from the projection because we don't know what we'll need

  lib_extend(this, ourProj); // transfer all the methods from the projection
  // copy the 4 things over we calculated in deriveConstants.sphere

  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere; // copy the 3 things we calculated in deriveConstants.eccentricity

  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2; // add in the datum object

  this.datum = datumObj; // init the projection

  this.init(); // legecy callback from back in the day when it went to spatialreference.org

  callback(null, this);
}

Proj_Projection.projections = projections;
Proj_Projection.projections.start();
/* harmony default export */ var Proj = (Proj_Projection);
;// CONCATENATED MODULE: ./node_modules/proj4/lib/datumUtils.js



function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */

function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn;
  /*  Earth radius at location  */

  var Sin_Lat;
  /*  Math.sin(Latitude)  */

  var Sin2_Lat;
  /*  Square of Math.sin(Latitude)  */

  var Cos_Lat;
  /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */

  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return {
      x: -Infinity,
      y: -Infinity,
      z: p.z
    };
  } else if (Latitude > HALF_PI) {
    /* Latitude out of range */
    return {
      x: Infinity,
      y: Infinity,
      z: p.z
    };
  }

  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }

  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1.0e0 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */

  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  /* distance between semi-minor axis and location */

  var RR;
  /* distance between center and location */

  var CT;
  /* sin of geocentric latitude */

  var ST;
  /* cos of geocentric latitude */

  var RX;
  var RK;
  var RN;
  /* Earth radius at location */

  var CPHI0;
  /* cos of start or old geodetic latitude in iterations */

  var SPHI0;
  /* sin of start or old geodetic latitude in iterations */

  var CPHI;
  /* cos of searched geodetic latitude */

  var SPHI;
  /* sin of searched geodetic latitude */

  var SDPHI;
  /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */

  var iter;
  /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied

  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);
  /*      special cases for latitude and longitude */

  if (P / a < genau) {
    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;
    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */

    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }
  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */


  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */

  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);
    /*  ellipsoidal (geodetic) height */

    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  /*      ellipsoidal (geodetic) latitude */


  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)

/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/

function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6]; // if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)

function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF; //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()

}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/datum_transform.js




function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}

/* harmony default export */ function datum_transform(source, dest, point) {
  // Short cut if the datums are identical.
  if (compareDatums(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  } // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest


  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  } // If this datum requires grid shifts, then apply it to geodetic coordinates.


  var source_a = source.a;
  var source_es = source.es;

  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);

    if (gridShiftCode !== 0) {
      return undefined;
    }

    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }

  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;

  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  } // Do we need to go through geocentric coordinates?


  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  } // Convert to geocentric coordinates.


  point = geodeticToGeocentric(point, source_es, source_a); // Convert between datums

  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }

  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }

  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);

    if (destGridShiftResult !== 0) {
      return undefined;
    }
  }

  return point;
}
function applyGridShift(source, inverse, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log('Grid shift grids not found');
    return -1;
  }

  var input = {
    x: -point.x,
    y: point.y
  };
  var output = {
    x: Number.NaN,
    y: Number.NaN
  };
  var onlyMandatoryGrids = false;
  var attemptedGrids = [];

  for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);

    if (grid.isNull) {
      output = input;
      break;
    }

    onlyMandatoryGrids = grid.mandatory;

    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }

      continue;
    }

    var subgrid = grid.grid.subgrids[0]; // skip tables that don't match our point at all

    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;

    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
      continue;
    }

    output = applySubgridShift(input, inverse, subgrid);

    if (!isNaN(output.x)) {
      break;
    }
  }

  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }

  point.x = -output.x;
  point.y = output.y;
  return 0;
}

function applySubgridShift(pin, inverse, ct) {
  var val = {
    x: Number.NaN,
    y: Number.NaN
  };

  if (isNaN(pin.x)) {
    return val;
  }

  var tb = {
    x: pin.x,
    y: pin.y
  };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);

  if (inverse) {
    if (isNaN(t.x)) {
      return val;
    }

    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9,
        tol = 1e-12;
    var dif, del;

    do {
      del = nadInterpolate(t, ct);

      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }

      dif = {
        x: tb.x - (del.x + t.x),
        y: tb.y - (del.y + t.y)
      };
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);

    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }

    val.x = adjust_lon(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }

  return val;
}

function nadInterpolate(pin, ct) {
  var t = {
    x: pin.x / ct.del[0],
    y: pin.y / ct.del[1]
  };
  var indx = {
    x: Math.floor(t.x),
    y: Math.floor(t.y)
  };
  var frct = {
    x: t.x - 1.0 * indx.x,
    y: t.y - 1.0 * indx.y
  };
  var val = {
    x: Number.NaN,
    y: Number.NaN
  };
  var inx;

  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }

  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }

  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  inx++;
  var f10 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  inx += ct.lim[0];
  var f11 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  inx--;
  var f01 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  var m11 = frct.x * frct.y,
      m10 = frct.x * (1.0 - frct.y),
      m00 = (1.0 - frct.x) * (1.0 - frct.y),
      m01 = (1.0 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/adjust_axis.js
/* harmony default export */ function adjust_axis(crs, denorm, point) {
  var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
  var v, t, i;
  var out = {};

  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }

    if (i === 0) {
      v = xin;

      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = 'x';
      } else {
        t = 'y';
      }
    } else if (i === 1) {
      v = yin;

      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = 'y';
      } else {
        t = 'x';
      }
    } else {
      v = zin;
      t = 'z';
    }

    switch (crs.axis[i]) {
      case 'e':
        out[t] = v;
        break;

      case 'w':
        out[t] = -v;
        break;

      case 'n':
        out[t] = v;
        break;

      case 's':
        out[t] = -v;
        break;

      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }

        break;

      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }

        break;

      default:
        //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
    }
  }

  return out;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/toPoint.js
/* harmony default export */ function toPoint(array) {
  var out = {
    x: array[0],
    y: array[1]
  };

  if (array.length > 2) {
    out.z = array[2];
  }

  if (array.length > 3) {
    out.m = array[3];
  }

  return out;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/checkSanity.js
/* harmony default export */ function checkSanity(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}

function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }

    throw new TypeError('coordinates must be finite numbers');
  }

  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/transform.js







function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84';
}

function transform_transform(source, dest, point, enforceAxis) {
  var wgs84;

  if (Array.isArray(point)) {
    point = toPoint(point);
  }

  checkSanity(point); // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84

  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new Proj('WGS84');
    point = transform_transform(source, wgs84, point, enforceAxis);
    source = wgs84;
  } // DGR, 2010/11/12


  if (enforceAxis && source.axis !== 'enu') {
    point = adjust_axis(source, false, point);
  } // Transform source points to long/lat, if they aren't already.


  if (source.projName === 'longlat') {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }

    point = source.inverse(point); // Convert Cartesian to longlat

    if (!point) {
      return;
    }
  } // Adjust for the prime meridian if necessary


  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  } // Convert datums if needed, and if possible.


  point = datum_transform(source.datum, dest.datum, point);

  if (!point) {
    return;
  } // Adjust for the prime meridian if necessary


  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    // else project
    point = dest.forward(point);

    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  } // DGR, 2010/11/12


  if (enforceAxis && dest.axis !== 'enu') {
    return adjust_axis(dest, true, point);
  }

  return point;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/core.js


var wgs84 = Proj('WGS84');

function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;

  if (Array.isArray(coords)) {
    transformedArray = transform_transform(from, to, coords, enforceAxis) || {
      x: NaN,
      y: NaN
    };

    if (coords.length > 2) {
      if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
        if (typeof transformedArray.z === 'number') {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform_transform(from, to, coords, enforceAxis);
    keys = Object.keys(coords);

    if (keys.length === 2) {
      return out;
    }

    keys.forEach(function (key) {
      if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
        if (key === 'x' || key === 'y' || key === 'z') {
          return;
        }
      } else {
        if (key === 'x' || key === 'y') {
          return;
        }
      }

      out[key] = coords[key];
    });
    return out;
  }
}

function checkProj(item) {
  if (item instanceof Proj) {
    return item;
  }

  if (item.oProj) {
    return item.oProj;
  }

  return Proj(item);
}

function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;

  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }

  toProj = checkProj(toProj);

  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function forward(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function inverse(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };

    if (single) {
      obj.oProj = toProj;
    }

    return obj;
  }
}

/* harmony default export */ var core = (proj4);
;// CONCATENATED MODULE: ./node_modules/mgrs/mgrs.js
/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;
/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */

var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */

var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
var A = 65; // A

var I = 73; // I

var O = 79; // O

var V = 86; // V

var Z = 90; // Z

/* harmony default export */ var mgrs = ({
  forward: mgrs_forward,
  inverse: mgrs_inverse,
  toPoint: mgrs_toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */

function mgrs_forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m

  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
;
/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */

function mgrs_inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));

  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }

  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
;
function mgrs_toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));

  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }

  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
;
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */

function degToRad(deg) {
  return deg * (Math.PI / 180.0);
}
/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */


function radToDeg(rad) {
  return 180.0 * (rad / Math.PI);
}
/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */


function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;

  var eccSquared = 0.00669438; //ellip.eccsq;

  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber; // (int)

  ZoneNumber = Math.floor((Long + 180) / 6) + 1; //Make sure the longitude 180.00 is in Zone 60

  if (Long === 180) {
    ZoneNumber = 60;
  } // Special zone for Norway


  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  } // Special zones for Svalbard


  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    } else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    } else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    } else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone

  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;
  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));

  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */


function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber; // check the ZoneNummber is valid

  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;

  var eccSquared = 0.00669438; //ellip.eccsq;

  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad; // remove 500,000 meter offset for longitude

  var x = UTMEasting - 500000.0;
  var y = UTMNorthing; // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly

  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  } // There are 60 zones with zone 1 being at West -180 to -174


  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu); // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);
  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;

  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat: lat,
      lon: lon
    };
  }

  return result;
}
/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */


function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if (84 >= lat && lat >= 72) {
    LetterDesignator = 'X';
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = 'W';
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = 'V';
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = 'U';
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = 'T';
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = 'S';
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = 'R';
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = 'Q';
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = 'P';
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = 'N';
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = 'M';
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = 'L';
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = 'K';
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = 'J';
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = 'H';
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = 'G';
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = 'F';
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = 'E';
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = 'D';
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = 'C';
  }

  return LetterDesignator;
}
/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */


function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */


function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */


function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;

  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}
/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */


function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index); // colInt and rowInt are the letters to build to return

  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }

  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }

  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }

  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */


function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }

  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0; // get Zone number

  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }

    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }

  var zoneLetter = mgrsString.charAt(i++); // Should we check the zone letter here? Why not.

  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }

  hunK = mgrsString.substring(i, i += 2);
  var set = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set); // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  } // calculate the char index for easting/northing separator


  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }

  var sep = remainder / 2;
  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;

  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}
/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */


function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;

    if (curCol === I) {
      curCol++;
    }

    if (curCol === O) {
      curCol++;
    }

    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }

      curCol = A;
      rewindMarker = true;
    }

    eastingValue += 100000.0;
  }

  return eastingValue;
}
/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */


function getNorthingFromChar(n, set) {
  if (n > 'V') {
    throw "MGRSPoint given invalid Northing " + n;
  } // rowOrigin is the letter at the origin of the set for the
  // column


  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;

    if (curRow === I) {
      curRow++;
    }

    if (curRow === O) {
      curRow++;
    } // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character


    if (curRow > V) {
      if (rewindMarker) {
        // making sure that this loop ends
        throw "Bad character: " + n;
      }

      curRow = A;
      rewindMarker = true;
    }

    northingValue += 100000.0;
  }

  return northingValue;
}
/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */


function getMinNorthing(zoneLetter) {
  var northing;

  switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;

    case 'D':
      northing = 2000000.0;
      break;

    case 'E':
      northing = 2800000.0;
      break;

    case 'F':
      northing = 3700000.0;
      break;

    case 'G':
      northing = 4600000.0;
      break;

    case 'H':
      northing = 5500000.0;
      break;

    case 'J':
      northing = 6400000.0;
      break;

    case 'K':
      northing = 7300000.0;
      break;

    case 'L':
      northing = 8200000.0;
      break;

    case 'M':
      northing = 9100000.0;
      break;

    case 'N':
      northing = 0.0;
      break;

    case 'P':
      northing = 800000.0;
      break;

    case 'Q':
      northing = 1700000.0;
      break;

    case 'R':
      northing = 2600000.0;
      break;

    case 'S':
      northing = 3500000.0;
      break;

    case 'T':
      northing = 4400000.0;
      break;

    case 'U':
      northing = 5300000.0;
      break;

    case 'V':
      northing = 6200000.0;
      break;

    case 'W':
      northing = 7000000.0;
      break;

    case 'X':
      northing = 7900000.0;
      break;

    default:
      northing = -1.0;
  }

  if (northing >= 0.0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/Point.js


function Point_Point(x, y, z) {
  if (!(this instanceof Point_Point)) {
    return new Point_Point(x, y, z);
  }

  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if (typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }

  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point_Point.fromMGRS = function (mgrsStr) {
  return new Point_Point(mgrs_toPoint(mgrsStr));
};

Point_Point.prototype.toMGRS = function (accuracy) {
  return mgrs_forward([this.x, this.y], accuracy);
};

/* harmony default export */ var lib_Point = (Point_Point);
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_enfn.js
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;
/* harmony default export */ function pj_enfn(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_mlfn.js
/* harmony default export */ function pj_mlfn(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_inv_mlfn.js


var MAX_ITER = 20;
/* harmony default export */ function pj_inv_mlfn(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;

  for (var i = MAX_ITER; i; --i) {
    /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s; //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;

    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;

    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  } //..reportError("cass:pj_inv_mlfn: Convergence error");


  return phi;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tmerc.js
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js






function tmerc_init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */

function tmerc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if (Math.abs(Math.abs(b) - 1) < EPSLN) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if (b - 1 > EPSLN) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }

  p.x = x;
  p.y = y;
  return p;
}
/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */

function tmerc_inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  } else {
    // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);

    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = HALF_PI * sign(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var tmerc_names = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
/* harmony default export */ var tmerc = ({
  init: tmerc_init,
  forward: tmerc_forward,
  inverse: tmerc_inverse,
  names: tmerc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sinh.js
/* harmony default export */ function sinh(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/hypot.js
/* harmony default export */ function hypot(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/log1py.js
/* harmony default export */ function log1py(x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinhy.js


/* harmony default export */ function asinhy(x) {
  var y = Math.abs(x);
  y = log1py(y * (1 + y / (hypot(1, y) + 1)));
  return x < 0 ? -y : y;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gatg.js
/* harmony default export */ function gatg(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return B + h * Math.sin(2 * B);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens.js
/* harmony default export */ function clens(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/cosh.js
/* harmony default export */ function cosh(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens_cmplx.js


/* harmony default export */ function clens_cmplx(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/etmerc.js
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js








function etmerc_init() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }

  if (this.approx) {
    // When '+approx' is set, use tmerc instead
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
}
function etmerc_forward(p) {
  var Ce = adjust_lon(p.x - this.long0);
  var Cn = p.y;
  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));
  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;
  return p;
}
function etmerc_inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var etmerc_names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ var etmerc = ({
  init: etmerc_init,
  forward: etmerc_forward,
  inverse: etmerc_inverse,
  names: etmerc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_zone.js

/* harmony default export */ function adjust_zone(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }

  return zone;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/utm.js


var dependsOn = 'etmerc';

function utm_init() {
  var zone = adjust_zone(this.zone, this.long0);

  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }

  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;
  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}
var utm_names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ var utm = ({
  init: utm_init,
  names: utm_names,
  dependsOn: dependsOn
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/srat.js
/* harmony default export */ function srat(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gauss.js

var gauss_MAX_ITER = 20;

function gauss_init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}
function gauss_forward(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}
function gauss_inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);

  for (var i = gauss_MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;

    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }

    p.y = lat;
  }
  /* convergence failed */


  if (!i) {
    return null;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var gauss_names = ["gauss"];
/* harmony default export */ var gauss = ({
  init: gauss_init,
  forward: gauss_forward,
  inverse: gauss_inverse,
  names: gauss_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sterea.js


function sterea_init() {
  gauss.init.apply(this);

  if (!this.rc) {
    return;
  }

  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;

  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function sterea_forward(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function sterea_inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;

  if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
}
var sterea_names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
/* harmony default export */ var sterea = ({
  init: sterea_init,
  forward: sterea_forward,
  inverse: sterea_inverse,
  names: sterea_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/stere.js






function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function stere_init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);

  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      } else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }

    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));

    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }

    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
} // Stereographic forward equations--mapping lat,long to x,y

function stere_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }

  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);

    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0); //trace(p.toString());

      return p;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    } else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }

    p.x = A * cosX * Math.sin(dlon) + this.x0;
  } //trace(p.toString());


  return p;
} //* Stereographic inverse equations--mapping x,y to lat/long

function stere_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);

  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;

    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }

    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);

    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    } else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }

    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat; //trace(p.toString());

        return p;
      }

      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
    } else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;

      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }

      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }

  p.x = lon;
  p.y = lat; //trace(p.toString());

  return p;
}
var stere_names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ var stere = ({
  init: stere_init,
  forward: stere_forward,
  inverse: stere_inverse,
  names: stere_names,
  ssfn_: ssfn_
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/somerc.js
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */
function somerc_init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function somerc_forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K; // spheric latitude

  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4); // spheric longitude

  var I = this.alpha * (p.x - this.lambda0); // psoeudo equatorial rotation

  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function somerc_inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;

  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    } //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));


    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}
var somerc_names = ["somerc"];
/* harmony default export */ var somerc = ({
  init: somerc_init,
  forward: somerc_forward,
  inverse: somerc_inverse,
  names: somerc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/omerc.js




var TOL = 1e-7;

function isTypeA(P) {
  var typeAProjections = ['Hotine_Oblique_Mercator', 'Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
  return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
}
/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/


function omerc_init() {
  var con,
      com,
      cosph0,
      D,
      F,
      H,
      L,
      sinph0,
      p,
      J,
      gamma = 0,
      gamma0,
      lamc = 0,
      lam1 = 0,
      lam2 = 0,
      phi1 = 0,
      phi2 = 0,
      alpha_c = 0,
      AB; // only Type A uses the no_off or no_uoff property
  // https://github.com/OSGeo/proj.4/issues/104

  this.no_off = isTypeA(this);
  this.no_rot = 'no_rot' in this;
  var alp = false;

  if ("alpha" in this) {
    alp = true;
  }

  var gam = false;

  if ("rectified_grid_angle" in this) {
    gam = true;
  }

  if (alp) {
    alpha_c = this.alpha;
  }

  if (gam) {
    gamma = this.rectified_grid_angle * D2R;
  }

  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;

    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }

  var one_es = 1.0 - this.es;
  com = Math.sqrt(one_es);

  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D - 1;

    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);

      if (this.lat0 < 0) {
        F = -F;
      }
    }

    this.E = F += D;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }

  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);

      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }

    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;

    if (con < -Math.pi) {
      lam2 -= TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }

    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }

  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  AB = this.A * this.B;

  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));

    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }

  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}
/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/

function omerc_forward(p) {
  var coords = {};
  var S, T, U, V, W, temp, u, v;
  p.x = p.x - this.lam0;

  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V = Math.sin(this.B * p.x);
    U = (S * this.singam - V * this.cosgam) / T;

    if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
      throw new Error();
    }

    v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
    temp = Math.cos(this.B * p.x);

    if (Math.abs(temp) < TOL) {
      u = this.A * p.x;
    } else {
      u = this.ArB * Math.atan2(S * this.cosgam + V * this.singam, temp);
    }
  } else {
    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p.y;
  }

  if (this.no_rot) {
    coords.x = u;
    coords.y = v;
  } else {
    u -= this.u_0;
    coords.x = v * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v * this.sinrot;
  }

  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function omerc_inverse(p) {
  var u, v, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p.x = (p.x - this.x0) * (1.0 / this.a);
  p.y = (p.y - this.y0) * (1.0 / this.a);

  if (this.no_rot) {
    v = p.y;
    u = p.x;
  } else {
    v = p.x * this.cosrot - p.y * this.sinrot;
    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }

  Qp = Math.exp(-this.BrA * v);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;

  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));

    if (coords.y === Infinity) {
      throw new Error();
    }

    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
  }

  coords.x += this.lam0;
  return coords;
}
var omerc_names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
/* harmony default export */ var omerc = ({
  init: omerc_init,
  forward: omerc_forward,
  inverse: omerc_inverse,
  names: omerc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/lcc.js






function lcc_init() {
  //double lat0;                    /* the reference latitude               */
  //double long0;                   /* the reference longitude              */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */
  //the above value can be set with proj4.defs
  //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined


  if (!this.k0) {
    this.k0 = 1;
  }

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0; // Standard Parallels cannot be equal and on opposite sides of the equator

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);
  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }

  if (isNaN(this.ns)) {
    this.ns = sin1;
  }

  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);

  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
} // Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function lcc_forward(p) {
  var lon = p.x;
  var lat = p.y; // singular cases :

  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;

  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;

    if (con <= 0) {
      return null;
    }

    rh1 = 0;
  }

  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
} // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function lcc_inverse(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;

  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }

  var theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }

  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z(this.e, ts);

    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }

  lon = adjust_lon(theta / this.ns + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
var lcc_names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"];
/* harmony default export */ var lcc = ({
  init: lcc_init,
  forward: lcc_forward,
  inverse: lcc_inverse,
  names: lcc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/krovak.js

function krovak_init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);

  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }

  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */


  if (!this.k0) {
    this.k0 = 0.9999;
  }

  this.s45 = 0.785398163397448;
  /* 45 */

  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
/* ellipsoid */

/* calculate xy from lat/lon */

/* Constants, identical to inverse transform function */

function krovak_forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */

  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }

  return p;
}
/* calculate lat/lon from xy */

function krovak_inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;
  /* Transformation */

  /* revert y, x*/

  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }

  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;

  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);

    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }

    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);

  if (iter >= 15) {
    return null;
  }

  return p;
}
var krovak_names = ["Krovak", "krovak"];
/* harmony default export */ var krovak = ({
  init: krovak_init,
  forward: krovak_forward,
  inverse: krovak_inverse,
  names: krovak_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/mlfn.js
/* harmony default export */ function mlfn(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e0fn.js
/* harmony default export */ function e0fn(x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e1fn.js
/* harmony default export */ function e1fn(x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e2fn.js
/* harmony default export */ function e2fn(x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e3fn.js
/* harmony default export */ function e3fn(x) {
  return x * x * x * (35 / 3072);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gN.js
/* harmony default export */ function gN(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lat.js


/* harmony default export */ function adjust_lat(x) {
  return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/imlfn.js
/* harmony default export */ function imlfn(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;

  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");


  return NaN;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cass.js










function cass_init() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/

function cass_forward(p) {
  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function cass_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);

    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;

      if (y < 0) {
        p.y *= -1;
      }

      return p;
    }

    var nl1 = gN(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;
}
var cass_names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ var cass = ({
  init: cass_init,
  forward: cass_forward,
  inverse: cass_inverse,
  names: cass_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/qsfnz.js
/* harmony default export */ function qsfnz(eccent, sinphi) {
  var con;

  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/laea.js



/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/

function laea_init() {
  var t = Math.abs(this.lat0);

  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }

  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);

    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;

      case this.S_POLE:
        this.dd = 1;
        break;

      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;

      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/

function laea_forward(p) {
  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;

      if (y <= EPSLN) {
        return null;
      }

      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }

      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }

      y = FORTPI - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }

    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;

      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;

      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;

      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
    }

    if (Math.abs(b) < EPSLN) {
      return null;
    }

    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);

        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }

        x = this.xmf * b * cosb * sinlam;
        break;

      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }

        break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function laea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;

  if (this.sphere) {
    var cosz = 0,
        rh,
        sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;

    if (phi > 1) {
      return null;
    }

    phi = 2 * Math.asin(phi);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }

    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;

      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;

      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;

      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }

    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab = 0;

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);

      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }

      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);

      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }

      q = x * x + y * y;

      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }

      ab = 1 - q / this.qp;

      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }

    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
}
/* determine latitude from authalic latitude */

var P00 = 0.33333333333333333333;
var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}

var laea_names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ var laea = ({
  init: laea_init,
  forward: laea_forward,
  inverse: laea_inverse,
  names: laea_names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinz.js
/* harmony default export */ function asinz(x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }

  return Math.asin(x);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aea.js





function aea_init() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }

  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/

function aea_forward(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function aea_inverse(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;

  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }

  theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  con = rh1 * this.ns0 / this.a;

  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/

function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);

  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;

  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;

    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }

  return null;
}
var aea_names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ var aea = ({
  init: aea_init,
  forward: aea_forward,
  inverse: aea_inverse,
  names: aea_names,
  phi1z: phi1z
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gnom.js



/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */

function gnom_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0); // Approximation for projecting points to the horizon (infinity)

  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}
/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function gnom_forward(p) {
  var sinphi, cosphi;
  /* sin and cos value        */

  var dlon;
  /* delta longitude value      */

  var coslon;
  /* cos of longitude        */

  var ksp;
  /* scale factor          */

  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;

  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }

  p.x = x;
  p.y = y;
  return p;
}
function gnom_inverse(p) {
  var rh;
  /* Rho */

  var sinc, cosc;
  var c;
  var lon, lat;
  /* Inverse equations
      -----------------*/

  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;

  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var gnom_names = ["gnom"];
/* harmony default export */ var gnom = ({
  init: gnom_init,
  forward: gnom_forward,
  inverse: gnom_inverse,
  names: gnom_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/iqsfnz.js

/* harmony default export */ function iqsfnz(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));

  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  } //var phi = 0.5* q/(1-eccent*eccent);


  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;

  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");


  return NaN;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cea.js




/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/

function cea_init() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/

function cea_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/

  var dlon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}
/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/

function cea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var cea_names = ["cea"];
/* harmony default export */ var cea = ({
  init: cea_init,
  forward: cea_forward,
  inverse: cea_inverse,
  names: cea_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqc.js


function eqc_init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
} // forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function eqc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
} // inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function eqc_inverse(p) {
  var x = p.x;
  var y = p.y;
  p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
  p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var eqc_names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ var eqc = ({
  init: eqc_init,
  forward: eqc_forward,
  inverse: eqc_inverse,
  names: eqc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/poly.js









var poly_MAX_ITER = 20;
function poly_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles

  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}
/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function poly_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);

  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function poly_inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;

      for (i = poly_MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;

        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;

      for (i = poly_MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;

        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      } //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);


      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var poly_names = ["Polyconic", "poly"];
/* harmony default export */ var poly = ({
  init: poly_init,
  forward: poly_forward,
  inverse: poly_inverse,
  names: poly_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/nzmg.js

/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */

var iterations = 1;
function nzmg_init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}
/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */

function nzmg_forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0; // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.

  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;

  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  } // 2. Calculate theta


  var th_re = d_psi;
  var th_im = d_lambda; // 3. Calculate z

  var th_n_re = 1;
  var th_n_im = 0; // theta^0

  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;

  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  } // 4. Calculate easting and northing


  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}
/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */

function nzmg_inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0; // 1. Calculate z

  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a; // 2a. Calculate theta - first approximation gives km accuracy

  var z_n_re = 1;
  var z_n_im = 0; // z^0

  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;

  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  } // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy


  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;

    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];

    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    } // Complex division


    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  } // 3. Calculate d_phi              ...                                    // and d_lambda


  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;

  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  } // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.


  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1E5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var nzmg_names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ var nzmg = ({
  init: nzmg_init,
  forward: nzmg_forward,
  inverse: nzmg_inverse,
  names: nzmg_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/mill.js

/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/

function mill_init() {//no-op
}
/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/

function mill_forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}
/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/

function mill_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var mill_names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ var mill = ({
  init: mill_init,
  forward: mill_forward,
  inverse: mill_inverse,
  names: mill_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sinu.js



var sinu_MAX_ITER = 20;




function sinu_init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/
  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/

function sinu_forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/

  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);

      for (var i = sinu_MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;

        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }

    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}
function sinu_inverse(p) {
  var lat, temp, lon, s;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));

    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }

    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  } else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);

    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat)); //temp = this.long0 + p.x / (this.a * Math.cos(lat));

      lon = adjust_lon(temp);
    } else if (s - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var sinu_names = ["Sinusoidal", "sinu"];
/* harmony default export */ var sinu = ({
  init: sinu_init,
  forward: sinu_forward,
  inverse: sinu_inverse,
  names: sinu_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/moll.js

function moll_init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/

function moll_forward(p) {
  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/

  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;

    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }

  theta /= 2;
  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/

  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }

  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function moll_inverse(p) {
  var theta;
  var arg;
  /* Inverse equations
      -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);
  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/

  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }

  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));

  if (lon < -Math.PI) {
    lon = -Math.PI;
  }

  if (lon > Math.PI) {
    lon = Math.PI;
  }

  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;

  if (Math.abs(arg) > 1) {
    arg = 1;
  }

  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var moll_names = ["Mollweide", "moll"];
/* harmony default export */ var moll = ({
  init: moll_init,
  forward: moll_forward,
  inverse: moll_inverse,
  names: moll_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqdc.js










function eqdc_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }

  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/

function eqdc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;
  /* Forward equations
      -----------------*/

  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }

  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}
/* Inverse equations
  -----------------*/

function eqdc_inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;

  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }

  var theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var eqdc_names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ var eqdc = ({
  init: eqdc_init,
  forward: eqdc_forward,
  inverse: eqdc_inverse,
  names: eqdc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/vandg.js



/* Initialize the Van Der Grinten projection
  ----------------------------------------*/

function vandg_init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}
function vandg_forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/

  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }

  var theta = asinz(2 * Math.abs(lat / Math.PI));

  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x = this.x0;

    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    } //  return(OK);

  }

  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);

  if (dlon < 0) {
    con = -con;
  }

  x = this.x0 + con; //con = Math.abs(con / (Math.PI * this.R));

  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);

  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  } else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }

  p.x = x;
  p.y = y;
  return p;
}
/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/

function vandg_inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  /* inverse equations
    -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;

  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }

  th1 = Math.acos(con) / 3;

  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var vandg_names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ var vandg = ({
  init: vandg_init,
  forward: vandg_forward,
  inverse: vandg_inverse,
  names: vandg_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aeqd.js










function aeqd_init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function aeqd_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;

  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    } else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);

    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));

      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }

      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }
}
function aeqd_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;

  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);

    if (rh > 2 * HALF_PI * this.a) {
      return;
    }

    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;

    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;

      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
        } else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      } else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);

    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }
}
var aeqd_names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ var aeqd = ({
  init: aeqd_init,
  forward: aeqd_forward,
  inverse: aeqd_inverse,
  names: aeqd_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/ortho.js



function ortho_init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function ortho_forward(p) {
  var sinphi, cosphi;
  /* sin and cos value        */

  var dlon;
  /* delta longitude value      */

  var coslon;
  /* cos of longitude        */

  var ksp;
  /* scale factor          */

  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;

  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }

  p.x = x;
  p.y = y;
  return p;
}
function ortho_inverse(p) {
  var rh;
  /* height above ellipsoid      */

  var z;
  /* angle          */

  var sinz, cosz;
  /* sin of z and cos of z      */

  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;

  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }

  lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;

  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
    } else {
      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}
var ortho_names = ["ortho"];
/* harmony default export */ var ortho = ({
  init: ortho_init,
  forward: ortho_forward,
  inverse: ortho_inverse,
  names: ortho_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/qsc.js
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

/* constants */

var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function qsc_init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  /* Determine the cube face from the center of projection. */

  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */


  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
} // QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function qsc_forward(p) {
  var xy = {
    x: 0,
    y: 0
  };
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */

  var area = {
    value: 0
  }; // move lon according to projection's lon

  p.x -= this.long0;
  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */

  if (this.es !== 0) {
    //if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }
  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */


  lon = p.x; //lon = lp.lam;

  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;

    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0.0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;

    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0.0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }

    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */


  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  /* Apply the result to the real area. */

  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  /* Now compute x, y from mu and nu */


  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
} // QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function qsc_inverse(p) {
  var lp = {
    lam: 0,
    phi: 0
  };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {
    value: 0
  };
  /* de-offset */

  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */

  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);

  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0.0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */


  t = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));

  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }
  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */


  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;

    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0.0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else
      /* area.value == AREA_ENUM.AREA_3 */
      {
        lp.lam = theta;
      }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;

    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else
      /* area.value == AREA_ENUM.AREA_3 */
      {
        lp.lam = theta < 0.0 ? -theta - SPI : -theta + SPI;
      }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;

    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }

    t += s * s;

    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */


    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */


    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */


    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);

    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */


  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));

    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}
/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */

function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;

  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);

    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0.0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }

  return theta;
}
/* Helper function: shift the longitude. */


function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;

  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }

  return slon;
}

var qsc_names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ var qsc = ({
  init: qsc_init,
  forward: qsc_forward,
  inverse: qsc_inverse,
  names: qsc_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/robin.js
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039


var COEFS_X = [[1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06], [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06], [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07], [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06], [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06], [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08], [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06], [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06], [0.9216, -0.00467746, -0.00010457, 4.81243e-06], [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06], [0.8679, -0.00609363, -0.000113898, 3.32484e-06], [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07], [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07], [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06], [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06], [0.6732, -0.00986209, -0.000199569, 1.91974e-05], [0.6213, -0.010418, 8.83923e-05, 6.24051e-06], [0.5722, -0.00906601, 0.000182, 6.24051e-06], [0.5322, -0.00677797, 0.000275608, 6.24051e-06]];
var COEFS_Y = [[-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11], [0.0620, 0.0124, -1.26793e-09, 4.22642e-10], [0.1240, 0.0124, 5.07171e-09, -1.60604e-09], [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09], [0.2480, 0.0124002, 7.10039e-08, -2.24e-08], [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08], [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07], [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07], [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07], [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07], [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07], [0.6769, 0.011713, -3.20223e-05, -5.16405e-07], [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07], [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06], [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09], [0.8936, 0.00969686, -6.4636e-05, -8.547e-06], [0.9394, 0.00840947, -0.000192841, -4.2106e-06], [0.9761, 0.00616527, -0.000256, -4.2106e-06], [1.0000, 0.00328947, -0.000319159, -4.2106e-06]];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5; // rad to 5-degree interval

var RC1 = 1 / C1;
var NODES = 18;

var poly3_val = function poly3_val(coefs, x) {
  return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};

var poly3_der = function poly3_der(coefs, x) {
  return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};

function newton_rapshon(f_df, start, max_err, iters) {
  var x = start;

  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;

    if (Math.abs(upd) < max_err) {
      break;
    }
  }

  return x;
}

function robin_init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function robin_forward(ll) {
  var lon = adjust_lon(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);

  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }

  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };

  if (ll.y < 0) {
    xy.y = -xy.y;
  }

  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function robin_inverse(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };

  if (ll.y >= 1) {
    // pathologic case
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    // find table interval
    var i = Math.floor(ll.y * NODES);

    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }

    for (;;) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    } // linear interpolation in 5 degree interval


    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]); // find t so that poly3_val(coefs, t) = ll.y

    t = newton_rapshon(function (x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * D2R;

    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }

  ll.x = adjust_lon(ll.x + this.long0);
  return ll;
}
var robin_names = ["Robinson", "robin"];
/* harmony default export */ var robin = ({
  init: robin_init,
  forward: robin_forward,
  inverse: robin_inverse,
  names: robin_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geocent.js

function geocent_init() {
  this.name = 'geocent';
}
function geocent_forward(p) {
  var point = geodeticToGeocentric(p, this.es, this.a);
  return point;
}
function geocent_inverse(p) {
  var point = geocentricToGeodetic(p, this.es, this.a, this.b);
  return point;
}
var geocent_names = ["Geocentric", 'geocentric', "geocent", "Geocent"];
/* harmony default export */ var geocent = ({
  init: geocent_init,
  forward: geocent_forward,
  inverse: geocent_inverse,
  names: geocent_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tpers.js
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};


var params = {
  h: {
    def: 100000,
    num: true
  },
  // default is Karman line, no default in PROJ.7
  azi: {
    def: 0,
    num: true,
    degrees: true
  },
  // default is North
  tilt: {
    def: 0,
    num: true,
    degrees: true
  },
  // default is Nadir
  long0: {
    def: 0,
    num: true
  },
  // default is Greenwich, conversion to rad is automatic
  lat0: {
    def: 0,
    num: true
  } // default is Equator, conversion to rad is automatic

};
function tpers_init() {
  Object.keys(params).forEach(function (p) {
    if (typeof this[p] === "undefined") {
      this[p] = params[p].def;
    } else if (params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (params[p].num) {
      this[p] = parseFloat(this[p]);
    }

    if (params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }.bind(this));

  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }

  this.pn1 = this.h / this.a; // Normalize relative to the Earth's radius

  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }

  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function tpers_forward(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;

  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;

    case mode.EQUIT:
      y = cosphi * coslam;
      break;

    case mode.S_POLE:
      y = -sinphi;
      break;

    case mode.N_POLE:
      y = sinphi;
      break;
  }

  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);

  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;

    case mode.EQUIT:
      y *= sinphi;
      break;

    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;

    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  } // Tilt 


  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;
  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}
function tpers_inverse(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = {
    x: p.x,
    y: p.y
  }; // Un-Tilt

  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;
  var rh = hypot(p.x, p.y);

  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);

    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;

      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;

      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;

      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }

    r.x = Math.atan2(p.x, p.y);
  }

  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}
var tpers_names = ["Tilted_Perspective", "tpers"];
/* harmony default export */ var tpers = ({
  init: tpers_init,
  forward: tpers_forward,
  inverse: tpers_inverse,
  names: tpers_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geos.js

function geos_init() {
  this.flip_axis = this.sweep === 'x' ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;

  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }

  this.radius_g = 1.0 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1.0;

  if (this.es !== 0.0) {
    var one_es = 1.0 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = 'ellipse'; // Use as a condition in the forward and inverse functions.
  } else {
    this.radius_p = 1.0;
    this.radius_p2 = 1.0;
    this.radius_p_inv2 = 1.0;
    this.shape = 'sphere'; // Use as a condition in the forward and inverse functions.
  }

  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}

function geos_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;

  if (this.shape === 'ellipse') {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r * Math.cos(lon) * Math.cos(lat);
    v_y = r * Math.sin(lon) * Math.cos(lat);
    v_z = r * Math.sin(lat);

    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0.0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }

    tmp = this.radius_g - v_x;

    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
    }
  } else if (this.shape === 'sphere') {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;

    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
    }
  }

  p.x = p.x * this.a;
  p.y = p.y * this.a;
  return p;
}

function geos_inverse(p) {
  var v_x = -1.0;
  var v_y = 0.0;
  var v_z = 0.0;
  var a, b, det, k;
  p.x = p.x / this.a;
  p.y = p.y / this.a;

  if (this.shape === 'ellipse') {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * hypot(1.0, v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * hypot(1.0, v_y);
    }

    var v_zp = v_z / this.radius_p;
    a = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;

    if (det < 0.0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }

    k = (-b - Math.sqrt(det)) / (2.0 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
  } else if (this.shape === 'sphere') {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);
    }

    a = v_y * v_y + v_z * v_z + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;

    if (det < 0.0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }

    k = (-b - Math.sqrt(det)) / (2.0 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
  }

  p.x = p.x + this.long0;
  return p;
}

var geos_names = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
/* harmony default export */ var geos = ({
  init: geos_init,
  forward: geos_forward,
  inverse: geos_inverse,
  names: geos_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/projs.js





























/* harmony default export */ function proj4_projs(proj4) {
  proj4.Proj.projections.add(tmerc);
  proj4.Proj.projections.add(etmerc);
  proj4.Proj.projections.add(utm);
  proj4.Proj.projections.add(sterea);
  proj4.Proj.projections.add(stere);
  proj4.Proj.projections.add(somerc);
  proj4.Proj.projections.add(omerc);
  proj4.Proj.projections.add(lcc);
  proj4.Proj.projections.add(krovak);
  proj4.Proj.projections.add(cass);
  proj4.Proj.projections.add(laea);
  proj4.Proj.projections.add(aea);
  proj4.Proj.projections.add(gnom);
  proj4.Proj.projections.add(cea);
  proj4.Proj.projections.add(eqc);
  proj4.Proj.projections.add(poly);
  proj4.Proj.projections.add(nzmg);
  proj4.Proj.projections.add(mill);
  proj4.Proj.projections.add(sinu);
  proj4.Proj.projections.add(moll);
  proj4.Proj.projections.add(eqdc);
  proj4.Proj.projections.add(vandg);
  proj4.Proj.projections.add(aeqd);
  proj4.Proj.projections.add(ortho);
  proj4.Proj.projections.add(qsc);
  proj4.Proj.projections.add(robin);
  proj4.Proj.projections.add(geocent);
  proj4.Proj.projections.add(tpers);
  proj4.Proj.projections.add(geos);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/index.js









core.defaultDatum = 'WGS84'; //default datum

core.Proj = Proj;
core.WGS84 = new core.Proj('WGS84');
core.Point = lib_Point;
core.toPoint = toPoint;
core.defs = lib_defs;
core.nadgrid = nadgrid;
core.transform = transform_transform;
core.mgrs = mgrs;
core.version = '__VERSION__';
proj4_projs(core);
/* harmony default export */ var lib = (core);
;// CONCATENATED MODULE: ./node_modules/ol/proj/proj4.js
/**
 * @module ol/proj/proj4
 */



/**
 * Make projections defined in proj4 (with `proj4.defs()`) available in
 * OpenLayers. Requires proj4 >= 2.8.0.
 *
 * This function should be called whenever changes are made to the proj4
 * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be
 * modified by this function.
 *
 * @param {?} proj4 Proj4.
 * @api
 */

function register(proj4) {
  var projCodes = Object.keys(proj4.defs);
  var len = projCodes.length;
  var i, j;

  for (i = 0; i < len; ++i) {
    var code = projCodes[i];

    if (!proj_get(code)) {
      var def = proj4.defs(code);
      var units = def.units;

      if (!units && def.projName === 'longlat') {
        units = 'degrees';
      }

      addProjection(new proj_Projection({
        code: code,
        axisOrientation: def.axis,
        metersPerUnit: def.to_meter,
        units: units
      }));
    }
  }

  for (i = 0; i < len; ++i) {
    var code1 = projCodes[i];
    var proj1 = proj_get(code1);

    for (j = 0; j < len; ++j) {
      var code2 = projCodes[j];
      var proj2 = proj_get(code2);

      if (!transforms_get(code1, code2)) {
        if (proj4.defs[code1] === proj4.defs[code2]) {
          addEquivalentProjections([proj1, proj2]);
        } else {
          var transform = proj4(code1, code2);
          addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform.forward), createSafeCoordinateTransform(proj2, proj1, transform.inverse));
        }
      }
    }
  }
}
;// CONCATENATED MODULE: ./src/util/map-utils.js
/**
 * @param {number} lat Latitude coordinate
 * @param {number} long Longitude coordinate
 * @returns {object} Proj object containing converted coordinates
 */function latlngToUTM(lat,long){var parsedLat=parseFloat(lat);var parsedLong=parseFloat(long);var wgs84="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";var utm="+proj=utm +zone=32";return lib(wgs84,utm,[parsedLong,parsedLat]);}/**
 * @param {object} resources Resources array
 * @param {boolean} useLocations Group resources as location
 * @returns {Array} Containing openLayer features and tooltip content
 */function getFeatures(resources){var useLocations=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// Loop resources and build coordinates and tooltip content
var features=[];if(useLocations){Object.values(resources).forEach(function(value){if(value.location in resources){features[value.location].resource_count+=1;}else{var _value$resourceDispla;if(value.location===""||value.geoCoordinates===""||value.geoCoordinates===null){return;}var geoCoordinates=value.geoCoordinates.split(",");var utmCoordinates=latlngToUTM(geoCoordinates[0],geoCoordinates[1]);features[value.location]={resourceName:(_value$resourceDispla=value.resourceDisplayName)!==null&&_value$resourceDispla!==void 0?_value$resourceDispla:value.resourceName,resourceId:value.id,resourceMail:value.resourceMail,location:value.location,locationName:value.locationName,northing:utmCoordinates[0],easting:utmCoordinates[1],resource_count:1};}});}else{Object.values(resources).forEach(function(value){var _value$resourceDispla2;if(value.location===""||value.geoCoordinates===""||value.geoCoordinates===null){return;}var geoCoordinates=value.geoCoordinates.split(",");var utmCoordinates=latlngToUTM(geoCoordinates[0],geoCoordinates[1]);features[value.id]={resourceName:(_value$resourceDispla2=value.resourceDisplayName)!==null&&_value$resourceDispla2!==void 0?_value$resourceDispla2:value.resourceName,resourceId:value.id,resourceMail:value.resourceMail,location:value.location,locationName:value.locationName,northing:utmCoordinates[0],easting:utmCoordinates[1]};});}return features;}
;// CONCATENATED MODULE: ./src/components/map-wrapper.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var map_wrapper = ({});
;// CONCATENATED MODULE: ./src/components/map-wrapper.js
// react
// openlayers
/**
 * MapWrapper component
 *
 * @param {object} props Props.
 * @param {object} props.resources Filtered resources array
 * @param {object} props.allResources All resources array
 * @param {object} props.config Config
 * @param {object} props.setLocationFilter Setter for location filter
 * @param {object} props.setResourceFilter Setter for resource filter
 * @param {string} props.setBookingView Setter for booking view
 * @param {boolean} props.useLocations Whether to render locations or resources
 * @param {Function} props.setFacilityFilter Set facility filter.
 * @param {object} props.filterParams Filter params.
 * @returns {JSX.Element} MapWrapper component
 */function MapWrapper(_ref){var resources=_ref.resources,allResources=_ref.allResources,config=_ref.config,setLocationFilter=_ref.setLocationFilter,setResourceFilter=_ref.setResourceFilter,setBookingView=_ref.setBookingView,useLocations=_ref.useLocations,setFacilityFilter=_ref.setFacilityFilter,filterParams=_ref.filterParams;var _useState=(0,react.useState)(),_useState2=slicedToArray_slicedToArray(_useState,2),map=_useState2[0],setMap=_useState2[1];var _useState3=(0,react.useState)(null),_useState4=slicedToArray_slicedToArray(_useState3,2),vectorLayer=_useState4[0],setVectorLayer=_useState4[1];var _useState5=(0,react.useState)(null),_useState6=slicedToArray_slicedToArray(_useState5,2),mapData=_useState6[0],setMapData=_useState6[1];var mapElement=(0,react.useRef)();var tooltip=(0,react.useRef)();(0,react.useEffect)(function(){if(!useLocations){if(Object.keys(filterParams).length===0){setMapData(getFeatures(allResources,useLocations));}else{var features=getFeatures(resources,useLocations);setMapData(features);tooltip.innerHTML="";}}else{setMapData(getFeatures(allResources,useLocations));}},[resources,allResources]);(0,react.useEffect)(function(){if(map){map.getLayers().getArray().forEach(function(value){// Loop vectorLayers and all but the original
// eslint-disable-next-line no-underscore-dangle
if(value.revision_>1){map.removeLayer(value);}});}},[mapData]);(0,react.useEffect)(function(){if(!mapData){return;}// Styling of the map marker
var iconStyle=new style_Style({image:new style_Icon({anchor:[0.55,25],anchorXUnits:"fraction",anchorYUnits:"pixels",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAdCAMAAABymtfJAAAAilBMVEVHcEwMbv0Mbv0Nbv0Mbv0eeP0Tcv0Mbv8Mbv0Mb/4Nbv0Nbv0Nbv0Nbv0Mbv0Nbv0Nbv2w0P8Nbv4Mbv0Nbv0Ma/sNbv1SmP4Lb/4Mbf2PvP41h/3b6v8whP6Etv4Nbv0Nbv0Nbv0Nbv0Nbv0Nbv2exf96r/7R5P8lfP0Nbv3////a6f/4+//8/f8k+JezAAAAKXRSTlMA/vHoQf3+CIYOi7vFNPjN2vopS+ACYfocGfz98ujks1OVd2mx2/np8fwU+MsAAAECSURBVCjPbZLpdsIgEIVngCQEsi/G2NbdVlDf//UMi9lO7x/CdyYXZi4ARjHjCc1owlkMo9ITRVRKIdJT6llb52pSXreW1oWaq6gNrBK1VF4BREKtJSJIG/eJGIaeNimc0cGffbn78gVnkOjgn9b60TkqwRpgeBugfpXOpIHMrsG3ofoR2B0B8i/NrW+4t3RnHTAH4U67l8/Xs3SXQAHMWWDQ/Xbuf0UY9FffBI69XXuADVk1TDbDdLZyReXWDG1VbEuHeA4LevAhMTqDlPmIIj6djzz6pDmLI6mmkI8fD3qc4BCTG10mohmFXs6uOomZ+Au2hNBeiCKXdkUh5gUfH9kbVG84zlaEEvsAAAAASUVORK5CYII="})});// Define feature array and apply styling
var features=[];Object.values(mapData).forEach(function(value){var _value$resourceDispla;var feature=new ol_Feature({geometry:new geom_Point([value.northing,value.easting]),resourceId:value.id,resourceName:(_value$resourceDispla=value.resourceDisplayName)!==null&&_value$resourceDispla!==void 0?_value$resourceDispla:value.resourceName,resourceMail:value.resourceMail,location:value.location,locationName:value.locationDisplayName,children:value.resource_count});feature.setStyle(iconStyle);features.push(feature);});var clusterSource=new source_Cluster({distance:60,minDistance:20,source:new source_Vector({features:features})});var styleCache={};var clusterStyle=function clusterStyle(feature){var size=feature.get("features").length;var style=styleCache[size];if(size===1){return iconStyle;}if(!style){style=new style_Style({image:new Circle({radius:12,fill:new style_Fill({color:"#0d6efd"})}),text:new style_Text({scale:1.5,text:size.toString(),fill:new style_Fill({color:"#fff"})})});styleCache[size]=style;}return style;};var clusters=new Vector({source:clusterSource,style:clusterStyle});if(map){setVectorLayer(clusters);}},[mapData,map]);(0,react.useEffect)(function(){// Handles removing old layers and adding new ones
if(map&&vectorLayer){map.getLayers().getArray().forEach(function(value){// eslint-disable-next-line no-underscore-dangle
if(value.revision_>1){map.removeLayer(value);}});map.addLayer(vectorLayer);// Add newly defined vectorLayer
}},[vectorLayer,map]);(0,react.useEffect)(function(){if(!config||config.df_map_username===""||config.df_map_password===""){return;}// Current map instances
var mapChildren=mapElement.current.children;var mapAlreadyLoaded=false;// Check if map is already loaded
Object.values(mapChildren).forEach(function(mapChild){if(mapChild.className.indexOf("ol-viewport")!==-1){mapAlreadyLoaded=true;}});// Return if map is already loaded
if(mapAlreadyLoaded){return;}// Initial setup of map - this only runs once
tooltip=document.getElementById("tooltip");// Proj4 projection definition
lib.defs("EPSG:25832","+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs");register(lib);// Projection settings for Denmark
var dkprojection=new proj_Projection({code:"EPSG:25832",extent:[-1877994.66,3638086.74,3473041.38,9494203.2]});// Layer definition
var layers=[new layer_Tile({// Map tiles
title:"WMS skærmkort (DAF)",type:"base",visible:true,preload:Infinity,source:new source_TileWMS({url:"https://services.datafordeler.dk/Dkskaermkort/topo_skaermkort/1.0.0/wms?username=".concat(config.df_map_username,"&password=").concat(config.df_map_password),params:{LAYERS:"dtk_skaermkort",VERSION:"1.1.1",TRANSPARENT:"FALSE",FORMAT:"image/png"},attributions:'<p>Kort fra <a href="https://datafordeler.dk" target="_blank">Datafordeleren</a>.'})})];// Map definition
var initialMap=new ol_Map({layers:layers,target:mapElement.current,view:new ol_View({minZoom:2,maxZoom:11,center:[574969.6851,6223950.2116],zoom:5.2,resolutions:[1638.4,819.2,409.6,204.8,102.4,51.2,25.6,12.8,6.4,3.2,1.6,0.8,0.4,0.2,0.1],projection:dkprojection})});// Tooltip definition
var overlay=new ol_Overlay({element:tooltip,offset:[0,-30],positioning:"bottom-center"});initialMap.addOverlay(overlay);// display popup on click
initialMap.on("click",function(evt){var pixel=evt.pixel;var targetFeature=initialMap.forEachFeatureAtPixel(pixel,function(target){return target;});if(targetFeature){var isCluster=targetFeature.values_.features.length>1;// Clicked feature is a cluster. Zoom in on it.
if(isCluster){var features=targetFeature.values_.features;var extent=boundingExtent(features.map(function(r){return r.getGeometry().getCoordinates();}));var mapZoom=initialMap.getView().getZoom();var mapMaxZoom=initialMap.getView().getMaxZoom();var resolution=initialMap.getView().getResolution();initialMap.getView().fit(extent,{duration:1500,padding:[250,100,100,100]});if(mapZoom===mapMaxZoom&&getWidth(extent)<resolution&&getHeight(extent)<resolution){var _ref2,_targetFeature$values;// Clicked feature is a single. Show info.
tooltip.style.display=targetFeature?"":"none";var coordinates=targetFeature.values_.geometry.flatCoordinates;// eslint-disable-next-line no-underscore-dangle
overlay.setPosition(coordinates);var count=targetFeature.values_.features.length;var dataResourceMailArray=targetFeature.values_.features.map(function(feature){return feature.values_.resourceMail;});var dataResourceNameArray=targetFeature.values_.features.map(function(feature){return feature.values_.resourceName;});var locationName=(_ref2=(_targetFeature$values=targetFeature.values_.features[0].values_.locationName)!==null&&_targetFeature$values!==void 0?_targetFeature$values:targetFeature.values_.features[0].values_.location)!==null&&_ref2!==void 0?_ref2:"";// eslint-disable-next-line no-underscore-dangle
tooltip.innerHTML="<div class='tooltip-closer'>\u2716\uFE0F</div>\n            <div class='tooltip-text'>\n                <span><b>".concat(locationName,"</b></span><span>").concat(count," ressourcer</span>\n                <a data-resource-mail=\"").concat(dataResourceMailArray,"\"\n                  data-resource-name=\"").concat(dataResourceNameArray,"\"\n                  class='tooltip-btn'\">\n                  Vis i kalender\n                </a>\n            </div>");}}else{// Clicked feature is a single. Show info.
tooltip.style.display=targetFeature?"":"none";var _coordinates=targetFeature.values_.geometry.flatCoordinates;// eslint-disable-next-line no-underscore-dangle
overlay.setPosition(_coordinates);if(useLocations){var _ref3,_targetFeature$values2,_ref4,_targetFeature$values3,_targetFeature$values4;var location=(_ref3=(_targetFeature$values2=targetFeature.values_.features[0].values_.location)!==null&&_targetFeature$values2!==void 0?_targetFeature$values2:targetFeature.values_.features[0].values_.locationName)!==null&&_ref3!==void 0?_ref3:"";var _locationName=(_ref4=(_targetFeature$values3=targetFeature.values_.features[0].values_.locationName)!==null&&_targetFeature$values3!==void 0?_targetFeature$values3:targetFeature.values_.features[0].values_.location)!==null&&_ref4!==void 0?_ref4:"";var children=(_targetFeature$values4=targetFeature.values_.features[0].values_.children)!==null&&_targetFeature$values4!==void 0?_targetFeature$values4:"";// eslint-disable-next-line no-underscore-dangle
tooltip.innerHTML="<div class='tooltip-closer'>\u2716\uFE0F</div>\n              <div class='tooltip-text'>\n                  <span><b>".concat(_locationName,"</b></span><span>").concat(children," test</span>\n                  <a data-location=\"").concat(location,"\"\n                    data-location-name=\"").concat(_locationName,"\"\n                    class='tooltip-btn'\">\n                    Vis i kalender\n                  </a>\n              </div>");}else{var _targetFeature$values5,_targetFeature$values6;var name=(_targetFeature$values5=targetFeature.values_.features[0].values_.resourceName)!==null&&_targetFeature$values5!==void 0?_targetFeature$values5:"";var resourceMail=(_targetFeature$values6=targetFeature.values_.features[0].values_.resourceMail)!==null&&_targetFeature$values6!==void 0?_targetFeature$values6:"";// eslint-disable-next-line no-underscore-dangle
tooltip.innerHTML="<div class='tooltip-closer'>\u2716\uFE0F</div>\n              <div class='tooltip-text'>\n                  <span><b>".concat(name,"</b></span>\n                  <a data-resource-mail=\"").concat(resourceMail,"\"\n                    data-resource-name=\"").concat(name,"\"\n                    class='tooltip-btn'\">\n                    Vis i kalender\n                  </a>\n              </div>");}}}});// change mouse cursor when over marker
initialMap.on("pointermove",function(e){var pixel=initialMap.getEventPixel(e.originalEvent);var hit=initialMap.hasFeatureAtPixel(pixel);initialMap.getTarget().style.cursor=hit?"pointer":"";});// Tooltip closer click event
document.getElementById("tooltip").addEventListener("click",function(event){var target=event.target.className;if(target==="tooltip-closer"){tooltip.innerHTML="";}if(target==="tooltip-btn"){if(useLocations){setLocationFilter([{value:event.target.getAttribute("data-location"),label:event.target.getAttribute("data-location-name")}]);}else{var dataResourceMail=event.target.getAttribute("data-resource-mail");var dataResourceName=event.target.getAttribute("data-resource-name");if(dataResourceMail.indexOf(",")>-1&&dataResourceName.indexOf(",")>-1){var dataResourceMailArray=dataResourceMail.split(",");var dataResourceNameArray=dataResourceName.split(",");if(dataResourceMailArray.length===dataResourceNameArray.length){// Merge arrays into array of objects
var mergedArray=dataResourceMailArray.map(function(value,index){return{value:value,label:dataResourceNameArray[index]};});setFacilityFilter([]);// Settimeout to prevent filters being set at the same time.
setTimeout(function(){setResourceFilter(mergedArray);},50);}}else{setResourceFilter([{value:event.target.getAttribute("data-resource-mail"),label:event.target.getAttribute("data-resource-name")}]);}}setBookingView("calendar");}});// save map and vector layer references to state
setMap(initialMap);},[]);return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"map-container",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{ref:mapElement,className:"map",id:"map",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{id:"tooltip",className:"tooltip"})})});}MapWrapper.defaultProps={resources:{},allResources:{}};/* harmony default export */ var components_map_wrapper = (MapWrapper);
;// CONCATENATED MODULE: ./src/components/main-navigation.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var main_navigation = ({});
;// CONCATENATED MODULE: ./src/components/main-navigation.js
/**
 * Main navigation component.
 *
 * @param {object} props Props.
 * @param {object} props.config Object containing configuration from drupal
 * @returns {JSX.Element} Info box component
 */function MainNavigation(_ref){var config=_ref.config;var _useState=(0,react.useState)(""),_useState2=slicedToArray_slicedToArray(_useState,2),createBookingUrl=_useState2[0],setCreateBookingUrl=_useState2[1];var _useState3=(0,react.useState)(""),_useState4=slicedToArray_slicedToArray(_useState3,2),changeBookingUrl=_useState4[0],setChangeBookingUrl=_useState4[1];(0,react.useEffect)(function(){if(config.create_booking_url){setCreateBookingUrl(config.create_booking_url);}else{setCreateBookingUrl(window.location.href);}if(config.change_booking_url){setChangeBookingUrl(config.change_booking_url);}else{setChangeBookingUrl(window.location.href);}},[config]);var activeUrl=window.location.href;return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col main-navigation-content",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{children:[createBookingUrl!==""&&/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("a",{href:createBookingUrl,className:"main-navigation-link ".concat(activeUrl===createBookingUrl?"active":"inactive"),children:"Opret ny booking"})}),changeBookingUrl!==""&&/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("a",{href:changeBookingUrl,className:"main-navigation-link ".concat(activeUrl===changeBookingUrl?"active":"inactive"),children:"Mine bookinger"})})]})})});}/* harmony default export */ var components_main_navigation = (MainNavigation);
;// CONCATENATED MODULE: ./src/util/helpers.js
/**
 * @param {object} obj Object to test.
 * @param {string} propertyName Property name to test for.
 * @returns {boolean} Does the object have the given property?
 */function helpers_hasOwnProperty(obj,propertyName){return Object.prototype.hasOwnProperty.call(obj,propertyName);}/**
 * @param {object} allResources All Resources.
 * @param {object} filterParams Object containing filtered parameters.
 * @returns {Array} Containing resources matching given filters.
 */function filterAllResources(allResources,filterParams){return allResources.filter(function(resource){if(resource.location===""){return false;}/*
      0: no match
      1: neutral // no match
      2: match
    */var matchingState=1;// Location filter
if(filterParams["location[]"]&&filterParams["location[]"].length!==0){if(filterParams["location[]"].includes(resource.location)){matchingState=2;}else{matchingState=0;}}// Resource filter
if(filterParams["resourceMail[]"]&&filterParams["resourceMail[]"].length!==0){if(filterParams["resourceMail[]"].includes(resource.resourceMail)){matchingState=2;}else if(matchingState===2){// If already matched, state persists, since location and resource does not intertwine.
matchingState=2;}else{matchingState=0;}}// VideoConference filter
if(filterParams.videoConferenceEquipment){if(!resource.videoConferenceEquipment&&matchingState===2){// If resource matched before now, this also has to match.
matchingState=0;}if(resource.videoConferenceEquipment&&matchingState===1){// If resource didn't match before now, it's now a match.
matchingState=2;}}// MonitorEquipment filter
if(filterParams.monitorEquipment){if(!resource.monitorEquipment&&matchingState===2){matchingState=0;}if(resource.monitorEquipment&&matchingState===1){matchingState=2;}}// WheelchairAccessible filter
if(filterParams.wheelchairAccessible){if(!resource.wheelchairAccessible&&matchingState===2){matchingState=0;}if(resource.wheelchairAccessible&&matchingState===1){matchingState=2;}}// Catering filter
if(filterParams.catering){if(!resource.catering&&matchingState===2){matchingState=0;}if(resource.catering&&matchingState===1){matchingState=2;}}// Capacity filter (between two values)
if(filterParams["capacity[between]"]&&matchingState!==0){var rangeArray=filterParams["capacity[between]"].split(",");if(resource.capacity>=rangeArray[0]&&resource.capacity<=rangeArray[1]){// If capacity is filtered, it should always overrule earlier matches.
matchingState=2;}else{matchingState=0;}}// Capacity filter (greater than value)
if(filterParams["capacity[gt]"]&&matchingState!==0){// If capacity is filtered, it should always overrule earlier matches.
if(resource.capacity>=filterParams["capacity[gt]"]){matchingState=2;}else{matchingState=0;}}// Resource category filter
if(filterParams.resourceCategory&&matchingState!==0){// Treat all resources that do not have a resource category set, as "Lokale".
var resCat=resource.resourceCategory===null||resource.resourceCategory===""?"Lokale":resource.resourceCategory;if(resCat!==filterParams.resourceCategory){matchingState=0;}}// HasWhitelist filter
if(filterParams.hasWhitelist){if(resource.hasWhitelist){matchingState=2;}else{matchingState=0;}}if(matchingState>1){return resource;}return false;});}/**
 * @param {Array} array Array of objects to sort.
 * @param {string} propertyName Property name on object to sort by.
 * @returns {Array} The sorted array.
 */function sortOptionsBy(array,propertyName){return array.sort(function(a,b){if(a[propertyName]&&b[propertyName]){var labelA=a[propertyName].toUpperCase();// ignore upper and lowercase
var labelB=b[propertyName].toUpperCase();// ignore upper and lowercase
if(labelA<labelB){return-1;}if(labelA>labelB){return 1;}}return 0;});}
;// CONCATENATED MODULE: ./src/util/url-validator.js
/** Url validator. */var UrlValidator=/*#__PURE__*/function(){function UrlValidator(){_classCallCheck(this,UrlValidator);}_createClass(UrlValidator,null,[{key:"minimizable",value:function minimizable(urlParams){if(!urlParams||!helpers_hasOwnProperty(urlParams,"from")||!helpers_hasOwnProperty(urlParams,"to")||!helpers_hasOwnProperty(urlParams,"resourceMail")||!helpers_hasOwnProperty(urlParams,"resource")){return false;}return dayjs_min_default()(urlParams.from,"YYYY-MM-DDTHH:MN:SS",true).isValid()&&dayjs_min_default()(urlParams.to,"YYYY-MM-DDTHH:MN:SS",true).isValid();}}]);return UrlValidator;}();
;// CONCATENATED MODULE: ./node_modules/react-toastify/dist/ReactToastify.css
// extracted by mini-css-extract-plugin
/* harmony default export */ var ReactToastify = ({});
;// CONCATENATED MODULE: ./src/components/create-booking-filters.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var create_booking_filters = ({});
;// CONCATENATED MODULE: ./src/components/create-booking-filters.js
/**
 * CreateBooking component.
 *
 * @param {object} props The props
 * @param {object} props.filterParams Filter parameters.
 * @param {Function} props.setFilterParams Set filter parameters.
 * @param {Array} props.allResources All resources.
 * @param {boolean} props.disabled Disable filters.
 * @param {string} props.userType User type: citizen or businessPartner.
 * @param {Array} props.locationFilter Location filters.
 * @param {Function} props.setLocationFilter Set Location filters.
 * @param {Array} props.resourceFilter Resource filters.
 * @param {Function} props.setResourceFilter Set resource filters.
 * @param {string} props.resourceCategoryFilter Resource category filters.
 * @param {Function} props.setResourceCategoryFilter Set resource category filters.
 * @param {Array} props.facilityFilter Facility filters.
 * @param {Function} props.setFacilityFilter Set facility filters.
 * @param {Function} props.setAppParams Set app params.
 * @returns {JSX.Element} Component.
 */function CreateBookingFilters(_ref){var filterParams=_ref.filterParams,setFilterParams=_ref.setFilterParams,allResources=_ref.allResources,disabled=_ref.disabled,userType=_ref.userType,locationFilter=_ref.locationFilter,setLocationFilter=_ref.setLocationFilter,resourceFilter=_ref.resourceFilter,setResourceFilter=_ref.setResourceFilter,resourceCategoryFilter=_ref.resourceCategoryFilter,setResourceCategoryFilter=_ref.setResourceCategoryFilter,facilityFilter=_ref.facilityFilter,setFacilityFilter=_ref.setFacilityFilter,setAppParams=_ref.setAppParams;var _useState=(0,react.useState)([]),_useState2=slicedToArray_slicedToArray(_useState,2),capacityFilter=_useState2[0],setCapacityFilter=_useState2[1];var _useState3=(0,react.useState)(false),_useState4=slicedToArray_slicedToArray(_useState3,2),hasWhitelist=_useState4[0],setHasWhitelist=_useState4[1];var _useState5=(0,react.useState)([]),_useState6=slicedToArray_slicedToArray(_useState5,2),locationOptions=_useState6[0],setLocationOptions=_useState6[1];var _useState7=(0,react.useState)([]),_useState8=slicedToArray_slicedToArray(_useState7,2),resourcesOptions=_useState8[0],setResourcesOptions=_useState8[1];var _useState9=(0,react.useState)([]),_useState10=slicedToArray_slicedToArray(_useState9,2),resourceCategoryOptions=_useState10[0],setResourceCategoryOptions=_useState10[1];// TODO: Describe.
setAriaLabelFilters();// Loop all resources and set filter options
(0,react.useEffect)(function(){if(resourcesOptions.length===allResources.length){return;}var locations=[];allResources.forEach(function(item){if(item.location!==""){if(locations.findIndex(function(e){return e.value===item.location;})===-1){var _item$locationDisplay;locations.push({value:item.location,label:(_item$locationDisplay=item.locationDisplayName)!==null&&_item$locationDisplay!==void 0?_item$locationDisplay:item.location});}}});setLocationOptions(sortOptionsBy(locations,"label"));setResourcesOptions(sortOptionsBy(allResources,"resourceDisplayName").map(function(value){var _value$resourceDispla;return{value:value.resourceMail,label:(_value$resourceDispla=value.resourceDisplayName)!==null&&_value$resourceDispla!==void 0?_value$resourceDispla:value.resourceName};}));var newResourceCategoryOptions=_toConsumableArray(new Set(allResources.filter(function(resource){return(resource===null||resource===void 0?void 0:resource.resourceCategory)!==null&&(resource===null||resource===void 0?void 0:resource.resourceCategory)!=="";}).map(function(resource){return resource.resourceCategory;})));// Make sure "Lokale" is in the array, since it is default for resources without resourceCategory.
if(newResourceCategoryOptions.indexOf("Lokale")===-1){newResourceCategoryOptions.push("Lokale");}setResourceCategoryOptions(newResourceCategoryOptions);// Add filtering based on filterParams
if(filterParams){if(filterParams["location[]"]){var filterLocations=filterParams["location[]"].reduce(function(carry,locationParam){var foundLocations=locations.filter(function(aLocation){return aLocation.value===locationParam;});foundLocations.forEach(function(foundLocation){return carry.push(foundLocation);});return carry;},[]);setLocationFilter(filterLocations);}if(filterParams["resourceMail[]"]){var filterResourceMails=filterParams["resourceMail[]"].reduce(function(carry,resourceParam){var foundResources=allResources.filter(function(resource){return resource.resourceMail===resourceParam;});foundResources.forEach(function(foundResource){var _foundResource$resour;return carry.push({value:foundResource.resourceMail,label:(_foundResource$resour=foundResource.resourceDisplayName)!==null&&_foundResource$resour!==void 0?_foundResource$resour:foundResource.resourceName});});return carry;},[]);setResourceFilter(filterResourceMails);}}},[allResources]);// Set location filter and resource dropdown options.
(0,react.useEffect)(function(){var locationValues=locationFilter.map(function(_ref2){var value=_ref2.value;return value;});if(locationValues.length>0){setFilterParams(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},filterParams),{"location[]":locationValues}));}else{// Define, clear and reassign copy
var filterParamsCopy=objectSpread2_objectSpread2({},filterParams);delete filterParamsCopy["location[]"];setFilterParams(objectSpread2_objectSpread2({},filterParamsCopy));}},[locationFilter]);// Set resource filter.
(0,react.useEffect)(function(){var resourceValues=resourceFilter.map(function(_ref3){var value=_ref3.value;return value;});if(resourceValues.length>0){setFilterParams(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},filterParams),{"resourceMail[]":resourceValues}));}else{// Define, clear and reassign copy
var filterParamsCopy=objectSpread2_objectSpread2({},filterParams);delete filterParamsCopy["resourceMail[]"];setFilterParams(objectSpread2_objectSpread2({},filterParamsCopy));}},[resourceFilter]);// Set only whitelisted filter.
(0,react.useEffect)(function(){if(hasWhitelist){setFilterParams(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},filterParams),{hasWhitelist:hasWhitelist}));}else if(helpers_hasOwnProperty(filterParams,"hasWhitelist")){var newFilterParams=objectSpread2_objectSpread2({},filterParams);delete newFilterParams.hasWhitelist;setFilterParams(newFilterParams);}},[hasWhitelist]);// Set capacity filter.
(0,react.useEffect)(function(){var _capacityFilter$type,_capacityFilter$value;var newFilterParams=objectSpread2_objectSpread2({},filterParams);var capacityType=(_capacityFilter$type=capacityFilter.type)!==null&&_capacityFilter$type!==void 0?_capacityFilter$type:null;var capacityValue=(_capacityFilter$value=capacityFilter.value)!==null&&_capacityFilter$value!==void 0?_capacityFilter$value:0;// Delete opposite entry to prevent both capacity[between] and capacity[gt] being set, causing a dead end.
delete newFilterParams["capacity[between]"];delete newFilterParams["capacity[gt]"];// Set capacity filter according to capacityType.
var capacity;switch(capacityType){case"between":capacity={"capacity[between]":capacityValue};break;case"gt":capacity={"capacity[gt]":capacityValue};break;default:break;}setFilterParams(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},newFilterParams),capacity));},[capacityFilter]);// Set facility filter.
(0,react.useEffect)(function(){var filterParamsObj=objectSpread2_objectSpread2({},filterParams);delete filterParamsObj.monitorEquipment;delete filterParamsObj.wheelchairAccessible;delete filterParamsObj.videoConferenceEquipment;delete filterParamsObj.catering;var facilitiesObj={};facilityFilter.forEach(function(value){facilitiesObj[value.value]="true";});setFilterParams(objectSpread2_objectSpread2(objectSpread2_objectSpread2({},filterParamsObj),facilitiesObj));},[facilityFilter]);// Set resource category filter.
(0,react.useEffect)(function(){setAppParams({resourceCategory:resourceCategoryFilter});},[resourceCategoryFilter]);return/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"category-tabs",children:resourceCategoryOptions.map(function(category,index){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"category-tab ".concat(resourceCategoryFilter===category?"active":""," ").concat(index===resourceCategoryOptions.length-1?"last":""," ").concat(index===0?"first":""),children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",className:"category-button",onClick:function onClick(){return setResourceCategoryFilter(category);},children:category})},category);})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"row filters-wrapper ".concat(disabled?"disable-wrapper":""),children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-3 col-xs-12 small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"location-filter",children:["Filtr\xE9r p\xE5 lokationer",/*#__PURE__*/(0,jsx_runtime.jsx)(react_select_esm,{styles:{},id:"location-filter",className:"filter",defaultValue:locationFilter,value:locationFilter,placeholder:"Lokationer...",placeholderClassName:"dropdown-placeholder",closeMenuOnSelect:false,options:locationOptions,onChange:function onChange(selectedLocations){setLocationFilter(selectedLocations);},isLoading:Object.values(locationOptions).length===0,loadingMessage:function loadingMessage(){return"Henter lokationer..";},filterOption:createFilter({ignoreAccents:false})// Improved performance with large datasets
,isMulti:true})]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-3 col-xs-12 small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"resource-filter",children:["Filtr\xE9r p\xE5 lokaler/ressourcer",/*#__PURE__*/(0,jsx_runtime.jsx)(react_select_esm,{styles:{},id:"resource-filter",className:"filter",defaultValue:resourceFilter,value:resourceFilter,placeholder:"Ressourcer...",placeholderClassName:"dropdown-placeholder",closeMenuOnSelect:false,options:resourcesOptions,onChange:function onChange(selectedResources){setResourceFilter(selectedResources);},isLoading:Object.values(resourcesOptions).length===0,loadingMessage:function loadingMessage(){return"Henter ressourcer..";},filterOption:createFilter({ignoreAccents:false})// Improved performance with large datasets
,isMulti:true})]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-3 col-xs-12 small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"facility-filter",children:["Filtr\xE9r p\xE5 faciliteter",/*#__PURE__*/(0,jsx_runtime.jsx)(react_select_esm,{styles:{},id:"facility-filter",className:"filter",defaultValue:facilityFilter,placeholder:"Facilitieter...",placeholderClassName:"dropdown-placeholder",closeMenuOnSelect:false,options:facilityOptions,onChange:function onChange(selectedFacilities){setFacilityFilter(selectedFacilities);},value:facilityFilter,isMulti:true})]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-3 col-xs-12 small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"capacity-filter",children:["Filtr\xE9r p\xE5 kapacitet",/*#__PURE__*/(0,jsx_runtime.jsx)(react_select_esm,{styles:{},id:"capacity-filter",className:"filter",defaultValue:{value:"0",label:"Alle",type:"gt"},placeholder:"Siddepladser...",placeholderClassName:"dropdown-placeholder",closeMenuOnSelect:true,options:capacityOptions,onChange:function onChange(selectedCapacity){setCapacityFilter(selectedCapacity);}})]})}),userType==="businessPartner"&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-3 col-xs-12 small-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{htmlFor:"capacity-filter",style:{display:"flex"},children:[/*#__PURE__*/(0,jsx_runtime.jsx)("input",{type:"checkbox",value:hasWhitelist,style:{width:"20px",height:"20px"},onChange:function onChange(_ref4){var target=_ref4.target;setHasWhitelist(!!target.checked);}}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{style:{marginLeft:"5px"},children:"Mine udvalgte ressourcer"})]})})]})]});}CreateBookingFilters.defaultProps={userType:""};/* harmony default export */ var components_create_booking_filters = (CreateBookingFilters);
;// CONCATENATED MODULE: ./src/components/create-booking-tabs.js
/**
 * CreateBookingTabs component.
 *
 * @param {object} props The props
 * @param {string} props.activeTab Name of the active tab.
 * @param {Function} props.onTabChange Handle change of tab.
 * @param {boolean} props.disabled Disable filters.
 * @returns {JSX.Element} Component.
 */function CreateBookingTabs(_ref){var activeTab=_ref.activeTab,onTabChange=_ref.onTabChange,disabled=_ref.disabled;var onTabClick=function onTabClick(event){var tab=event.target.getAttribute("data-view");onTabChange(tab);};return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row viewswapper-wrapper ".concat(disabled?"disable-wrapper":""),children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"viewswapper-container",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:onTabClick,"data-view":"calendar",className:activeTab==="calendar"?"active booking-btn":"booking-btn",children:"Kalender"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:onTabClick,"data-view":"list",className:activeTab==="list"?"active booking-btn":"booking-btn",children:"Liste"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:onTabClick,"data-view":"map",className:activeTab==="map"?"active booking-btn":"booking-btn",children:"Kort"})]})});}/* harmony default export */ var create_booking_tabs = (CreateBookingTabs);
;// CONCATENATED MODULE: ./src/components/resource-details.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var resource_details = ({});
;// CONCATENATED MODULE: ./src/components/resource-details.js
/**
 * REsourece details component.
 *
 * @param {object} props Props.
 * @param {object} props.setShowResourceDetails Set show resource details
 * @param {object} props.resource Object of the resource to show
 * @returns {JSX.Element} Component.
 */function ResourceDetails(_ref){var _resource$resourceDis,_resource$resourceDis2,_resource$locationDis;var setShowResourceDetails=_ref.setShowResourceDetails,resource=_ref.resource;var hideResourceView=function hideResourceView(){setShowResourceDetails(null);};var sanitizedDescription=resource.resourceDescription?node_modules_html_react_parser(purify_default().sanitize(resource.resourceDescription,{})):"";var getFacilitiesList=function getFacilitiesList(){var facilities=getResourceFacilities(resource);return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"facility-container",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"facility-item",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"facility-icon",children:/*#__PURE__*/(0,jsx_runtime.jsx)(chair_ForwardRef,{})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{children:[resource.capacity," siddepladser"]})]}),Object.values(facilities).map(function(value){return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"facility-item",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"facility-icon",children:value.icon}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:value.title})]},value.title);})]});};return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:resource!==null?"fade-in-content resource-container":"resource-container",children:[!resource&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{}),resource&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"resource-headline",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:(_resource$resourceDis=resource.resourceDisplayName)!==null&&_resource$resourceDis!==void 0?_resource$resourceDis:resource.resourceName}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",className:"booking-btn-inv",onClick:hideResourceView,children:"Tilbage til listen"})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"resource-details row",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"image-wrapper col-xs-12 col-md-4",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"image",children:/*#__PURE__*/(0,jsx_runtime.jsx)("img",{alt:(_resource$resourceDis2=resource.resourceDisplayName)!==null&&_resource$resourceDis2!==void 0?_resource$resourceDis2:resource.resourceName,src:resource.resourceImage})})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"facilities col-xs-12 col-md-4",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"resource-details--title",children:"Faciliteter"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:getFacilitiesList(resource)})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"location col-xs-12 col-md-4",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"resource-details--title",children:"Lokation"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:(_resource$locationDis=resource.locationDisplayName)!==null&&_resource$locationDis!==void 0?_resource$locationDis:resource.location})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"spacer"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:resource.streetName})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:resource.postalCode}),"\xA0",/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:resource.city})]})]})]}),resource.resourceDescription&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"resource-description",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Beskrivelse"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:sanitizedDescription})})]})]})]});}/* harmony default export */ var components_resource_details = (ResourceDetails);
;// CONCATENATED MODULE: ./src/system-failure-screen.js
/**
 * System failure component
 *
 * @returns {JSX.Element} System failure component.
 */function SystemFailureScreen(){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"App",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"container-fluid",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"app-wrapper",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row no-gutter main-container",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-12",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"col-xs-offset-3 col-xs-6",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("h1",{children:"System fejl"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Book aarhus servicen er desv\xE6rre utilg\xE6ngelig i \xF8jeblikket. Pr\xF8v igen senere..."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Vi beklager ulejligheden."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",className:"button button-primary",onClick:function onClick(){return window.location.reload(false);},children:"Genindl\xE6s siden"})})]})})})})})})});}/* harmony default export */ var system_failure_screen = (SystemFailureScreen);
;// CONCATENATED MODULE: ./src/create-booking.js
/**
 * CreateBooking component.
 *
 * @param {object} props The props
 * @param {object} props.config App config.
 * @returns {JSX.Element} Component.
 */function CreateBooking(_ref){var _ref2,_ref3;var config=_ref.config;// Booking data.
var _useState=(0,react.useState)(new Date()),_useState2=slicedToArray_slicedToArray(_useState,2),date=_useState2[0],setDate=_useState2[1];var _useState3=(0,react.useState)({}),_useState4=slicedToArray_slicedToArray(_useState3,2),calendarSelection=_useState4[0],setCalendarSelection=_useState4[1];var _useState5=(0,react.useState)({subject:"",email:""}),_useState6=slicedToArray_slicedToArray(_useState5,2),authorFields=_useState6[0],setAuthorFields=_useState6[1];// Filter parameters, selected in CreateBookingFilters. An object containing
// structured information about current filtering.
var _useState7=(0,react.useState)({}),_useState8=slicedToArray_slicedToArray(_useState7,2),appParams=_useState8[0],setAppParams=_useState8[1];var _useState9=(0,react.useState)({}),_useState10=slicedToArray_slicedToArray(_useState9,2),filterParams=_useState10[0],setFilterParams=_useState10[1];var _useState11=(0,react.useState)([]),_useState12=slicedToArray_slicedToArray(_useState11,2),locationFilter=_useState12[0],setLocationFilter=_useState12[1];var _useState13=(0,react.useState)([]),_useState14=slicedToArray_slicedToArray(_useState13,2),resourceFilter=_useState14[0],setResourceFilter=_useState14[1];var _useState15=(0,react.useState)("Lokale"),_useState16=slicedToArray_slicedToArray(_useState15,2),resourceCategoryFilter=_useState16[0],setResourceCategoryFilter=_useState16[1];// App configuration and behavior.
var _useState17=(0,react.useState)("maximized"),_useState18=slicedToArray_slicedToArray(_useState17,2),displayState=_useState18[0],setDisplayState=_useState18[1];var _useState19=(0,react.useState)(null),_useState20=slicedToArray_slicedToArray(_useState19,2),urlResource=_useState20[0],setUrlResource=_useState20[1];var _useState21=(0,react.useState)(null),_useState22=slicedToArray_slicedToArray(_useState21,2),validUrlParams=_useState22[0],setValidUrlParams=_useState22[1];var _useState23=(0,react.useState)("calendar"),_useState24=slicedToArray_slicedToArray(_useState23,2),activeTab=_useState24[0],setActiveTab=_useState24[1];var _useState25=(0,react.useState)(false),_useState26=slicedToArray_slicedToArray(_useState25,2),userHasInteracted=_useState26[0],setUserHasInteracted=_useState26[1];var _useState27=(0,react.useState)(null),_useState28=slicedToArray_slicedToArray(_useState27,2),showResourceDetails=_useState28[0],setShowResourceDetails=_useState28[1];var _useState29=(0,react.useState)(false),_useState30=slicedToArray_slicedToArray(_useState29,2),showSystemFailure=_useState30[0],setShowSystemFailure=_useState30[1];// Loaded data.
var _useState31=(0,react.useState)(null),_useState32=slicedToArray_slicedToArray(_useState31,2),filteredResources=_useState32[0],setFilteredResources=_useState32[1];var _useState33=(0,react.useState)(null),_useState34=slicedToArray_slicedToArray(_useState33,2),resources=_useState34[0],setResources=_useState34[1];var _useState35=(0,react.useState)([]),_useState36=slicedToArray_slicedToArray(_useState35,2),allResources=_useState36[0],setAllResources=_useState36[1];var _useState37=(0,react.useState)(null),_useState38=slicedToArray_slicedToArray(_useState37,2),userInformation=_useState38[0],setUserInformation=_useState38[1];// Loading
var _useState39=(0,react.useState)(true),_useState40=slicedToArray_slicedToArray(_useState39,2),loadingResources=_useState40[0],setLoadingResources=_useState40[1];var _useState41=(0,react.useState)(true),_useState42=slicedToArray_slicedToArray(_useState41,2),loadingUserInformation=_useState42[0],setLoadingUserInformation=_useState42[1];var _useState43=(0,react.useState)(false),_useState44=slicedToArray_slicedToArray(_useState43,2),loadingFiltering=_useState44[0],setLoadingFiltering=_useState44[1];var _useState45=(0,react.useState)([]),_useState46=slicedToArray_slicedToArray(_useState45,2),facilityFilter=_useState46[0],setFacilityFilter=_useState46[1];// Load all resources and current user information.
(0,react.useEffect)(function(){Api.fetchAllResources(config.api_endpoint).then(function(loadedResources){setAllResources(loadedResources);}).catch(function(fetchAllResourcesError){toast.error("Der opstod en fejl. Prøv igen senere.",fetchAllResourcesError);setShowSystemFailure(true);}).finally(function(){setLoadingResources(false);});if(!config.step_one){Api.fetchUserInformation(config.api_endpoint).then(function(retrievedUserInformation){setUserInformation(retrievedUserInformation);}).catch(function(fetchUserInformationError){toast.error("Der opstod en fejl. Prøv igen senere.",fetchUserInformationError);setShowSystemFailure(true);}).finally(function(){setLoadingUserInformation(false);});}else{setLoadingUserInformation(false);}},[]);// @TODO: use app params when implementing new booking tab (lokale, transport etc.)
(0,react.useEffect)(function(){},[appParams]);// When all resources have been loaded, check if parameters contain
// selections.
(0,react.useEffect)(function(){// If existing booking data is set in url, start in minimized state.
if(allResources.length>0){var currentUrl=new URL(window.location.href);var params=Object.fromEntries(currentUrl.searchParams);// If a list of urlParameters exist the display can be minimized.
if(UrlValidator.minimizable(params)){setValidUrlParams(params);setDisplayState("minimized");}var matchingResource=Object.values(allResources).filter(function(value){return value.id===parseInt(params.resource,10);})[0];if(matchingResource){setUrlResource(matchingResource);}setFilterParams({"location[]":currentUrl.searchParams.getAll("location[]"),"resourceMail[]":currentUrl.searchParams.getAll("resourceMail[]")});}},[allResources]);// Effects to run when urlResource is set. This should only happen once in
// extension of app initialisation.
(0,react.useEffect)(function(){// If resource is set in url parameters, select the relevant filters.
if(urlResource&&urlResource!==[]){// Set location filter.
if(helpers_hasOwnProperty(urlResource,"location")){var _urlResource$location;setLocationFilter([{value:urlResource.location,label:(_urlResource$location=urlResource.locationDisplayName)!==null&&_urlResource$location!==void 0?_urlResource$location:urlResource.location}]);}// Set resource filter.
if(helpers_hasOwnProperty(urlResource,"resourceMail")&&helpers_hasOwnProperty(urlResource,"resourceName")){var _urlResource$resource;setResourceFilter([{value:urlResource.resourceMail,label:(_urlResource$resource=urlResource.resourceDisplayName)!==null&&_urlResource$resource!==void 0?_urlResource$resource:urlResource.resourceName}]);}}// Set filter params to trigger filtering of resources
if(urlResource&&urlResource.location&&urlResource.resourceMail){setFilterParams({"location[]":urlResource.location,"resourceMail[]":urlResource.resourceMail});}// Use data from url parameters.
if(validUrlParams&&Object.values(calendarSelection).length===0&&urlResource){setDate(new Date(validUrlParams.from));setCalendarSelection({start:new Date(validUrlParams.from),end:new Date(validUrlParams.to),allDay:false,resource:urlResource});}},[urlResource]);// Find resources that match filterParams.
(0,react.useEffect)(function(){setLoadingFiltering(true);var newFilteredResources=filterAllResources(allResources,filterParams);setFilteredResources(newFilteredResources);// Limit the number of results to resourceLimit
var limitedResources=_toConsumableArray(newFilteredResources);limitedResources.length=Math.min(limitedResources.length,resourceLimit);setResources(limitedResources);if(Object.values(filterParams).length>0){setUserHasInteracted(true);}},[filterParams]);// Set selection as json.
(0,react.useEffect)(function(){if(config!==null&&config!==void 0&&config.output_field_id){var _calendarSelection$re,_calendarSelection$re2;document.getElementById(config.output_field_id).value=JSON.stringify(objectSpread2_objectSpread2({start:calendarSelection===null||calendarSelection===void 0?void 0:calendarSelection.start,end:calendarSelection===null||calendarSelection===void 0?void 0:calendarSelection.end,resourceId:(_calendarSelection$re=calendarSelection===null||calendarSelection===void 0?void 0:calendarSelection.resourceId)!==null&&_calendarSelection$re!==void 0?_calendarSelection$re:calendarSelection===null||calendarSelection===void 0?void 0:(_calendarSelection$re2=calendarSelection.resource)===null||_calendarSelection$re2===void 0?void 0:_calendarSelection$re2.resourceMail},authorFields));}},[calendarSelection,authorFields]);var displayInfoBox=(config===null||config===void 0?void 0:config.info_box_color)&&(config===null||config===void 0?void 0:config.info_box_header)&&(config===null||config===void 0?void 0:config.info_box_content);var onTabChange=function onTabChange(tab){setActiveTab(tab);setLoadingFiltering(true);};return/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[config&&!showSystemFailure&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"App",children:[(loadingResources||loadingUserInformation)&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"container-fluid",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"app-wrapper",style:{minHeight:"100px"},children:/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{})})}),!loadingResources&&!loadingUserInformation&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"container-fluid",children:[/*#__PURE__*/(0,jsx_runtime.jsx)(components_main_navigation,{config:config}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"app-wrapper",children:[displayState==="maximized"&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"app-content",children:[/*#__PURE__*/(0,jsx_runtime.jsx)(components_create_booking_filters,{filterParams:filterParams,setFilterParams:setFilterParams,allResources:allResources,disabled:(_ref2=showResourceDetails!==null||validUrlParams!==null)!==null&&_ref2!==void 0?_ref2:false,userType:userInformation===null||userInformation===void 0?void 0:userInformation.userType,locationFilter:locationFilter,setLocationFilter:setLocationFilter,resourceFilter:resourceFilter,setResourceFilter:setResourceFilter,resourceCategoryFilter:resourceCategoryFilter,setResourceCategoryFilter:setResourceCategoryFilter,facilityFilter:facilityFilter,setFacilityFilter:setFacilityFilter,setAppParams:setAppParams}),displayInfoBox&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_info_box,{config:config}),/*#__PURE__*/(0,jsx_runtime.jsx)(create_booking_tabs,{activeTab:activeTab,onTabChange:onTabChange,disabled:(_ref3=showResourceDetails!==null)!==null&&_ref3!==void 0?_ref3:false}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"row no-gutter main-container",children:[activeTab==="map"&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"map",children:/*#__PURE__*/(0,jsx_runtime.jsx)(components_map_wrapper,{resources:resources,allResources:allResources,config:config,setLocationFilter:setLocationFilter,setResourceFilter:setResourceFilter,setBookingView:onTabChange,useLocations:false,setFacilityFilter:setFacilityFilter,filterParams:filterParams})}),activeTab==="list"&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"list ".concat(showResourceDetails!==null?"resourceview-visible":""),children:[/*#__PURE__*/(0,jsx_runtime.jsx)(components_list_container,{resources:resources,setShowResourceDetails:setShowResourceDetails,userHasInteracted:userHasInteracted,isLoading:loadingFiltering,setIsLoading:setLoadingFiltering}),(filteredResources===null||filteredResources===void 0?void 0:filteredResources.length)>resourceLimit&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{style:{textAlign:"right",padding:"1em"},children:["Viser ",resources.length," ud af ",filteredResources.length," resultater. Filtr\xE9r yderligere for at begr\xE6nse resultater."]})]}),activeTab==="calendar"&&/*#__PURE__*/ // {/* Display calendar for selections */}
(0,jsx_runtime.jsxs)("div",{className:"calendar ".concat(showResourceDetails!==null?"resourceview-visible":""),children:[/*#__PURE__*/(0,jsx_runtime.jsx)(components_calendar,{resources:resources,date:date,setDate:setDate,calendarSelection:calendarSelection,setCalendarSelection:setCalendarSelection,config:config,setShowResourceDetails:setShowResourceDetails,urlResource:urlResource,setDisplayState:setDisplayState,showResourceDetails:showResourceDetails,userHasInteracted:userHasInteracted,isLoading:loadingFiltering,setIsLoading:setLoadingFiltering}),(filteredResources===null||filteredResources===void 0?void 0:filteredResources.length)>resourceLimit&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{style:{textAlign:"right",padding:"1em"},children:["Viser ",resources.length," ud af ",filteredResources.length," resultater. Filtr\xE9r yderligere for at begr\xE6nse resultater."]})]}),showResourceDetails&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_resource_details,{showResourceDetails:showResourceDetails,setShowResourceDetails:setShowResourceDetails,resource:urlResource!==null&&urlResource!==void 0?urlResource:allResources.filter(function(el){return el.resourceMail===showResourceDetails;})[0]})]})]}),allResources&&displayState==="minimized"&&calendarSelection!=={}&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsx)(components_minimized_display,{setDisplayState:setDisplayState,resource:urlResource!==null&&urlResource!==void 0?urlResource:allResources.filter(function(el){return el.resourceMail===calendarSelection.resourceId;})[0],calendarSelection:calendarSelection})}),!(config!==null&&config!==void 0&&config.step_one)&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row no-gutter",children:authorFields&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_author_fields,{authorFields:authorFields,setAuthorFields:setAuthorFields})})]})]})]}),showSystemFailure&&/*#__PURE__*/(0,jsx_runtime.jsx)(system_failure_screen,{})]});}/* harmony default export */ var create_booking = (CreateBooking);
;// CONCATENATED MODULE: ./src/util/display-toast.js
/** @param {string} text The toast display text */function displaySuccess(text){toast.success(text);}/**
 * @param {string} errorString - The toast display text
 * @param {object} error - The error
 */function displayError(errorString,error){var displayText="".concat(errorString,"\n\n  \"").concat(error,"\"");toast.error(displayText,{autoClose:false});}
;// CONCATENATED MODULE: ./src/components/user-booking-edit.js
/**
 * @param {object} props Props.
 * @param {object} props.config App config.
 * @param {object} props.booking Booking to edit.
 * @param {Function} props.onBookingChanged Callback when booking has changed.
 * @param {Function} props.close Callback to close edit component without action.
 * @returns {JSX.Element} Component.
 */function UserBookingEdit(_ref){var config=_ref.config,booking=_ref.booking,onBookingChanged=_ref.onBookingChanged,close=_ref.close;var _useState=(0,react.useState)(false),_useState2=slicedToArray_slicedToArray(_useState,2),loading=_useState2[0],setLoading=_useState2[1];var _useState3=(0,react.useState)([]),_useState4=slicedToArray_slicedToArray(_useState3,2),events=_useState4[0],setEvents=_useState4[1];var _useState5=(0,react.useState)([]),_useState6=slicedToArray_slicedToArray(_useState5,2),resources=_useState6[0],setResources=_useState6[1];var _useState7=(0,react.useState)(new Date()),_useState8=slicedToArray_slicedToArray(_useState7,2),date=_useState8[0],setDate=_useState8[1];var _useState9=(0,react.useState)(null),_useState10=slicedToArray_slicedToArray(_useState9,2),calendarSelection=_useState10[0],setCalendarSelection=_useState10[1];var calendarRef=(0,react.useRef)();(0,react.useEffect)(function(){if(booking){setDate(new Date(booking.start));Api.fetchResource(config.api_endpoint,booking.resourceMail).then(function(resource){setResources([resource]);});}},[booking]);(0,react.useEffect)(function(){if(resources.length>0){Api.fetchEvents(config.api_endpoint,resources,date).then(function(newEvents){return setEvents(newEvents);}).catch(function(err){displayError("Kunne ikke hente optagede intervaller.",err);});}},[resources]);(0,react.useEffect)(function(){if(calendarSelection){var _calendarRef$current;calendarRef===null||calendarRef===void 0?void 0:(_calendarRef$current=calendarRef.current)===null||_calendarRef$current===void 0?void 0:_calendarRef$current.getApi().gotoDate(date);}if(resources.length>0){Api.fetchEvents(config.api_endpoint,resources,date).then(function(newEvents){return setEvents(newEvents);});}},[date]);/**
   * Edit booking.
   *
   * @param {object} bookingEdit Booking to edit.
   * @param {Date} newStart New start date.
   * @param {Date} newEnd New end date.
   */var requestDateChange=function requestDateChange(bookingEdit,newStart,newEnd){var newData={id:bookingEdit.exchangeId,start:newStart.toISOString(),end:newEnd.toISOString()};if(bookingEdit!==null&&bookingEdit!==void 0&&bookingEdit.exchangeId){setLoading(true);Api.patchBooking(config.api_endpoint,bookingEdit.exchangeId,newData).then(function(data){displaySuccess("Ændring af tidspunkt lykkedes");onBookingChanged(bookingEdit.exchangeId,data.start,data.end);}).catch(function(err){displayError("Ændring af tidspunkt fejlede.",err);}).finally(function(){setLoading(false);});}};/**
   * Format date string.
   *
   * @param {string} dateString Date string to format.
   * @returns {string} Date formatted as string.
   */function getFormattedDateTime(dateString){return dayjs_min_default()(dateString).format("D/M [kl.] HH:mm");}/**
   * OnCalenderSelection.
   *
   * @param {object} selection The new selection object.
   * @returns {void} Nothing is returned
   */var onCalendarSelection=function onCalendarSelection(selection){var newSelection={allDay:selection.allDay,resourceId:selection.resource.id,end:selection.end,start:selection.start};setCalendarSelection(newSelection);};(0,react.useEffect)(function(){var highlightElement=document.querySelector("div.fc-highlight");if(highlightElement!==null&&(resources===null||resources===void 0?void 0:resources.length)>0){setTimeout(function(){var _resources$0$resource;document.querySelector("div.fc-highlight").innerHTML=server_browser.renderToString(/*#__PURE__*/(0,jsx_runtime.jsx)(calendar_selection_box,{calendarSelection:calendarSelection,calendarSelectionResourceTitle:(_resources$0$resource=resources[0].resourceName)!==null&&_resources$0$resource!==void 0?_resources$0$resource:"",calendarSelectionResourceId:resources[0].id,actionText:"Anmod om \xE6ndring af tidspunkt"}));document.getElementById("calendar-selection-choice-confirm").addEventListener("mousedown",function(e){e.stopPropagation();requestDateChange(booking,calendarSelection.start,calendarSelection.end);});document.getElementById("calendar-selection-container").addEventListener("mousedown",function(e){e.stopPropagation();});document.getElementById("calendar-selection-close").addEventListener("mousedown",function(e){e.stopPropagation();calendarRef.current.getApi().unselect();setCalendarSelection(null);});},1);}},[calendarSelection,events]);var getBusyIntervals=function getBusyIntervals(busyIntervals){return busyIntervals.map(function(value){var interval=handleBusyIntervals(value);if(interval.start===booking.start&&interval.end===booking.end){interval.display="background";interval.title="Din booking";interval.backgroundColor="#33bd33";}return interval;});};var getSelectOverlap=function getSelectOverlap(event){var _event$_def,_event$_def$ui;// eslint-disable-next-line no-underscore-dangle
return(event===null||event===void 0?void 0:(_event$_def=event._def)===null||_event$_def===void 0?void 0:(_event$_def$ui=_event$_def.ui)===null||_event$_def$ui===void 0?void 0:_event$_def$ui.display)==="background";};return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"main-container",children:[loading&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{}),!loading&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"Calendar no-gutter col-md-12",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("h2",{children:"V\xE6lg nyt tidspunkt for booking"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"col small-padding",style:{width:"100%"},children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{style:{margin:"1em 0"},children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Resource: "}),booking.resourceDisplayName]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Titel p\xE5 booking: "}),booking.title]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Nuv\xE6rende valg: "}),getFormattedDateTime(booking.start)," - ",getFormattedDateTime(booking.end)]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:calendarSelection&&/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Nyt valg: "}),getFormattedDateTime(calendarSelection.start)," - ",getFormattedDateTime(calendarSelection.end)]})})]}),/*#__PURE__*/(0,jsx_runtime.jsx)(components_calendar_header,{config:config,date:date,setDate:setDate,setIsLoading:function setIsLoading(){}}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist_main,{ref:calendarRef,plugins:[resource_timegrid_main,interaction_main,_fullcalendar_daygrid_main,_fullcalendar_timegrid_main,_fullcalendar_list_main,_fullcalendar_resource_timeline_main],titleFormat:{year:"numeric",month:"long",day:"numeric"},headerToolbar:"",initialView:"resourceTimelineDay",duration:"days: 3",selectConstraint:"businessHours",selectMirror:true,displayEventTime:true,scrollTimeReset:false,slotLabelFormat:{hour:"numeric",omitZeroMinute:false},nowIndicator:true,navLinks:true,height:"300px",slotDuration:"00:15:00",allDaySlot:false,selectable:true,unselectAuto:false,schedulerLicenseKey:config.license_key,slotMinTime:"06:00:00",slotMaxTime:"24:00:00",selectOverlap:getSelectOverlap,nextDayThreshold:"21:00:00",editable:false,dayMaxEvents:true,locale:locales_da/* default */.Z,select:onCalendarSelection,validRange:{start:date},resourceOrder:"resourceId",resources:resources.map(function(value){return calendar_utils_handleResources(value,date);}),events:getBusyIntervals(events)}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:close,style:{margin:"1em 0"},children:"Annull\xE9r"})]})})]})]});}/* harmony default export */ var user_booking_edit = (UserBookingEdit);
;// CONCATENATED MODULE: ./src/components/user-booking-delete.js
/**
 * @param {object} props Props.
 * @param {object} props.config App config.
 * @param {object} props.booking Booking to delete.
 * @param {Function} props.onBookingDeleted Callback when booking has been deleted.
 * @param {Function} props.close Callback to close delete component without action.
 * @returns {JSX.Element} Component.
 */function UserBookingDelete(_ref){var config=_ref.config,booking=_ref.booking,onBookingDeleted=_ref.onBookingDeleted,close=_ref.close;var _useState=(0,react.useState)(false),_useState2=slicedToArray_slicedToArray(_useState,2),loading=_useState2[0],setLoading=_useState2[1];/**
   * Delete the booking.
   *
   * @param {object} bookingToDelete Booking to request deletion of.
   */var requestDeletion=function requestDeletion(bookingToDelete){var bookingId=bookingToDelete.exchangeId;if(bookingId){setLoading(true);Api.deleteBooking(config.api_endpoint,bookingId).then(function(){displaySuccess("Sletning af booking lykkedes");onBookingDeleted(bookingId);}).catch(function(err){displayError("Sletning af booking fejlede",err);}).finally(function(){setLoading(false);});}};/**
   * Format date to string.
   *
   * @param {Date} dateObj Date for format.
   * @returns {string} Date formatted as string.
   */function getFormattedDateTime(dateObj){return dayjs_min_default()(dateObj).format("D/M [kl.] HH:mm");}return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"main-container",children:[loading&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{}),!loading&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"no-gutter col-md-12",style:{padding:"1em"},children:[/*#__PURE__*/(0,jsx_runtime.jsx)("h2",{children:"Slet booking"}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col small-padding",style:{width:"100%"},children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{style:{margin:"1em 0"},children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Resource: "}),booking.resourceDisplayName]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Titel p\xE5 booking: "}),booking.title]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Tidspunkt: "}),getFormattedDateTime(booking.start)," - ",getFormattedDateTime(booking.end)]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{style:{margin:"1em 0"},children:/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:"Er du sikker p\xE5, at du vil slette bookingen?"})}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:function onClick(){return requestDeletion(booking);},style:{margin:"0 .5em 0 0"},children:"Ja, slet den!"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:close,children:"Annull\xE9r"})]})})})]})]});}/* harmony default export */ var user_booking_delete = (UserBookingDelete);
;// CONCATENATED MODULE: ./src/user-panel.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var user_panel = ({});
;// CONCATENATED MODULE: ./src/user-panel.js
/**
 * @param {object} props Props.
 * @param {object} props.config App config.
 * @returns {JSX.Element} Component.
 */function UserPanel(_ref){var _Object$values;var config=_ref.config;var _useState=(0,react.useState)(true),_useState2=slicedToArray_slicedToArray(_useState,2),loading=_useState2[0],setLoading=_useState2[1];var _useState3=(0,react.useState)(null),_useState4=slicedToArray_slicedToArray(_useState3,2),userBookings=_useState4[0],setUserBookings=_useState4[1];var _useState5=(0,react.useState)(null),_useState6=slicedToArray_slicedToArray(_useState5,2),editBooking=_useState6[0],setEditBooking=_useState6[1];var _useState7=(0,react.useState)(null),_useState8=slicedToArray_slicedToArray(_useState7,2),deleteBooking=_useState8[0],setDeleteBooking=_useState8[1];var _useState9=(0,react.useState)(""),_useState10=slicedToArray_slicedToArray(_useState9,2),search=_useState10[0],setSearch=_useState10[1];var _useState11=(0,react.useState)("asc"),_useState12=slicedToArray_slicedToArray(_useState11,2),dateSort=_useState12[0],setDateSort=_useState12[1];var _useState13=(0,react.useState)({"order[start]":dateSort}),_useState14=slicedToArray_slicedToArray(_useState13,2),sort=_useState14[0],setSort=_useState14[1];var _useState15=(0,react.useState)(1),_useState16=slicedToArray_slicedToArray(_useState15,2),page=_useState16[0],setPage=_useState16[1];var _useState17=(0,react.useState)([]),_useState18=slicedToArray_slicedToArray(_useState17,2),pendingBookings=_useState18[0],setPendingBookings=_useState18[1];var pageSize=10;var _useState19=(0,react.useState)(),_useState20=slicedToArray_slicedToArray(_useState19,2),changedBookingId=_useState20[0],setChangedBookingId=_useState20[1];var onBookingChanged=function onBookingChanged(bookingId,start,end){setEditBooking(null);setChangedBookingId(bookingId);var newUserBookings=objectSpread2_objectSpread2({},userBookings);var bookingIndex=newUserBookings["hydra:member"].findIndex(function(el){return el.exchangeId===bookingId;});if(bookingIndex!==-1){newUserBookings["hydra:member"][bookingIndex].start=start;newUserBookings["hydra:member"][bookingIndex].end=end;}setUserBookings(newUserBookings);};var onBookingDeleted=function onBookingDeleted(bookingId){setDeleteBooking(null);var newUserBookings=objectSpread2_objectSpread2({},userBookings);newUserBookings["hydra:member"]=newUserBookings["hydra:member"].filter(function(el){return el.exchangeId!==bookingId;});setUserBookings(newUserBookings);};var close=function close(){setDeleteBooking(null);setEditBooking(null);};/**
   * @param {Date} dateObj Date for format.
   * @returns {string} Date formatted as string.
   */function getFormattedDateTime(dateObj){return dayjs_min_default()(dateObj).format("dddd [d.] D/M [kl.] HH:mm");}var fetchSearch=function fetchSearch(){if(config){setLoading(true);Api.fetchUserBookings(config.api_endpoint,search,sort,page,pageSize).then(function(loadedUserBookings){var pending=[];var newLoadedUserBookings=objectSpread2_objectSpread2({},loadedUserBookings);newLoadedUserBookings["hydra:member"]=newLoadedUserBookings["hydra:member"].map(function(booking){var newBooking=objectSpread2_objectSpread2({},booking);if(newBooking.status==="AWAITING_APPROVAL"){newBooking.status=/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{size:"small"});pending.push(newBooking.exchangeId);}return newBooking;});setUserBookings(newLoadedUserBookings);return pending;}).then(function(pending){if(pending.length>0){setPendingBookings(pending);}}).catch(function(fetchUserBookingsError){displayError("Der opstod en fejl. Prøv igen senere...",fetchUserBookingsError);}).finally(function(){setLoading(false);});}};var submitSearch=function submitSearch(event){event.preventDefault();event.stopPropagation();if(page!==1){// This automatically triggers a search.
setPage(1);}else{fetchSearch();}};var currentBookings=userBookings?(_Object$values=Object.values(userBookings["hydra:member"]))!==null&&_Object$values!==void 0?_Object$values:[]:[];var getStatus=function getStatus(status){if(typeof status==="string"){switch(status){case"ACCEPTED":return"Godkendt";case"DECLINED":return"Afvist";case"AWAITING_APPROVAL":return"Afventer godkendelse";default:return"Ukendt status";}}return status;};var onFilterChange=function onFilterChange(event){setSearch(event.target.value);};var onDateSortChange=function onDateSortChange(event){setDateSort(event.target.value);setSort({"order[start]":event.target.value});fetchSearch();};var addPage=function addPage(value){var newValue=page+value;if(newValue<1||newValue>Math.ceil(userBookings["hydra:totalItems"]/pageSize)){return;}setPage(page+value);};var decrementPage=function decrementPage(event){event.stopPropagation();event.preventDefault();addPage(-1);};var incrementPage=function incrementPage(event){event.stopPropagation();event.preventDefault();addPage(1);};var renderBooking=function renderBooking(booking){var now=new Date();var bookingEnd=new Date(booking.end);return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"user-booking".concat(bookingEnd<now?" expired":""),children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[booking.exchangeId===changedBookingId&&/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:"\xC6ndring gennemf\xF8rt."}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"location",children:booking.resourceDisplayName?booking.resourceDisplayName:booking.resource}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"subject",children:booking.title}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:"status",children:getStatus(booking.status)})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:getFormattedDateTime(booking.start)}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"\u2192"}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:getFormattedDateTime(booking.end)})]}),bookingEnd<now&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Booking er udl\xF8bet"}),bookingEnd>=now&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:function onClick(){return setDeleteBooking(booking);},children:"Anmod om sletning"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:function onClick(){return setEditBooking(booking);},children:"Anmod om \xE6ndring af tidspunkt"})]})]},booking.exchangeId);};(0,react.useEffect)(function(){if(page!==null){fetchSearch();}},[page]);(0,react.useEffect)(function(){if(pendingBookings.length>0){Api.fetchBookingStatus(config.api_endpoint,pendingBookings).then(function(response){var newUserBookings=objectSpread2_objectSpread2({},userBookings);newUserBookings["hydra:member"]=newUserBookings["hydra:member"].map(function(booking){var newBooking=objectSpread2_objectSpread2({},booking);response.forEach(function(element){if(element.exchangeId===booking.exchangeId){newBooking.status=element.status;}});return newBooking;});setUserBookings(newUserBookings);}).catch(function(bookingStatusError){displayError("Der opstod en fejl. Prøv igen senere...",bookingStatusError);});}},[pendingBookings]);return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"App",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"container-fluid",children:[/*#__PURE__*/(0,jsx_runtime.jsx)(components_main_navigation,{config:config}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"row",children:/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col no-padding",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"row filters-wrapper",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-3",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("form",{onSubmit:submitSearch,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("input",{value:search,className:"filter",style:{marginRight:"1em"},placeholder:"S\xF8getekst",name:"filterText",onChange:onFilterChange,type:"text"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"submit",children:"S\xF8g"})]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"col-md-3",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("select",{name:"dateSort",onChange:onDateSortChange,value:dateSort,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("option",{value:"asc",children:"F\xF8rst kommende"}),/*#__PURE__*/(0,jsx_runtime.jsx)("option",{value:"desc",children:"Senest kommende"})]})})]})})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"app-wrapper",children:[deleteBooking&&/*#__PURE__*/(0,jsx_runtime.jsx)(user_booking_delete,{config:config,booking:deleteBooking,onBookingDeleted:onBookingDeleted,close:close}),editBooking&&/*#__PURE__*/(0,jsx_runtime.jsx)(user_booking_edit,{config:config,booking:editBooking,onBookingChanged:onBookingChanged,close:close}),!editBooking&&!deleteBooking&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"userpanel row",children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"col no-padding",children:[loading&&/*#__PURE__*/(0,jsx_runtime.jsx)(components_loading_spinner,{}),userBookings&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"userbookings-container",children:currentBookings.map(renderBooking)}),userBookings&&/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{style:{display:"flex",justifyContent:"space-between"},children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:decrementPage,style:{margin:"1em"},children:"\u2190"}),"Side ",page," / ",Math.ceil(userBookings["hydra:totalItems"]/pageSize),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button",onClick:incrementPage,style:{margin:"1em"},children:"\u2192"})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{style:{margin:"1em"},children:["Antal bookinger: ",userBookings["hydra:totalItems"]]})]})]})})]})]})});}/* harmony default export */ var src_user_panel = (UserPanel);
;// CONCATENATED MODULE: ./src/app.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ var app = ({});
;// CONCATENATED MODULE: ./src/app.js
// Set day js locale globally.
dayjs_min_default().locale("da");/**
 * App component.
 *
 * @returns {JSX.Element} App component.
 */function App(){// App configuration and behavior.
var _useState=(0,react.useState)(null),_useState2=slicedToArray_slicedToArray(_useState,2),config=_useState2[0],setConfig=_useState2[1];var _useState3=(0,react.useState)(true),_useState4=slicedToArray_slicedToArray(_useState3,2),loadingConfig=_useState4[0],setLoadingConfig=_useState4[1];// Get configuration.
(0,react.useEffect)(function(){ConfigLoader.loadConfig().then(function(loadedConfig){setConfig(loadedConfig);}).finally(function(){setLoadingConfig(false);});},[]);return/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)(ToastContainer,{position:"bottom-right",autoClose:5000}),config&&/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[config.create_booking_mode&&/*#__PURE__*/(0,jsx_runtime.jsx)(create_booking,{config:config}),!config.create_booking_mode&&/*#__PURE__*/(0,jsx_runtime.jsx)(src_user_panel,{config:config})]}),!config&&!loadingConfig&&/*#__PURE__*/(0,jsx_runtime.jsx)(system_failure_screen,{})]});}/* harmony default export */ var src_app = (App);
;// CONCATENATED MODULE: ./src/index.js
var root=client.createRoot(document.getElementById("react-booking-app"));root.render(/*#__PURE__*/(0,jsx_runtime.jsx)(react.StrictMode,{children:/*#__PURE__*/(0,jsx_runtime.jsx)(BrowserRouter,{children:/*#__PURE__*/(0,jsx_runtime.jsx)(src_app,{})})}));
}();
/******/ })()
;
//# sourceMappingURL=main.7fb050e7.js.map